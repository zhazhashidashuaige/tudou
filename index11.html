<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åœŸçš‡å¸å°æ‰‹æœº</title>
    <!-- Safari PWA/Fullscreen Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/50dRBnZR/c0a269c8637df7a30e8b491cd7519343.jpg">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* --- å…¨å±€ä¸åŸºç¡€æ ·å¼ --- */
        :root {
            --bg-color: #f0f2f5;
            --app-screen-bg: #ffffff;
            --primary-text-color: #000000;
            --secondary-text-color: #8e8e93;
            --accent-color: #007aff;
            --danger-color: #ff3b30;
            --edit-color: #ff9500;
            --border-color: #c6c6c8;
            --input-bg: #ffffff;
            --button-bg: #007aff;
            --button-text-color: #ffffff;
            --item-bg: #ffffff;
            --item-active-bg: #e5e5ea;
            --system-font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --system-font-color: #000000;
            --online-color: #34c759;
            --busy-color: #ff9500;
            --offline-color: #8e8e93;
            --like-color: #ff3b30;
            --listen-together-color: #ff4d6d;
            --owner-title-bg: #ffc107;
            --admin-title-bg: #28a745;
            --member-title-bg: #6c757d;
        }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden;
            font-family: var(--system-font-family);
            background-color: #000;
            display: flex; justify-content: center; align-items: center;
            user-select: none; -webkit-user-select: none;
        }
        
        body, .app-screen, .modal-content, .settings-item label, .music-item-info .title, .preset-item-content {
            color: var(--system-font-color);
        }
        
        *:focus { outline: none; -webkit-tap-highlight-color: transparent; }
        /* --- Font Awesome Icon Sizing --- */
            .app-icon .icon i { font-size: 30px; color: #333; }
            #dock .app-icon .icon i { font-size: 28px; }
            .action-btn i, .back-btn i { font-size: 20px; }
            .player-controls .icon-btn i { font-size: 24px; color: white; }
            .player-controls .play-pause-btn i { font-size: 40px; }
            #player-modal .player-header .icon-btn i { font-size: 22px; color: white; }
            .chat-toolbar .icon-btn i { font-size: 24px; color: #555; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; }
            #chat-input-buttons .icon-btn i, #chat-send-real-btn i { font-size: 26px; color: #555; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; }
            #close-quote-btn i { font-size: 16px; color: white; }
            .comment-actions-inline .icon-btn i { font-size: 18px; }
            .post-footer .comment-actions-inline .icon-btn i { font-size: 20px; }
            .like-btn.liked i { color: var(--like-color); }
            .edit-action i, .delete-action i { font-size: 18px; }
            #status-bar #battery-icon i { font-size: 18px; }
        /* --- æ‰‹æœºå±å¹•å®¹å™¨ (Fullscreen/PWA Optimized) --- */
        #phone-screen {
            width: 100%; height: 100%;
            background-image: url('https://img.xjh.me/random_img.php?type=bg&ctype=nature&return=302');
            background-size: cover; background-position: center;
            display: flex; flex-direction: column;
            position: relative; overflow: hidden;
            transition: background-image 0.5s ease-in-out;
        }
        /* å½“APPæ‰“å¼€æ—¶ï¼Œéšè—ä¸»å±å¹•å†…å®¹ */
        #phone-screen.app-open > #main-content,
        #phone-screen.app-open > #dock {
            visibility: hidden;
        }

        /* --- é¡¶éƒ¨åŒºåŸŸ (çŠ¶æ€æ  + çµåŠ¨å²›) --- */
        #top-area { 
            position: absolute; top: 0; left: 0; right: 0; 
            padding: 10px; 
            padding-top: calc(env(safe-area-inset-top, 10px)); /* iPhone Safe Area */
            display: flex; justify-content: center; align-items: flex-start; 
            z-index: 50; pointer-events: none; 
            height: 74px; /* å¢åŠ é«˜åº¦ */
            box-sizing: border-box;
        }
        #status-bar { width: 100%; display: flex; justify-content: space-between; align-items: center; color: white; font-weight: 600; font-size: 14px; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); padding: 0 15px; position: relative; top: 0; }
        #time { min-width: 50px; text-align: left; }
        #battery-status { display: flex; justify-content: flex-end; align-items: center; gap: 5px; }
        #battery-icon { font-size: 18px; }

        /* --- çµåŠ¨å²› --- */
        #dynamic-island { position: absolute; top: calc(env(safe-area-inset-top, 8px) + 1px); /* å‘ä¸Šåç§»2px */ height: 20px; width: 100px; max-width: 50%; background-color: black; border-radius: 10px; transition: all 0.5s cubic-bezier(0.65, 0, 0.35, 1); pointer-events: auto; display: flex; align-items: center; justify-content: space-between; padding: 0 8px; box-sizing: border-box; overflow: hidden; }
        #dynamic-island.music-active { width: 240px; }
        .island-content { color: white; font-size: 11px; opacity: 0; transition: opacity 0.3s ease; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #dynamic-island.music-active .island-content { opacity: 1; }
        .island-music-info { flex-grow: 1; text-align: left; padding: 0 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .island-waveform { width: 20px; height: 12px; display: flex; justify-content: space-between; align-items: flex-end; }
        .island-waveform span { width: 2px; height: 100%; background-color: #34c759; border-radius: 1px; animation: waveform-dance 1.2s infinite ease-in-out; }
        .island-waveform span:nth-child(2) { animation-delay: -1.0s; }
        .island-waveform span:nth-child(3) { animation-delay: -0.8s; }
        .island-waveform.paused span { animation-play-state: paused; height: 2px; }
        @keyframes waveform-dance { 0%, 100% { height: 2px; } 50% { height: 100%; } }
        /* --- çµåŠ¨å²› (è§†é¢‘é€šè¯) --- */
        #dynamic-island.video-call-active { width: 150px; background-color: #34c759; }
        #dynamic-island.video-call-active .island-content { opacity: 1; }
        #dynamic-island.video-call-active .island-music-info,
        #dynamic-island.video-call-active .island-waveform { display: none; }
        #dynamic-island .island-video-call-icon,
        #dynamic-island .island-video-call-timer { display: none; color: white; font-weight: 500; font-variant-numeric: tabular-nums; }
        #dynamic-island.video-call-active .island-video-call-icon,
        #dynamic-island.video-call-active .island-video-call-timer { display: block; }
        .island-video-call-icon::before { content: 'ğŸ“¹'; font-size: 13px; margin-right: 5px; }
        .island-video-call-timer { font-size: 13px; }

        /* --- é€šçŸ¥æ¨ªå¹… --- */
        #notification-container { position: absolute; top: calc(env(safe-area-inset-top, 10px) + 60px); left: 0; right: 0; padding: 0 10px; z-index: 250; pointer-events: none; display: flex; flex-direction: column-reverse; align-items: center; gap: 8px; }
        .notification-banner { width: 90%; max-width: 380px; background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 12px 16px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); color: #000; font-size: 15px; transform: translateY(-150%); transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease-out; pointer-events: auto; cursor: grab; opacity: 1; position: relative; }
        .notification-banner.persistent {
    background-color: rgba(255, 60, 48, 0.85); /* é†’ç›®çš„çº¢è‰²èƒŒæ™¯ */
    color: white;
    cursor: grab;
}
.notification-banner.persistent .details {
    font-size: 13px;
    line-height: 1.5;
    margin-top: 5px;
    opacity: 0.9;
    white-space: pre-wrap; /* å…è®¸æ¢è¡Œ */
}
        .notification-banner.show { transform: translateY(0); }
        .notification-banner:not(.show) { opacity: 0; }

        /* --- ä¸»å†…å®¹åŒºä¸APPå›¾æ ‡ --- */
        #main-content { flex-grow: 1; padding: calc(env(safe-area-inset-top, 10px) + 80px) 20px 20px 20px; }
        #app-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; justify-items: center; }
        .app-icon { display: flex; flex-direction: column; align-items: center; gap: 8px; text-align: center; cursor: pointer; width: 70px; position: relative; }
        .app-icon .icon { width: 60px; height: 60px; background-color: rgba(255, 255, 255, 0.9); border-radius: 15px; display: flex; justify-content: center; align-items: center; font-size: 30px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: transform 0.1s ease-in-out; overflow: hidden; }
        .app-icon .icon img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon:active .icon { transform: scale(0.9); }
        .app-icon .label { color: white; font-size: 12px; text-shadow: 1px 1px 2px rgba(0,0,0,0.6); }

        /* --- åº•éƒ¨ Dock æ  --- */
        #dock { padding: 8px 20px; padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 8px); margin: 15px; margin-bottom: 0; background-color: rgba(255, 255, 255, 0.2); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 25px; display: flex; justify-content: space-around; align-items: center; flex-shrink: 0; }
        #dock .app-icon { position: relative; top: 3px; /* å‘ä¸‹åç§»3px */ }

        /* --- APP ç•Œé¢é€šç”¨æ ·å¼ --- */
        .app-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-color); transform: translateY(100%); transition: transform 0.3s ease-in-out; display: flex; flex-direction: column; z-index: 10; }
        .app-screen.sub-screen { z-index: 11; } /* å­å±å¹•å±‚çº§æ›´é«˜ */
        .app-screen.active { transform: translateY(0); }
        .app-screen.parent-hidden { visibility: hidden; } /* éšè—è¢«è¦†ç›–çš„çˆ¶çº§ç•Œé¢ */
.app-header { position: sticky; top: 0; display: flex; align-items: center; justify-content: space-between; padding: 10px 15px; background-color: var(--app-screen-bg); border-bottom: 1px solid var(--border-color); flex-shrink: 0; padding-top: calc(env(safe-area-inset-top, 10px) + 15px); min-height: 45px; /* å¢åŠ é«˜åº¦ */ box-sizing: content-box; z-index: 10; /* ç¡®ä¿headeråœ¨å†…å®¹ä¹‹ä¸Š */ }        .app-header-left, .app-header-right { flex: 0 0 60px; display: flex; }
        .app-header-left { justify-content: flex-start; }
        .app-header-right { justify-content: flex-end; align-items: center; }
        .app-header .back-btn, .app-header .action-btn { position: relative; top: 8px; /* å‘ä¸‹åç§»8px */ }
        .app-header .back-btn { font-size: 16px; color: var(--accent-color); cursor: pointer; background: none; border: none; padding: 5px 10px; white-space: nowrap; font-family: inherit; }
        .app-header .title-wrapper { flex-grow: 1; text-align: center; }
        .app-header .title { font-size: 17px; font-weight: 600; position: relative; top: -5px; /* å‘ä¸Šåç§»5px */ }
        .app-header .action-btn { font-size: 28px; color: var(--accent-color); cursor: pointer; background: none; border: none; padding: 5px 10px; line-height: 1; display: flex; align-items: center; justify-content: center; }
        .app-header .action-btn.small { font-size: 16px; font-weight: normal; padding: 5px 10px; }
        /* OPTIMIZATION: æ”¾å¤§è®¾ç½®æŒ‰é’®å›¾æ ‡ */
        .app-header .action-btn[data-icon-id="header-settings"] img { height: 48px; width: 48px; }
        .app-header .action-btn img { height: 24px; width: auto; } /* é»˜è®¤æŒ‰é’®å›¾æ ‡å¤§å° */
        .app-content { flex-grow: 1; overflow-y: auto; position: relative; /* ä¸ºFABæŒ‰é’®å®šä½æä¾›åŸºå‡† */ padding-top: calc(env(safe-area-inset-top, 10px) + 60px); }
        .app-bottom-tabs { position: absolute; bottom: 0; left: 0; right: 0; height: 50px; padding-bottom: env(safe-area-inset-bottom, 0px); background-color: var(--item-bg); border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; align-items: flex-start; z-index: 5; box-sizing: border-box; }
        .tab-link { flex: 1; text-align: center; padding: 8px 0; cursor: pointer; color: var(--secondary-text-color); border-top: 2px solid transparent; font-size: 14px; }
        .tab-link.active { color: var(--accent-color); border-top-color: var(--accent-color); }
        .tab-content-wrapper { flex-grow: 1; overflow: hidden; position: relative; z-index: 0; }
        .tab-content { display: none; padding: 15px; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow-y: auto; box-sizing: border-box; padding-bottom: 80px; /* FIX: ä¿®å¤åº•éƒ¨é®æŒ¡é—®é¢˜ */ }
        .tab-content.active { display: block; }
#world-book-tab-content, #archive-tab-content, #info-tab-content {
    padding-bottom: 80px;
}

        /* --- è®¾ç½® APP ç‰¹å®šæ ·å¼ --- */
        .settings-group { margin-bottom: 25px; padding: 0 20px; }
        .settings-group .group-title { font-size: 14px; color: var(--secondary-text-color); padding-left: 15px; text-transform: uppercase; }
.group-title-wrapper { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
.style-actions { display: flex; gap: 15px; padding-right: 15px; }
.style-actions .icon-btn { background: none; border: none; cursor: pointer; color: var(--secondary-text-color); font-size: 16px; padding: 5px; }
.style-actions .icon-btn:hover { color: var(--accent-color); }
        .settings-group .group-content { background-color: var(--item-bg); border-radius: 10px; overflow: hidden; }
        .settings-item { padding: 12px 15px; border-bottom: 1px solid var(--border-color); display: flex; flex-direction: column; }
        .settings-item:last-child { border-bottom: none; }
        .settings-item label { font-size: 16px; margin-bottom: 8px; }
        .settings-item input, .settings-item select { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 5px; font-size: 15px; box-sizing: border-box; font-family: inherit; }
        .settings-item input[type="password"] { -webkit-text-security: disc; }
        .settings-button { width: 100%; padding: 12px; font-size: 16px; color: var(--button-text-color); background-color: var(--button-bg); border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; font-family: inherit; }
        .settings-button:active { background-color: #0056b3; }
        .settings-button.secondary { background-color: #555; }
        .settings-button.secondary:active { background-color: #333; }
        #global-realtime-char-selector {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    gap: 15px;
    padding-top: 5px;
}
    .realtime-char-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        cursor: pointer;
        border: 2px solid transparent;
        border-radius: 8px;
        padding: 5px;
        transition: border-color 0.2s;
    }
    .realtime-char-item .avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-size: cover;
        background-position: center;
        flex-shrink: 0;
    }
    .realtime-char-item .name {
        font-size: 11px;
        text-align: center;
        word-break: break-all;
        line-height: 1.2;
        height: 2.4em; /* ç¡®ä¿æœ€å¤šæ˜¾ç¤ºä¸¤è¡Œ */
        overflow: hidden;
    }
    .realtime-char-item.selected {
        border-color: var(--accent-color);
    }
        #confirm-api-btn { margin-top: 15px; }
        .button-group { display: flex; gap: 10px; margin-top: 10px; }
        .filter-dropdown {
        display: none;
        position: absolute;
        top: calc(env(safe-area-inset-top, 10px) + 75px); /* Position below the header */
        right: 15px;
        width: 180px;
        background-color: var(--item-bg);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        border: 1px solid var(--border-color);
        z-index: 20;
        max-height: 250px;
        overflow-y: auto;
        padding: 10px;
    }
    .filter-dropdown.visible {
        display: block;
    }
    .filter-dropdown .checkbox-label {
        width: 100%;
        padding: 8px 5px;
        border: none;
        border-radius: 4px;
    }
    .filter-dropdown .checkbox-label:hover {
        background-color: var(--item-active-bg);
    }
        #styles-tab-content.active {
        display: flex;
        height: 100%;
        padding: 15px;
    }
    .love-letter-container {
    display: flex;
    flex-direction: row;
    width: 100%;
    height: 100%;
    gap: 15px;
    padding: 15px;
    box-sizing: border-box;
}
.styles-container {
    display: block;
    height: 100%;
    padding: 0;
}
.styles-rows-container {
    height: 100%;
    overflow-y: auto;
    padding: 15px;
    box-sizing: border-box;
}
.style-row-group {
    margin-bottom: 25px;
}
.style-row-group h3 {
    margin-top: 0;
    margin-bottom: 10px;
    padding-left: 5px;
}
.styles-row-scroll {
    display: flex;
    overflow-x: auto;
    gap: 15px;
    padding: 5px;
    padding-bottom: 15px; /* Space for scrollbar */
    scrollbar-width: thin;
}
.styles-row-scroll::-webkit-scrollbar {
    height: 6px;
}
.styles-row-scroll::-webkit-scrollbar-thumb {
    background-color: #ccc;
    border-radius: 3px;
}
.styles-row-scroll .style-preview-card {
    width: 200px;
    min-height: 180px; /* ç¡®ä¿å¡ç‰‡æœ‰æœ€å°é«˜åº¦ */
    flex-shrink: 0;
}
        .styles-column {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow-y: auto; /* å…è®¸å‚ç›´æ»šåŠ¨ */
    overflow-x: hidden; /* ç¦æ­¢æ°´å¹³æ»šåŠ¨ */
}
    .styles-column h3 {
        text-align: center;
        margin-top: 0;
        margin-bottom: 10px;
        flex-shrink: 0;
    }
    #sent-letters-list, #received-letters-list {
        flex-grow: 1;
        padding: 0; /* Fix: Removed unnecessary padding */
        align-content: flex-start;
    }
    .style-preview-item {
        padding: 10px;
        background-color: var(--item-bg);
        border-radius: 5px;
        cursor: pointer;
        border: 1px solid var(--border-color);
    }
    .style-preview-item:hover {
        background-color: var(--item-active-bg);
    }
    .style-preview-name {
        font-weight: bold;
        margin-bottom: 8px;
    }
    .style-preview-content {
        font-size: 12px;
        color: var(--secondary-text-color);
        white-space: pre;
        overflow: hidden;
        text-overflow: ellipsis;
        max-height: 4.5em; /* Limit to about 3 lines */
    }
        .styles-list {
display: grid;
grid-template-columns: 1fr; /* Single column for better mobile view */
gap: 10px;
align-content: start;
}
    

    .style-preview-card {
    padding: 10px;
    background-color: var(--item-bg);
    border-radius: 8px;
    cursor: pointer;
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow: hidden;
}
    .style-preview-card:hover {
        background-color: var(--item-active-bg);
    }
    .style-preview-card .style-preview-name {
    font-weight: bold;
    white-space: normal; /* å…è®¸æ¢è¡Œ */
    word-break: break-all; /* ç¡®ä¿é•¿å•è¯ä¹Ÿèƒ½æ¢è¡Œ */
    font-size: 14px;
    text-align: left;
    border-bottom: none;
    padding-bottom: 0;
    margin-bottom: 0;
    flex-grow: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

    /* Theme Preview Specific Styles */
    .theme-preview-wrapper {
        background-color: var(--bg-color);
        padding: 8px;
        border-radius: 5px;
        transform: scale(0.9);
        transform-origin: top center;
        pointer-events: none; /* Prevent clicks inside preview */
    }
    .mini-header {
        font-size: 8px;
        padding: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--border-color);
        background-color: var(--app-screen-bg);
    }
    .mini-list-item {
        margin-top: 4px;
    }
    .mini-list-item .swipe-content {
        padding: 4px;
        font-size: 8px;
        display: flex;
        align-items: center;
        gap: 4px;
        background-color: var(--item-bg);
    }
    .mini-list-item .avatar {
        width: 16px; height: 16px; border-radius: 50%; background-color: #ccc;
    }
    .mini-moments-card {
        margin-top: 4px;
    }
    .mini-moments-card .post-item-content {
        padding: 4px;
        font-size: 8px;
        background-color: var(--item-bg);
    }
    .mini-tabs {
        margin-top: 4px;
        display: flex;
        justify-content: space-around;
        font-size: 8px;
        padding: 4px 0;
        border-top: 1px solid var(--border-color);
        background-color: var(--item-bg);
    }
    
    /* Bubble Preview Specific Styles */
    .bubble-preview-wrapper {
    padding: 8px;
    border-radius: 5px;
    background-color: #f0f2f5; /* A neutral chat background */
    pointer-events: none;
    display: flex;
    flex-direction: column;
    gap: 5px;
    flex-grow: 1;
    justify-content: center;
}
    .bubble-preview-wrapper .message-item {
        transform: scale(0.9);
        gap: 4px;
    }
    .bubble-preview-wrapper .avatar {
        width: 20px;
        height: 20px;
    }
    .bubble-preview-wrapper .message-bubble {
        padding: 4px 8px;
        font-size: 9px;
    }
    .style-preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 8px;
}
.style-preview-actions {
    display: flex;
    gap: 8px;
    flex-shrink: 0;
}
.style-preview-actions .icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--secondary-text-color);
    font-size: 14px;
    padding: 0 4px;
}
.style-preview-actions .icon-btn:hover { color: var(--accent-color); }
.style-preview-actions .delete-style-btn:hover { color: var(--danger-color); }
        /* --- éŸ³ä¹ APP --- */
        #music-list { list-style: none; padding: 0; margin: 0; }
        .music-list-item { position: relative; background-color: var(--item-bg); border-bottom: 1px solid var(--border-color); overflow: hidden; }
        .music-item-content { padding: 10px 15px; background-color: var(--item-bg); transition: transform 0.3s ease; position: relative; z-index: 2; display: flex; justify-content: space-between; align-items: center; }
        .music-item-info { display: flex; flex-direction: column; overflow: hidden; }
        .music-item-info .title { font-size: 16px; font-weight: 500; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
        .music-item-info .artist { font-size: 13px; color: var(--secondary-text-color); white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
        .music-item-duration { font-size: 14px; color: var(--secondary-text-color); flex-shrink: 0; padding-left: 10px; }
        .music-list-item.playing .music-item-info .title, .music-list-item.playing .music-item-info .artist { color: var(--accent-color); }

        /* --- æµ®åŠ¨æ­Œè¯ --- */
        #lyrics-container { position: absolute; top: calc(env(safe-area-inset-top, 10px) + 60px); left: 50%; transform: translateX(-50%); width: 90%; max-width: 380px; background-color: rgba(0,0,0,0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; border-radius: 12px; padding: 10px; box-sizing: border-box; font-size: 14px; text-align: center; z-index: 40; cursor: grab; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        #lyrics-container.visible { opacity: 1; visibility: visible; }
        #lyrics-line { font-weight: bold; text-shadow: 1px 1px 2px black; }

        /* --- éŸ³ä¹æ’­æ”¾å™¨æ¨¡æ€æ¡† --- */
        #player-modal { position: absolute; top: 50%; left: 50%; width: 80%; max-width: 300px; height: 60%; max-height: 550px; transform: translate(-50%, -50%) scale(0.9); background-color: rgba(50, 50, 50, 0.2); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); border-radius: 20px; z-index: 150; display: flex; flex-direction: column; color: white; opacity: 0; visibility: hidden; transition: opacity 0.3s, transform 0.3s, visibility 0.3s; }
        #player-modal.show { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); }
        .player-header { padding: 15px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .player-header .icon-btn { background: none; border: none; cursor: pointer; padding: 5px; font-size: 22px; color: white; }
        .player-song-info { text-align: center; }
        .player-song-info .title { font-size: 16px; font-weight: bold; }
        .player-song-info .artist { font-size: 13px; color: #ccc; }
        #listen-together-info { font-size: 12px; color: var(--listen-together-color); margin-top: 4px; display: none; align-items: center; justify-content: center; gap: 5px; }
        .listen-heart { width: 14px; height: 12px; position: relative; animation: heart-beat 1.2s infinite cubic-bezier(0.215, 0.61, 0.355, 1); }
        .listen-heart::before, .listen-heart::after { content: ""; position: absolute; top: 0; left: 7px; width: 7px; height: 11px; background: var(--listen-together-color); border-radius: 7px 7px 0 0; transform: rotate(-45deg); transform-origin: 0 100%; }
        .listen-heart::after { left: 0; transform: rotate(45deg); transform-origin: 100% 100%; }
        @keyframes heart-beat { 0% { transform: scale(0.95); } 5% { transform: scale(1.1); } 39% { transform: scale(0.85); } 45% { transform: scale(1); } 60% { transform: scale(0.95); } 100% { transform: scale(0.9); } }
        .player-body { flex-grow: 1; overflow: hidden; position: relative; }
        .player-view { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow-y: auto; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        .player-view.active { opacity: 1; pointer-events: auto; }
        #player-lyrics-view { padding: 10px 20px; font-size: 16px; line-height: 1.8; text-align: center; }
        #player-lyrics-view .lyric-line { transition: color 0.3s, transform 0.3s, opacity 0.3s; opacity: 0.5; }
        #player-lyrics-view .lyric-line.active { color: white; opacity: 1; transform: scale(1.1); font-weight: bold; }
        .player-playlist-view { list-style: none; padding: 0; margin: 0; }
        .player-playlist-item { display: flex; align-items: center; padding: 10px 20px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .player-playlist-item.playing .info .title { color: var(--accent-color); }
        .player-playlist-item .info { flex-grow: 1; }
        .player-playlist-item .info .title { font-size: 15px; }
        .player-playlist-item .info .artist { font-size: 12px; color: #aaa; }
        .delete-from-queue-btn { background: transparent; border: none; color: white; font-size: 18px; cursor: pointer; }
        .player-playlist-header { padding: 10px 20px; display: flex; justify-content: flex-end; }
        .player-footer { padding: 15px 20px; flex-shrink: 0; }
        #progress-bar { width: 100%; -webkit-appearance: none; appearance: none; height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; outline: none; }
        #progress-bar::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; background: white; border-radius: 50%; cursor: pointer; }
        #progress-bar::-moz-range-thumb { width: 14px; height: 14px; background: white; border-radius: 50%; cursor: pointer; }
        .player-controls { display: flex; justify-content: space-around; align-items: center; margin-top: 15px; }
        .player-controls .icon-btn { background: none; border: none; cursor: pointer; padding: 5px; }
        .player-controls .icon-btn img { height: 20px; width: auto; }
        .player-controls .play-pause-btn img { height: 32px; }
        #player-playback-mode-btn { font-size: 20px; }

        /* --- ç¾åŒ– APP --- */
        #beautify-app-screen .app-content { padding-bottom: 50px; }
        #wallpaper-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .wallpaper-item { width: 100%; height: auto; aspect-ratio: 9 / 16; border-radius: 8px; cursor: pointer; position: relative; overflow: hidden; border: 2px solid transparent; transition: border-color 0.2s; background-color: #f0f0f0; }
        .wallpaper-item img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .wallpaper-item.is-wallpaper { border-color: var(--accent-color); }
        .wallpaper-item.is-chat-bg { border-color: var(--listen-together-color); }
        .wallpaper-item.is-wallpaper.is-chat-bg { border-image: linear-gradient(45deg, var(--accent-color), var(--listen-together-color)) 1; }
        .wallpaper-item::before { content: 'å£çº¸'; position: absolute; bottom: 2px; left: 4px; background-color: var(--accent-color); color: white; padding: 1px 4px; border-radius: 3px; font-size: 9px; font-weight: bold; display: none; }
        .wallpaper-item.is-wallpaper::before { display: block; }
        .wallpaper-item::after { content: 'èƒŒæ™¯'; position: absolute; bottom: 2px; right: 4px; background-color: var(--listen-together-color); color: white; padding: 1px 4px; border-radius: 3px; font-size: 9px; font-weight: bold; display: none; }
        .wallpaper-item.is-chat-bg::after { display: block; }
        #font-list { list-style: none; padding: 0; margin: 0; }
        .font-list-item { position: relative; background-color: var(--item-bg); border-bottom: 1px solid var(--border-color); overflow: hidden; }
        .font-item-content { padding: 15px; background-color: var(--item-bg); transition: transform 0.3s ease; position: relative; z-index: 2; display: flex; justify-content: space-between; align-items: center; }
        .font-item-content.active { color: var(--accent-color); font-weight: bold; }
        .font-color-btn { background: none; border: 1px solid var(--border-color); border-radius: 5px; padding: 3px 8px; cursor: pointer; font-size: 14px; }
        #icon-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; }
        .icon-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; }
        .icon-item .icon-preview { width: 36px; height: 36px; display: flex; justify-content: center; align-items: center; font-size: 24px; }
        .icon-item .icon-preview img { max-width: 100%; max-height: 100%; }
        .icon-item .icon-name { font-size: 9px; color: var(--secondary-text-color); text-align: center; word-break: break-word; }
        #bubble-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .bubble-item { display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; padding: 10px; border-radius: 8px; }
        .bubble-item .bubble-preview-container { width: 100%; height: 40px; display: flex; justify-content: center; align-items: center; }
        .bubble-item .bubble-preview-container button { background-color: white; border: 1px solid var(--border-color); border-radius: 8px; padding: 5px 10px; font-size: 14px; color: var(--accent-color); font-family: inherit; }
        .bubble-item .bubble-preview-container button img { height: 24px; width: auto; }
        .bubble-item.global-bubble-item { border: 2px solid transparent; } /* Replaced dashed border with transparent */

        /* ä¼˜åŒ–ï¼šç¡®ä¿æ°”æ³¡ç½‘æ ¼åœ¨æ‰€æœ‰è®¾å¤‡ä¸Šéƒ½èƒ½è‰¯å¥½æ¢è¡Œï¼Œè€Œä¸æ˜¯æ¨ªå‘æ»šåŠ¨ */
        #bubble-grid {
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
        }

        /* ä¼˜åŒ–ï¼šå½“åº“ç”¨äºé€‰æ‹©èƒŒæ™¯æ—¶ï¼Œæä¾›æ›´åˆé€‚çš„é¢„è§ˆå°ºå¯¸ */
        .modal-overlay.background-preview-mode .library-item {
            aspect-ratio: 9 / 16;
            border-radius: 8px; /* å¼ºåˆ¶ä½¿ç”¨çŸ©å½¢ï¼Œè€Œéåœ†å½¢ */
        }
        .modal-overlay.background-preview-mode .library-item.circular {
            border-radius: 8px; /* è¦†ç›– .circular çš„åœ†å½¢æ ·å¼ */
        }
            .theme-css-editor {
        width: 100%;
        box-sizing: border-box;
        border: 1px solid var(--border-color);
        background-color: #ffffff;
        color: #000000;
        font-family: 'Courier New', Courier, monospace;
        font-size: 14px;
        padding: 10px;
        resize: vertical;
        white-space: pre;
        overflow-wrap: normal;
        overflow-x: auto;
        border-radius: 5px; /* Added for consistency */
    }
    .theme-css-editor::placeholder {
        color: #aaa;
        font-style: italic;
    }
        .bubble-css-preview {
        margin-top: 15px;
        padding: 15px;
        background-color: #f0f2f5;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-height: 100px;
    }
        /* --- å¼¹çª—/æ¨¡æ€æ¡†æ ·å¼ (Z-Index Management) --- */
        .modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: flex; justify-content: center; align-items: center; z-index: 100; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        #gcs-member-modal { z-index: 110; }
        #library-modal, #load-persona-modal, #gcs-manage-members-modal, #gcs-member-action-modal, #bubble-io-modal, #post-moment-modal { z-index: 120; }
        #edit-photo-modal { z-index: 140; }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--app-screen-bg); padding: 20px; border-radius: 14px; width: 90%; max-width: 350px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); transform: scale(0.9); transition: transform 0.2s; }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-title { font-size: 18px; font-weight: 600; text-align: center; margin-bottom: 15px; }
        #memory-char-selector-modal .modal-body {
    max-height: 320px; /* è°ƒæ•´é«˜åº¦ä»¥é€‚åº”ä¸‰è¡Œ */
    overflow: hidden; /* éšè—å‚ç›´æ»šåŠ¨æ¡ */
}
#memory-char-selector-grid {
    display: grid;
    grid-template-rows: repeat(3, 1fr);
    grid-auto-flow: column;
    gap: 10px;
    overflow-x: auto;
    padding-bottom: 15px; /* ä¸ºæ»šåŠ¨æ¡ç•™å‡ºç©ºé—´ */
    height: 100%;
    box-sizing: border-box;
}
.modal-body { margin-bottom: 20px; max-height: 60vh; overflow-y: auto; }
        .modal-body .form-group { margin-bottom: 12px; }
        .modal-body .form-group label { display: block; font-size: 14px; margin-bottom: 5px; color: var(--secondary-text-color); }
        .modal-body .form-group input, .modal-body .form-group select,
        .form-group input[type="text"], .form-group input[type="number"], .form-group input[type="password"] { 
            width: 100%; 
            padding: 8px; 
            border: 1px solid var(--border-color); 
            border-radius: 5px; 
            font-size: 15px; 
            box-sizing: border-box; 
            font-family: inherit; 
        }
        .wide-textarea { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 5px; font-size: 15px; box-sizing: border-box; resize: vertical; min-height: 120px; font-family: inherit; }
        input::placeholder,
        textarea::placeholder {
            font-family: inherit;
            opacity: 0.7;
        }
        #pat-suffix-input { width: 100%; box-sizing: border-box; }
        .uniform-input-box { width: 100%; height: 40px; min-height: 40px !important; padding: 8px 15px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 5px; font-size: 15px; font-family: inherit; resize: none; }
        .modal-actions { display: flex; justify-content: space-around; gap: 10px; flex-direction: column; }
        .modal-actions button { width: 100%; padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 500; font-family: inherit; }
        .modal-actions .confirm-btn { background-color: var(--accent-color); color: white; }
        .modal-actions .cancel-btn { background-color: #e5e5ea; color: var(--accent-color); }
        .modal-actions .danger-btn { background-color: var(--danger-color); color: white; }
        .modal-actions.row { flex-direction: row; } .modal-actions.row button { flex: 1; }
        .modal-tabs { display: flex; margin-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .tab-btn { flex: 1; padding: 10px; border: none; background: none; cursor: pointer; font-size: 16px; color: var(--secondary-text-color); border-bottom: 2px solid transparent; font-family: inherit; }
        .tab-btn.active { color: var(--accent-color); border-bottom-color: var(--accent-color); }
        .modal-tab-content { display: none; }
        .modal-tab-content.active { display: block; }
        #add-music-modal .modal-actions .single-button { flex: none; width: 100%; }
        .inline-inputs { display: flex; gap: 10px; }
        .inline-inputs .form-group { flex: 1; }
        .inline-inputs input { text-align: center; }
        #bubble-preview-wrapper { width: 100%; height: 80px; border: 1px dashed var(--border-color); margin-top: 15px; display: flex; justify-content: center; align-items: center; border-radius: 8px; overflow: hidden; }
        #bubble-preview { display: flex; justify-content: center; align-items: center; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
        .hidden-by-logic { display: none !important; }
        .fr-history-container {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid var(--border-color);
    max-height: 15vh;
    overflow-y: auto;
    display: flex;
    flex-direction: column-reverse; /* å…³é”®ï¼šå®ç°ä»ä¸‹åˆ°ä¸Šçš„æ˜¾ç¤ºé¡ºåº */
    gap: 8px;
}
.history-line {
    font-size: 12px;
    color: var(--secondary-text-color);
    margin: 0;
    text-align: left;
    line-height: 1.5;
}
.history-line strong {
    color: var(--primary-text-color);
}

        /* --- åˆ—è¡¨æ»‘åŠ¨é€šç”¨æ ·å¼ --- */
                .preset-list-item, .preset-data-item, .music-list-item, .font-list-item, .contact-list-item, .comment-item, .moments-post-item, .message-board-item, .stock-item { position: relative; background-color: var(--item-bg); border-bottom: 1px solid var(--border-color); overflow: hidden; touch-action: pan-y; }
                .preset-item-content, .preset-data-item-content, .music-item-content, .font-item-content, .contact-item-content, .comment-item-main, .post-item-content, .message-board-item-main, .stock-item-content { background-color: var(--item-bg); transition: transform 0.3s ease; position: relative; z-index: 2; }
            .preset-item-actions, .music-item-actions, .font-item-actions, .preset-data-item-actions, .contact-item-actions, .comment-item-actions-swipe, .post-item-actions, .message-board-item-actions, .stock-item-actions { position: absolute; top: 0; right: 0; height: 100%; display: flex; z-index: 1; }
            .preset-item-actions > div, .music-item-actions > div, .font-item-actions > div, .preset-data-item-actions > div, .contact-item-actions > div, .comment-item-actions-swipe > div, .post-item-actions > div, .message-board-item-actions > div, .stock-item-actions > div { width: 70px; height: 100%; color: white; display: flex; justify-content: center; align-items: center; cursor: pointer; }
                .pin-action { background-color: #8e8e93; }
        .contact-list-item.pinned > .contact-item-content { background-color: #f7f7f7; }
        .edit-action { background-color: var(--edit-color); }
        .delete-action { background-color: var(--danger-color); }
        #manage-presets-modal .modal-content { min-height: 300px; }
        #manage-presets-modal .modal-body p { margin-top: 0; margin-bottom: 15px; }
        
        /* --- æ­Œæ›²è¯¦æƒ…é¡µ & åŠ¨æ€è¯„è®ºåŒº (é€šç”¨æ ·å¼) --- */
        #song-details-screen { background-color: var(--app-screen-bg); display: flex; flex-direction: column; }
        #song-details-screen .app-content { display: flex; flex-direction: column; overflow: hidden; padding: 0; }
        .details-song-info { text-align: center; padding: 15px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .details-song-info .title { font-size: 20px; font-weight: bold; }
        .details-song-info .artist { font-size: 16px; color: var(--secondary-text-color); }
        .details-lyrics-container { flex: 1; overflow-y: auto; padding: 20px; font-size: 18px; line-height: 2; text-align: center; }
        .details-lyrics-container .lyric-line { transition: color 0.3s, transform 0.3s, opacity 0.3s; opacity: 0.4; }
        .details-lyrics-container .lyric-line.active { color: var(--primary-text-color); opacity: 1; transform: scale(1.1); font-weight: bold; }
        .details-comments-section { flex: 1; border-top: 1px solid var(--border-color); display: flex; flex-direction: column; }
        .details-comments-list { flex-grow: 1; overflow-y: auto; padding: 15px; }
        .comment-item { border-bottom: none; }
        .comment-item-main { display: flex; gap: 10px; padding: 10px 0; }
        .comment-avatar { width: 40px; height: 40px; border-radius: 50%; background-color: #ccc; flex-shrink: 0; background-size: cover; background-position: center; }
        .comment-content { flex-grow: 1; }
        .comment-header { display: flex; justify-content: space-between; align-items: center; }
        .comment-author { font-weight: bold; font-size: 15px; }
        .comment-actions-inline { display: flex; gap: 15px; font-size: 14px; color: var(--secondary-text-color); }
        .comment-actions-inline .icon-btn { background: none; border: none; cursor: pointer; padding: 0 5px; display: flex; align-items: center; gap: 4px; }
        .comment-actions-inline .icon-btn.liked { color: var(--like-color); }
        .comment-text { margin-top: 5px; font-size: 15px; line-height: 1.5; }
        .comment-replies { margin-left: 50px; margin-top: 10px; border-left: 2px solid #eee; padding-left: 10px; }
        .reply-item { font-size: 14px; margin-bottom: 8px; position: relative; cursor: pointer; }
        .reply-author { font-weight: bold; }
        .reply-target { color: var(--accent-color); }
        .reply-input-container { display: none; margin-top: 5px; }
        .reply-input-container.active { display: flex; gap: 5px; }
        .reply-input-container input { flex-grow: 1; border: 1px solid var(--border-color); border-radius: 15px; padding: 5px 10px; }
        .comment-timestamp, .reply-timestamp { font-size: 12px; color: var(--secondary-text-color); margin-left: 8px; }
        .reply-item { display: flex; gap: 8px; align-items: flex-start; }
        .reply-avatar { width: 24px; height: 24px; border-radius: 50%; background-color: #ccc; flex-shrink: 0; background-size: cover; background-position: center; margin-top: 2px; }
        .reply-content { flex-grow: 1; }
        .comment-input-area { padding: 10px; border-top: 1px solid var(--border-color); background-color: #f9f9f9; flex-shrink: 0; display: flex; gap: 10px; align-items: center; }
        .comment-input-area input { flex-grow: 1; padding: 10px; border: 1px solid var(--border-color); border-radius: 20px; box-sizing: border-box; }
        .comment-input-area button { flex-shrink: 0; width: 70px; padding: 8px 15px; border-radius: 20px; }

        /* --- èµ„æ–™ APP --- */
        #data-app-screen .app-content { padding: 0; display: flex; flex-direction: column; }
        #data-app-screen .tab-content { padding: 0; } /* ç§»é™¤å†…è¾¹è· */
        .preset-data-list { list-style: none; padding: 0; margin: 0; padding-bottom: 50px; /* BUG FIX: ä¿®å¤åº•éƒ¨é®æŒ¡ */ }
        .preset-data-item-content { display: flex; align-items: center; gap: 15px; padding: 15px; }
        .preset-data-avatar { width: 50px; height: 50px; border-radius: 50%; background-color: #e0e0e0; background-size: cover; background-position: center; flex-shrink: 0; }
        .preset-data-info { overflow: hidden; }
        .preset-data-name { font-size: 16px; font-weight: 500; }
        .preset-data-excerpt { font-size: 13px; color: var(--secondary-text-color); white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
        .modal-avatar-preview { width: 80px; height: 80px; border-radius: 50%; background-color: #f0f0f0; margin: 0 auto 15px; background-size: cover; background-position: center; }
        .modal-avatar-actions { display: flex; gap: 10px; justify-content: center; margin-bottom: 15px; }
        .modal-avatar-actions button { flex: 1; }
        .data-group-input-wrapper {
        display: flex;
        align-items: center; /* ç¡®ä¿åœ¨flexå®¹å™¨ä¸­å‚ç›´å±…ä¸­å¯¹é½ */
        gap: 10px;
    }
    .data-group-input-wrapper #data-group,
    .data-group-input-wrapper #data-group-select {
        width: 50%;
        /* ä¸è®¾ç½®å›ºå®šé«˜åº¦ï¼Œè®©å…¶ç”±å†…è¾¹è·å’Œå­—ä½“å¤§å°è‡ªç„¶å†³å®š */
    }
    /* ç¡®ä¿ä¸‹æ‹‰æ¡†ç»§æ‰¿ä¸å…¶ä»–è¾“å…¥æ¡†ç›¸åŒçš„é€šç”¨æ ·å¼ */
    .data-group-input-wrapper #data-group-select {
        background-color: var(--input-bg);
        color: var(--primary-text-color);
    }

        /* --- èŠå¤© APP --- */
        #chat-app-screen .app-content { padding-bottom: 50px; }
        #chat-app-screen.selection-mode .contact-list-item.selected .contact-item-content { background-color: var(--item-active-bg); }
        #message-list { list-style: none; padding: 0; margin: 0; padding-bottom: calc(50px + env(safe-area-inset-bottom, 0px)); /* ä¿®å¤åˆ—è¡¨æˆªæ–­ */ }
        .contact-item-content { display: flex; align-items: center; gap: 12px; padding: 10px 15px; }
        .contact-avatar { width: 50px; height: 50px; border-radius: 50%; background-color: #e0e0e0; background-size: cover; background-position: center; flex-shrink: 0; position: relative; }
        .contact-avatar.group-puzzle { background-color: transparent; }
        .puzzle-piece { position: absolute; width: 50%; height: 50%; background-size: cover; background-position: center; }
        .puzzle-piece:nth-child(1) { top: 0; left: 0; border-top-left-radius: 50%; }
        .puzzle-piece:nth-child(2) { top: 0; right: 0; border-top-right-radius: 50%; }
        .puzzle-piece:nth-child(3) { bottom: 0; left: 0; border-bottom-left-radius: 50%; }
        .puzzle-piece:nth-child(4) { bottom: 0; right: 0; border-bottom-right-radius: 50%; }
        .unread-badge { position: absolute; top: -2px; left: -2px; width: 18px; height: 18px; background-color: var(--danger-color); color: white; border-radius: 50%; font-size: 11px; font-weight: bold; display: flex; justify-content: center; align-items: center; border: 2px solid var(--item-bg); }
        .contact-avatar.shake, .moments-notification-btn.shake { animation: shake-anim 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake-anim { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
        .contact-info { flex-grow: 1; overflow: hidden; }
        .contact-name { font-size: 17px; font-weight: 500; }
        .contact-last-msg { font-size: 14px; color: var(--secondary-text-color); white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
        .contact-meta { text-align: right; flex-shrink: 0; font-size: 12px; color: var(--secondary-text-color); }
        .contact-status { display: flex; align-items: center; justify-content: flex-end; gap: 4px; }
        .status-indicator { width: 8px; height: 8px; border-radius: 50%; }
        .status-indicator.online { background-color: var(--online-color); }
        .status-indicator.busy { background-color: var(--busy-color); }
        .status-indicator.offline { background-color: var(--offline-color); }
        #single-chat-screen { display: flex; flex-direction: column; background-size: cover; background-position: center; }
        #single-chat-screen .app-header .title-wrapper { display: flex; flex-direction: column; align-items: center; line-height: 1.2; position: relative; top: 10px; /* å‘ä¸‹åç§»10px */ }
        #single-chat-screen .chat-header-name { font-size: 16px; font-weight: 600; cursor: pointer; }
        #single-chat-screen .chat-header-status { font-size: 11px; color: var(--secondary-text-color); cursor: pointer; display: flex; align-items: center; gap: 5px; }
        #single-chat-screen .chat-header-signature { font-size: 11px; color: var(--secondary-text-color); cursor: pointer; margin-top: 2px; }
        #single-chat-screen.selection-mode #chat-settings-btn { font-size: 16px; font-weight: normal; padding: 5px 10px; }
        #single-chat-screen .app-content { flex-grow: 1; padding: 10px; overflow-y: auto; display: flex; flex-direction: column-reverse; background-color: transparent; }
        #chat-messages-view { display: flex; flex-direction: column; gap: 15px; padding-bottom: 10px; }
        .message-item { display: flex; align-items: flex-start; gap: 8px; position: relative; -webkit-touch-callout: none; /* Disable iOS default long-press menu */ }
        .message-item.selected::before, .message-timestamp.selected::before { content: ''; position: absolute; top: -5px; left: -5px; right: -5px; bottom: -5px; background-color: rgba(0, 122, 255, 0.15); border-radius: 12px; z-index: -1; }
        .message-content-wrapper { max-width: 70%; display: flex; flex-direction: column; }
        .message-bubble { padding: 8px 12px; border-radius: 18px; line-height: 1.5; word-wrap: break-word; }
        .message-item.user { justify-content: flex-end; }
        .message-item.contact { justify-content: flex-start; }
.message-item .avatar { width: 40px; height: 40px; border-radius: 50%; background-color: #ccc; flex-shrink: 0; cursor: pointer; background-size: cover; background-position: center calc(50% +0px); /* å¤´åƒå›¾ç‰‡å‚ç›´ä½ç§»è°ƒèŠ‚ */ position: relative; }        .message-item .avatar .avatar-frame { position: absolute; top: 50%; left: 50%; transform: translate(-50%, calc(-50% - 2px)); width: calc(100% * 250 / 268 + 10px); height: calc(100% + 10px); background-size: contain; background-repeat: no-repeat; background-position: center; }
        .message-item.user .avatar { order: 2; }
        .message-item.user .message-content-wrapper { align-items: flex-end; }
        .message-item.user .message-bubble { background-color: var(--accent-color); color: white; border-bottom-right-radius: 4px; }
        .message-item.contact .message-bubble { background-color: white; color: black; border-bottom-left-radius: 4px; }
        .message-timestamp { width: 100%; text-align: center; font-size: 12px; color: var(--secondary-text-color); margin: 10px 0; cursor: pointer; position: relative; }
        .typing-indicator { text-align: center; font-size: 12px; color: var(--secondary-text-color); padding: 5px; }
        #chat-footer { flex-shrink: 0; background-color: #f7f7f7; border-top: 1px solid var(--border-color); padding: 5px 8px; padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 5px); display: flex; flex-direction: column; position: relative; top: -2px; }
        #quote-preview { display: none; padding: 8px; margin-bottom: 5px; background-color: #e9e9e9; border-radius: 8px; font-size: 13px; color: #555; position: relative; }
        #quote-preview-content { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #close-quote-btn { position: absolute; top: 5px; right: 5px; background: #aaa; color: white; border: none; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; line-height: 16px; text-align: center; cursor: pointer; }
        .chat-input-area { display: flex; align-items: center; gap: 5px; }
        #chat-send-real-btn { background: none; border: none; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; }
        #chat-input { flex-grow: 1; border: none; background-color: white; border-radius: 18px; padding: 8px 15px; font-size: 16px; resize: none; max-height: 100px; }
        #chat-input-buttons { display: flex; align-items: center; }
        #chat-input-buttons .icon-btn { background: none; border: none; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; }
        .chat-toolbar-wrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; position: relative; left: 3px; padding-top: 2px; }
        .chat-toolbar-wrapper::-webkit-scrollbar { display: none; }
        .chat-toolbar { display: flex; justify-content: flex-start; white-space: nowrap; gap: 15px; }
        .chat-toolbar .icon-btn { background: none; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; }
        .chat-toolbar .icon-btn img, #chat-input-buttons .icon-btn img, #chat-send-real-btn img { height: 44px; width: 44px; object-fit: contain; }
        .chat-toolbar .icon-btn.disabled, #chat-emoji-btn.disabled { opacity: 0.5; cursor: not-allowed; }
#emoji-picker-panel { position: absolute; bottom: 0; left: 0; right: 0; height: 250px; background-color: #f9f9f9; border-top: 1px solid var(--border-color); transform: translateY(100%); transition: transform 0.3s ease; z-index: 20; display: flex; flex-direction: column; padding-bottom: env(safe-area-inset-bottom, 0px); overflow-x: hidden; touch-action: pan-y; /* æ ¸å¿ƒä¼˜åŒ–ï¼šç¦æ­¢æ¨ªå‘æ»‘åŠ¨ */ }
        #emoji-picker-panel.visible { transform: translateY(0); }
        .emoji-picker-header { padding: 10px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); }
        .emoji-picker-header button { background: none; border: none; font-size: 16px; color: var(--accent-color); cursor: pointer; }
        #emoji-grid { flex-grow: 1; overflow-y: auto; padding: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 10px; }
        .emoji-item { width: 40px; height: 40px; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; position: relative; border: 2px solid transparent; border-radius: 4px; }
        #emoji-picker-panel.selection-mode .emoji-item.selected { border-color: var(--accent-color); }
        
        /* --- New/Modified Message Bubble Types --- */
        .message-bubble.voice { padding: 5px 10px; display: flex; align-items: center; gap: 8px; cursor: pointer; overflow: hidden; /* BUG FIX */ }
        .voice-waveform-container { flex-grow: 1; height: 20px; display: flex; align-items: center; justify-content: space-between; padding: 0 5px; min-width: 0; /* BUG FIX */ }
        .voice-waveform-container span { width: 2px; background-color: #888; border-radius: 1px; transition: height 0.2s; }
        .voice-waveform-container.playing span { animation: waveform-play 1.2s infinite ease-in-out; }
        .voice-waveform-container.playing span:nth-child(2n) { animation-delay: -0.2s; }
        .voice-waveform-container.playing span:nth-child(3n) { animation-delay: -0.4s; }
        .voice-waveform-container.playing span:nth-child(4n) { animation-delay: -0.6s; }
        .voice-waveform-container.playing span:nth-child(5n) { animation-delay: -0.8s; }
        @keyframes waveform-play { 0%, 100% { height: 10%; } 50% { height: 100%; } }
        .message-item.user .voice-waveform-container span { background-color: white; }
        .voice-duration { font-size: 12px; flex-shrink: 0; /* BUG FIX */ }
        .voice-text { display: none; margin-top: 5px; padding: 8px; background-color: #f0f0f0; border-radius: 8px; font-size: 14px; }
        
        .message-bubble.image, .message-bubble.camera { padding: 0; background: none; max-width: 60%; }
        .message-bubble.image img, .message-bubble.camera img { max-width: 100%; border-radius: 12px; display: block; }
        
        .message-bubble.emoji-bubble { background: none; padding: 0; display: inline-block; line-height: 0; max-width: 100px; }
        .message-bubble.emoji-bubble img { width: 100%; height: auto; display: block; }

        .message-bubble.camera { position: relative; cursor: pointer; }
        .camera-text-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: white; color: black; display: flex; justify-content: center; align-items: flex-start; text-align: center; padding: 10px; box-sizing: border-box; border-radius: 12px; opacity: 0; visibility: hidden; transition: opacity 0.2s; }
        .message-bubble.camera.show-text .camera-text-overlay { opacity: 1; visibility: visible; }
        .camera-text-overlay { word-break: break-all; overflow-y: auto; } /* BUG FIX: ä¿®å¤æ–‡å­—æº¢å‡º */
        .message-bubble.link { background-color: white; padding: 10px; cursor: pointer; border-radius: 12px; display: flex; flex-direction: column; gap: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .link-info .title { font-weight: bold; font-size: 15px; }
        .link-info .summary { font-size: 13px; color: var(--secondary-text-color); }
        .link-info .source { font-size: 12px; color: var(--secondary-text-color); border-top: 1px solid #eee; padding-top: 5px; margin-top: 5px; }
        .message-bubble.red-packet { background-color: #fa9d3b; color: white; width: 200px; cursor: pointer; }
        .message-bubble.red-packet.claimed, .message-bubble.red-packet.returned, .message-bubble.red-packet.expired { background-color: #fbcda5; }
        .red-packet-header { display: flex; align-items: center; gap: 8px; }
        .red-packet-icon { font-size: 24px; }
        .red-packet-body { margin-top: 5px; font-size: 14px; }
        .red-packet-footer { font-size: 10px; color: #eee; border-top: 1px solid rgba(255,255,255,0.5); margin-top: 8px; padding-top: 4px; }
        .message-bubble.red-packet.claimed .red-packet-footer, .message-bubble.red-packet.returned .red-packet-footer, .message-bubble.red-packet.expired .red-packet-footer { color: #fff; }
        .message-quote { background-color: #f0f0f0; padding: 5px 8px; border-radius: 6px; font-size: 13px; color: #666; border-left: 3px solid #ccc; margin-bottom: 5px; }
        .message-item.user .message-quote { background-color: rgba(255,255,255,0.2); color: #eee; border-left-color: #fff; }
        /* Group Chat Styles */
        .group-message-header { margin-bottom: 4px; font-size: 12px; color: var(--secondary-text-color); display: flex; align-items: center; gap: 6px; }
        .group-title { padding: 1px 5px; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; }
        .title-owner { background-color: var(--owner-title-bg); }
        .title-admin { background-color: var(--admin-title-bg); }
        .title-member { background-color: var(--member-title-bg); }
        .group-nickname { cursor: pointer; }
        .message-item.user .group-message-header { justify-content: flex-end; }

        /* --- é•¿æŒ‰èœå• --- */
        #context-menu, #wallpaper-context-menu { position: absolute; display: none; background-color: rgba(40, 40, 40, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 8px; padding: 5px; z-index: 110; flex-direction: column; }
        #context-menu { flex-direction: row; } /* Original menu remains row */
        .context-menu-btn { background: none; border: none; color: white; font-size: 13px; padding: 8px 12px; cursor: pointer; border-radius: 5px; text-align: left; width: 100%; box-sizing: border-box; }
        #context-menu .context-menu-btn { text-align: center; } /* Keep original centered */
        .context-menu-btn:hover { background-color: rgba(255, 255, 255, 0.2); }
        .context-menu-btn.danger { color: var(--danger-color); }
        #background-context-menu { position: absolute; display: none; background-color: rgba(40, 40, 40, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 8px; padding: 5px; z-index: 120; flex-direction: column; }
        #background-context-menu .context-menu-btn { text-align: left; }

        /* --- è‡ªå®šä¹‰å•é€‰/å¤šé€‰æŒ‰é’® --- */
        .radio-group, .checkbox-list { display: flex; gap: 10px; flex-wrap: wrap; }
        .radio-label, .checkbox-label { display: flex; align-items: center; gap: 5px; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 20px; cursor: pointer; font-family: inherit; }
        .radio-label input[type="radio"], .checkbox-label input[type="checkbox"] { display: none; }
        .radio-label input[type="radio"]:checked + span, .checkbox-label input[type="checkbox"]:checked + span { color: var(--accent-color); font-weight: bold; }
        .radio-label:has(input:checked), .checkbox-label:has(input:checked) { border-color: var(--accent-color); }

        /* --- èŠå¤©è®¾ç½®ç•Œé¢ --- */
        #chat-app-screen .app-content, #chat-settings-screen .app-content, #group-chat-settings-screen .app-content { padding: 0; display: flex; flex-direction: column; padding-bottom: 50px; }
        .chat-settings-layout { display: flex; gap: 15px; }
        .chat-settings-main { flex-grow: 1; display: flex; flex-direction: column; }
        .chat-settings-side { flex-shrink: 0; width: 80px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .chat-settings-avatar { width: 60px; height: 60px; border-radius: 50%; background-color: #eee; background-size: cover; background-position: center; position: relative; flex-shrink: 0; }
        .chat-settings-avatar .avatar-frame { position: absolute; top: 50%; left: 50%; transform: translate(-50%, calc(-50% - 5px)); width: calc(100% * 250 / 268 + 10px); height: calc(100% + 10px); background-size: contain; background-repeat: no-repeat; background-position: center; }
        .chat-settings-side-btn { font-size: 12px; padding: 5px 0; width: 100%; text-align: center; background-color: #eee; border-radius: 5px; cursor: pointer; }
        .chat-settings-section { margin-bottom: 20px; }
        .chat-settings-section .group-title { font-size: 14px; color: var(--secondary-text-color); margin-bottom: 8px; }
        .world-book-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .world-book-header label { font-size: 14px; color: var(--secondary-text-color); }
        .world-book-list-container { max-height: 100px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; padding: 10px; }
        .world-book-list-container .checkbox-label { display: flex; width: 100%; border: none; padding: 5px 0; border-radius: 0; }
        .form-group.aligned-right { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .form-group.aligned-right label { margin-bottom: 0; }
        .form-group.aligned-right input[type="checkbox"] { order: 2; -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; position: relative; }
        .form-group.aligned-right input[type="checkbox"]:checked { background-color: var(--accent-color); border-color: var(--accent-color); }
            .form-group .checkbox-label.tick-style {
        border: none;
        padding-left: 0;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border-radius: 0; /* Override default */
    }
    .form-group .checkbox-label.tick-style input[type="checkbox"] {
        display: inline-block; /* Make it visible */
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        cursor: pointer;
        position: relative;
        flex-shrink: 0;
    }
    .form-group .checkbox-label.tick-style input[type="checkbox"]:checked {
        background-color: var(--accent-color);
        border-color: var(--accent-color);
    }
    .form-group .checkbox-label.tick-style input[type="checkbox"]:checked::after {
        content: 'âœ“';
        color: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 12px;
        font-weight: bold;
    }
        .form-group.aligned-right input[type="checkbox"]:checked::after { content: 'âœ“'; color: white; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 14px; }
        .form-group.aligned-right input[type="number"] { width: 60px; text-align: right; }
        #cs-context-memory, #gcs-context-memory { width: 80px !important; }
        .chat-settings-actions { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        .chat-settings-actions .button-group { display: flex; gap: 10px; }
        .chat-settings-actions .button-group button { flex: 1; }
        .library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .library-item { aspect-ratio: 1 / 1; border-radius: 8px; cursor: pointer; position: relative; border: 2px solid transparent; flex-shrink: 0; overflow: hidden; /* BUG FIX: Add overflow hidden for masking */ }
        .library-item.circular { border-radius: 50%; }
        .library-item img { width: 100%; height: 100%; object-fit: cover; }
        .library-item.no-frame { border: 2px dashed #ccc; display: flex; justify-content: center; align-items: center; font-size: 24px; color: #ccc; }
        .library-item.selected { border-color: var(--accent-color); }
        .library-item::after { content: 'âœ“'; position: absolute; top: 2px; right: 2px; width: 16px; height: 16px; background-color: var(--accent-color); color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 10px; transform: scale(0); transition: transform 0.2s; }
        .library-modal.selection-mode .library-item.selected::after { transform: scale(1); }
        #avatar-frame-preview-area { width: 100%; height: 140px; display: flex; justify-content: center; align-items: center; margin-bottom: 15px; }
        #avatar-frame-preview { background-position-y: calc(50% + 0px);/* æ–°å¢ï¼šå¤´åƒå›¾ç‰‡å‚ç›´ä½ç§»è°ƒèŠ‚ */ width: 80px; height: 80px; background-color: #eee; background-size: cover; background-position: center; border-radius: 50%; position: relative; flex-shrink: 0; }
#avatar-frame-preview .avatar-frame { position: absolute; top: 50%; left: 50%; transform: translate(-50%, calc(-50% - 6.5px)); width: calc(100% * 250 / 268 + 10px); height: calc(100% + 20px); background-size: contain; background-repeat: no-repeat; background-position: center; }        /* Group Red Packet Modal */
        #group-red-packet-member-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 10px; max-height: 150px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; }
        .group-member-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; border: 2px solid transparent; border-radius: 8px; padding: 5px; }
        .group-member-item.selected { border-color: var(--accent-color); }
        .group-member-item .avatar { width: 40px; height: 40px; border-radius: 50%; background-size: cover; flex-shrink: 0; }
        .group-member-item .name { font-size: 12px; text-align: center; }
        /* Group Chat Settings */
        #gcs-member-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 15px; }
        .gcs-member-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; }
        .gcs-member-item .avatar { width: 50px; height: 50px; border-radius: 50%; background-size: cover; background-position: center; position: relative; flex-shrink: 0; }
        .gcs-member-item .avatar .role-badge { position: absolute; bottom: 0; right: 0; width: 16px; height: 16px; border-radius: 50%; color: white; font-size: 10px; display: flex; justify-content: center; align-items: center; font-weight: bold; }
        .role-badge.owner { background-color: var(--owner-title-bg); }
        .role-badge.admin { background-color: var(--admin-title-bg); }
        .gcs-member-item .name { font-size: 12px; text-align: center; }
        .gcs-action-btn { width: 50px; height: 50px; border-radius: 50%; border: 2px dashed var(--border-color); background: none; font-size: 24px; color: var(--border-color); cursor: pointer; }
        #gcs-member-action-body { display: flex; flex-direction: column; gap: 10px; }
        #gcs-manage-members-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; max-height: 250px; overflow-y: auto; }
        .gcs-manage-member-item { position: relative; }
        .gcs-manage-member-item input[type="checkbox"] { display: none; }
        .gcs-manage-member-item label { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; border: 2px solid transparent; border-radius: 8px; padding: 5px; }
        .gcs-manage-member-item input[type="checkbox"]:checked + label { border-color: var(--accent-color); background-color: rgba(0, 122, 255, 0.1); }
        .gcs-manage-member-item .avatar { width: 40px; height: 40px; border-radius: 50%; background-size: cover; background-position: center; flex-shrink: 0; }
        .gcs-manage-member-item .name { font-size: 12px; text-align: center; }

        /* --- World Book Group Selector --- */
        .wb-group-selector { position: relative; }
        .wb-group-selector-btn { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 5px; font-size: 15px; text-align: left; background-color: white; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
               .wb-group-selector-btn { font-family: inherit; }
        .wb-group-selector-btn::after { content: 'â–¼'; font-size: 12px; }
        .wb-group-dropdown { display: none; position: absolute; top: 100%; left: 0; right: 0; background-color: white; border: 1px solid var(--border-color); border-radius: 5px; max-height: 150px; overflow-y: auto; z-index: 10; }
        .wb-group-dropdown.visible { display: block; }
        .wb-group-dropdown .checkbox-label { width: 100%; border: none; border-radius: 0; border-bottom: 1px solid #eee; padding: 8px 12px; box-sizing: border-box; font-family: inherit; /* ç¡®ä¿ç»§æ‰¿å­—ä½“ */ }
        .wb-group-dropdown .checkbox-label:last-child { border-bottom: none; }

        /* --- åŠ¨æ€ (Moments) ç•Œé¢ --- */
        #moments-tab-content, #char-moments-screen .app-content { position: relative; } /* For FAB positioning */
        #moments-tab-content { padding: 0; background-color: #f0f2f5; }
        #moments-tab-content > .app-content { height: 100%; box-sizing: border-box; }
        .moments-scroll-container { height: 100%; overflow-y: auto; padding-bottom: 20px; /* å¢åŠ åº•éƒ¨å†…è¾¹è·ä»¥é¿å…FABé®æŒ¡ */ box-sizing: border-box; position: relative; }
        .moments-cover { width: 100%; height: auto; aspect-ratio: 16 / 9; min-height: 200px; background-color: #ccc; background-size: cover; background-position: center; cursor: pointer; position: relative; }
        .moments-profile-header { display: flex; justify-content: flex-end; position: relative; padding: 0 15px; bottom: 40px; margin-bottom: -40px; }
        .moments-profile-info { display: flex; align-items: flex-end; }
        .moments-profile-text { margin-right: 15px; text-align: right; }
        .moments-profile-name { font-size: 20px; font-weight: bold; color: #fff; text-shadow: 1px 1px 3px rgba(0,0,0,0.7); cursor: pointer; }
        .moments-profile-signature { font-size: 13px; color: #f0f0f0; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); margin-top: 5px; cursor: pointer; word-break: break-all; }
        .moments-profile-avatar { width: 80px; height: 80px; border-radius: 12px; border: 3px solid white; background-color: #eee; background-size: cover; background-position: center; cursor: pointer; flex-shrink: 0; }
        .moments-filter-tabs { display: flex; justify-content: space-around; padding: 10px 0; background-color: var(--item-bg); border-top: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color); margin-top: 15px; }
        .moments-filter-tab { color: var(--secondary-text-color); cursor: pointer; font-size: 15px; padding: 5px 10px; }
        .moments-filter-tab.active { color: var(--accent-color); font-weight: bold; }
        .moments-feed { padding: 15px; display: flex; flex-direction: column; gap: 20px; }
        /* .moments-post-item is now in the generic swipeable list styles */
        .post-item-content { padding: 15px; }
        .post-header { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; padding-bottom: 0; }
        .post-avatar { width: 44px; height: 44px; border-radius: 50%; background-color: #ccc; background-size: cover; background-position: center; cursor: pointer; }
        .post-author-info { flex-grow: 1; }
        .post-author-name { font-weight: 500; font-size: 16px; cursor: pointer; }
        .post-timestamp { font-size: 12px; color: var(--secondary-text-color); }
        .post-content-text { font-size: 15px; line-height: 1.6; word-break: break-word; padding-top:0; padding-bottom: 10px; }
        .post-image-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; margin-bottom: 10px; padding-top:0; padding-bottom: 10px;}
        .post-image-item { width: 100%; aspect-ratio: 1 / 1; background-size: cover; background-position: center; border-radius: 6px; position: relative; cursor: pointer; }
        .post-image-item .camera-text-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: white; color: black; display: flex; justify-content: center; align-items: flex-start; text-align: center; padding: 10px; box-sizing: border-box; border-radius: 6px; opacity: 0; visibility: hidden; transition: opacity 0.2s; }
        .post-image-item.show-text .camera-text-overlay { opacity: 1; visibility: visible; }
        .post-log-summary { font-size: 15px; line-height: 1.6; background-color: #f9f9f9; padding: 10px; border-radius: 6px; cursor: pointer; }
        .post-log-summary p { white-space: pre-wrap; }
                /* --- å±•å…æ ·å¼ --- */
#exhibition-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            /* ç§»é™¤å†…è¾¹è·ï¼Œäº¤ç”±çˆ¶å®¹å™¨ .tab-content å¤„ç† */
        }
        .gift-item-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 8px;
            cursor: pointer;
            padding: 10px;
            border-radius: 8px;
            transition: background-color 0.2s;
        }
        .gift-item-card:hover {
            background-color: var(--item-active-bg);
        }
        .gift-item-card .icon {
            font-size: 32px;
            color: var(--owner-title-bg);
        }
        .gift-item-card .name {
            font-size: 13px;
            font-weight: 500;
            word-break: break-all;
        }
        .gift-item-card .sender, .gift-item-card .date {
            font-size: 11px;
            color: var(--secondary-text-color);
        }
                .gift-item-card {
            position: relative;
            overflow: hidden; /* Ensure actions stay within card boundaries */
        }
        .gift-item-actions {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 8px;
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none; /* Let clicks pass through by default */
        }
        .gift-item-card:hover .gift-item-actions {
            opacity: 1;
            pointer-events: auto; /* Enable clicks on hover */
        }
        .gift-item-actions .icon-btn {
            background-color: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--primary-text-color);
            cursor: pointer;
            font-size: 14px;
        }
        .gift-item-actions .icon-btn:hover {
            background-color: white;
        }
        .gift-item-actions .delete-gift-btn:hover {
            color: var(--danger-color);
        }
        .post-visibility-info { font-size: 12px; color: var(--secondary-text-color); padding-top: 5px; padding-bottom: 0; }
        .post-footer { border-top: 1px solid #f0f0f0; padding-top: 10px; margin-top: 0; }
        .post-likes-summary { font-size: 14px; color: var(--secondary-text-color); padding: 8px 0; border-top: 1px solid #f0f0f0; display: flex; align-items: center; gap: 6px; }
        .post-likes-summary .icon { color: var(--like-color); }
        .moments-fab-container { position: absolute; right: 20px; bottom: calc(env(safe-area-inset-bottom, 0px) + 10px); /* è°ƒæ•´é«˜åº¦ä»¥æ‚¬æµ®åœ¨æ ‡ç­¾æ ä¸Šæ–¹ */ z-index: 15; }        .moments-fab { width: 56px; height: 56px; border-radius: 50%; background-color: var(--accent-color); color: white; font-size: 28px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); cursor: pointer; transition: transform 0.2s; display: flex; justify-content: center; align-items: center; }
        #moments-tab-content .moments-fab-container, #mail-app-screen .moments-fab-container, #weibo-app-screen .moments-fab-container { bottom: calc(env(safe-area-inset-bottom, 0px) + 60px); }
        #moments-fab:active { transform: scale(0.95); }
        #moments-fab-options { position: absolute; bottom: 65px; right: 0; display: none; flex-direction: column; gap: 10px; align-items: flex-end; }
        .fab-option { background-color: white; padding: 8px 16px; border-radius: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; font-size: 14px; white-space: nowrap; }
                #mail-app-screen .moments-fab-container {
            bottom: calc(env(safe-area-inset-bottom, 0px) + 60px);
        }
        #moments-notification-btn { position: relative; }
        #moments-notification-badge { position: absolute; top: -2px; left: -2px; width: 18px; height: 18px; background-color: var(--danger-color); color: white; border-radius: 50%; font-size: 11px; font-weight: bold; display: none; justify-content: center; align-items: center; border: 2px solid var(--item-bg); }
        #moments-notification-badge.visible, .moments-notification-badge-clone.visible { display: flex; }
        .moments-notification-badge-clone { position: absolute; top: -2px; left: -2px; width: 18px; height: 18px; background-color: var(--danger-color); color: white; border-radius: 50%; font-size: 11px; font-weight: bold; display: none; justify-content: center; align-items: center; border: 2px solid var(--item-bg); }
        /* --- åŠ¨æ€å‘å¸ƒå¼¹çª— --- */
        #post-moment-modal .modal-content { max-width: 400px; }
        #post-moment-modal-body .form-group { margin-bottom: 15px; }
        #post-moment-modal-body label { font-weight: 500; }
        .friend-selector-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; max-height: 120px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; }
        .friend-selector-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; border: 2px solid transparent; border-radius: 8px; padding: 5px; }
        .friend-selector-item.selected { border-color: var(--accent-color); }
        .friend-selector-item .avatar { width: 40px; height: 40px; border-radius: 50%; background-size: cover; background-position: center; flex-shrink: 0; }
    .friend-selector-item .name { font-size: 12px; text-align: center; }
    #moment-comment-author-selector, #moment-post-author-selector, #leave-message-author-selector, #weibo-post-author-selector, #weibo-comment-author-selector { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; max-height: 120px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; }
    .author-selector-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; border: 2px solid transparent; border-radius: 8px; padding: 5px; }
        .author-selector-item.selected { border-color: var(--accent-color); }
        .author-selector-item .avatar { width: 40px; height: 40px; border-radius: 50%; background-size: cover; background-position: center; flex-shrink: 0; }
        .author-selector-item .name { font-size: 12px; text-align: center; }
        /* --- åŠ¨æ€é€šçŸ¥å¼¹çª— --- */
        #moments-notification-modal .modal-body { max-height: 70vh; }
        #moments-notification-list { list-style: none; padding: 0; margin: 0; }
        .notification-item-container {
            position: relative;
            z-index: 2;
            background-color: var(--item-bg);
            transition: transform 0.3s ease;
            cursor: pointer;
        }
        .notification-item-container:hover { background-color: var(--item-active-bg); }
        .notification-item-content { display: flex; align-items: center; gap: 15px; padding: 12px 15px; padding-bottom: 0; }
        .notification-avatar { width: 44px; height: 44px; border-radius: 50%; background-color: #e0e0e0; background-size: cover; background-position: center; flex-shrink: 0; }
        .notification-info { overflow: hidden; font-size: 15px; line-height: 1.5; }
        .notification-actor-name { font-weight: 500; color: var(--accent-color); }
        .notification-content-summary { color: var(--secondary-text-color); margin-left: 5px; }
        .notification-timestamp { font-size: 12px; color: var(--secondary-text-color); margin-top: 4px; padding-left: 59px; padding-bottom: 8px; }
        .notification-item.unread .notification-item-container { background-color: #f0f8ff; }
        /* --- æç¤ºæ¶ˆæ¯ --- */
        #toast { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px; border-radius: 20px; font-size: 14px; z-index: 200; opacity: 0; transition: opacity 0.3s, bottom 0.3s; pointer-events: none; }
        #toast.show { opacity: 1; bottom: 100px; }
        /* --- ç›¸å†Œä¸ç…§ç‰‡ç®¡ç† --- */
        #view-album-screen .app-content { padding: 10px; }
        .album-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .album-item { width: 100%; aspect-ratio: 1 / 1; position: relative; cursor: pointer; border-radius: 8px; overflow: hidden; }
        .album-item-cover { width: 100%; height: 100%; background-size: cover; background-position: center; background-color: #eee; }
        .album-item-overlay { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.8), transparent); padding: 8px; color: white; display: flex; flex-direction: column; justify-content: flex-end; gap: 4px; }
        .album-item-name { font-weight: bold; font-size: 14px; }
        .album-item-info { font-size: 11px; opacity: 0.9; }
        .album-item-footer {display: flex;justify-content: space-between;align-items: center;}
        .album-item-actions { text-align: right; }
        .album-item-actions .icon-btn { background-color: rgba(0,0,0,0.5); border-radius: 50%; width: 24px; height: 24px; color: white; border: none; cursor: pointer; }
        .album-item.selected-for-deletion { border: 3px solid var(--danger-color); }
        .photo-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .photo-grid-item { width: 100%; aspect-ratio: 1 / 1; background-size: cover; background-position: center; border-radius: 6px; position: relative; cursor: pointer; }
        .photo-grid-item.selected-for-deletion { outline: 3px solid var(--danger-color); }
        #manage-albums-modal .modal-actions.multi-button { flex-direction: row; }
        #manage-albums-modal .modal-actions.multi-button button { flex: 1; }

        /* --- ç•™è¨€æ¿ --- */
        .message-board-avatar { width: 32px; height: 32px; border-radius: 50%; background-color: #eee; background-size: cover; background-position: center; flex-shrink: 0; }
        .message-board-signature { display: flex; align-items: center; justify-content: flex-end; gap: 8px; }
        .message-board-feed { padding: 15px; display: flex; flex-direction: column; gap: 15px; }
        .message-board-item { background-color: transparent; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border-bottom: none; }
        .message-board-item-main { padding: 15px; border-radius: 8px; }
        .message-board-header { display: flex; align-items: center; gap: 10px; }
        .message-board-recipient { font-weight: bold; font-size: 16px; margin: 0; }
        .message-board-content { font-size: 15px; line-height: 1.6; margin: 15px 0; text-align: center; }
        .message-board-footer { text-align: right; }
        .message-board-sender { font-style: italic; }
        .message-board-timestamp { font-size: 12px; color: var(--secondary-text-color); margin-top: 5px; }
        .message-board-replies { margin-left: 42px; margin-top: 10px; border-left: 2px solid #eee; padding-left: 10px; }

        /* --- ç…§ç‰‡ä¸Šä¼ å¼¹çª— --- */
        #upload-photo-image-preview-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 5px; max-height: 120px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; margin-top: 10px; }
        .upload-preview-item { width: 60px; height: 60px; background-size: cover; background-position: center; border-radius: 4px; }
        .post-photo-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-top: 10px; }
        .post-photo-item { width: 100%; aspect-ratio: 1 / 1; background-size: cover; background-position: center; border-radius: 6px; }
        /* --- Photo Viewer Modal (New Style) --- */
        .viewer-nav-btn { position: absolute; top: 50%; transform: translateY(-50%); background-color: rgba(0,0,0,0.3); color: white; border: none; border-radius: 50%; width: 44px; height: 44px; font-size: 24px; cursor: pointer; z-index: 15; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        .viewer-nav-btn.prev-btn { left: 15px; }
        .viewer-nav-btn.next-btn { right: 15px; }
        #photo-viewer-container { width: 100%; height: 100%; position: relative; display: flex; }
        #viewer-image-view, #viewer-text-view { display: none; width: 100%; height: 100%; }
        #view-photo-modal.image-mode #viewer-image-view, #view-photo-modal.text-mode #viewer-text-view { display: flex; }
        
        #viewer-text-view { display: flex; flex-direction: column; align-items: center; background-color: white; padding: 22px 20px 20px; box-sizing: border-box; width: 75vw; height: 75vh; max-width: 400px; max-height: 400px; margin: auto; border-radius: 12px; position: relative; }
        #view-photo-text-display { height: 100%; width: 100%; overflow-y: auto; font-size: 16px; line-height: 1.8; color: black; text-align: center; box-sizing: border-box; }
            #viewer-text-view .photo-viewer-name,
    #viewer-text-view .photo-viewer-desc {
        background: transparent;
        color: black;
        text-shadow: none;
        position: relative;
        padding: 0 10px;
        width: 100%;
        box-sizing: border-box;
    }
    #viewer-text-view .photo-viewer-name {
        font-size: 18px;
        font-weight: bold;
        padding-bottom: 15px;
        flex-shrink: 0;
    }
    #viewer-text-view .photo-viewer-desc {
        font-size: 14px;
        padding-top: 15px;
        color: var(--secondary-text-color);
        flex-shrink: 0;
    }
        #view-photo-modal { background-color: rgba(0,0,0,0.85); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        .photo-viewer-content { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0; box-sizing: border-box; cursor: pointer; }
        .photo-viewer-close-btn { position: absolute; top: calc(env(safe-area-inset-top, 0px) + 15px); right: 15px; font-size: 30px; color: white; background: none; border: none; cursor: pointer; z-index: 10; width: 40px; height: 40px; text-shadow: 0 0 5px black; }
            #view-photo-text-close-btn {
        top: -5px;
        right: -5px;
        color: #888;
        text-shadow: none;
    }
        .photo-viewer-name { position: absolute; top: 0; left: 0; right: 0; z-index: 5; font-size: 18px; font-weight: bold; color: white; text-align: center; text-shadow: 1px 1px 3px black; transition: opacity 0.3s; padding: 10px 15px; background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent); cursor: text; }
        #view-photo-image { max-width: 100%; max-height: 100%; object-fit: contain; }
        .photo-viewer-desc { position: absolute; bottom: 0; left: 0; right: 0; font-size: 14px; color: white; text-align: center; max-height: 25%; overflow-y: auto; text-shadow: 1px 1px 3px black; transition: opacity 0.3s; padding: 10px 15px; background: linear-gradient(to top, rgba(0,0,0,0.7), transparent); cursor: text; }
        .photo-viewer-image-container { position: relative; max-width: 100%; max-height: 100%; display: flex; align-items: center; justify-content: center; }
        #view-photo-modal.text-hidden .photo-viewer-name, #view-photo-modal.text-hidden .photo-viewer-desc, #view-photo-modal.text-hidden .photo-viewer-close-btn, #view-photo-modal.text-hidden .viewer-nav-btn { opacity: 0; pointer-events: none; }
            /* --- Simple Image Viewer --- */
            #simple-viewer-modal { background-color: rgba(0,0,0,0.8); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); z-index: 130; cursor: pointer; }
            .simple-viewer-content { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box; }
            #simple-viewer-image { max-width: 100%; max-height: 100%; object-fit: contain; display: none; }
            #simple-viewer-text { background-color: white; color: black; padding: 30px; padding-top: 32px; border-radius: 8px; overflow-y: auto; font-size: 16px; line-height: 1.8; text-align: center; display: none; justify-content: center; align-items: flex-start; cursor: default; width: 75vw; height: 75vh; max-width: 400px; max-height: 400px; box-sizing: border-box; }
            /* --- è§†é¢‘é€šè¯å¼¹çª— --- */
        #video-call-modal { display: none; transition: opacity 0.3s, transform 0.3s; }
        #video-call-modal.visible { display: flex; }
        #video-call-modal.minimized { opacity: 0; transform: scale(0.5); pointer-events: none; }
        #video-call-main-view { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center; z-index: 1; transition: opacity 0.3s ease-in-out; }
        #video-call-pip-view { position: absolute; top: calc(env(safe-area-inset-top, 15px) + 15px); right: 15px; width: calc(100% / 6); height: auto; aspect-ratio: 9 / 16; background-size: cover; background-position: center; border-radius: 12px; border: 2px solid rgba(255, 255, 255, 0.7); box-shadow: 0 4px 10px rgba(0,0,0,0.5); z-index: 3; transition: all 0.3s ease-in-out; }
        .video-call-content { position: relative; z-index: 2; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; padding: calc(env(safe-area-inset-top, 20px)) 15px calc(env(safe-area-inset-bottom, 20px)) 15px; box-sizing: border-box; background: linear-gradient(to bottom, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0) 30%, rgba(0,0,0,0) 70%, rgba(0,0,0,0.6) 100%); }
    .video-call-header { position: relative; display: flex; justify-content: center; align-items: flex-start; min-height: 120px; flex-shrink: 0; flex-wrap: wrap; }
        .video-call-avatar-img { width: 80px; height: 80px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.8); object-fit: cover; } /* BUG FIX: Added object-fit */
        .video-call-char-info { display: flex; flex-direction: column; align-items: center; text-align: center; } /* å•äººé€šè¯æ—¶ä½¿ç”¨ */
        #video-call-participants-container { display: flex; justify-content: center; align-items: flex-start; gap: 15px; flex-wrap: wrap; width: 100%; padding: 0 40px; box-sizing: border-box; } /* ç¾¤èŠå®¹å™¨ */
        .video-participant-info { display: flex; flex-direction: column; align-items: center; max-width: 80px; } /* ç¾¤èŠå•äººä¿¡æ¯ */
        #video-call-minimize-btn { position: absolute; top: 0; left: 0; background-color: rgba(0, 0, 0, 0.4); border: none; color: white; width: 36px; height: 36px; border-radius: 50%; font-size: 24px; line-height: 36px; text-align: center; text-shadow: 1px 1px 3px black; cursor: pointer; z-index: 5; transition: background-color 0.2s; }
        #video-call-minimize-btn:active { background-color: rgba(0, 0, 0, 0.7); }
        .video-call-avatar-img { width: 80px; height: 80px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.8); } /* å•äººé€šè¯å¤´åƒ */
        .video-participant-info .video-call-avatar-img { width: 50px; height: 50px; } /* ç¾¤èŠå¤´åƒ */
        .video-call-name-text { margin-top: 10px; font-size: 20px; font-weight: bold; color: white; text-shadow: 1px 1px 3px black; } /* å•äººé€šè¯åå­— */
        .video-participant-info .video-call-name-text { font-size: 12px; margin-top: 5px; font-weight: normal; } /* ç¾¤èŠåå­— */
    .video-call-message-box { flex-grow: 1; overflow-y: auto; background-color: rgba(0, 0, 0, 0.4); border-radius: 12px; margin: 15px 0; padding: 15px; color: white; line-height: 1.6; font-size: 16px; scrollbar-width: none; margin-top: calc((100vw / 6 * 16 / 9) - 90px); }
    .video-call-message-box::-webkit-scrollbar { display: none; }
    .video-chat-msg-user { color: #a7d7ff; font-weight: bold; margin-bottom: 5px; }
    .video-chat-msg-char { margin-bottom: 15px; white-space: pre-wrap; }
    .video-call-footer { display: flex; flex-direction: column; align-items: center; gap: 25px; }
    .video-call-controls { display: flex; justify-content: center; align-items: center; width: 100%; gap: 40px; }
    .video-call-button-placeholder { display: flex; flex-direction: column; align-items: center; gap: 8px; color: white; font-size: 12px; }
    .video-call-icon-btn { background-color: rgba(80, 80, 80, 0.7); border: 1px solid rgba(255, 255, 255, 0.1); width: 64px; height: 64px; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: transform 0.2s, background-color 0.2s; }
    .video-call-icon-btn:active { transform: scale(0.95); background-color: rgba(100, 100, 100, 0.8); }
    .video-call-icon-btn img { width: 32px; height: 32px; }
    .video-call-icon-btn.hangup { background-color: var(--danger-color); }
    .video-call-icon-btn.hangup:active { background-color: #d13026; }
    .video-call-input-area { width: 100%; display: flex; justify-content: center; margin-bottom: 5px; }
    .video-call-speak-btn { background-color: var(--accent-color); color: white; border: none; border-radius: 25px; padding: 12px 30px; font-size: 16px; font-weight: 500; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: transform 0.2s, background-color 0.2s; position: relative; top: -5px; }
    .video-call-speak-btn:active { transform: scale(0.98); background-color: #0062cc; }
    #video-call-input-wrapper { display: flex; width: 100%; max-width: 400px; gap: 8px; }
    #video-call-input { flex-grow: 1; border: 1px solid rgba(255,255,255,0.2); background-color: rgba(0,0,0,0.3); color: white; border-radius: 20px; padding: 10px 15px; font-size: 16px; }
    #video-call-send-btn { background-color: var(--accent-color); color: white; border: none; border-radius: 20px; padding: 0 20px; font-size: 16px; cursor: pointer; }
    #video-call-refresh-btn {
    background: none;
    border: none;
    color: white;
    font-size: 20px;
    cursor: pointer;
    padding: 0 10px;
    opacity: 0.8;
}
#video-call-refresh-btn:active {
    opacity: 1;
}
    #video-call-float-btn { position: fixed; right: 15px; bottom: 100px; width: 60px; height: 60px; background-color: var(--accent-color); border-radius: 50%; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 199; cursor: pointer; display: flex; justify-content: center; align-items: center; background-size: cover; background-position: center; border: 2px solid white; transform: scale(0); opacity: 0; transition: opacity 0.3s, transform 0.3s; }
    #video-call-float-btn.visible { transform: scale(1); opacity: 1; }
    #video-call-float-btn img { width: 32px; height: 32px; }
    #video-call-float-btn { display: none; position: absolute; z-index: 201; bottom: 100px; right: 20px; width: 60px; height: 60px; background-color: var(--accent-color); border-radius: 50%; box-shadow: 0 4px 12px rgba(0,0,0,0.3); cursor: pointer; background-size: cover; background-position: center; border: 2px solid white; transition: transform 0.2s; }
    #video-call-float-btn.visible { display: block; }
    #video-call-float-btn:active { transform: scale(0.9); }
    /* --- ä¿¡ç®± APP --- */
/* --- ä¿¡ç®± APP (ä¼˜åŒ–å) --- */
#love-letter-tab-content.active { padding: 0; display: flex; flex-direction: column; height: 100%; }
.love-letter-list { list-style: none; padding: 0; margin: 0; flex-shrink: 0; } /* Unread list doesn't scroll */
.love-letter-item { padding: 12px 15px; border-bottom: 1px solid var(--border-color); cursor: pointer; background-color: var(--item-bg); }
.love-letter-collection-container { flex-grow: 1; overflow-y: auto; padding: 15px; padding-bottom: 70px; /* ä¿®å¤ï¼šå¢åŠ åº•éƒ¨å†…è¾¹è·ä»¥é¿å…é®æŒ¡ */ border-top: 1px solid var(--border-color); } /* Makes this area scrollable */
.love-letter-item.unread { background-color: #eaf3ff; }
.love-letter-item:hover { background-color: var(--item-active-bg); }
.love-letter-main { display: flex; align-items: center; }
.love-letter-avatar { width: 44px; height: 44px; border-radius: 50%; background-color: #eee; background-size: cover; background-position: center; flex-shrink: 0; margin-right: 12px; }
.love-letter-info { flex-grow: 1; overflow: hidden; }
.love-letter-sender { font-size: 16px; font-weight: bold; }
.love-letter-preview { font-size: 13px; color: var(--secondary-text-color); white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
.love-letter-meta { text-align: right; font-size: 12px; color: var(--secondary-text-color); }
.love-letter-actions { display: flex; justify-content: flex-end; align-items: center; gap: 20px; padding-top: 8px; margin-left: 56px; /* Align with avatar */ }
.love-letter-actions .icon-btn { background: none; border: none; font-size: 16px; color: var(--secondary-text-color); cursor: pointer; }
.love-letter-actions .icon-btn:hover { color: var(--accent-color); }
.love-letter-actions .delete-btn:hover { color: var(--danger-color); }

.love-letter-collection-container { flex-grow: 1; overflow-y: auto; padding: 15px; border-top: 1px solid var(--border-color); } /* Makes this area scrollable */

.love-letter-collection-container { padding: 15px; border-top: 1px solid var(--border-color); }
.love-letter-collection-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 15px; align-items: start; }
.love-letter-preview-card {
    height: 220px; /* æ–°å¢ï¼šä¸ºå¡ç‰‡è®¾ç½®ç»Ÿä¸€é«˜åº¦ */
    background: var(--love-letter-texture), linear-gradient(to bottom right, #fdfbf7, #f4f0e8);
    border: 1px solid #e0d8cc;
    border-radius: 8px;
    padding: 12px;
    font-family: inherit;
    color: #5c5245;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    cursor: pointer;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.love-letter-preview-header {
    display: flex;
    align-items: center;
    gap: 10px;
    border-bottom: 1px dashed #dcd3c5;
    padding-bottom: 8px;
}
.love-letter-preview-content .salutation {
font-weight: bold;
/* æ–°å¢ï¼šç¡®ä¿ç§°å‘¼å³ä½¿è¿‡é•¿ä¹Ÿä¸ä¼šæ¢è¡Œï¼Œè€Œæ˜¯ä»¥çœç•¥å·ç»“å°¾ */
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
/* ä¼˜åŒ–ï¼šæ ¹æ®è¦æ±‚åˆ é™¤å¤´åƒ */
display: none;
}
.love-letter-preview-meta {
    overflow: hidden;
}
.love-letter-preview-meta .subject {
font-weight: bold;
font-size: 15px;
/* ä¼˜åŒ–ï¼šå…è®¸æ ‡é¢˜æ¢è¡Œä»¥å®Œæ•´æ˜¾ç¤º */
white-space: normal;
word-break: break-all;
}
.love-letter-preview-meta .subject.unread-subject {
    color: var(--accent-color);
}
.love-letter-preview-meta .timestamp {
    font-size: 11px;
    color: #a09383;
}
.love-letter-preview-content {
    font-size: 13px;
    line-height: 1.6;
    display: flex; /* æ–°å¢ï¼šå¯ç”¨flexå¸ƒå±€ */
    flex-direction: column; /* æ–°å¢ï¼šå‚ç›´æ’åˆ—å­å…ƒç´  */
    flex-grow: 1; /* æ–°å¢ï¼šä½¿å…¶å¡«å……å¡ç‰‡å†…çš„å‰©ä½™å‚ç›´ç©ºé—´ */
    min-height: 0; /* æ–°å¢ï¼šä¿®å¤flexå­é¡¹å†…å®¹æº¢å‡ºçš„å¸¸è§é—®é¢˜ */
}
.love-letter-preview-content .body-preview {
    max-height: 3.2em; /* æ–°å¢ï¼šè®¾ç½®2è¡Œæ–‡å­—çš„æœ€å¤§é«˜åº¦ (2 * 1.6em line-height) */
    -webkit-line-clamp: 2; /* ä¼˜åŒ–ï¼šä¸¥æ ¼é™åˆ¶ä¸ºæœ€å¤šæ˜¾ç¤º2è¡Œ */
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 4;
    -webkit-box-orient: vertical;
}
.love-letter-preview-content .signature {
    text-align: right;
    font-style: italic;
    margin-top: 8px;
    white-space: normal; /* ä¼˜åŒ–ï¼šå…è®¸ç­¾åæ¢è¡Œä»¥å®Œæ•´æ˜¾ç¤º */
    word-break: break-all; /* æ–°å¢ï¼šç¡®ä¿é•¿å•è¯ä¹Ÿèƒ½æ¢è¡Œ */
    margin-top: auto; /* æ ¸å¿ƒæ–°å¢ï¼šè‡ªåŠ¨å¤–è¾¹è·å°†ç­¾åæ¨è‡³å®¹å™¨åº•éƒ¨ */
}
.love-letter-preview-card .love-letter-actions {
    justify-content: flex-end;
    border-top: 1px dashed #dcd3c5;
    padding-top: 8px;
    margin-left: 0; /* Override old style */
}
.collected-letter-item { display: flex; flex-direction: column; align-items: center; text-align: center; cursor: pointer; }
.collected-letter-item .title { font-size: 11px; font-weight: bold; width: 100%; white-space: normal; word-break: break-all; text-align: center; margin-bottom: 5px; }
.collected-letter-item .icon { font-size: 36px; color: #a38c6d; margin-bottom: 5px; }
.collected-letter-item .sender { font-size: 10px; color: var(--secondary-text-color); }
.collected-letter-item .date { font-size: 9px; color: #ccc; }
#love-letter-style-grid {
    grid-template-columns: repeat(2, 1fr); /* æ¯è¡Œ2ä¸ªï¼Œä½¿å…¶æ›´å¤§ */
    gap: 15px;
}
.letter-style-preview-content {
    height: 160px; /* å¢åŠ é¢„è§ˆåŒºåŸŸçš„é«˜åº¦ */
    padding: 10px;
    font-family: inherit;
    font-size: 11px; /* å¢å¤§é¢„è§ˆå­—ä½“ */
    line-height: 1.5;
    color: #5c5245;
    background: var(--love-letter-texture), linear-gradient(to bottom right, #fdfbf7, #f4f0e8);
    border: 1px solid #e0d8cc;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    overflow: hidden;
    cursor: pointer;
}
.letter-style-preview-content .salutation {
    font-weight: bold;
}
.letter-style-preview-content .body {
    flex-grow: 1;
    overflow: hidden;
    padding: 5px 0;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 4;
    -webkit-box-orient: vertical;
}
.letter-style-preview-content .signature {
    text-align: right;
    font-style: italic;
    flex-shrink: 0;
}
        /* --- æƒ…ä¹¦å¡ç‰‡ä¼˜åŒ–ï¼šæ‚¬æµ®æŒ‰é’®æ ·å¼ --- */
        .love-letter-preview-card {
            position: relative; /* ä¸ºç»å¯¹å®šä½çš„actionsæä¾›å®¹å™¨ */
            overflow: hidden; /* ç¡®ä¿actionsä¸ä¼šè¶…å‡ºå¡ç‰‡è¾¹ç•Œ */
        }
        .love-letter-preview-card .love-letter-actions {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            justify-content: flex-end;
            gap: 8px;
            padding: 8px;
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
            opacity: 0; /* é»˜è®¤éšè— */
            transition: opacity 0.2s ease-in-out;
            pointer-events: none; /* é»˜è®¤ä¸å¯ç‚¹å‡» */
            border-top: none; /* ç§»é™¤æ—§çš„åˆ†å‰²çº¿ */
            margin: 0; /* ç§»é™¤æ—§çš„å¤–è¾¹è· */
        }
        .love-letter-preview-card:hover .love-letter-actions {
            opacity: 1; /* æ‚¬æµ®æ—¶æ˜¾ç¤º */
            pointer-events: auto; /* æ‚¬æµ®æ—¶å¯ç‚¹å‡» */
        }
        .love-letter-preview-card .love-letter-actions .icon-btn {
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--primary-text-color);
            font-size: 14px;
        }
        .love-letter-preview-card .love-letter-actions .icon-btn:hover {
            background-color: white;
            color: var(--accent-color);
        }
        .love-letter-preview-card .love-letter-actions .delete-letter-btn:hover {
            color: var(--danger-color);
        }
/* --- æ‹†ä¿¡åŠ¨ç”» --- */
#unread-letter-prompt { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.3); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); z-index: 210; display: flex; justify-content: center; align-items: center; cursor: pointer; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
#unread-letter-prompt.visible { opacity: 1; visibility: visible; }
#unread-letter-prompt .envelope-icon { font-size: 80px; color: white; transition: transform 0.4s ease-in-out; }

/* --- ä¿¡çº¸é˜…è¯»å™¨ --- */
:root {
    --love-letter-texture: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
    --love-letter-gradient: linear-gradient(to bottom right, #f4f0e8, #fdfbf7);
}
#love-letter-viewer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 220; display: flex; flex-direction: column;
    padding: calc(env(safe-area-inset-top, 10px) + 20px) 25px calc(env(safe-area-inset-bottom, 10px) + 20px);
    box-sizing: border-box;
    font-family: var(--system-font-family); color: #333;
    transform: scale(0.1) rotate(-15deg); border-radius: 50%; opacity: 0; visibility: hidden;
    transition: all 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    background: var(--love-letter-texture), var(--love-letter-gradient);
}
#love-letter-viewer.visible { transform: scale(1) rotate(0deg); border-radius: 0; opacity: 1; visibility: visible; }
.letter-content-wrapper { flex-grow: 1; overflow-y: auto; line-height: 2; font-size: 17px; }
.letter-salutation { margin-bottom: 2em; }
.letter-body { white-space: pre-wrap; }
.letter-signature { text-align: right; margin-top: 3em; position: relative; padding-right: 80px; }
.letter-sender-name { display: block; }
.letter-timestamp { display: block; font-size: 14px; color: #888; margin-top: 0.5em; }
.letter-stamp {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 70px;
    height: 70px;
    background-color: rgba(255,255,255,0.5);
    border: 3px dashed #bba0a0;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.letter-close-btn { position: absolute; top: calc(env(safe-area-inset-top, 10px) + 5px); right: 5px; width: 40px; height: 40px; background: none; border: none; font-size: 32px; color: #aaa; cursor: pointer; z-index: 10; text-shadow: 0 0 3px white; }
/* --- ä¿¡ç®± APP ä¼˜åŒ–æ ·å¼ --- */
        #love-letter-tab-content.active { display: flex; flex-direction: column; height: 100%; }
        #unread-letters-container { flex-shrink: 0; }
        #read-letters-container { flex-grow: 1; overflow-y: auto; }
        .love-letter-meta { display: flex; align-items: center; justify-content: space-between; flex-grow: 1; }
        .love-letter-actions { display: flex; gap: 15px; }
        .love-letter-actions .icon-btn { background: none; border: none; font-size: 16px; color: var(--secondary-text-color); cursor: pointer; padding: 5px; }
.letter-reply-btn { position: absolute; bottom: calc(env(safe-area-inset-bottom, 15px) -75px); left: 50%; transform: translateX(-50%); width: 56px; height: 56px; background-color: #a38c6d; color: white; border-radius: 50%; border: none; font-size: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); cursor: pointer; transition: transform 0.2s; z-index: 15; }        .letter-reply-btn:active { transform: translateX(-50%) scale(0.95); }
        .author-selector-grid { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 10px; }
        .author-selector-grid::-webkit-scrollbar { height: 4px; }
        .author-selector-grid::-webkit-scrollbar-thumb { background: #ccc; border-radius: 2px; }
        .author-selector-grid .author-selector-item { flex-shrink: 0; }
        /* --- æ˜ä¿¡ç‰‡åŠŸèƒ½æ ·å¼ --- */
#postcard-wall {
    padding: 15px;
    align-content: flex-start;
    /* æ ¸å¿ƒä¿®å¤ï¼šä¸ºç§»åŠ¨ç«¯è®¾ç½®æ›´ç´§å‡‘çš„å“åº”å¼å¸ƒå±€ï¼Œå…è®¸3åˆ—æ˜¾ç¤º */
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 10px; /* ä¿æŒä¸€ä¸ªåˆé€‚çš„é—´è· */
}

/* ä¼˜åŒ–ï¼šä»…åœ¨å®½å±è®¾å¤‡ä¸Šå¼ºåˆ¶ä½¿ç”¨4åˆ—å¸ƒå±€ï¼Œä»¥è·å¾—æœ€ä½³è§†è§‰æ•ˆæœ */
@media (min-width: 992px) {
    #postcard-wall {
        grid-template-columns: repeat(4, 1fr);
    }
}

.postcard-preview-card {
    background-color: var(--item-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    cursor: pointer;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
    aspect-ratio: 10 / 13; /* æ¥è¿‘ç…§ç‰‡å¢™çš„æ¯”ä¾‹ */
}
.postcard-preview-actions {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    padding: 8px;
    background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
}
.postcard-preview-card:hover .postcard-preview-actions {
    opacity: 1;
}
.postcard-preview-actions .icon-btn {
    background-color: rgba(255, 255, 255, 0.8);
    border: none;
    border-radius: 50%;
    width: 28px;
    height: 28px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: var(--primary-text-color);
    cursor: pointer;
    font-size: 14px;
}
.postcard-preview-actions .icon-btn:hover {
    background-color: white;
}
.postcard-preview-actions .delete-postcard-btn:hover {
    color: var(--danger-color);
}
.postcard-preview-card.unread::before {
    content: 'NEW';
    position: absolute;
    top: 8px;
    right: 8px;
    background-color: var(--danger-color);
    color: white;
    font-size: 10px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 5px;
    z-index: 2;
}
.postcard-preview-image {
    width: 100%;
    flex-grow: 1;
    background-size: cover;
    background-position: center;
    background-color: #eee;
}
.postcard-preview-footer {
    padding: 8px;
    background-color: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
}
.postcard-preview-location, .postcard-preview-timestamp {
    font-size: 10px;
    color: var(--secondary-text-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
}
.postcard-preview-sender {
    font-size: 12px;
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.postcard-preview-location, .postcard-preview-timestamp {
    font-size: 10px;
    color: var(--secondary-text-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
}

/* --- æ‹†æ˜ä¿¡ç‰‡åŠ¨ç”» --- */
#unread-postcard-prompt { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.3); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); z-index: 215; display: none; justify-content: center; align-items: center; cursor: pointer; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
#unread-postcard-prompt.visible { display: flex; opacity: 1; visibility: visible; }
#unread-postcard-prompt .postcard-icon { font-size: 80px; color: white; transition: transform 0.4s ease-in-out, opacity 0.3s; }
#unread-postcard-prompt.opening .postcard-icon { transform: scale(0.8) rotate(-15deg); opacity: 0; }

/* --- æ˜ä¿¡ç‰‡æŸ¥çœ‹å™¨ --- */
#postcard-viewer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 225; display: none; flex-direction: column; justify-content: center; align-items: center;
    padding: 20px; box-sizing: border-box;
    background-color: rgba(0,0,0,0.5); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    opacity: 0; visibility: hidden; transition: opacity 0.4s ease;
}
#postcard-viewer.visible { display: flex; opacity: 1; visibility: visible; } /* æ ¸å¿ƒä¿®å¤ï¼šæ·»åŠ æ­¤è¡Œ */
.postcard-card-full {
    width: 100%;
    max-width: 680px; /* è°ƒæ•´æœ€å¤§å®½åº¦ */
    min-height: 300px; /* è®¾ç½®æœ€å°é«˜åº¦ */
    background-color: var(--item-bg);
    border-radius: 12px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    display: flex;
    overflow: hidden;
    transform: scale(0.8);
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}
#postcard-viewer.visible .postcard-card-full { transform: scale(1); }
.postcard-image-section { flex: 0 0 45%; background-color: #eee; } /* æ¢å¤ï¼šå›¾ç‰‡åŒºå¡«å……æ ·å¼ */
.postcard-image-section img { width: 100%; height: 100%; object-fit: cover; } /* æ¢å¤ï¼šå›¾ç‰‡è£å‰ªä»¥å¡«å……ï¼Œè€Œéå®Œæ•´æ˜¾ç¤º */
.postcard-content-section { flex: 1 1 55%; display: flex; flex-direction: column; padding: 20px; } /* ä¿®æ”¹ï¼šè®©æ–‡å­—åŒºè‡ªé€‚åº”å‰©ä½™ç©ºé—´ */
.postcard-text-area { flex-grow: 1; overflow-y: hidden; font-size: 15px; line-height: 1.7; } /* ä¿®æ”¹ï¼šç§»é™¤æ»šåŠ¨æ¡ */
.postcard-salutation { font-weight: bold; margin-bottom: 1em; }
.postcard-body { white-space: pre-wrap; }
.postcard-signature-area { flex-shrink: 0; text-align: right; position: relative; padding-top: 15px; padding-right: 60px; }
.postcard-signature { font-style: italic; }
.postcard-location, .postcard-timestamp { font-size: 12px; color: var(--secondary-text-color); margin-top: 5px; }
.postcard-stamp { position: absolute; bottom: 0; right: 0; width: 50px; height: 50px; border-radius: 50%; background-size: cover; background-position: center; border: 2px solid var(--border-color); }
.postcard-close-btn { position: absolute; top: calc(env(safe-area-inset-top, 10px) + 5px); right: 10px; width: 40px; height: 40px; background: none; border: none; font-size: 32px; color: white; cursor: pointer; z-index: 10; text-shadow: 0 0 5px black; }

.postcard-gift-area {
    margin-top: 15px;
    padding: 10px 15px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 20px;
    color: var(--primary-text-color);
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    animation: gift-appear 0.5s 0.4s backwards;
}
@keyframes gift-appear {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
.postcard-gift-area i { color: var(--owner-title-bg); }
.postcard-reply-btn {
    position: absolute;
    bottom: 0;
    left: 20px;
    width: 44px;
    height: 44px;
    background-color: #a38c6d;
    color: white;
    border-radius: 50%;
    border: none;
    font-size: 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    cursor: pointer;
    transition: transform 0.2s, background-color 0.2s;
    display: flex;
    justify-content: center;
    align-items: center;
}
.postcard-reply-btn:hover {
    background-color: #8a7358;
}
.postcard-reply-btn:active {
    transform: scale(0.95);
}
/* é€‚é…ç§»åŠ¨ç«¯ */
@media (max-width: 600px) {
    .postcard-content-section {
        flex-grow: 1;
        flex-shrink: 1;
        min-height: 0;
    }
    .postcard-signature-area { padding-right: 55px; }
}

/* --- è§†é¢‘é€šè¯å¼¹çª—ï¼šæ–°å¢æ ·å¼ --- */
        #video-call-modal.minimized {
            display: none !important; /* æœ€å°åŒ–æ—¶éšè—å¼¹çª— */
        }
        #user-video-view {
            position: absolute;
            top: calc(env(safe-area-inset-top, 20px) + 15px);
            right: 15px;
            width: 25%;
            max-width: 120px;
            aspect-ratio: 9 / 16;
            background-size: cover;
            background-position: center;
            background-color: #333;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            z-index: 3;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        #video-call-minimize-btn {
            position: absolute;
            top: calc(env(safe-area-inset-top, 20px) + 15px);
            left: 15px;
            width: 30px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.4);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            line-height: 30px;
            text-align: center;
            cursor: pointer;
            z-index: 5;
        }
        #floating-video-btn {
            display: none; /* é»˜è®¤éšè— */
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 80px);
            right: 20px;
            width: 60px;
            height: 60px;
            background-color: var(--accent-color);
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            cursor: pointer;
            z-index: 99;
            background-size: cover;
            background-position: center;
        }
        #floating-video-btn.visible {
            display: block;
        }
        /* --- å“åº”å¼è°ƒæ•´ï¼šé€‚é…ç§»åŠ¨ç«¯çš„å°å±å¹• --- */
        @media (max-width: 600px) {
            #viewer-text-view, #simple-viewer-text {
                width: 90vw; /* åœ¨å°å±å¹•ä¸Šï¼Œè®©æ–‡å­—å›¾æ›´å®½ä¸€äº› */
            }
        }
        .theme-css-preview {
            margin-top: 10px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 8px;
            min-height: 80px;
            border: 1px solid #ced4da;
            overflow: hidden; /* Prevents children from breaking layout */
        }
        #theme-preview-header .app-header, 
        #theme-preview-list-item .swipe-content,
        #theme-preview-moments .moments-post-item,
        #theme-preview-tabs .app-bottom-tabs {
            position: relative !important; /* Override sticky/absolute for preview */
            top: 0;
            bottom: auto; /* Reset bottom positioning */
            padding-top: 15px; /* Reset safe area padding */
            min-height: 0;
        }
        #theme-preview-list-item .contact-list-item {
border-bottom: none; /* Remove border for single item preview */
}
/* New styles for chat input preview */
#theme-preview-chat-input .chat-footer {
padding: 5px 8px;
display: flex;
flex-direction: column;
border-top: 1px solid #ccc;
}
#theme-preview-chat-input .chat-input-area {
display: flex;
align-items: center;
gap: 5px;
}
#theme-preview-chat-input .chat-input {
flex-grow: 1;
border: none;
background-color: white;
border-radius: 18px;
padding: 8px 15px;
font-size: 14px;
resize: none;
}
#theme-preview-chat-input .chat-toolbar {
display: flex;
justify-content: space-around;
padding-top: 5px;
}
#theme-preview-chat-input .icon-btn i {
font-size: 22px;
color: #555;
padding: 0 10px;
}
/* --- æ–°å¢ï¼šè½¬å‘æ¶ˆæ¯æ ·å¼ --- */
.message-bubble.forwarded {
background-color: #fff;
border: 1px solid var(--border-color);
padding: 10px;
cursor: pointer;
max-width: 250px;
}
.forwarded-title {
font-size: 15px;
font-weight: 500;
padding-bottom: 8px;
border-bottom: 1px solid #eee;
margin-bottom: 8px;
}
.forwarded-summary {
font-size: 13px;
color: var(--secondary-text-color);
line-height: 1.5;
max-height: 4.5em; /* Limit to 3 lines */
overflow: hidden;
text-overflow: ellipsis;
white-space: pre-wrap;
}
#forward-contact-list .contact-list-item {
border-bottom: 1px solid var(--border-color);
cursor: pointer;
}
#forward-contact-list .contact-list-item:last-child {
border-bottom: none;
}
#forward-contact-list .contact-list-item:hover .contact-item-content {
background-color: var(--item-active-bg);
}
#view-forwarded-content .message-item {
transform: scale(0.95);
transform-origin: left;
margin-bottom: 5px;
}
/* --- æ–°å¢ï¼šæ”¶è—åŠŸèƒ½æ ·å¼ --- */
#chat-collect-btn {
background: none;
border: none;
cursor: pointer;
padding: 0;
display: none; /* Initial state */
align-items: center;
justify-content: center;
}
#chat-collect-btn i {
font-size: 26px;
color: #ff9500; /* A gold/star color */
width: 44px;
height: 44px;
display: flex;
align-items: center;
justify-content: center;
}
#collection-grid {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 20px;
}
.collection-item-card {
display: flex;
flex-direction: column;
align-items: center;
text-align: center;
gap: 8px;
cursor: pointer;
padding: 10px;
border-radius: 8px;
transition: background-color 0.2s;
position: relative; /* For actions positioning */
overflow: hidden; /* For actions positioning */
}
.collection-item-card:hover {
background-color: var(--item-active-bg);
}
.collection-item-card .icon {
font-size: 32px;
color: #a38c6d; /* A scroll-like color */
}
.collection-item-card .name {
font-size: 13px;
font-weight: 500;
word-break: break-all;
height: 2.6em; /* 2 lines */
overflow: hidden;
}
.collection-item-card .participants, .collection-item-card .date {
font-size: 11px;
color: var(--secondary-text-color);
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
width: 100%;
}
.collection-item-actions {
position: absolute;
bottom: 0;
left: 0;
right: 0;
display: flex;
justify-content: flex-end;
gap: 8px;
padding: 8px;
background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
opacity: 0;
transition: opacity 0.2s ease-in-out;
pointer-events: none;
}
.collection-item-card:hover .collection-item-actions {
opacity: 1;
pointer-events: auto;
}
.collection-item-actions .icon-btn {
background-color: rgba(255, 255, 255, 0.8);
border: none;
border-radius: 50%;
width: 28px;
height: 28px;
display: flex;
justify-content: center;
align-items: center;
color: var(--primary-text-color);
cursor: pointer;
font-size: 14px;
}
.collection-item-actions .icon-btn:hover { background-color: white; }
.collection-item-actions .delete-collection-btn:hover { color: var(--danger-color); }
#collection-viewer-modal .modal-content {
height: 80vh; /* -- CORE FIX: Reduced height -- */
}
#collection-viewer-content .message-item {
transform: scale(0.95);
transform-origin: left;
margin-bottom: 5px;
}
/* --- æ–°å¢ï¼šBugä¿®å¤æ ·å¼ --- */
#mail-settings-modal .style-preview-name {
white-space: normal; /* å…è®¸æ¢è¡Œ */
word-break: break-all; /* å¼ºåˆ¶æ¢è¡Œ */
overflow: visible;
text-overflow: clip;
}
</style>
<style id="theme-preview-styles"></style>
<style id="saved-styles-preview-style"></style>
<style id="mail-settings-preview-style"></style>
<style id="anniversary-calendar-styles">
    .anniversary-details-item {
        padding: 12px;
        border-radius: 8px;
        background-color: #f9f9f9;
        border-left: 4px solid var(--accent-color);
    }
    .anniversary-details-item.special {
        border-left-color: var(--danger-color);
        background-color: #fff0f0;
    }
    .anniversary-details-item .name {
        font-weight: bold;
        font-size: 16px;
    }
    .anniversary-details-item .associated-chars {
        font-size: 12px;
        color: var(--secondary-text-color);
        margin-top: 4px;
    }
                    #diary-app-screen .app-bottom-tabs {
            position: relative; /* å…³é”®ä¿®å¤ï¼šè¦†ç›– absolute å®šä½ï¼Œä½¿å…¶åœ¨ flex å¸ƒå±€ä¸­å æ®ç©ºé—´ */
            flex-shrink: 0; /* é˜²æ­¢æ ‡ç­¾æ åœ¨ç©ºé—´ä¸è¶³æ—¶è¢«å‹ç¼© */
        }
        
    /* --- æ‰‹è´¦ APP - çºªå¿µæ—¥æ—¥å†æ ·å¼ (å·²ä¼˜åŒ–) --- */
        #diary-app-screen .tab-content {
            background-color: var(--bg-color); /* ä¸ºæ‰€æœ‰æ ‡ç­¾é¡µæ·»åŠ èƒŒæ™¯è‰²ï¼Œé˜²æ­¢é€è§† */
        }
        #anniversary-tab-content.active {
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
            .calendar-container {
        width: 100%;
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
    padding: 15px;
    }
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 5px;
            flex-shrink: 0;
        }
        .calendar-header-left .current-date-display {
            font-size: 16px;
            font-weight: 500;
        }
        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .calendar-nav .current-month-year {
            font-size: 18px;
            font-weight: 600;
        }
        .calendar-nav .nav-arrow {
                    
            cursor: pointer;
            color: var(--accent-color);
            font-size: 24px;
        }
            .calendar-body {
        display: flex;
        flex-direction: column;
        flex-grow: 1; /* ç¡®ä¿åœ¨flexå®¹å™¨ä¸­èƒ½æ­£å¸¸å¢é•¿ */
    }
        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            text-align: center;
            padding: 10px 0;
            font-weight: 500;
            color: var(--secondary-text-color);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
            .calendar-grid {
    display: grid;
grid-template-columns: repeat(7, 1fr);
    grid-auto-rows: 100px; /* æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿è¡Œæœ‰è¶³å¤Ÿçš„æœ€å°é«˜åº¦ */
        gap: 1px;
        background-color: var(--border-color);
        border: 1px solid var(--border-color);
        flex-grow: 1;
    }
        .calendar-day {
            background-color: var(--item-bg);
            padding: 4px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* æ ¸å¿ƒä¿®å¤ï¼šé¡¶éƒ¨å¯¹é½ä»¥é€‚åº”å¤šè¡Œæ–‡å­— */
            align-items: center;    /* æ ·å¼ä¼˜åŒ–ï¼šæ°´å¹³å±…ä¸­ */
            overflow: hidden;
            gap: 4px; /* æ ·å¼ä¼˜åŒ–ï¼šå¢åŠ æ•°å­—å’Œæ–‡å­—çš„é—´è· */
                        position: relative; /* ä¸ºç¼–è¾‘æŒ‰é’®æä¾›å®šä½ä¸Šä¸‹æ–‡ */
        }
        .calendar-day.other-month {
            opacity: 0.5;
            background-color: #f8f8f8;
        }
        .calendar-day.other-month .day-number,
        .calendar-day.other-month .day-info {
             color: var(--secondary-text-color);
        }
        .calendar-day .day-number {
            font-size: 22px; /* æ ·å¼ä¼˜åŒ–ï¼šæ”¾å¤§æ•°å­— */
            font-weight: 500;
        }
            .calendar-day .day-info {
        font-size: 11px; /* ä¼˜åŒ–ï¼šå¾®è°ƒå­—ä½“ä»¥é€‚åº”æ›´å¤šå†…å®¹ */
        white-space: normal; /* æ ¸å¿ƒä¿®å¤ï¼šå…è®¸æ–‡å­—æ¢è¡Œ */
        word-break: break-all; /* æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿é•¿å•è¯ä¹Ÿèƒ½è¢«å¼ºåˆ¶æ¢è¡Œ */
        width: 100%;
        text-align: center;
        line-height: 1.4; /* æ ¸å¿ƒä¿®å¤ï¼šå¢åŠ è¡Œé«˜ï¼Œè®©å¤šè¡Œæ–‡å­—æ›´æ¸…æ™° */
        padding: 0 2px; /* ä¼˜åŒ–ï¼šå¢åŠ å·¦å³å†…è¾¹è·ï¼Œé˜²æ­¢æ–‡å­—è´´è¾¹ */
        box-sizing: border-box;
    }
        .calendar-day.holiday .day-number,
        .calendar-day.holiday .day-info {
            color: var(--danger-color); /* æ ·å¼ä¼˜åŒ–ï¼šé«˜äº®æ•°å­—å’Œæ–‡å­— */
            font-weight: bold;
        }
.calendar-day-actions {
position: absolute;
bottom: 0;
left: 0;
right: 0;
display: flex;
justify-content: flex-end;
gap: 8px;
padding: 8px;
background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
opacity: 0;
transition: opacity 0.2s ease-in-out;
pointer-events: none; /* Let clicks pass through by default */
}

.calendar-day.actions-visible .calendar-day-actions {
opacity: 1;
pointer-events: auto;
}
.calendar-action-btn {
    width: 24px;
    height: 24px;
    background-color: rgba(0, 0, 0, 0.1);
    border: none;
    border-radius: 50%;
    color: var(--primary-text-color);
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 12px;
    transition: background-color 0.2s;
}
.calendar-action-btn:hover {
    background-color: rgba(0, 0, 0, 0.2);
}
.calendar-action-btn.delete:hover {
    background-color: var(--danger-color);
    color: white;
}
        /* --- èµ„äº§ APP - é“¶è¡Œæ ·å¼ --- */
    .bank-balance-display {
        display: flex;
        justify-content: space-around;
        background-color: var(--item-bg);
        padding: 15px;
        border-radius: 10px;
        text-align: center;
    }
    .balance-item {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    .balance-label {
        font-size: 14px;
        color: var(--secondary-text-color);
    }
    .balance-value {
        font-size: 18px;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
    }
    .balance-item.loan .balance-value {
        color: var(--danger-color);
    }
    .bank-action-group {
        display: flex;
        gap: 10px;
        padding: 15px;
        align-items: center;
    }
    .bank-action-group input {
        flex-grow: 1;
        text-align: right;
    }
    .bank-action-group button {
        flex-shrink: 0;
        width: 100px;
    }
        #bank-tab-content.active {
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 25px;
    }
    /* --- èµ„äº§ APP - å½©ç¥¨æ ·å¼ --- */
#lottery-number-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
gap: 8px;
padding: 10px;
background-color: var(--item-bg);
border-radius: 10px;
}
.lottery-number {
width: 100%;
aspect-ratio: 1 / 1;
display: flex;
justify-content: center;
align-items: center;
background-color: #f0f2f5;
border: 1px solid var(--border-color);
border-radius: 50%;
cursor: pointer;
font-weight: 500;
transition: background-color 0.2s, color 0.2s, border-color 0.2s;
}
.lottery-number:hover {
background-color: #e0e2e5;
}
.lottery-number.selected {
background-color: var(--danger-color);
color: white;
border-color: var(--danger-color);
}
#lottery-buy-btn:disabled {
background-color: #a0a0a0;
cursor: not-allowed;
}
/* --- èµ„äº§ APP - è‚¡å¸‚æ ·å¼ --- */
.stock-item {
        border-radius: 8px;
        margin-bottom: 10px;
        border-bottom: none; /* è¦†ç›–é€šç”¨æ»‘åŠ¨æ ·å¼ä¸­çš„ä¸‹åˆ’çº¿ */
        background-color: transparent; /* å®¹å™¨æœ¬èº«é€æ˜ï¼Œè®©å†…å®¹å±‚è´Ÿè´£èƒŒæ™¯ */
    }
    .stock-item-content {
        /* å°†åŸæœ¬é”™è¯¯çš„flexå¸ƒå±€æ ·å¼ç§»åˆ°è¿™é‡Œ */
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 12px;
        cursor: pointer;
        transition: background-color 0.2s;
        /* å†…å®¹å±‚ä¹Ÿéœ€è¦åœ†è§’ä»¥ä¿è¯è§†è§‰æ­£ç¡® */
        border-radius: 8px;
    }
    .stock-item:hover .stock-item-content {
        background-color: var(--item-active-bg);
    }
.stock-item:hover {
    background-color: var(--item-active-bg);
}
.stock-info {
    flex-grow: 1;
    overflow: hidden;
}
.stock-name {
    font-size: 16px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.stock-ticker {
    font-size: 12px;
    color: var(--secondary-text-color);
}
.stock-chart {
    width: 80px;
    height: 30px;
    display: flex;
    align-items: flex-end;
    gap: 2px;
    flex-shrink: 0;
}
.chart-bar {
    flex: 1;
    background-color: #ccc;
    border-radius: 1px;
}
.chart-bar.up { background-color: #e54040; }
.chart-bar.down { background-color: #4db364; }

.stock-price-info {
    text-align: right;
    min-width: 80px;
    flex-shrink: 0;
}
.stock-price {
    font-size: 16px;
    font-weight: 500;
    font-variant-numeric: tabular-nums;
}
.stock-change {
    font-size: 12px;
}
.stock-change.up { color: #e54040; }
.stock-change.down { color: #4db364; }
        /* --- å¾®åš (Weibo) ç•Œé¢ --- */
        #weibo-main-tab-content, #weibo-char-main-tab-content { padding: 0; background-color: #f0f2f5; }
        .weibo-scroll-container { height: 100%; overflow-y: auto; padding-bottom: 80px; box-sizing: border-box; }
        .weibo-cover { width: 100%; height: auto; aspect-ratio: 16 / 9; min-height: 150px; background-color: #ccc; background-size: contain; background-position: center; }
        .weibo-profile-header { position: relative; padding: 0 20px; margin-top: -40px; margin-bottom: 0; }
        .weibo-profile-content { display: flex; justify-content: center; align-items: flex-end; }
        .weibo-profile-avatar { width: 80px; height: 80px; border-radius: 50%; border: 3px solid var(--item-bg); background-color: #eee; background-size: cover; background-position: center; flex-shrink: 0; }
        .weibo-profile-actions { display: none; }
        .weibo-profile-details { padding: 50px 15px 15px; background-color: var(--item-bg); border-radius: 0; text-align: center; margin-top: -45px; }
        .weibo-profile-name { font-size: 20px; font-weight: bold; }
        .weibo-profile-bio { font-size: 14px; color: var(--secondary-text-color); margin-top: 8px; line-height: 1.5; }
        .weibo-stats { display: flex; justify-content: space-around; margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--border-color); }
        .weibo-stat-item { text-align: center; }
                .weibo-stat-item[data-stat-type] { cursor: pointer; }
        .weibo-stat-item .count { font-weight: bold; font-size: 16px; }
        .weibo-stat-item .label { font-size: 12px; color: var(--secondary-text-color); }
        .weibo-feed { padding: 0 15px; display: flex; flex-direction: column; gap: 15px; }
        .weibo-post-item { background-color: var(--item-bg); border-radius: 8px; overflow: hidden; }
        .post-forwarded-content { background-color: #f7f7f7; padding: 10px; margin: 10px 0; border-radius: 6px; cursor: pointer; border: 1px solid #eee; }
        .post-forwarded-content .post-author-name { font-size: 15px; }
        .post-forwarded-content .post-content-text { font-size: 14px; }
        .post-footer-stats { display: flex; justify-content: space-around; font-size: 13px; color: var(--secondary-text-color); padding: 8px 0; border-top: 1px solid #f0f0f0; }
        .footer-stat-item { display: flex; align-items: center; gap: 5px; }
        /* --- Weibo Post Swipe Actions & Comments --- */
        .weibo-post-item { position: relative; overflow: hidden; touch-action: pan-y; }
        .weibo-post-item .post-item-content { background-color: var(--item-bg); transition: transform 0.3s ease; position: relative; z-index: 2; }
        .weibo-post-item .post-item-actions { position: absolute; top: 0; right: 0; height: 100%; display: flex; z-index: 1; }
        .weibo-post-item .post-item-actions > div { width: 70px; height: 100%; color: white; display: flex; justify-content: center; align-items: center; cursor: pointer; }
        .weibo-post-item .details-comments-list { padding: 10px 15px 0 15px; }
        .weibo-post-item .comment-input-area { padding: 10px 15px; }
</style>
    <script src="https://kit.fontawesome.com/492a2d863d.js" crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&display=swap" rel="stylesheet">
    <style id="bubble-preview-styles"></style>
    <style>
            /* --- è®¾ç½® APP - è®°å¿†æ ‡ç­¾é¡µæ ·å¼ --- */
                #char-memory-table .placeholder-row td {
        text-align: center;
        color: var(--secondary-text-color);
        padding: 40px 15px;
        white-space: normal;
    }
    #memory-tab-content.active {
            padding: 15px;
    padding-bottom: 65px; /* ä¸ºåº•éƒ¨æ ‡ç­¾æ ç•™å‡ºè¶³å¤Ÿç©ºé—´ */
    box-sizing: border-box;
        display: flex; /* Use flexbox to make the container grow */
    }
    .memory-table-container {
        flex-grow: 1; /* Allow the container to fill available space */
    
        overflow: auto; /* Enable both vertical and horizontal scrolling */
        width: 100%;
        height: 100%;
    
        box-sizing: border-box;
    }
    #char-memory-table {
            border-spacing: 0; /* æ›¿æ¢ border-collapse ä»¥ä¿®å¤ sticky å®šä½ */
    min-width: 1650px; /* 11 columns * 150px */
        width: 100%;
    }
    #char-memory-table th,
    #char-memory-table td, #char-memory-table .placeholder-row td {
        border-top: 1px solid var(--border-color);
        border-left: 1px solid var(--border-color);
        padding: 10px 15px;
        text-align: center;
        vertical-align: middle;
        font-size: 14px;
                white-space: normal; /* å…è®¸æ–‡æœ¬æ¢è¡Œ */
                max-width: 250px; /* é™åˆ¶å•å…ƒæ ¼æœ€å¤§å®½åº¦ï¼Œçº¦18ä¸ªæ±‰å­— */
                word-break: break-word; /* å¼ºåˆ¶é•¿å•è¯æˆ–æ— ç©ºæ ¼å­—ç¬¦ä¸²æ¢è¡Œ */
    }
    #char-memory-table td {
    position: relative;
}
.memory-cell-actions {
    position: absolute;
    bottom: 2px;
    right: 2px;
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
}
#char-memory-table tr:hover .memory-cell-actions {
    opacity: 0.8;
}
.memory-cell-actions:hover {
    opacity: 1;
}

/* --- æ–°å¢ï¼šä¸ºè¡¨æ ¼è¡¥å…¨å³ä¾§å’Œåº•éƒ¨çš„è¾¹æ¡† --- */
#char-memory-table th:last-child,
#char-memory-table td:last-child {
    border-right: 1px solid var(--border-color);
}
#char-memory-table tbody tr:last-child td,
#char-memory-table .placeholder-row td {
    border-bottom: 1px solid var(--border-color);
}


.memory-edit-btn, .memory-delete-btn {
    background-color: rgba(0,0,0,0.4);
    border: none;
    color: white;
    border-radius: 4px;
    width: 22px;
    height: 22px;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
}
.memory-delete-btn:hover {
    background-color: var(--danger-color);
}
.memory-edit-btn:hover {
    background-color: var(--accent-color);
}
    #char-memory-table th {
        background-color: #f7f7f7;
        position: sticky; /* Make headers sticky */
        top: 0; /* Stick to the top of the scrollable container */
        z-index: 2;
    }
    #char-memory-table thead tr:nth-child(2) th {
        top: 47px; /* Offset for the second row of headers */
    margin-top: -1px; /* ä¿®å¤stickyè¡¨å¤´ä¹‹é—´çš„ç¼éš™ */
    }
    #char-memory-table tbody tr:hover {
        background-color: var(--item-active-bg);
    }
    
    
#char-memory-table thead {
    position: sticky;
    top: 0;
    z-index: 3;
}
        /* --- æ‰‹è´¦ APP - ç§˜å¯†æ ‡ç­¾é¡µæ ·å¼ --- */
        #secret-tab-content.active {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            align-content: flex-start;
        }
        .secret-item-card {
            position: relative; /* ä¸ºåŠ¨ä½œæŒ‰é’®æä¾›å®šä½ä¸Šä¸‹æ–‡ */
            overflow: hidden; /* ç¡®ä¿æŒ‰é’®çš„åœ†è§’ä¸ä¼šæº¢å‡º */
            aspect-ratio: 1 / 1;
            background-color: #fffae1; /* ä¾¿åˆ©è´´é»„è‰² */
            box-shadow: 3px 3px 8px rgba(0,0,0,0.15);
            padding: 10px;
            font-family: var(--system-font-family); /* ä½¿ç”¨å…¨å±€å­—ä½“ */
            color: #5c5245;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            transform: rotate(calc(var(--random-rotate) * 1deg)); /* éšæœºæ—‹è½¬ */
            border-bottom: 1px solid #e0d8cc;
        }
        .secret-item-card:hover {
            transform: scale(1.05) rotate(0deg);
            z-index: 5;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
        }
        .secret-item-card .title {
            font-weight: bold;
            font-size: 14px;
            line-height: 1.4;
            -webkit-line-clamp: 3;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-box-orient: vertical;
        }
        .secret-item-card .meta {
            text-align: right;
            font-size: 11px;
            font-style: italic;
        }
        .secret-item-card .name {
            display: block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* --- ç§˜å¯†æŸ¥çœ‹å™¨æ ·å¼ --- */
        #secret-viewer-modal {
            z-index: 230;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .secret-card-full {
            width: 90vw;
            max-width: 400px;
            height: 90vw;
            max-height: 400px;
            background-color: #fffae1;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
            padding: 25px;
            font-family: var(--system-font-family);
            font-size: 18px;
            line-height: 1.8;
            color: #5c5245;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            opacity: 0;
            transform: scale(0.95) translateY(10px);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #secret-viewer-modal.visible .secret-card-full {
            opacity: 1;
             transform: rotate(0deg) scale(1);
        }
        .secret-content-area {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            scrollbar-width: thin;
        }
.secret-footer-area {
            transform: translateZ(0); /* æ ¸å¿ƒä¿®å¤ï¼šå¼ºåˆ¶å¼€å¯ç¡¬ä»¶åŠ é€Ÿï¼Œé˜²æ­¢åŠ¨ç”»æ—¶å­—ä½“è·³åŠ¨ */
            flex-shrink: 0;
            text-align: right;
            margin-top: 20px;
            font-style: italic;
            font-size: 14px;
        }
        #secret-viewer-name { display: block; }
         /* --- ç§˜å¯†ä¾¿åˆ©è´´æ‚¬æµ®æŒ‰é’®æ ·å¼ --- */
        .secret-item-actions {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 8px;
            background: linear-gradient(to top, rgba(0,0,0,0.4), transparent);
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none;
            z-index: 3;
        }
        .secret-item-card:hover .secret-item-actions {
            opacity: 1;
            pointer-events: auto;
        }
        .secret-item-actions .icon-btn {
            background-color: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--primary-text-color);
            cursor: pointer;
            font-size: 14px;
        }
        .secret-item-actions .icon-btn:hover {
            background-color: white;
        }
        .secret-item-actions .delete-secret-btn:hover {
            color: var(--danger-color);
        }
    </style>
</head>
<body>
    <audio id="audio-player"></audio>

    <!-- æ‰‹æœºå±å¹•ä¸»å®¹å™¨ -->
    <div id="phone-screen">
        <div id="top-area">
            <div id="dynamic-island">
                <div class="island-content island-music-info"></div>
                <div class="island-content island-waveform"><span></span><span></span><span></span></div>
                <div class="island-content island-video-call-icon"></div>
                <div class="island-content island-video-call-timer"></div>
            </div>
            <div id="status-bar">
                <div id="time">12:00</div>
                <div id="battery-status"><span id="battery-level">100%</span><span id="battery-icon" data-icon-id="status-battery-default"><i class="fa-solid fa-battery-full"></i></span></div>
            </div>
        </div>
        <div id="notification-container"></div>
        <!-- æ–°å¢ï¼šæ¥ç”µé€šçŸ¥æ¨ªå¹… -->
            <div id="incoming-call-banner" style="display: none; position: absolute; top: calc(env(safe-area-inset-top, 10px) + 60px); left: 50%; transform: translateX(-50%); width: 90%; max-width: 380px; background-color: rgba(60, 60, 60, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 250; color: white;">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div id="incoming-call-avatar" style="width: 60px; height: 60px; border-radius: 50%; background-size: cover; background-position: center; flex-shrink: 0;"></div>
                    <div style="flex-grow: 1;">
                        <div id="incoming-call-name" style="font-weight: bold; font-size: 18px;"></div>
                        <div style="font-size: 14px; margin-top: 4px;">é‚€è¯·ä½ è¿›è¡Œè§†é¢‘é€šè¯</div>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-around; gap: 20px; margin-top: 15px;">
                    <button id="incoming-call-reject-btn" style="flex: 1; padding: 10px; border-radius: 25px; border: none; background-color: #ff3b30; color: white; font-size: 16px; cursor: pointer;"><i class="fa-solid fa-phone-slash"></i></button>
                    <button id="incoming-call-accept-btn" style="flex: 1; padding: 10px; border-radius: 25px; border: none; background-color: #34c759; color: white; font-size: 16px; cursor: pointer;"><i class="fa-solid fa-phone"></i></button>
                </div>
            </div>
        <!-- ä¸»å±å¹•APPå›¾æ ‡ -->
        <div id="main-content">
            <div id="app-grid">
                <div class="app-icon" id="chat-app-btn"><div class="icon" data-icon-id="app-chat"><i class="fa-solid fa-comment-dots"></i></div><span class="label">èŠå¤©</span></div>
                <div class="app-icon" id="music-app-btn"><div class="icon" data-icon-id="app-music"><i class="fa-solid fa-music"></i></div><span class="label">éŸ³ä¹</span></div>
                <div class="app-icon" id="shop-app-btn"><div class="icon" data-icon-id="app-shop"><i class="fa-solid fa-shop"></i></div><span class="label">è´­ç‰©</span></div>
                <div class="app-icon" id="diary-app-btn"><div class="icon" data-icon-id="app-diary"><i class="fa-solid fa-book-bookmark"></i></div><span class="label">æ‰‹è´¦</span></div>
                <div class="app-icon" id="mail-app-btn"><div class="icon" data-icon-id="app-mail"><i class="fa-solid fa-envelope"></i></div><span class="label">ä¿¡ç®±</span></div>
                <div class="app-icon"><div class="icon" data-icon-id="app-ranking"><i class="fa-solid fa-chart-simple"></i></div><span class="label">æ¦œå•</span></div>
                <div class="app-icon"><div class="icon" data-icon-id="app-pet"><i class="fa-solid fa-paw"></i></div><span class="label">æ¡Œå® </span></div>
                <div class="app-icon"><div class="icon" data-icon-id="app-game"><i class="fa-solid fa-gamepad"></i></div><span class="label">æ¸¸æˆ</span></div>
                <div class="app-icon"><div class="icon" data-icon-id="app-forum"><i class="fa-solid fa-blog"></i></div><span class="label">è®ºå›</span></div>
                                <div class="app-icon" id="assets-app-btn"><div class="icon" data-icon-id="app-assets"><i class="fa-solid fa-building-columns"></i></div><span class="label">èµ„äº§</span></div>
                            <div class="app-icon" id="entertainment-app-btn"><div class="icon" data-icon-id="app-entertainment"><i class="fa-solid fa-snowman"></i></div><span class="label">å¨±ä¹</span></div>
                <div class="app-icon" id="weibo-app-btn"><div class="icon" data-icon-id="app-weibo"><i class="fa-solid fa-mobile-screen-button"></i></div><span class="label">å¾®åš</span></div>
                            </div>
        </div>

        <!-- åº•éƒ¨Dockæ  -->
        <div id="dock">
            <div class="app-icon" id="settings-app-btn"><div class="icon" data-icon-id="dock-settings"><i class="fa-solid fa-wrench"></i></div></div>
            <div class="app-icon" id="beautify-app-btn"><div class="icon" data-icon-id="dock-beautify"><i class="fa-solid fa-icons"></i></div></div>
            <div class="app-icon" id="data-app-btn"><div class="icon" data-icon-id="dock-data"><i class="fa-solid fa-folder-open"></i></div></div>
        </div>

        <!-- è®¾ç½®APPç•Œé¢ -->
        <div id="settings-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title">è®¾ç½®</h2></div>
                <div class="app-header-right">
                                    <button class="action-btn" id="memory-repair-btn" style="display: none;" title="ä¿®å¤/é‡å»ºè®°å¿†"><i class="fa-solid fa-screwdriver-wrench"></i></button>
                <button class="action-btn" id="memory-settings-btn" style="display: none;"><i class="fa-solid fa-gear"></i></button>
            </div>
            </div>
                    <div class="app-content tab-content-wrapper">
            <div id="main-settings-tab-content" class="tab-content active">
                <div class="settings-group"><div class="group-title">API é…ç½®</div><div class="group-content"><div class="settings-item"><label for="api-url">åä»£åœ°å€</label><input type="text" id="api-url" placeholder="ä¾‹å¦‚: https://api.example.com"></div><div class="settings-item"><label for="api-key">API å¯†é’¥</label><input type="password" id="api-key" placeholder="è¯·è¾“å…¥æ‚¨çš„ API Key"></div></div><button id="confirm-api-btn" class="settings-button" data-bubble-id="settings-load-model">åŠ è½½æ¨¡å‹</button></div>
                <div class="settings-group"><div class="group-title">æ¨¡å‹é€‰æ‹©</div><div class="group-content"><div class="settings-item"><select id="model-select"><option value="">è¯·å…ˆåŠ è½½æ¨¡å‹</option></select></div></div></div>
                <div class="settings-group"><div class="group-title">API é¢„è®¾</div><div class="group-content"><div class="settings-item"><label for="preset-select">é€‰æ‹©é¢„è®¾</label><select id="preset-select"><option value="">æ— </option></select></div></div><div class="button-group"><button id="save-preset-btn" class="settings-button" data-bubble-id="settings-save-preset">ä¿å­˜é¢„è®¾</button><button id="manage-presets-btn" class="settings-button secondary" data-bubble-id="settings-manage-presets">ç®¡ç†é¢„è®¾</button></div></div>
                <div class="settings-group"><div class="group-title">æ•°æ®ç®¡ç†</div><div class="button-group" style="flex-direction: column; gap: 10px;">
                    <div style="display: flex; gap: 10px;">
                    <button id="export-all-btn" class="settings-button">å¯¼å‡ºå…¨éƒ¨æ•°æ®</button>
                    <button id="import-all-btn" class="settings-button secondary">å¯¼å…¥å…¨éƒ¨æ•°æ®</button>
                </div>
                    <input type="file" id="import-file-input" style="display: none;" multiple accept=".zip">
                    
                                
            </div>
        </div>
        <div class="settings-group">
            <div class="group-title">å…¨å±€ä¸Šä¸‹æ–‡è®°å¿†</div>
            <div class="group-content">
                <div class="settings-item">
                    <div class="form-group aligned-right">
                        <label for="global-context-memory">å…¨å±€ä¸Šä¸‹æ–‡è®°å¿†æ•°é‡</label>
                        <input type="number" id="global-context-memory" value="99" style="width: 80px !important;">
                    </div>
                </div>
            </div>
        </div>
            <div class="settings-group">
                <div class="group-title">å…¨å±€åå°å®æ—¶æ´»åŠ¨</div>
                <div class="group-content">
                    <div class="settings-item">
                        <div class="form-group aligned-right">
                            <label for="global-realtime-interval">å…¨å±€æ´»åŠ¨é—´éš”(åˆ†é’Ÿ)</label>
                            <input type="number" id="global-realtime-interval" value="30" style="width: 80px !important;">
                        </div>
                    </div>
                    <div class="settings-item">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label>é€‰æ‹©è¦å¼€å¯çš„è§’è‰²</label>
                            <button id="global-realtime-select-all" class="settings-button secondary" style="width: auto; padding: 5px 10px; font-size: 14px;">å…¨é€‰/å…¨ä¸é€‰</button>
                        </div>
                        <div id="global-realtime-char-selector">
                            <!-- Char items will be injected here -->
                        </div>
                    </div>
                </div>
            </div>
            </div>
            <div id="guide-tab-content" class="tab-content">
                <p style="text-align:center; color: #888; margin-top: 50px;">æŒ‡å—åŠŸèƒ½å¾…å¼€å‘...</p>
            </div>
            <div id="memory-tab-content" class="tab-content">
                <div class="memory-table-container">
                <table id="char-memory-table">
                    <thead>
                        <tr>
                            <th rowspan="2">Char</th>
                            <th rowspan="2">å…³ç³»</th>
                            <th rowspan="2">æ€åº¦</th>
                            <th colspan="7">äº‹ä»¶</th>
                            <th colspan="2">ç¾ç»Š</th>
                        </tr>
                        <tr>
                            <th>æ—¥æœŸ</th>
                            <th>æ—¶é—´</th>
                            <th>åœ°ç‚¹</th>
                            <th>äººç‰©</th>
                            <th>å†…å®¹</th>
                            <th>æƒ…ç»ª</th>
                            <th>æƒé‡</th>
                            <th>é‡è¦ç‰©å“</th>
                            <th>çº¦å®š</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Memory rows will be dynamically inserted here -->
                    </tbody>
                </table>
            </div>
            </div>
        </div>
        <div class="app-bottom-tabs">
            <div class="tab-link active" data-tab="main-settings">è®¾ç½®</div>
            <div class="tab-link" data-tab="guide">æŒ‡å—</div>
            <div class="tab-link" data-tab="memory">è®°å¿†</div>
        </div>
        </div>

        <!-- éŸ³ä¹APPç•Œé¢ -->
        <div id="music-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title">éŸ³ä¹</h2></div>
                <div class="app-header-right"><button class="action-btn" id="add-music-btn" data-icon-id="music-add"><i class="fa-solid fa-plus"></i></button></div>
            </div>
            <div class="app-content" style="padding:0;"><ul id="music-list"></ul></div>
        </div>

        <!-- æ­Œæ›²è¯¦æƒ…é¡µ -->
        <div id="song-details-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="song-details-back-btn">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title">æ­Œæ›²è¯¦æƒ…</h2></div>
                <div class="app-header-right"></div>
            </div>
            <div class="app-content">
                <div class="details-song-info"><div class="title" id="details-song-title">æ­Œæ›²å</div><div class="artist" id="details-song-artist">æ­Œæ‰‹</div></div>
                <div class="details-lyrics-container" id="details-lyrics-view"></div>
                <div class="details-comments-section">
                    <div class="details-comments-list" id="details-comments-list"></div>
                    <div class="comment-input-area"><input type="text" id="comment-input" placeholder="å‘è¡¨ä½ çš„è¯„è®º..."> <button id="send-comment-btn" class="settings-button" data-icon-id="comment-send" style="width: 50px; padding: 5px; display: flex; align-items: center; justify-content: center;"><i class="fa-solid fa-paper-plane"></i></button></div>
                </div>
            </div>
        </div>

        <!-- ç¾åŒ–APPç•Œé¢ -->
        <div id="beautify-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title">ç¾åŒ–</h2></div>
                <div class="app-header-right">
                    <button class="action-btn" id="beautify-action-btn" data-icon-id="beautify-add"><i class="fa-solid fa-plus"></i></button>
                    <button class="action-btn" id="bubble-action-btn" style="display: none;"><i class="fa-solid fa-plus"></i></button>
                </div>
            </div>
            <div class="app-content tab-content-wrapper">
                <div id="wallpaper-tab-content" class="tab-content active">
                    <div id="wallpaper-grid"></div>
                    <input type="file" id="wallpaper-file-input" multiple accept="image/*" style="display:none;">
                </div>
                <div id="font-tab-content" class="tab-content"><ul id="font-list"></ul></div>
                <div id="icon-tab-content" class="tab-content"><div id="icon-grid"></div></div>
                <div id="bubble-tab-content" class="tab-content"><div id="bubble-grid"></div></div>
                                <div id="theme-tab-content" class="tab-content">
                    <div class="settings-group">
                        <div class="group-title-wrapper">
                        <div class="group-title">ç©ºé—´å¡ç‰‡</div>
                        <div class="style-actions">
                            <button class="icon-btn save-single-style-btn" data-module="momentsPost" title="ä¿å­˜æ­¤æ ·å¼"><i class="fa-solid fa-folder"></i></button>
                            <button class="icon-btn load-single-style-btn" data-module="momentsPost" title="è¯»å–æ ·å¼"><i class="fa-solid fa-folder-open"></i></button>
                        </div>
                    </div>
                        <div class="group-content">
                        <textarea id="theme-css-moments" class="theme-css-editor" rows="6"></textarea>
                        </div>
                        <div class="theme-css-preview" id="theme-preview-moments"></div>
                    </div>
                    <div class="settings-group">
                        <div class="group-title-wrapper">
                        <div class="group-title">é¡¶éƒ¨çŠ¶æ€æ </div>
                        <div class="style-actions">
                            <button class="icon-btn save-single-style-btn" data-module="appHeader" title="ä¿å­˜æ­¤æ ·å¼"><i class="fa-solid fa-folder"></i></button>
                            <button class="icon-btn load-single-style-btn" data-module="appHeader" title="è¯»å–æ ·å¼"><i class="fa-solid fa-folder-open"></i></button>
                        </div>
                    </div>
                        <div class="group-content">
                        <textarea id="theme-css-header" class="theme-css-editor" rows="6"></textarea>
                        </div>
                        <div class="theme-css-preview" id="theme-preview-header"></div>
                    </div>
                    <div class="settings-group">
                        <div class="group-title">                    <div class="group-title-wrapper">
                        <div class="group-title">åº•éƒ¨æ ‡ç­¾æ </div>
                        <div class="style-actions">
                            <button class="icon-btn save-single-style-btn" data-module="bottomTabs" title="ä¿å­˜æ­¤æ ·å¼"><i class="fa-solid fa-folder"></i></button>
                            <button class="icon-btn load-single-style-btn" data-module="bottomTabs" title="è¯»å–æ ·å¼"><i class="fa-solid fa-folder-open"></i></button>
                        </div>
                    </div>åº•éƒ¨æ ‡ç­¾æ </div>
                        <div class="group-content">
                        <textarea id="theme-css-tabs" class="theme-css-editor" rows="6"></textarea>
                        </div>
                        <div class="theme-css-preview" id="theme-preview-tabs"></div>
                    </div>
                    <div class="settings-group">
                        <div class="group-title-wrapper">
                        <div class="group-title">é€šç”¨åˆ—è¡¨å¡ç‰‡</div>
                        <div class="style-actions">
                            <button class="icon-btn save-single-style-btn" data-module="listItem" title="ä¿å­˜æ­¤æ ·å¼"><i class="fa-solid fa-folder"></i></button>
                            <button class="icon-btn load-single-style-btn" data-module="listItem" title="è¯»å–æ ·å¼"><i class="fa-solid fa-folder-open"></i></button>
                        </div>
                    </div>
                        <div class="group-content">
                        <textarea id="theme-css-list-item" class="theme-css-editor" rows="6"></textarea>
                        </div>
                        <div class="theme-css-preview" id="theme-preview-list-item"></div>
                        
                    </div>                <div class="settings-group">
                    <div class="group-title-wrapper">
                        <div class="group-title">æƒ…ä¹¦ä¿¡çº¸</div>
                        <div class="style-actions">
                            <button class="icon-btn save-single-style-btn" data-module="loveLetter" title="ä¿å­˜æ­¤æ ·å¼"><i class="fa-solid fa-folder"></i></button>
                            <button class="icon-btn load-single-style-btn" data-module="loveLetter" title="è¯»å–æ ·å¼"><i class="fa-solid fa-folder-open"></i></button>
                        </div>
                    </div>
                    <div class="group-content">
                    <textarea id="theme-css-letter" class="theme-css-editor" rows="6"></textarea>
                    </div>
                    <div class="theme-css-preview" id="theme-preview-letter"></div>
                </div>
                            <div class="settings-group">
                <div class="group-title-wrapper">
                    <div class="group-title">èŠå¤©è¾“å…¥æ </div>
                    <div class="style-actions">
                        <button class="icon-btn save-single-style-btn" data-module="chatInput" title="ä¿å­˜æ­¤æ ·å¼"><i class="fa-solid fa-folder"></i></button>
                        <button class="icon-btn load-single-style-btn" data-module="chatInput" title="è¯»å–æ ·å¼"><i class="fa-solid fa-folder-open"></i></button>
                    </div>
                </div>
                <div class="group-content">
                <textarea id="theme-css-chat-input" class="theme-css-editor" rows="6"></textarea>
                </div>
                <div class="theme-css-preview" id="theme-preview-chat-input"></div>
            </div>
                    <div class="settings-group">
                                        <div class="button-group">
                    <button id="theme-restore-btn" class="settings-button danger-btn">è¿˜åŸé»˜è®¤</button>
                    <button id="theme-apply-btn" class="settings-button">åº”ç”¨æ ·å¼</button>
                </div>
                <div class="button-group" style="margin-top: 10px;">
                    <button id="theme-save-style-btn" class="settings-button secondary">ä¿å­˜æ ·å¼</button>
                    <button id="theme-load-style-btn" class="settings-button secondary">è¯»å–æ ·å¼</button>
                </div>
                    </div>
                </div>

            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="wallpaper">å£çº¸</div><div class="tab-link" data-tab="font">å­—ä½“</div><div class="tab-link" data-tab="icon">å›¾æ ‡</div><div class="tab-link" data-tab="bubble">æ°”æ³¡</div><div class="tab-link" data-tab="theme">ä¸»é¢˜</div>
            </div>
        </div>

        <!-- èµ„æ–™APPç•Œé¢ -->
        <div id="data-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title">èµ„æ–™</h2></div>
                <div class="app-header-right">
                <button class="action-btn" id="data-filter-btn" style="display: none;"><i class="fa-solid fa-filter"></i></button>
                <button class="action-btn" id="data-action-btn" data-icon-id="data-add"><i class="fa-solid fa-plus"></i></button>
            </div>
        </div>
        <div id="world-book-filter-dropdown" class="filter-dropdown"></div>
            <div class="app-content tab-content-wrapper">
                <div id="world-book-tab-content" class="tab-content active"><ul id="world-book-list" class="preset-data-list"></ul></div>
                        <div id="archive-tab-content" class="tab-content"><ul id="archive-list" class="preset-data-list"></ul></div>
        <div id="info-tab-content" class="tab-content"><ul id="info-list" class="preset-data-list"></ul></div>
            <div id="styles-tab-content" class="tab-content">
        <div class="styles-rows-container">
            <div class="style-row-group">
                <h3>æ°”æ³¡æ ·å¼</h3>
                <div class="styles-row-scroll" id="saved-bubbles-row"></div>
            </div>
            <div class="style-row-group">
                <h3>ç©ºé—´å¡ç‰‡æ ·å¼</h3>
                <div class="styles-row-scroll" id="saved-themes-momentsPost-row"></div>
            </div>
            <div class="style-row-group">
                <h3>é¡¶éƒ¨çŠ¶æ€æ æ ·å¼</h3>
                <div class="styles-row-scroll" id="saved-themes-appHeader-row"></div>
            </div>
            <div class="style-row-group">
                <h3>åº•éƒ¨æ ‡ç­¾æ æ ·å¼</h3>
                <div class="styles-row-scroll" id="saved-themes-bottomTabs-row"></div>
            </div>
            <div class="style-row-group">
                <h3>é€šç”¨åˆ—è¡¨å¡ç‰‡æ ·å¼</h3>
                <div class="styles-row-scroll" id="saved-themes-listItem-row"></div>
            </div>
            <div class="style-row-group">
                <h3>æƒ…ä¹¦ä¿¡çº¸æ ·å¼</h3>
                <div class="styles-row-scroll" id="saved-themes-loveLetter-row"></div>
            </div>
                        <div class="style-row-group">
                <h3>èŠå¤©è¾“å…¥æ æ ·å¼</h3>
                <div class="styles-row-scroll" id="saved-themes-chatInput-row"></div>
            </div>
        </div>
    </div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="world-book">ä¸–ç•Œä¹¦</div><div class="tab-link" data-tab="archive">æ¡£æ¡ˆ</div><div class="tab-link" data-tab="info">ä¿¡æ¯</div><div class="tab-link" data-tab="styles">æ ·å¼</div>
            </div>
        </div>

        <!-- èŠå¤©APPç•Œé¢ -->
        <div id="chat-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="chat-list-back-btn">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title" id="chat-list-title">æ¶ˆæ¯</h2></div>
                <div class="app-header-right">
                    <button class="action-btn" id="chat-list-action-btn" data-icon-id="chat-add"><i class="fa-solid fa-plus"></i></button>
                    <button class="action-btn" id="moments-notification-btn" data-icon-id="header-notification" style="display: none;">
                        <i class="fa-solid fa-bell"></i>
                        <div id="moments-notification-badge">0</div>
                    </button>
                </div>
            </div>
            <div class="app-content tab-content-wrapper">
                <div id="message-list-tab-content" class="tab-content active" style="padding:0;"><ul id="message-list"></ul></div>
                <div id="moments-tab-content" class="tab-content">
                    <!-- User's Moments Page Content will be injected by JS -->
                </div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="message-list">æ¶ˆæ¯</div><div class="tab-link" data-tab="moments">åŠ¨æ€</div>
            </div>
        </div>

        <!-- å•èŠ/ç¾¤èŠç•Œé¢ -->
        <div id="single-chat-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="chat-back-btn">&lt; æ¶ˆæ¯</button></div>
                <div class="title-wrapper">
                    <div class="chat-header-name" id="chat-header-name">è”ç³»äºº</div>
                    <div class="chat-header-status" id="chat-header-status"></div>
                    <div class="chat-header-signature" id="chat-header-signature">ä¸ªæ€§ç­¾å</div>
                </div>
                <div class="app-header-right">
                    <button class="action-btn" id="add-friend-btn" style="display: none;" data-icon-id="chat-add-friend"><i class="fa-solid fa-plus"></i></button>
                    <button class="action-btn" id="chat-settings-btn" data-icon-id="header-settings"><i class="fa-solid fa-gear"></i></button>
                </div>
            </div>
            <div class="app-content">
                <div id="chat-messages-view"></div>
            </div>
            <div id="chat-footer">
                <div id="quote-preview"><span id="quote-preview-content"></span><button id="close-quote-btn" data-icon-id="chat-quote-close"><i class="fa-solid fa-xmark"></i></button></div>
                <div class="typing-indicator" id="typing-indicator" style="display: none;">å¯¹æ–¹æ­£åœ¨è¾“å…¥...</div>
                <div class="chat-input-area">
                    <button id="chat-send-real-btn" data-icon-id="chat-send-real"><i class="fa-solid fa-comments"></i></button>
                            <button id="chat-collect-btn" data-icon-id="chat-collect" style="display: none;"><i class="fa-solid fa-star"></i></button>
                    <textarea id="chat-input" rows="1" placeholder="è¾“å…¥æ¶ˆæ¯..."></textarea>
                    <div id="chat-input-buttons">
                        <button class="icon-btn" id="chat-emoji-btn" data-icon-id="chat-emoji"><i class="fa-solid fa-face-smile"></i></button>
                                            <button class="icon-btn" id="chat-forward-btn" style="display: none;" data-icon-id="chat-forward"><i class="fa-solid fa-share"></i></button>
                        <button class="icon-btn" id="chat-send-fake-btn" style="display: none;" data-icon-id="chat-send-fake"><i class="fa-solid fa-keyboard"></i></button>
                    </div>
                </div>
                <div class="chat-toolbar-wrapper">
                    <div class="chat-toolbar">
                        <button class="icon-btn" id="chat-refresh-btn" data-icon-id="chat-refresh"><i class="fa-solid fa-arrows-rotate"></i></button>
                        <button class="icon-btn" id="chat-voice-btn" data-icon-id="chat-voice"><i class="fa-solid fa-microphone"></i></button>
                        <button class="icon-btn" id="chat-image-btn" data-icon-id="chat-image"><i class="fa-solid fa-images"></i></button>
                        <button class="icon-btn" id="chat-camera-btn" data-icon-id="chat-camera"><i class="fa-solid fa-camera"></i></button>
                        <button class="icon-btn" id="chat-video-btn" data-icon-id="chat-video"><i class="fa-solid fa-video"></i></button>
                        <button class="icon-btn" id="chat-music-btn" data-icon-id="chat-music"><i class="fa-solid fa-headphones"></i></button>
                        <button class="icon-btn" id="chat-link-btn" data-icon-id="chat-link"><i class="fa-solid fa-newspaper"></i></button>
                        <button class="icon-btn" id="chat-redpacket-btn" data-icon-id="chat-redpacket"><i class="fa-solid fa-wallet"></i></button>
                        <button class="icon-btn" id="chat-shop-btn" data-icon-id="chat-shop"><i class="fa-solid fa-bag-shopping"></i></button>
                    </div>
                </div>
                <input type="file" id="chat-image-input" accept="image/*" style="display: none;">
            </div>
                    <div id="emoji-picker-panel">
            <div class="emoji-picker-header">
                <button id="close-emoji-picker-btn" data-bubble-id="emoji-close">å…³é—­</button>
                <button id="emoji-mode-toggle-btn" class="cancel-btn" data-bubble-id="emoji-delete-toggle">åˆ é™¤</button>
                <button id="add-emoji-btn" data-bubble-id="emoji-add">æ·»åŠ </button>
                <button id="emoji-delete-btn" class="danger-btn" style="display:none;" data-bubble-id="emoji-delete-confirm">ç¡®è®¤</button>
            </div>
            <div id="emoji-grid"></div>
        </div>
        </div>

        <!-- å•èŠè®¾ç½®ç•Œé¢ -->
        <div id="chat-settings-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="chat-settings-back-btn">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title">èŠå¤©è®¾ç½®</h2></div>
                <div class="app-header-right"></div>
            </div>
            <div class="app-content tab-content-wrapper">
                <!-- Char è®¾ç½® -->
                <div id="char-settings-tab-content" class="tab-content active">
                    <div class="chat-settings-layout">
                        <div class="chat-settings-main">
                            <div class="form-group"><label for="cs-char-name">åå­—</label><input type="text" id="cs-char-name"></div>
                            
                            <div class="chat-settings-section">
                                <div class="world-book-header">
                                    <label>å…³è”ä¸–ç•Œä¹¦</label>
                                    <div id="cs-world-book-group-selector" class="wb-group-selector">
                                        <button class="wb-group-selector-btn">é€‰æ‹©åˆ†ç»„</button>
                                        <div class="wb-group-dropdown"></div>
                                    </div>
                                </div>
                                <div id="cs-world-book-list-container" class="world-book-list-container"><ul id="cs-world-book-list" class="checkbox-list"></ul></div>
                            </div>
                            <div class="form-group"><label for="cs-context-memory">ä¸Šä¸‹æ–‡è®°å¿†æ•°é‡</label><input type="number" id="cs-context-memory" value="99"></div>
                        </div>
                        <div class="chat-settings-side">
                            <div id="cs-char-avatar" class="chat-settings-avatar"><div class="avatar-frame"></div></div>
                            <button id="cs-char-avatar-library-btn" class="chat-settings-side-btn" data-bubble-id="cs-avatar-lib">å¤´åƒåº“</button>
                            <button id="cs-char-avatar-frame-btn" class="chat-settings-side-btn" data-bubble-id="cs-frame-lib">å¤´åƒæ¡†</button>
                            <button id="cs-char-background-btn" class="chat-settings-side-btn" data-bubble-id="cs-chat-bg">èƒŒæ™¯</button>
                        </div>
                    </div>
                                                                    <div class="form-group"><label for="cs-relationship">ä½ ä»¬çš„å…³ç³»</label><input type="text" id="cs-relationship" placeholder="ä¾‹å¦‚ï¼šæœ‹å‹ã€æ‹äººã€å…„å¦¹..."></div>

                    <div class="form-group"><label for="cs-persona">äººè®¾</label><textarea id="cs-persona" class="wide-textarea" rows="5"></textarea></div>
                    <div class="chat-settings-actions">
                        <div class="button-group"><button id="cs-save-persona-btn" class="settings-button secondary" data-bubble-id="cs-save-persona">ä¿å­˜åˆ°èµ„æ–™</button><button id="cs-load-persona-btn" class="settings-button secondary" data-bubble-id="cs-load-persona">ä»èµ„æ–™è¯»å–</button></div>

                        <div class="button-group"><button id="cs-clear-history-btn" class="settings-button danger-btn" data-bubble-id="cs-clear-history">æ¸…ç©ºè®°å½•</button><button id="cs-delete-friend-btn" class="settings-button danger-btn" data-bubble-id="cs-delete-friend">åˆ é™¤å¥½å‹</button></div>
                        <div class="form-group aligned-right"><label for="cs-realtime-activity-toggle">åå°å®æ—¶æ´»åŠ¨</label><input type="checkbox" id="cs-realtime-activity-toggle"></div>
                        <div class="form-group aligned-right" id="cs-realtime-interval-group" style="display: none;"><label for="cs-realtime-interval">æ´»åŠ¨é—´éš”(åˆ†é’Ÿ)</label><input type="number" id="cs-realtime-interval" value="30"></div>
                        <button id="cs-restore-btn" class="settings-button secondary" data-bubble-id="cs-restore">è¿˜åŸæ›´æ”¹</button>
                    </div>
                </div>
                <!-- User è®¾ç½® -->
                <div id="user-settings-tab-content" class="tab-content">
                    <div class="chat-settings-layout">
                        <div class="chat-settings-main">
                            <div class="form-group"><label for="us-user-name">ä½ çš„åå­—</label><input type="text" id="us-user-name"></div>
                        </div>
                        <div class="chat-settings-side">
                            <div id="us-user-avatar" class="chat-settings-avatar"><div class="avatar-frame"></div></div>
                            <button id="us-user-avatar-library-btn" class="chat-settings-side-btn" data-bubble-id="us-avatar-lib">å¤´åƒåº“</button>
                            <button id="us-user-avatar-frame-btn" class="chat-settings-side-btn" data-bubble-id="us-frame-lib">å¤´åƒæ¡†</button>
                            <button id="us-user-video-background-btn" class="chat-settings-side-btn" data-bubble-id="us-video-bg">è§†é¢‘èƒŒæ™¯</button>
                        </div>
                    </div>
                    <div class="form-group"><label for="us-persona">ä½ çš„äººè®¾</label><textarea id="us-persona" class="wide-textarea" rows="5"></textarea></div>
                    <div class="chat-settings-actions">
                        <div class="button-group"><button id="us-save-persona-btn" class="settings-button secondary" data-bubble-id="us-save-persona">ä¿å­˜åˆ°èµ„æ–™</button><button id="us-load-persona-btn" class="settings-button secondary" data-bubble-id="us-load-persona">ä»èµ„æ–™è¯»å–</button></div>
                    </div>
                                    <div class="settings-group" id="us-bubble-customization">
                    <div class="group-title">èŠå¤©æ°”æ³¡æ ·å¼</div>
    <div class="group-content">
        <div class="settings-item">
            <textarea id="us-bubble-css" class="theme-css-editor" rows="10"></textarea>
        </div>
    </div>
                    <div class="bubble-css-preview" id="us-bubble-preview">
                        <!-- Preview will be rendered here -->
                    </div>
                                <div class="button-group" style="margin-top: 10px;">
                <button id="us-bubble-restore-btn" class="settings-button danger-btn">è¿˜åŸé»˜è®¤</button>
                <button id="us-bubble-apply-btn" class="settings-button">åº”ç”¨æ ·å¼</button>
            </div>
            <div class="button-group" style="margin-top: 10px;">
                <button id="us-bubble-save-style-btn" class="settings-button secondary">ä¿å­˜æ ·å¼</button>
                <button id="us-bubble-load-style-btn" class="settings-button secondary">è¯»å–æ ·å¼</button>
            </div>
                </div>
                </div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="char-settings">Charè®¾ç½®</div><div class="tab-link" data-tab="user-settings">Userè®¾ç½®</div>
            </div>
        </div>

        <!-- ç¾¤èŠè®¾ç½®ç•Œé¢ -->
        <div id="group-chat-settings-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="gcs-back-btn">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title">ç¾¤èŠè®¾ç½®</h2></div>
                <div class="app-header-right"></div>
            </div>
            <div class="app-content tab-content-wrapper">
                <!-- Group è®¾ç½® -->
                <div id="gcs-group-settings-tab-content" class="tab-content active">
                    <div class="chat-settings-layout">
                        <div class="chat-settings-main">
                            <div class="form-group"><label for="gcs-group-name">ç¾¤èŠåç§°</label><input type="text" id="gcs-group-name"></div>
                            <div class="chat-settings-section">
                                <div class="world-book-header">
                                    <label>å…³è”ä¸–ç•Œä¹¦ (å¯¹å…¨ä½“æˆå‘˜ç”Ÿæ•ˆ)</label>
                                    <div id="gcs-world-book-group-selector" class="wb-group-selector">
                                        <button class="wb-group-selector-btn">é€‰æ‹©åˆ†ç»„</button>
                                        <div class="wb-group-dropdown"></div>
                                    </div>
                                </div>
                                <div id="gcs-world-book-list-container" class="world-book-list-container"><ul id="gcs-world-book-list" class="checkbox-list"></ul></div>
                            </div>
                            <div class="form-group"><label for="gcs-context-memory">ä¸Šä¸‹æ–‡è®°å¿†æ•°é‡</label><input type="number" id="gcs-context-memory" value="99"></div>
                        </div>
                        <div class="chat-settings-side">
                            <div id="gcs-group-avatar" class="chat-settings-avatar"><div class="avatar-frame"></div></div>
                            <button id="gcs-group-avatar-library-btn" class="chat-settings-side-btn" data-bubble-id="gcs-avatar-lib">å¤´åƒåº“</button>
                            <div style="height: 29px;"></div> <!-- ç©ºç™½å ä½ -->
                            <button id="gcs-group-background-btn" class="chat-settings-side-btn" data-bubble-id="gcs-chat-bg">èƒŒæ™¯</button>
                        </div>
                    </div>
                    <div class="chat-settings-section">
                        <div class="group-title">ç¾¤æˆå‘˜</div>
                        <div id="gcs-member-list"></div>
                    </div>
                    <div class="chat-settings-actions">
                        <div class="button-group">
                            <button id="gcs-clear-history-btn" class="settings-button secondary" data-bubble-id="gcs-clear-history">æ¸…ç©ºè®°å½•</button>
                            <button id="gcs-mute-all-btn" class="settings-button secondary" data-bubble-id="gcs-mute-all">å…¨ä½“ç¦è¨€</button>
                            <button id="gcs-disband-btn" class="settings-button danger-btn" data-bubble-id="gcs-disband">è§£æ•£ç¾¤èŠ</button>
                        </div>
                    </div>
                </div>
                <!-- User è®¾ç½® (ç¾¤èŠå†…) -->
                <div id="gcs-user-settings-tab-content" class="tab-content">
                    <div class="chat-settings-layout">
                        <div class="chat-settings-main">
                            <div class="form-group"><label for="gcs-us-user-name">ä½ åœ¨æœ¬ç¾¤çš„æ˜µç§°</label><input type="text" id="gcs-us-user-name"></div>
                        </div>
                        <div class="chat-settings-side">
                            <div id="gcs-us-user-avatar" class="chat-settings-avatar"><div class="avatar-frame"></div></div>
                            <button id="gcs-us-user-avatar-library-btn" class="chat-settings-side-btn" data-bubble-id="gcs-us-avatar-lib">å¤´åƒåº“</button>
                            <button id="gcs-us-user-avatar-frame-btn" class="chat-settings-side-btn" data-bubble-id="gcs-us-frame-lib">å¤´åƒæ¡†</button>
                            <button id="gcs-us-user-video-background-btn" class="chat-settings-side-btn" data-bubble-id="gcs-us-video-bg">è§†é¢‘èƒŒæ™¯</button>
                        </div>
                    </div>
                    <div class="form-group"><label for="gcs-us-persona">ä½ åœ¨æœ¬ç¾¤çš„äººè®¾</label><textarea id="gcs-us-persona" class="wide-textarea" rows="5"></textarea></div>
                    <div class="chat-settings-actions">
                        <div class="button-group"><button id="gcs-us-save-persona-btn" class="settings-button secondary" data-bubble-id="gcs-us-save-persona">ä¿å­˜åˆ°èµ„æ–™</button><button id="gcs-us-load-persona-btn" class="settings-button secondary" data-bubble-id="gcs-us-load-persona">ä»èµ„æ–™è¯»å–</button></div>
                    </div>
                                    <div class="settings-group" id="gcs-us-bubble-customization">
                    <div class="group-title">èŠå¤©æ°”æ³¡æ ·å¼</div>
    <div class="group-content">
        <div class="settings-item">
            <textarea id="gcs-us-bubble-css" class="theme-css-editor" rows="10"></textarea>
        </div>
    </div>
                    <div class="bubble-css-preview" id="gcs-us-bubble-preview">
                        <!-- Preview will be rendered here -->
                    </div>
                                <div class="button-group" style="margin-top: 10px;">
                <button id="gcs-us-bubble-restore-btn" class="settings-button danger-btn">è¿˜åŸé»˜è®¤</button>
                <button id="gcs-us-bubble-apply-btn" class="settings-button">åº”ç”¨æ ·å¼</button>
            </div>
            <div class="button-group" style="margin-top: 10px;">
                <button id="gcs-us-bubble-save-style-btn" class="settings-button secondary">ä¿å­˜æ ·å¼</button>
                <button id="gcs-us-bubble-load-style-btn" class="settings-button secondary">è¯»å–æ ·å¼</button>
            </div>
                </div>
                </div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="gcs-group-settings">ç¾¤è®¾ç½®</div><div class="tab-link" data-tab="gcs-user-settings">æˆ‘çš„è®¾ç½®</div>
            </div>
        </div>
        <!-- æŸ¥çœ‹ç›¸å†Œç•Œé¢ -->
        <div id="view-album-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="view-album-back-btn">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title" id="view-album-title">ç›¸å†Œ</h2></div>
                <div class="app-header-right">
                    <button class="action-btn small" id="delete-photos-btn" style="display: none;">åˆ é™¤</button>
                </div>
            </div>
            <div class="app-content">
                <div id="album-photo-grid" class="photo-grid"></div>
            </div>
        </div>
        <!-- CharåŠ¨æ€ä¸»é¡µ -->
        <div id="char-moments-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="char-moments-back-btn">&lt; åŠ¨æ€</button></div>
                <div class="title-wrapper"><h2 class="title">åŠ¨æ€</h2></div>
                <div class="app-header-right">
                     <button class="action-btn" id="char-moments-notification-btn" data-icon-id="header-notification">
                        <i class="fa-solid fa-bell"></i>
                        <div id="char-moments-notification-badge" class="moments-notification-badge-clone">0</div>
                    </button>
                </div>
            </div>
            <div class="app-content" style="padding:0;">
                <!-- Content will be injected here -->
            </div>
        </div>
<!-- ä¿¡ç®±APPç•Œé¢ -->
        <div id="mail-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title">ä¿¡ç®±</h2></div>
                <div class="app-header-right">
                    <button class="action-btn" id="mail-filter-btn" style="display: none;"><i class="fa-solid fa-filter"></i></button>
                    <button class="action-btn" id="mail-settings-btn" data-icon-id="header-settings"><i class="fa-solid fa-gear"></i></button>
                </div>
            </div>
                        <div id="mail-filter-dropdown" class="filter-dropdown"></div>
                                <div id="postcard-filter-dropdown" class="filter-dropdown"></div>
            <div class="app-content tab-content-wrapper">
                <div id="love-letter-tab-content" class="tab-content active">
                    <div id="all-letters-container" class="styles-rows-container">
                         <div id="all-letters-list" class="love-letter-collection-grid"></div>
                    </div>
                </div>
                <div id="postcard-tab-content" class="tab-content">
                    <div id="postcard-wall" class="love-letter-collection-grid">
                        <!-- Postcards will be rendered here by JS -->
                    </div>
                </div>

<div id="drift-bottle-tab-content" class="tab-content"><p style="text-align:center; color: #888; margin-top: 50px;">æ¼‚æµç“¶åŠŸèƒ½å¾…å¼€å‘...</p></div>
</div>
<div class="moments-fab-container" id="mail-fab-container" style="display: none;"><div id="mail-fab" class="moments-fab"><i class="fa-solid fa-plus"></i></div></div>
<div class="moments-fab-container" id="postcard-fab-container" style="display: none;"><div id="postcard-fab" class="moments-fab"><i class="fa-solid fa-plus"></i></div></div>
<div class="app-bottom-tabs">
<div class="tab-link active" data-tab="love-letter">æƒ…ä¹¦</div>
<div class="tab-link" data-tab="postcard">æ˜ä¿¡ç‰‡</div>

                <div class="tab-link" data-tab="drift-bottle">æ¼‚æµç“¶</div>
            </div>
        </div>
        <!-- æ‰‹è´¦APPç•Œé¢ -->
        <div id="diary-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; è¿”å›</button></div>
                <div class="title-wrapper"><h2 class="title">æ‰‹è´¦</h2></div>
<div class="app-header-right">
                    <button class="action-btn" id="diary-filter-btn" style="display: none;"><i class="fa-solid fa-filter"></i></button>
                    <button class="action-btn" id="diary-action-btn" style="display: none;"><i class="fa-solid fa-plus"></i></button>
                </div>            </div>
                        <div id="secret-filter-dropdown" class="filter-dropdown"></div>
            <div class="app-content tab-content-wrapper">
                                <div id="anniversary-tab-content" class="tab-content active">
                    <div class="calendar-container">
                        <div class="calendar-header">
                            <div class="calendar-header-left">
                                <span class="current-date-display">2025å¹´9æœˆ9æ—¥æ˜ŸæœŸäºŒ</span>
                            </div>
                            <div class="calendar-nav">
                                <span class="current-month-year">2025å¹´9æœˆ</span>
                                                                
                                <div class="nav-arrow" id="prev-month-btn"><i class="fa-solid fa-caret-up"></i></div>
                                <div class="nav-arrow" id="next-month-btn"><i class="fa-solid fa-caret-down"></i></div>
                            </div>
                        </div>
                        <div class="calendar-body">
                            <div class="calendar-weekdays">
                                <span>æ—¥</span><span>ä¸€</span><span>äºŒ</span><span>ä¸‰</span><span>å››</span><span>äº”</span><span>å…­</span>
                            </div>
                            <div class="calendar-grid" id="anniversary-calendar-grid">
                                <!-- Calendar days will be generated by JS -->
                            </div>
                        </div>
                    </div>
                </div>
                <div id="secret-tab-content" class="tab-content"></div>
                <div id="diary-tab-content" class="tab-content"><p style="text-align:center; color: #888; margin-top: 50px;">æ—¥è®°åŠŸèƒ½å¾…å¼€å‘...</p></div>
                    <div id="collection-tab-content" class="tab-content">
        <div id="collection-grid"></div>
    </div>
    <!-- æ–°å¢ï¼šç¼–è¾‘æ”¶è—å¼¹çª— -->
<div id="edit-collection-modal" class="modal-overlay" style="z-index: 260;">
    <div class="modal-content">
        <h3 class="modal-title">ç¼–è¾‘æ”¶è—</h3>
        <div class="modal-body">
            <input type="hidden" id="editing-collection-id">
            <div class="form-group">
                <label for="collection-name-input">åç§°</label>
                <input type="text" id="collection-name-input">
            </div>
        </div>
        <div class="modal-actions row">
            <button id="cancel-edit-collection-btn" class="cancel-btn">å–æ¶ˆ</button>
            <button id="save-collection-btn" class="confirm-btn">ä¿å­˜</button>
        </div>
    </div>
</div>
    <!-- æ–°å¢ï¼šæ”¶è—è®°å½•æŸ¥çœ‹å™¨ -->
<div id="collection-viewer-modal" class="modal-overlay" style="z-index: 250;">
<div class="modal-content" style="width: 95%; max-width: 500px; height: 85vh; display: flex; flex-direction: column;">
<h3 class="modal-title" id="collection-viewer-title"></h3>
<div class="modal-body" id="collection-viewer-content" style="flex-grow: 1; background-color: #f0f2f5; padding: 10px; border-radius: 8px; overflow-y: auto;">
<!-- Collected messages will be rendered here -->
</div>
<div class="modal-actions" style="margin-top: 15px;">
<button id="close-collection-viewer-btn" class="cancel-btn">å…³é—­</button>
</div>
</div>
</div>
<!-- æ–°å¢ï¼šç§˜å¯†æŸ¥çœ‹å™¨ -->
<div id="secret-viewer-modal" class="modal-overlay">
    <button id="secret-viewer-close-btn" class="postcard-close-btn">&times;</button>
    <div class="secret-card-full">
        <div class="secret-content-area">
            <p id="secret-viewer-content"></p>
        </div>
        <div class="secret-footer-area">
            <span id="secret-viewer-name"></span>
            <span id="secret-viewer-timestamp"></span>
        </div>
    </div>
</div>
<!-- æ–°å¢ï¼šç§˜å¯†ç¼–è¾‘å¼¹çª— -->
<div id="edit-secret-modal" class="modal-overlay" style="z-index: 240;">
    <div class="modal-content">
        <h3 class="modal-title">ç¼–è¾‘ç§˜å¯†</h3>
        <div class="modal-body">
            <input type="hidden" id="editing-secret-id">
            <div class="form-group">
                <label for="secret-title-input">æ ‡é¢˜</label>
                <input type="text" id="secret-title-input">
            </div>
            <div class="form-group">
                <label for="secret-content-input">å†…å®¹</label>
                <textarea id="secret-content-input" class="wide-textarea" rows="5"></textarea>
            </div>
        </div>
        <div class="modal-actions row">
            <button id="cancel-edit-secret-btn" class="cancel-btn">å–æ¶ˆ</button>
            <button id="save-edit-secret-btn" class="confirm-btn">ä¿å­˜</button>
        </div>
    </div>
</div>
                                <div id="exhibition-tab-content" class="tab-content">
                    <div id="exhibition-grid"></div>
                </div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="anniversary">çºªå¿µæ—¥</div>
                <div class="tab-link" data-tab="secret">ç§˜å¯†</div>
                <div class="tab-link" data-tab="diary">æ—¥è®°</div>
                <div class="tab-link" data-tab="collection">è—é¦†</div>
                <div class="tab-link" data-tab="exhibition">å±•å…</div>
            </div>
        </div>
            <!-- èµ„äº§APPç•Œé¢ -->
    <div id="assets-app-screen" class="app-screen">
        <div class="app-header">
            <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; è¿”å›</button></div>
            <div class="title-wrapper"><h2 class="title">é“¶è¡Œ</h2></div>
            <div class="app-header-right"></div>
        </div>
        <div class="app-content tab-content-wrapper">
            <div id="bank-tab-content" class="tab-content active">
                <!-- ä½™é¢æ˜¾ç¤ºåŒº -->
                <div class="bank-balance-display">
                    <div class="balance-item">
                        <span class="balance-label">ç°é‡‘ä½™é¢</span>
                        <span class="balance-value" id="bank-cash-balance">Â¥ 0.00</span>
                    </div>
                    <div class="balance-item">
                        <span class="balance-label">é“¶è¡Œå­˜æ¬¾</span>
                        <span class="balance-value" id="bank-deposit-balance">Â¥ 0.00</span>
                    </div>
                    <div class="balance-item loan">
                        <span class="balance-label">è´·æ¬¾æ€»é¢</span>
                        <span class="balance-value" id="bank-loan-balance">Â¥ 0.00</span>
                    </div>
                </div>

                <!-- æ“ä½œåŒº -->
                <div class="settings-group">
                    <div class="group-title">å­˜æ¬¾</div>
                    <div class="group-content">
                        <div class="bank-action-group">
                            <input type="number" id="bank-deposit-input" class="uniform-input-box" placeholder="è¾“å…¥å­˜æ¬¾é‡‘é¢">
                            <button id="bank-deposit-btn" class="settings-button">ç¡®è®¤å­˜æ¬¾</button>
                        </div>
                    </div>
                </div>

                <div class="settings-group">
                    <div class="group-title">å–æ¬¾</div>
                    <div class="group-content">
                        <div class="bank-action-group">
                            <input type="number" id="bank-withdraw-input" class="uniform-input-box" placeholder="è¾“å…¥å–æ¬¾é‡‘é¢">
                            <button id="bank-withdraw-btn" class="settings-button secondary">ç¡®è®¤å–æ¬¾</button>
                        </div>
                    </div>
                </div>

                <div class="settings-group">
                    <div class="group-title">è´·æ¬¾</div>
                    <div class="group-content">
                        <div class="bank-action-group">
                            <input type="number" id="bank-loan-input" class="uniform-input-box" placeholder="è¾“å…¥è´·æ¬¾é‡‘é¢">
                            <button id="bank-loan-btn" class="settings-button danger-btn">ç”³è¯·è´·æ¬¾</button>
                        </div>
                    </div>
                </div>
                            <div class="settings-group">
                <div class="group-title">å¿è¿˜è´·æ¬¾</div>
                <div class="group-content">
                    <div class="bank-action-group">
                        <input type="number" id="bank-repay-input" class="uniform-input-box" placeholder="è¾“å…¥è¿˜æ¬¾é‡‘é¢">
                        <button id="bank-repay-btn" class="settings-button secondary">ç¡®è®¤è¿˜æ¬¾</button>
                    </div>
                </div>
            </div>
            </div>
            <div id="stock-tab-content" class="tab-content">
                            <div id="stock-list-container" style="padding: 15px;">
                <!-- Stock items will be injected here -->
            </div>
            </div>
                    <div id="lottery-tab-content" class="tab-content" style="padding: 15px;">
            <div class="settings-group">
                <div class="group-title">é€‰æ‹©æ‚¨çš„å¹¸è¿å·ç  (é€‰æ‹©5ä¸ª)</div>
                <div id="lottery-number-grid">
                    <!-- Numbers 1-50 will be generated by JS -->
                </div>
            </div>

            <div class="settings-group">
                <div class="group-title">å½“å‰é€‰æ‹©</div>
                <div id="lottery-selection-display" class="group-content" style="padding: 10px; min-height: 40px; display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 18px; font-weight: bold;">
                    <span>-</span><span>-</span><span>-</span><span>-</span><span>-</span>
                </div>
            </div>

            <div class="settings-group">
                <button id="lottery-buy-btn" class="settings-button" disabled>èŠ±è´¹ Â¥1000.00 è´­ä¹°</button>
            </div>
            
            <div id="lottery-results-area">
                <!-- Results will be rendered here by JS -->
            </div>
        </div>
            <div id="monopoly-tab-content" class="tab-content">
                <p style="text-align:center; color: #888; margin-top: 50px;">å¤§å¯Œç¿åŠŸèƒ½å¾…å¼€å‘...</p>
            </div>
        </div>
        <div class="app-bottom-tabs">
            <div class="tab-link active" data-tab="bank">é“¶è¡Œ</div>
            <div class="tab-link" data-tab="stock">è‚¡å¸‚</div>
            <div class="tab-link" data-tab="lottery">å½©ç¥¨</div>
            <div class="tab-link" data-tab="monopoly">å¤§å¯Œç¿</div>
        </div>
    </div>
    <!-- è´­ç‰©APPç•Œé¢ -->
<div id="shop-app-screen" class="app-screen">
    <div class="app-header">
        <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; è¿”å›</button></div>
        <div class="title-wrapper"><h2 class="title">è´­ä¹°</h2></div>
        <div class="app-header-right"></div>
    </div>
    <div class="app-content tab-content-wrapper">
        <div id="purchase-tab-content" class="tab-content active">
            <p style="text-align:center; color: #888; margin-top: 50px;">è´­ä¹°åŠŸèƒ½å¾…å¼€å‘...</p>
        </div>
        <div id="resale-tab-content" class="tab-content">
            <p style="text-align:center; color: #888; margin-top: 50px;">è½¬å”®åŠŸèƒ½å¾…å¼€å‘...</p>
        </div>
        <div id="takeout-tab-content" class="tab-content">
            <p style="text-align:center; color: #888; margin-top: 50px;">å¤–å–åŠŸèƒ½å¾…å¼€å‘...</p>
        </div>
        <div id="blindbox-tab-content" class="tab-content">
            <p style="text-align:center; color: #888; margin-top: 50px;">ç›²ç›’åŠŸèƒ½å¾…å¼€å‘...</p>
        </div>
    </div>
    <div class="app-bottom-tabs">
        <div class="tab-link active" data-tab="purchase">è´­ä¹°</div>
        <div class="tab-link" data-tab="resale">è½¬å”®</div>
        <div class="tab-link" data-tab="takeout">å¤–å–</div>
        <div class="tab-link" data-tab="blindbox">ç›²ç›’</div>
    </div>
</div>
    <!-- å¨±ä¹APPç•Œé¢ -->
    <div id="entertainment-app-screen" class="app-screen">
        <div class="app-header">
            <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; è¿”å›</button></div>
            <div class="title-wrapper"><h2 class="title">ç›´æ’­</h2></div>
                    <div class="app-header-right"><button class="action-btn" id="entertainment-settings-btn" style="display: none;"><i class="fa-solid fa-gear"></i></button></div>
        </div>
        <div class="app-content tab-content-wrapper">
        <div id="livestream-tab-content" class="tab-content active">
            <p style="text-align:center; color: #888; margin-top: 50px;">ç›´æ’­åŠŸèƒ½å¾…å¼€å‘...</p>
        </div>
        <div id="fortune-tab-content" class="tab-content" style="padding: 20px; padding-bottom: 80px;">
            <div id="fortune-initial-view">
                <p style="text-align:center; color: #888; margin-top: 50px;">è½»ç‚¹ä¸‹æ–¹æŒ‰é’®ï¼Œå¼€å¯ä»Šæ—¥å åœï¼ˆç»“æœä»…ä¾›å¨±ä¹ï¼‰</p>
                <button id="start-divination-btn" class="settings-button" style="margin-top: 20px;">å¼€å§‹å åœ</button>
            </div>
            <div id="fortune-result-view" style="display: none;">
                <!-- ç»“æœå°†ç”±JSæ¸²æŸ“äºæ­¤ -->
            </div>
        </div>
        <div id="questionnaire-tab-content" class="tab-content">
            <p style="text-align:center; color: #888; margin-top: 50px;">é—®å·åŠŸèƒ½å¾…å¼€å‘...</p>
        </div>
    </div>
    <div class="app-bottom-tabs">
        <div class="tab-link active" data-tab="livestream">ç›´æ’­</div>
            <div class="tab-link" data-tab="fortune">è¿åŠ¿</div>
        <div class="tab-link" data-tab="questionnaire">é—®å·</div>
    </div>
    </div>

        <!-- å¾®åšAPPç•Œé¢ -->
    <div id="weibo-app-screen" class="app-screen">
        <div class="app-header">
            <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; è¿”å›</button></div>
            <div class="title-wrapper"><h2 class="title">ä½ çš„ä¸»é¡µ</h2></div>
            <div class="app-header-right" id="weibo-header-actions"></div>
        </div>
        <div class="app-content tab-content-wrapper">
            <div id="weibo-main-tab-content" class="tab-content active">
                <!-- User's Weibo content -->
            </div>
            <div id="weibo-char-main-tab-content" class="tab-content">
                <!-- Char's Weibo content -->
            </div>
            <div id="hot-search-tab-content" class="tab-content">
                <p style="text-align:center; color: #888; margin-top: 50px;">çƒ­æœåŠŸèƒ½å¾…å¼€å‘...</p>
            </div>
            <div id="weibo-square-tab-content" class="tab-content">
                <p style="text-align:center; color: #888; margin-top: 50px;">å¹¿åœºåŠŸèƒ½å¾…å¼€å‘...</p>
            </div>
        </div>
        <div class="app-bottom-tabs">
            <div class="tab-link active" data-tab="weibo-main">ä½ çš„ä¸»é¡µ</div>
            <div class="tab-link" data-tab="weibo-char-main">TAçš„ä¸»é¡µ</div>
            <div class="tab-link" data-tab="hot-search">çƒ­æœ</div>
            <div class="tab-link" data-tab="weibo-square">å¹¿åœº</div>
        </div>
    </div>
        <!-- æ–°å¢ï¼šå¾®åšä¸»é¡µè®¾ç½®å¼¹çª— -->
    <div id="weibo-profile-settings-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">ä¸»é¡µè®¾ç½®</h3>
            <div class="modal-body">
                <div id="weibo-add-profile-fields" class="hidden-by-logic" style="margin-bottom: 15px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px;">
                    <div class="form-group">
                        <label id="weibo-profile-form-name-label">æ–°ä¸»é¡µåå­—</label>
                        <input type="text" id="new-weibo-profile-name" class="uniform-input-box" placeholder="ä¾‹å¦‚ï¼šæ­Œæ‰‹A">
                    </div>
                    <div class="form-group">
                        <label id="weibo-profile-form-bio-label">æ–°ä¸»é¡µç®€ä»‹</label>
                        <input type="text" id="new-weibo-profile-bio" class="uniform-input-box" placeholder="ä¾‹å¦‚ï¼šä¸€ä½çƒ­çˆ±å”±æ­Œçš„éŸ³ä¹äºº">
                    </div>
                    <div class="form-group">
                        <label id="weibo-profile-form-persona-label">æ–°ä¸»é¡µäººè®¾</label>
                        <textarea id="new-weibo-profile-persona" class="wide-textarea" rows="3" placeholder="è¿™éƒ¨åˆ†å†…å®¹ä¸ä¼šå…¬å¼€å±•ç¤ºï¼Œä½†ä¼šå½±å“NPCå¯¹ä½ çš„è®¤çŸ¥..."></textarea>
                    </div>
                    <div class="modal-actions row">
                        <button id="weibo-cancel-add-profile-btn" class="cancel-btn">å–æ¶ˆ</button>
                        <button id="weibo-save-profile-btn" class="confirm-btn">ä¿å­˜</button>
                    </div>
                </div>
                <div id="weibo-profile-selector-grid" class="author-selector-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));">
                    <!-- Profile items will be injected here -->
                </div>
                <div id="weibo-profile-management-actions" class="modal-actions row" style="margin-top: 15px; flex-direction: row; justify-content: center;"></div>
            </div>
            <div class="modal-actions row">
                <button id="close-weibo-profile-settings-btn" class="cancel-btn">å…³é—­</button>
                <button id="confirm-weibo-profile-settings-btn" class="confirm-btn">ç¡®å®š</button>
            </div>
        </div>
    </div>
    <!-- æµ®åŠ¨æ­Œè¯ & éŸ³ä¹æ’­æ”¾å™¨ -->
    <div id="lyrics-container"><div id="lyrics-line">...</div></div>
    <div id="player-modal">
        <div class="player-header"><button class="icon-btn" id="hide-player-btn" data-icon-id="player-close"><i class="fa-solid fa-circle-chevron-down"></i></button><div class="player-song-info"><div class="title">æ­Œæ›²å</div><div class="artist">æ­Œæ‰‹</div><div id="listen-together-info"><div class="listen-heart"></div><span id="listen-together-text"></span></div></div><button class="icon-btn" id="toggle-playlist-view-btn" data-icon-id="player-playlist"><i class="fa-solid fa-bars"></i></button></div>
        <div class="player-body"><div id="player-lyrics-view" class="player-view active"></div><div id="player-playlist-view-container" class="player-view"><div class="player-playlist-header"><button class="settings-button secondary" id="restore-playlist-btn" style="padding: 5px 10px; font-size: 12px;" data-bubble-id="player-restore-playlist">è¿˜åŸ</button></div><ul class="player-playlist-view"></ul></div></div>
        <div class="player-footer"><input type="range" id="progress-bar" value="0" step="1"><div class="player-controls"><button class="icon-btn" id="player-prev-btn" data-icon-id="player-prev"><i class="fa-solid fa-circle-chevron-left"></i></button><button class="icon-btn play-pause-btn" id="player-play-pause-btn" data-icon-id="player-play"><i class="fa-solid fa-circle-play"></i></button><button class="icon-btn" id="player-next-btn" data-icon-id="player-next"><i class="fa-solid fa-circle-chevron-right"></i></button><button class="icon-btn" id="player-playback-mode-btn" data-icon-id="player-mode-repeat"><i class="fa-solid fa-arrow-right-arrow-left"></i></button></div></div>
    </div>

    <!-- å¼¹çª—é›†åˆ -->
    <div id="manage-presets-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ç®¡ç†APIé¢„è®¾</h3><div class="modal-body"><p style="font-size: 12px; color: #888; text-align: center;">å‘å·¦æ»‘åŠ¨å¯è¿›è¡Œç¼–è¾‘æˆ–åˆ é™¤</p><ul id="preset-list"></ul></div><div class="modal-actions row"><button id="close-manage-modal-btn" class="cancel-btn" data-bubble-id="modal-close-preset">å…³é—­</button></div></div></div>
    <div id="edit-preset-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ç¼–è¾‘é¢„è®¾</h3><div class="modal-body"><input type="hidden" id="edit-preset-index"><div class="form-group"><label for="edit-preset-name">é¢„è®¾åç§°</label><input type="text" id="edit-preset-name"></div><div class="form-group"><label for="edit-preset-url">åä»£åœ°å€</label><input type="text" id="edit-preset-url"></div><div class="form-group"><label for="edit-preset-key">API å¯†é’¥</label><input type="text" id="edit-preset-key"></div></div><div class="modal-actions row"><button id="cancel-edit-btn" class="cancel-btn" data-bubble-id="modal-cancel">å–æ¶ˆ</button><button id="save-edit-btn" class="confirm-btn" data-bubble-id="modal-save">ä¿å­˜</button></div></div></div>
    <div id="add-music-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">æ·»åŠ éŸ³ä¹</h3><div class="modal-body"><div class="modal-tabs"><button class="tab-btn active" data-tab="upload">ä¸Šä¼ </button><button class="tab-btn" data-tab="url">URL</button></div><div id="tab-content-music-upload" class="modal-tab-content active"><p style="font-size:12px; color:#888; text-align:center; margin-bottom:15px;">æ”¯æŒæ‰¹é‡ä¸Šä¼ ï¼Œæ–‡ä»¶åæ ¼å¼ä¸ºâ€œç¤ºä¾‹æ­Œæ‰‹ - ç¤ºä¾‹æ­Œæ›².ç¤ºä¾‹ä¸»æµåª’ä½“æ ¼å¼â€ã€‚</p><button id="upload-music-btn" class="settings-button" data-bubble-id="modal-select-file">é€‰æ‹©æ–‡ä»¶</button><input type="file" id="music-file-input" multiple accept="audio/*,.lrc" style="display:none;"></div><div id="tab-content-music-url" class="modal-tab-content"><p style="font-size:12px; color:#888; text-align:center; margin-bottom:10px;">æ”¯æŒæ‰¹é‡ä¸Šä¼ ï¼Œæ¯è¡Œä¸€æ¡ï¼Œæ ¼å¼ä¸ºâ€œç¤ºä¾‹æ­Œæ‰‹ - ç¤ºä¾‹æ­Œåï¼šhttp://ç¤ºä¾‹é“¾æ¥.ç¤ºä¾‹ä¸»æµåª’ä½“æ ¼å¼â€ã€‚</p><textarea id="music-url-input" class="wide-textarea"></textarea><button id="confirm-add-url-btn" class="settings-button" data-bubble-id="modal-add-url">æ·»åŠ URL</button></div></div><div class="modal-actions row"><button id="cancel-add-music-btn" class="cancel-btn single-button" data-bubble-id="modal-cancel-music">å–æ¶ˆ</button></div></div></div>
    <div id="edit-song-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ç¼–è¾‘æ­Œæ›²ä¿¡æ¯</h3><div class="modal-body"><input type="hidden" id="edit-song-id"><div class="form-group"><label for="edit-song-title">æ­Œå</label><input type="text" id="edit-song-title"></div><div class="form-group"><label for="edit-song-artist">æ­Œæ‰‹</label><input type="text" id="edit-song-artist"></div></div><div class="modal-actions row"><button id="cancel-edit-song-btn" class="cancel-btn" data-bubble-id="modal-cancel-song">å–æ¶ˆ</button><button id="save-edit-song-btn" class="confirm-btn" data-bubble-id="modal-save-song">ä¿å­˜</button></div></div></div>
    <div id="add-font-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">æ·»åŠ å­—ä½“</h3><div class="modal-body"><div class="modal-tabs"><button class="tab-btn active" data-tab="upload">ä¸Šä¼ </button><button class="tab-btn" data-tab="url">URL</button></div><div id="tab-content-font-upload" class="modal-tab-content active"><button id="upload-font-btn" class="settings-button" data-bubble-id="modal-upload-font">é€‰æ‹©æ–‡ä»¶</button><input type="file" id="font-file-input" multiple accept=".ttf,.otf,.woff,.woff2" style="display:none;"></div><div id="tab-content-font-url" class="modal-tab-content"><textarea id="font-url-input" class="wide-textarea" placeholder="æ¯è¡Œä¸€ä¸ªURLï¼Œæˆ–ä½¿ç”¨â€œå­—ä½“å:URLâ€æ ¼å¼"></textarea><button id="confirm-add-font-url-btn" class="settings-button" data-bubble-id="modal-add-font-url">æ·»åŠ URL</button></div></div><div class="modal-actions row"><button id="cancel-add-font-btn" class="cancel-btn" data-bubble-id="modal-cancel-font">å–æ¶ˆ</button></div></div></div>
    <div id="replace-icon-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">æ›¿æ¢å›¾æ ‡</h3><div class="modal-body"><input type="hidden" id="replace-icon-id"><div class="modal-tabs"><button class="tab-btn active" data-tab="upload">ä¸Šä¼ </button><button class="tab-btn" data-tab="url">URL</button></div><div id="tab-content-icon-upload" class="modal-tab-content active"><button id="upload-icon-btn" class="settings-button" data-bubble-id="modal-upload-icon">é€‰æ‹©å›¾ç‰‡</button><input type="file" id="icon-file-input" accept="image/*" style="display:none;"></div><div id="tab-content-icon-url" class="modal-tab-content"><textarea id="icon-url-input" class="wide-textarea" rows="1" placeholder="è¾“å…¥å›¾ç‰‡URL"></textarea><button id="confirm-replace-icon-url-btn" class="settings-button" style="margin-top:10px;" data-bubble-id="modal-confirm-icon-url">ç¡®è®¤</button></div></div><div class="modal-actions"><button id="restore-icon-btn" class="danger-btn" style="margin-top: 10px;" data-bubble-id="modal-restore-icon">è¿˜åŸ</button><button id="cancel-replace-icon-btn" class="cancel-btn" data-bubble-id="modal-cancel-icon">å–æ¶ˆ</button></div></div></div>
    <div id="edit-bubble-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ç¼–è¾‘æ°”æ³¡</h3><div class="modal-body"><input type="hidden" id="edit-bubble-id"><div class="form-group"><label>å›¾ç‰‡æ›¿æ¢</label><div class="checkbox-group"><input type="checkbox" id="replace-bg-only-checkbox"><label for="replace-bg-only-checkbox">ä»…æ›¿æ¢åº•å›¾</label></div><button class="settings-button" id="upload-bubble-btn" data-bubble-id="bubble-upload-img">ä¸Šä¼ å›¾ç‰‡</button><input type="file" id="bubble-file-input" accept="image/*" style="display:none;"><textarea id="bubble-url-input" class="uniform-input-box" placeholder="æˆ–è¾“å…¥å›¾ç‰‡URL" style="margin-top:10px;"></textarea><hr style="margin:15px 0; border:none; border-top:1px solid var(--border-color);"></div><div class="inline-inputs"><div class="form-group"><label>å®½åº¦</label><input type="text" id="bubble-width-input"></div><div class="form-group"><label>é«˜åº¦</label><input type="text" id="bubble-height-input"></div></div><div class="inline-inputs"><div class="form-group"><label>Xåç§»</label><input type="text" id="bubble-pos-x-input"></div><div class="form-group"><label>Yåç§»</label><input type="text" id="bubble-pos-y-input"></div></div><div class="form-group bubble-color-group"><label>æ–‡å­—é¢œè‰²</label><input type="text" id="bubble-color-input"></div><div class="form-group bubble-color-group"><label>èƒŒæ™¯é¢œè‰²</label><input type="text" id="bubble-bg-color-input"></div><div class="form-group bubble-color-group"><label>è¾¹æ¡†é¢œè‰²</label><input type="text" id="bubble-border-color-input"></div><label>é¢„è§ˆ</label><div id="bubble-preview-wrapper"><div id="bubble-preview"><span>é¢„è§ˆæ–‡å­—</span></div></div></div><div class="modal-actions"><button id="save-bubble-btn" class="confirm-btn" data-bubble-id="bubble-save">ä¿å­˜</button><button id="restore-bubble-btn" class="danger-btn" data-bubble-id="bubble-restore">è¿˜åŸ</button><button id="cancel-edit-bubble-btn" class="cancel-btn" data-bubble-id="bubble-cancel">å–æ¶ˆ</button></div></div></div>
    <div id="bubble-io-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">æ°”æ³¡å¤‡ä»½</h3><div class="modal-body"><div class="button-group" style="flex-direction: column;"><button id="export-bubbles-btn" class="settings-button">ä¸€é”®å¯¼å‡º</button><button id="import-bubbles-btn" class="settings-button secondary">ä¸€é”®å¯¼å…¥</button><input type="file" id="import-bubbles-input" accept=".json" style="display: none;"></div></div><div class="modal-actions"><button id="cancel-bubble-io-btn" class="cancel-btn">å–æ¶ˆ</button></div></div></div>
    <div id="data-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="data-modal-title">åˆ›å»ºæ¡ç›®</h3><div class="modal-body"><input type="hidden" id="data-editing-id"><div class="form-group avatar-group" style="display:none;"><div id="data-avatar-preview" class="modal-avatar-preview"></div><div class="modal-avatar-actions"><button id="data-upload-avatar-btn" class="settings-button secondary" data-bubble-id="data-upload-avatar">ä¸Šä¼ </button><button id="data-add-avatar-url-btn" class="settings-button secondary" data-bubble-id="data-add-avatar-url">æ·»åŠ </button></div><input type="file" id="data-avatar-file-input" accept="image/*" style="display:none;"></div><div class="form-group"><label for="data-name">åç§°</label><input type="text" id="data-name"></div><div class.="form-group" id="data-group-container">
                <label for="data-group">åˆ†ç»„</label>
                <div class="data-group-input-wrapper">
                    <input type="text" id="data-group" placeholder="è¾“å…¥æˆ–é€‰æ‹©åˆ†ç»„">
                    <select id="data-group-select"></select>
                </div>
            </div><div class="form-group"><label for="data-content">å†…å®¹</label><textarea id="data-content" class="wide-textarea" rows="6"></textarea></div></div><div class="modal-actions row"><button id="cancel-data-btn" class="cancel-btn" data-bubble-id="data-cancel">å–æ¶ˆ</button><button id="save-data-btn" class="confirm-btn" data-bubble-id="data-save">ä¿å­˜</button></div></div></div>
    <div id="add-contact-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">æ·»åŠ è”ç³»äºº</h3><div class="modal-body"><div class="form-group"><label for="new-contact-name">åå­—</label><input type="text" id="new-contact-name" placeholder="è¾“å…¥è”ç³»äººåå­—"></div></div><div class="modal-actions row"><button id="cancel-add-contact-btn" class="cancel-btn" data-bubble-id="contact-add-cancel">å–æ¶ˆ</button><button id="confirm-add-contact-btn" class="confirm-btn" data-bubble-id="contact-add-confirm">æ·»åŠ </button></div></div></div>
    <div id="add-emoji-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">æ·»åŠ è¡¨æƒ…åŒ…</h3><div class="modal-body"><div class="modal-tabs"><button class="tab-btn active" data-tab="upload">ä¸Šä¼ </button><button class="tab-btn" data-tab="url">URL</button></div><div id="tab-content-emoji-upload" class="modal-tab-content active"><p style="font-size:12px; color:#888; text-align:center; margin-bottom:15px;">æ”¯æŒæ‰¹é‡ä¸Šä¼ ï¼Œæ¯è¡Œä¸€ä¸ªæè¿°ã€‚</p><textarea id="upload-emoji-desc" class="wide-textarea" placeholder="è¡¨æƒ…åŒ…æ–‡å­—æè¿°(æ¯è¡Œä¸€ä¸ª)"></textarea><button id="upload-emoji-file-btn" class="settings-button" data-bubble-id="emoji-upload-file">é€‰æ‹©æ–‡ä»¶</button><input type="file" id="emoji-file-input" accept="image/*" multiple style="display:none;"></div><div id="tab-content-emoji-url" class="modal-tab-content"><p style="font-size:12px; color:#888; text-align:center; margin-bottom:10px;">æ¯è¡Œä¸€æ¡ï¼Œæ ¼å¼ä¸ºâ€œæ–‡å­—æè¿°:http://é“¾æ¥â€ã€‚</p><textarea id="emoji-url-input" class="wide-textarea"></textarea><button id="confirm-add-emoji-url-btn" class="settings-button" data-bubble-id="emoji-add-url">æ·»åŠ URL</button></div></div><div class="modal-actions row"><button id="cancel-add-emoji-btn" class="cancel-btn single-button" data-bubble-id="emoji-add-cancel">å–æ¶ˆ</button></div></div></div>
    <div id="pat-suffix-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">æ‹ä¸€æ‹</h3><div class="modal-body"><input type="text" id="pat-suffix-input" placeholder="æ·»åŠ åç¼€ (å¯é€‰)"></div><div class="modal-actions row"><button id="cancel-pat-btn" class="cancel-btn" data-bubble-id="pat-cancel">å–æ¶ˆ</button><button id="confirm-pat-btn" class="confirm-btn" data-bubble-id="pat-confirm">æ‹</button></div></div></div>
    <div id="edit-status-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ä¿®æ”¹çŠ¶æ€</h3><div class="modal-body"><div class="form-group"><label for="status-desc-input">çŠ¶æ€æè¿°</label><input type="text" id="status-desc-input" placeholder="ä¾‹å¦‚ï¼šæ­£åœ¨å¼€ä¼š"></div><div class="form-group"><label>é€‰æ‹©çŠ¶æ€</label><div id="status-select-group" class="radio-group"></div></div></div><div class="modal-actions row"><button id="cancel-edit-status-btn" class="cancel-btn" data-bubble-id="status-edit-cancel">å–æ¶ˆ</button><button id="confirm-edit-status-btn" class="confirm-btn" data-bubble-id="status-edit-confirm">ç¡®è®¤</button></div></div></div>
    <div id="voice-input-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">è¯­éŸ³å†…å®¹</h3><div class="modal-body"><textarea id="voice-text-input" class="wide-textarea" placeholder="è¾“å…¥è¯­éŸ³çš„æ–‡å­—å†…å®¹..."></textarea></div><div class="modal-actions row"><button id="cancel-voice-btn" class="cancel-btn" data-bubble-id="voice-cancel">å–æ¶ˆ</button><button id="confirm-voice-btn" class="confirm-btn" data-bubble-id="voice-confirm">å‘é€</button></div></div></div>
    <div id="camera-input-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">å›¾ç‰‡æè¿°</h3><div class="modal-body"><textarea id="camera-text-input" class="wide-textarea" placeholder="è¾“å…¥å›¾ç‰‡çš„æ–‡å­—æè¿°..."></textarea></div><div class="modal-actions row"><button id="cancel-camera-btn" class="cancel-btn" data-bubble-id="camera-cancel">å–æ¶ˆ</button><button id="confirm-camera-btn" class="confirm-btn" data-bubble-id="camera-confirm">å‘é€</button></div></div></div>
    <div id="link-share-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">åˆ†äº«é“¾æ¥</h3><div class="modal-body"><div class="form-group"><label>æ ‡é¢˜ (å¿…å¡«)</label><input type="text" id="link-title-input"></div><div class="form-group"><label>æ‘˜è¦</label><input type="text" id="link-summary-input"></div><div class="form-group"><label>æ¥æº</label><input type="text" id="link-source-input"></div><div class="form-group"><label>å®Œæ•´å†…å®¹</label><textarea id="link-content-input" class="wide-textarea" rows="4"></textarea></div></div><div class="modal-actions row"><button id="cancel-link-btn" class="cancel-btn" data-bubble-id="link-cancel">å–æ¶ˆ</button><button id="confirm-link-btn" class="confirm-btn" data-bubble-id="link-confirm">åˆ†äº«</button></div></div></div>
    <div id="red-packet-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">å‘çº¢åŒ…</h3><div class="modal-body"><div class="form-group"><label>é‡‘é¢</label><input type="number" id="red-packet-amount-input" class="uniform-input-box" placeholder="0.00"></div><div class="form-group"><label>ç•™è¨€</label><input type="text" id="red-packet-message-input" class="uniform-input-box" placeholder="æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼"></div></div><div class="modal-actions row"><button id="cancel-red-packet-btn" class="cancel-btn" data-bubble-id="rp-cancel">å–æ¶ˆ</button><button id="confirm-red-packet-btn" class="confirm-btn" data-bubble-id="rp-confirm">å¡é’±è¿›çº¢åŒ…</button></div></div></div>
    <div id="group-red-packet-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">å‘ç¾¤çº¢åŒ…</h3><div class="modal-body"><div class="modal-tabs"><button class="tab-btn active" data-tab="exclusive">ä¸“å±</button><button class="tab-btn" data-tab="lucky">æ‹¼æ‰‹æ°”</button><button class="tab-btn" data-tab="normal">æ™®é€š</button></div><div id="tab-content-rp-exclusive" class="modal-tab-content active"><div class="form-group"><label>é‡‘é¢</label><input type="number" class="red-packet-input" data-type="exclusive-amount" placeholder="0.00"></div><div class="form-group"><label>ç•™è¨€</label><input type="text" class="red-packet-input" data-type="exclusive-message" placeholder="æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼"></div><div class="form-group"><label>é€‰æ‹©å‘é€å¯¹è±¡</label><div id="group-red-packet-member-grid"></div></div></div><div id="tab-content-rp-lucky" class="modal-tab-content"><div class="form-group"><label>æ€»é‡‘é¢</label><input type="number" class="red-packet-input" data-type="lucky-amount" placeholder="0.00"></div><div class="form-group"><label>çº¢åŒ…ä¸ªæ•°</label><input type="number" class="red-packet-input" data-type="lucky-count" placeholder="å¡«å†™ä¸ªæ•°"></div><div class="form-group"><label>ç•™è¨€</label><input type="text" class="red-packet-input" data-type="lucky-message" placeholder="æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼"></div></div><div id="tab-content-rp-normal" class="modal-tab-content"><div class="form-group"><label>å•ä¸ªé‡‘é¢</label><input type="number" class="red-packet-input" data-type="normal-amount" placeholder="0.00"></div><div class="form-group"><label>çº¢åŒ…ä¸ªæ•°</label><input type="number" class="red-packet-input" data-type="normal-count" placeholder="å¡«å†™ä¸ªæ•°"></div><div class="form-group"><label>ç•™è¨€</label><input type="text" class="red-packet-input" data-type="normal-message" placeholder="æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼"></div></div></div><div class="modal-actions row"><button id="cancel-group-red-packet-btn" class="cancel-btn" data-bubble-id="grp-cancel">å–æ¶ˆ</button><button id="confirm-group-red-packet-btn" class="confirm-btn" data-bubble-id="grp-confirm">å¡é’±è¿›çº¢åŒ…</button></div></div></div>
    <div id="edit-comment-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ç¼–è¾‘è¯„è®º</h3><div class="modal-body"><textarea id="edit-comment-input" class="wide-textarea"></textarea></div><div class="modal-actions row"><button id="cancel-edit-comment-btn" class="cancel-btn" data-bubble-id="comment-edit-cancel">å–æ¶ˆ</button><button id="save-edit-comment-btn" class="confirm-btn" data-bubble-id="comment-edit-save">ä¿å­˜</button></div></div></div>
    <div id="view-content-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="view-content-title"></h3><div class="modal-body" id="view-content-body"></div><div class="modal-actions"><button id="close-view-content-btn" class="cancel-btn" data-bubble-id="view-content-close">å…³é—­</button></div></div></div>
    <div id="edit-message-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ç¼–è¾‘æ¶ˆæ¯</h3><div class="modal-body"><input type="hidden" id="editing-message-id"><div class="form-group"><label>æ¶ˆæ¯ç±»å‹</label><div id="edit-message-type-group" class="radio-group"></div></div><div id="edit-message-inputs-container"></div></div><div class="modal-actions row"><button id="cancel-edit-message-btn" class="cancel-btn" data-bubble-id="msg-edit-cancel">å–æ¶ˆ</button><button id="save-edit-message-btn" class="confirm-btn" data-bubble-id="msg-edit-save">ä¿å­˜</button></div></div></div>
    <div id="library-modal" class="modal-overlay"><div class="modal-content library-modal"><h3 class="modal-title" id="library-modal-title">åº“</h3><div class="modal-body"><div id="library-modal-preview-area"></div><div class="button-group" style="margin-bottom: 15px;"><button id="library-upload-btn" class="settings-button" data-bubble-id="lib-upload">ä¸Šä¼ </button><button id="library-add-url-btn" class="settings-button" data-bubble-id="lib-add-url">æ·»åŠ URL</button></div><div id="library-grid" class="library-grid"></div><input type="file" id="library-file-input" style="display:none" multiple></div><div class="modal-actions"><button id="library-close-btn" class="cancel-btn" data-bubble-id="lib-close">å…³é—­</button><button id="library-mode-toggle-btn" class="cancel-btn">åˆ é™¤</button><button id="library-delete-btn" class="danger-btn" style="display:none;" data-bubble-id="lib-delete">ç¡®è®¤åˆ é™¤</button></div></div></div>
        <div id="background-library-modal" class="modal-overlay"><div class="modal-content library-modal"><h3 class="modal-title" id="background-library-modal-title">é€‰æ‹©èƒŒæ™¯</h3><div class="modal-body"><div class="button-group" style="margin-bottom: 15px;"><button id="background-library-upload-btn" class="settings-button">ä¸Šä¼ </button><button id="background-library-add-url-btn" class="settings-button">æ·»åŠ URL</button></div><div id="background-library-grid" class="library-grid"></div><input type="file" id="background-library-file-input" style="display:none" multiple></div><div class="modal-actions"><button id="background-library-close-btn" class="cancel-btn">å…³é—­</button><button id="background-library-mode-toggle-btn" class="cancel-btn">åˆ é™¤</button><button id="background-library-delete-btn" class="danger-btn" style="display:none;">ç¡®è®¤åˆ é™¤</button></div></div></div>
    <div id="load-persona-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="load-persona-title">è¯»å–èµ„æ–™</h3><div class="modal-body" id="load-persona-list"></div><div class="modal-actions"><button id="load-persona-cancel-btn" class="cancel-btn" data-bubble-id="persona-load-cancel">å–æ¶ˆ</button></div></div></div>
    <div id="load-style-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="load-style-title">è¯»å–æ ·å¼</h3><div class="modal-body" id="load-style-list"></div><div class="modal-actions"><button id="load-style-cancel-btn" class="cancel-btn">å–æ¶ˆ</button></div></div></div>
    <div id="gcs-member-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="gcs-member-modal-title">æˆå‘˜è®¾ç½®</h3><div class="modal-body"><input type="hidden" id="gcs-editing-member-id"><div class="chat-settings-layout"><div class="chat-settings-main"><div class="form-group"><label>ç¾¤åç‰‡</label><input type="text" id="gcs-member-nickname"></div><div class="chat-settings-section"><div class="world-book-header"><label>å…³è”ä¸–ç•Œä¹¦ (ä»…å¯¹è¯¥æˆå‘˜ç”Ÿæ•ˆ)</label><div id="gcs-member-world-book-group-selector" class="wb-group-selector"><button class="wb-group-selector-btn">é€‰æ‹©åˆ†ç»„</button><div class="wb-group-dropdown"></div></div></div><div id="gcs-member-world-book-list-container" class="world-book-list-container"><ul id="gcs-member-world-book-list" class="checkbox-list"></ul></div></div></div><div class="chat-settings-side"><div id="gcs-member-avatar" class="chat-settings-avatar"><div class="avatar-frame"></div></div><button id="gcs-member-avatar-library-btn" class="chat-settings-side-btn" data-bubble-id="gcs-member-avatar-lib">å¤´åƒåº“</button><button id="gcs-member-avatar-frame-btn" class="chat-settings-side-btn" data-bubble-id="gcs-member-frame-lib">å¤´åƒæ¡†</button></div></div><div class="form-group"><label for="gcs-member-relationship">ä½ å’ŒTAçš„å…³ç³»</label><input type="text" id="gcs-member-relationship" placeholder="ä¾‹å¦‚ï¼šæœ‹å‹ã€æ‹äººã€å…„å¦¹..."></div> <div class="form-group"><label>äººè®¾</label><textarea id="gcs-member-persona" class="wide-textarea" rows="5"></textarea></div><div class="button-group"><button id="gcs-member-save-persona-btn" class="settings-button secondary" data-bubble-id="gcs-member-save-persona">ä¿å­˜åˆ°èµ„æ–™</button><button id="gcs-member-load-persona-btn" class="settings-button secondary" data-bubble-id="gcs-member-load-persona">ä»èµ„æ–™è¯»å–</button></div></div><div class="modal-actions row"><button id="gcs-member-modal-cancel-btn" class="cancel-btn" data-bubble-id="gcs-member-cancel">å–æ¶ˆ</button><button id="gcs-member-modal-save-btn" class="confirm-btn" data-bubble-id="gcs-member-save">ä¿å­˜</button></div></div></div>
    <div id="gcs-manage-members-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="gcs-manage-members-title">ç®¡ç†æˆå‘˜</h3><div class="modal-body" id="gcs-manage-members-list"></div><div class="modal-actions row"><button id="gcs-manage-members-cancel-btn" class="cancel-btn" data-bubble-id="gcs-manage-cancel">å–æ¶ˆ</button><button id="gcs-manage-members-confirm-btn" class="confirm-btn" data-bubble-id="gcs-manage-confirm">ç¡®è®¤</button></div></div></div>
    <div id="gcs-member-action-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="gcs-member-action-title">ç®¡ç†æˆå‘˜</h3><div class="modal-body" id="gcs-member-action-body"></div><div class="modal-actions"><button id="gcs-member-action-cancel-btn" class="cancel-btn" data-bubble-id="gcs-member-action-cancel">å–æ¶ˆ</button></div></div></div>
    <!-- ç•™è¨€å¼¹çª— -->
    <div id="leave-message-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">å†™ç•™è¨€</h3>
            <div class="modal-body">
                <div class="form-group hidden-by-logic" id="leave-message-author-selector-container">
                        <label>å‘å¸ƒäºº</label>
                        <div id="leave-message-author-selector"></div>
                    </div>
                <div class="form-group">
                    <label for="message-recipient">ç§°å‘¼</label>
                    <input type="text" id="message-recipient" placeholder="To:">
                </div>
                <div class="form-group">
                    <label for="message-content">å†…å®¹</label>
                    <textarea id="message-content" class="wide-textarea" rows="5" placeholder="è¯´ç‚¹ä»€ä¹ˆå§..."></textarea>
                </div>
                <div class="form-group">
                    <label for="message-sender">è½æ¬¾</label>
                    <input type="text" id="message-sender" placeholder="From:">
                </div>
                <hr>
                <div class="form-group">
                    <label>è°å¯ä»¥çœ‹</label>
                    <div class="radio-group" id="leave-message-visibility">
                        <label class="radio-label"><input type="radio" name="message-visibility" value="public" checked><span>å…¬å¼€</span></label>
                        <label class="radio-label"><input type="radio" name="message-visibility" value="specific"><span>æŒ‡å®šå¥½å‹</span></label>
                    </div>
                </div>
                <div class="form-group hidden-by-logic" id="leave-message-friend-selector-container">
                    <div id="leave-message-friend-selector" class="friend-selector-grid"></div>
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-leave-message-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="confirm-leave-message-btn" class="confirm-btn">å‘è¡¨</button>
            </div>
        </div>
    </div>
    
    <!-- ç›¸å†Œç®¡ç†å¼¹çª— -->
    <div id="manage-albums-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">ç®¡ç†ç›¸å†Œ</h3>
            <div class="app-header-right" style="position: absolute; top: 15px; right: 15px;">
                <button class="action-btn small" id="create-album-btn">æ–°å»º</button>
            </div>
            <div class="modal-body">
                <div id="manage-albums-grid" class="album-grid"></div>
            </div>
            <div class="modal-actions multi-button">
                 <button id="delete-selected-albums-btn" class="danger-btn" style="display: none;">åˆ é™¤é€‰ä¸­</button>
                <button id="close-manage-albums-btn" class="cancel-btn">å…³é—­</button>
            </div>
        </div>
    </div>

    <!-- æ–°å»º/ç¼–è¾‘ç›¸å†Œå¼¹çª— -->
    <div id="edit-album-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title" id="edit-album-title">æ–°å»ºç›¸å†Œ</h3>
            <div class="modal-body">
                <input type="hidden" id="editing-album-id">
                <div class="form-group">
                    <label for="album-name-input">ç›¸å†Œåç§°</label>
                    <input type="text" id="album-name-input" placeholder="å¿…å¡«">
                </div>
                <div class="form-group">
                    <label for="album-desc-input">ç›¸å†Œæè¿°</label>
                    <textarea id="album-desc-input" class="wide-textarea" rows="3" placeholder="é€‰å¡«"></textarea>
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-edit-album-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="save-album-btn" class="confirm-btn">ä¿å­˜</button>
            </div>
        </div>
    </div>
    <!-- ç®€æ˜“å›¾ç‰‡/æ–‡å­—æŸ¥çœ‹å™¨ -->
    <div id="simple-viewer-modal" class="modal-overlay">
        <div class="simple-viewer-content">
            <img id="simple-viewer-image" src="">
            <div id="simple-viewer-text"></div>
            <button id="simple-viewer-prev-btn" class="viewer-nav-btn prev-btn" style="display: none;">&lt;</button>
            <button id="simple-viewer-next-btn" class="viewer-nav-btn next-btn" style="display: none;">&gt;</button>
        </div>
    </div>
    <!-- ç¼–è¾‘ç…§ç‰‡ä¿¡æ¯å¼¹çª— -->
    <div id="edit-photo-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">ç¼–è¾‘ç…§ç‰‡ä¿¡æ¯</h3>
            <div class="modal-body">
                <input type="hidden" id="editing-photo-id">
                <div class="form-group">
                    <label for="photo-name-input">ç…§ç‰‡åç§°</label>
                    <input type="text" id="photo-name-input">
                </div>
                <div class="form-group">
                    <label for="photo-desc-input">ç…§ç‰‡æè¿°</label>
                    <textarea id="photo-desc-input" class="wide-textarea" rows="3"></textarea>
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-edit-photo-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="save-photo-btn" class="confirm-btn">ä¿å­˜</button>
            </div>
        </div>
    </div>
    <!-- ç…§ç‰‡æŸ¥çœ‹å¼¹çª— -->
    <div id="view-photo-modal" class="modal-overlay">
        <div id="photo-viewer-container">
            <!-- çœŸå®å›¾ç‰‡è§†å›¾ -->
            <div id="viewer-image-view" class="photo-viewer-content">
                    <button id="view-photo-close-btn" class="photo-viewer-close-btn">&times;</button>
                    <div class="photo-viewer-image-container">
                        <div id="view-photo-name" class="photo-viewer-name"></div>
                        <img id="view-photo-image" src="">
                        <div id="view-photo-desc" class="photo-viewer-desc"></div>
                    </div>
                </div>
                    <!-- è™šæ‹Ÿæ–‡å­—å›¾è§†å›¾ -->
        <div id="viewer-text-view">
             <button id="view-photo-text-close-btn" class="photo-viewer-close-btn">&times;</button>
             <div id="view-photo-text-name" class="photo-viewer-name"></div>
             <div id="view-photo-text-display"></div>
             <div id="view-photo-text-desc" class="photo-viewer-desc"></div>
        </div>
        </div>
        <button id="photo-viewer-prev-btn" class="viewer-nav-btn prev-btn" style="display: none;">&lt;</button>
        <button id="photo-viewer-next-btn" class="viewer-nav-btn next-btn" style="display: none;">&gt;</button>
    </div>
    <!-- ä¸Šä¼ ç…§ç‰‡å¼¹çª— -->
    <div id="upload-photo-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">ä¸Šä¼ ç…§ç‰‡</h3>
            <div class="modal-body">
                <div class="form-group">
                    <label for="upload-photo-name">ç…§ç‰‡åç§°</label>
                    <input type="text" id="upload-photo-name" placeholder="å¿…å¡«ï¼Œä¾‹å¦‚ï¼šæµ·è¾¹çš„æ—¥è½">
                </div>
                <div class="form-group">
                    <div class="button-group">
                        <button id="upload-photo-local-btn" class="settings-button secondary">å›¾ç‰‡</button>
                        <button id="upload-photo-text-btn" class="settings-button secondary">æ–‡å­—å›¾</button>
                    </div>
                     <input type="file" id="upload-photo-file-input" accept="image/*" style="display:none;" multiple>
                </div>
                <div id="upload-photo-image-preview-grid"></div>
                 <div class="form-group hidden-by-logic" id="upload-photo-text-image-input-group">
                    <label>æ–‡å­—å›¾æè¿° (æ¯è¡Œä¸€å¼ )</label>
                    <textarea id="upload-photo-text-image-desc" class="wide-textarea" rows="2" placeholder="AIå°†æ ¹æ®ä½ çš„æè¿°ç”Ÿæˆå›¾ç‰‡..."></textarea>
                </div>
                <div class="form-group">
                    <label for="upload-photo-desc">ç…§ç‰‡æè¿° (å¯é€‰)</label>
                    <textarea id="upload-photo-desc" class="wide-textarea" rows="2" placeholder="è®°å½•è¿™ä¸€åˆ»çš„æƒ³æ³•..."></textarea>
                </div>
                <div class="form-group">
                    <label for="upload-photo-album-select">ä¸Šä¼ åˆ°ç›¸å†Œ</label>
                    <select id="upload-photo-album-select"></select>
                </div>
                <hr>
                <div class="form-group">
                    <label>è°å¯ä»¥çœ‹</label>
                    <div class="radio-group" id="upload-photo-visibility">
                        <label class="radio-label"><input type="radio" name="photo-visibility" value="public" checked><span>å…¬å¼€</span></label>
                        <label class="radio-label"><input type="radio" name="photo-visibility" value="specific"><span>æŒ‡å®šå¥½å‹</span></label>
                    </div>
                </div>
                <div class="form-group hidden-by-logic" id="upload-photo-friend-selector-container">
                    <div id="upload-photo-friend-selector" class="friend-selector-grid"></div>
                </div>
                <div class="form-group">
                <label class="checkbox-label tick-style">
                    <input type="checkbox" id="upload-photo-comment-private-checkbox">
                    <span>è¯„è®ºåŒºåŠ å¯†</span>
                </label>
            </div>
            <div class="form-group">
                <label class="checkbox-label tick-style">
                    <input type="checkbox" id="upload-photo-visibility-public-checkbox">
                    <span>å¯¹Charå…¬å¼€å¯è§èŒƒå›´</span>
                </label>
            </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-upload-photo-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="confirm-upload-photo-btn" class="confirm-btn">å‘å¸ƒ</button>
            </div>
        </div>
    </div>
    <!-- åŠ¨æ€å‘å¸ƒå¼¹çª— -->
    <div id="post-moment-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title" id="post-moment-modal-title">å‘è¡¨åŠ¨æ€</h3>
            <div class="modal-body" id="post-moment-modal-body">
                <!-- è¯´è¯´å‘å¸ƒåŒº -->
                <div id="post-moment-status-section">
                    <div class="form-group">
                        <label>ç±»å‹</label>
                        <div class="radio-group" id="post-moment-status-type">
                            <label class="radio-label"><input type="radio" name="status-type" value="text" checked><span>æ–‡å­—</span></label>
                            <label class="radio-label"><input type="radio" name="status-type" value="image"><span>å›¾ç‰‡</span></label>
                            <label class="radio-label"><input type="radio" name="status-type" value="text-image"><span>æ–‡å­—å›¾</span></label>
                        </div>
                    </div>
                    <div class="form-group hidden-by-logic" id="post-moment-image-buttons">
                        <div class="button-group">
                            <button id="post-moment-upload-btn" class="settings-button secondary">ä¸Šä¼ </button>
                            <button id="post-moment-add-url-btn" class="settings-button secondary">æ·»åŠ URL</button>
                        </div>
                        <input type="file" id="post-moment-image-input" accept="image/*" style="display:none;" multiple>
                    </div>
                    <div class="form-group hidden-by-logic" id="post-moment-text-image-input">
                        <label>å›¾ç‰‡æè¿°</label>
                        <textarea id="post-moment-text-image-desc" class="wide-textarea" rows="2" placeholder="è¾“å…¥AIç”Ÿæˆå›¾ç‰‡çš„æè¿°..."></textarea>
                    </div>
                    <div class="form-group">
                        <label>å†…å®¹</label>
                        <textarea id="post-moment-status-content" class="wide-textarea" rows="4" placeholder="åˆ†äº«æ–°é²œäº‹..."></textarea>
                    </div>
                </div>
                <!-- æ—¥å¿—å‘å¸ƒåŒº -->
                <div id="post-moment-log-section" class="hidden-by-logic">
                     <div class="form-group">
                        <label>æ ‡é¢˜</label>
                        <input type="text" id="post-moment-log-title" placeholder="è¯·è¾“å…¥æ—¥å¿—æ ‡é¢˜">
                    </div>
                    <div class="form-group">
                        <label>å†…å®¹</label>
                        <textarea id="post-moment-log-content" class="wide-textarea" rows="6" placeholder="è®°å½•ä»Šå¤©çš„å¿ƒæƒ…..."></textarea>
                    </div>
                </div>
                <hr>
                <!-- é€šç”¨åŒºåŸŸ -->
                <div class="form-group">
                    <label>è°å¯ä»¥çœ‹</label>
                    <div class="radio-group" id="post-moment-visibility">
                        <label class="radio-label"><input type="radio" name="visibility" value="public" checked><span>å…¬å¼€</span></label>
                        <label class="radio-label"><input type="radio" name="visibility" value="specific"><span>æŒ‡å®šå¥½å‹</span></label>
                    </div>
                </div>
                <div class="form-group hidden-by-logic" id="post-moment-friend-selector-container">
                    <div id="post-moment-friend-selector" class="friend-selector-grid"></div>
                </div>
                                    <div class="form-group" id="post-moment-comment-privacy-container">
            <label class="checkbox-label tick-style">
                <input type="checkbox" id="post-moment-comment-private-checkbox">
                <span>è¯„è®ºåŒºåŠ å¯†</span>
            </label>
        </div>
        <div class="form-group" id="post-moment-visibility-privacy-container">
                <label class="checkbox-label tick-style">
                    <input type="checkbox" id="post-moment-visibility-public-checkbox">
                    <span>å¯¹Charå…¬å¼€å¯è§èŒƒå›´</span>
                </label>
            </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-post-moment-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="confirm-post-moment-btn" class="confirm-btn">å‘å¸ƒ</button>
            </div>
        </div>
    </div>
                        <!-- åŠ¨æ€è¯„è®ºç¼–è¾‘å¼¹çª— -->
        <div id="edit-moment-comment-modal" class="modal-overlay">
            <div class="modal-content">
                <h3 class="modal-title">ç¼–è¾‘è¯„è®º</h3>
                <div class="modal-body">
                    <div class="form-group">
                        <label>è¯„è®ºè€…</label>
                        <div id="moment-comment-author-selector"></div>
                    </div>
                    <div class="form-group">
                        <label>è¯„è®ºå†…å®¹</label>
                        <textarea id="edit-moment-comment-content" class="wide-textarea" rows="4"></textarea>
                    </div>
                </div>
                <div class="modal-actions row">
                    <button id="cancel-edit-moment-comment-btn" class="cancel-btn">å–æ¶ˆ</button>
                    <button id="save-edit-moment-comment-btn" class="confirm-btn">ä¿å­˜</button>
                </div>
            </div>
        </div>
        <!-- åŠ¨æ€é€šçŸ¥å¼¹çª— -->
        <div id="moments-notification-modal" class="modal-overlay">
            <div class="modal-content">
                <h3 class="modal-title">é€šçŸ¥</h3>
                <div class="modal-body" style="padding: 0;">
                    <ul id="moments-notification-list" class="preset-data-list">
                        <!-- Notifications will be rendered here by JS -->
                    </ul>
                </div>
                <div class="modal-actions">
                    <button id="close-moments-notification-modal-btn" class="cancel-btn">å…³é—­</button>
                </div>
            </div>
        </div>
    <!-- æ¶ˆæ¯é•¿æŒ‰èœå• -->
    <div id="context-menu" style="display: none;">
        <button class="context-menu-btn" id="context-menu-edit">ç¼–è¾‘</button>
        <button class="context-menu-btn" id="context-menu-quote">å¼•ç”¨</button>
        <button class="context-menu-btn" id="context-menu-recall">æ’¤å›</button>
        <button class="context-menu-btn" id="context-menu-copy">å¤åˆ¶</button>
        <button class="context-menu-btn" id="context-menu-multiselect">å¤šé€‰</button>
        <button class="context-menu-btn" id="context-menu-cancel">å–æ¶ˆ</button>
    </div>
    <!-- æ‹†ä¿¡ä¸é˜…è¯»å™¨ -->
    <div id="unread-letter-prompt">
        <div class="envelope-icon"><i class="fa-regular fa-envelope"></i></div>
    </div>
    <div id="love-letter-viewer">
        <!-- The folded corner is now done with CSS pseudo-elements -->
        <button class="letter-close-btn" id="letter-close-btn">&times;</button> <!-- BUG FIX: Added ID -->
        <div class="letter-content-wrapper">
            <div class="letter-salutation"></div>
            <div class="letter-body"></div>
            <div class="letter-signature">
                <span class="letter-sender-name"></span>
                <span class="letter-timestamp"></span>
                <!-- The stamp is now positioned relative to the signature area -->
                <div class="letter-stamp"></div>
                <button class="letter-reply-btn" id="letter-reply-btn" title="å›ä¿¡"><i class="fa-solid fa-pen-nib"></i></button>
            </div>
        </div>
    </div>
        <!-- æ–°å¢ï¼šå›ä¿¡æ˜ä¿¡ç‰‡å¼¹çª— -->
    <div id="reply-postcard-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">å›ä¿¡</h3>
            <div class="modal-body">
                <input type="hidden" id="reply-original-postcard-id">
                <div class="form-group">
                    <label>ç§°å‘¼</label>
                    <input type="text" id="reply-postcard-salutation">
                </div>
                <div class="form-group" style="text-align: center;">
                    <img id="reply-postcard-image-preview" src="" alt="æ˜ä¿¡ç‰‡å›¾ç‰‡é¢„è§ˆ" style="max-width: 100%; height: auto; max-height: 150px; border-radius: 8px; margin-bottom: 10px; border: 1px solid var(--border-color); object-fit: cover;">
                    <div class="button-group">
                        <button id="upload-reply-postcard-image-btn" class="settings-button secondary">ä¸Šä¼ </button>
                        <button id="add-reply-postcard-image-url-btn" class="settings-button secondary">æ·»åŠ URL</button>
                    </div>
                    <input type="file" id="reply-postcard-image-file-input" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label>å†…å®¹</label>
                    <textarea id="reply-postcard-body" class="wide-textarea" rows="4" placeholder="åˆ†äº«ä½ çš„è¿‘å†µ..."></textarea>
                </div>
                <div class="form-group">
                    <label>è½æ¬¾</label>
                    <input type="text" id="reply-postcard-signature">
                </div>
                <div class="form-group">
                    <label>åœ°ç‚¹</label>
                    <input type="text" id="reply-postcard-location" placeholder="ä½ åœ¨å“ªé‡Œï¼Ÿ">
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-reply-postcard-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="send-reply-postcard-btn" class="confirm-btn">å‘é€</button>
            </div>
        </div>
    </div>
    <!-- æ–°å¢ï¼šå†™æ–°æ˜ä¿¡ç‰‡å¼¹çª— -->
    <div id="new-postcard-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">å†™æ–°æ˜ä¿¡ç‰‡</h3>
            <div class="modal-body">
                <div class="form-group">
                    <label>æ”¶ä¿¡äºº</label>
                    <div id="new-postcard-recipient-selector" class="author-selector-grid"></div>
                </div>
                <div class="form-group">
                    <label for="new-postcard-salutation">ç§°å‘¼</label>
                    <input type="text" id="new-postcard-salutation" placeholder="To:">
                </div>
                <div class="form-group" style="text-align: center;">
                    <img id="new-postcard-image-preview" src="" alt="æ˜ä¿¡ç‰‡å›¾ç‰‡é¢„è§ˆ" style="display: none; max-width: 100%; height: auto; max-height: 150px; border-radius: 8px; margin-bottom: 10px; border: 1px solid var(--border-color); object-fit: cover;">
                    <div class="button-group">
                        <button id="upload-new-postcard-image-btn" class="settings-button secondary">ä¸Šä¼ </button>
                        <button id="add-new-postcard-image-url-btn" class="settings-button secondary">æ·»åŠ </button>
                    </div>
                    <input type="file" id="new-postcard-image-file-input" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label for="new-postcard-body">å†…å®¹</label>
                    <textarea id="new-postcard-body" class="wide-textarea" rows="4" placeholder="åˆ†äº«ä½ çš„è¿‘å†µ..."></textarea>
                </div>
                <div class="form-group">
                    <label for="new-postcard-signature">è½æ¬¾</label>
                    <input type="text" id="new-postcard-signature" placeholder="From:">
                </div>
                <div class="form-group">
                    <label for="new-postcard-location">åœ°ç‚¹</label>
                    <input type="text" id="new-postcard-location" placeholder="ä½ åœ¨å“ªé‡Œï¼Ÿ">
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-new-postcard-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="send-new-postcard-btn" class="confirm-btn">å‘é€</button>
            </div>
        </div>
    </div>
        <!-- æ–°å¢ï¼šæ˜ä¿¡ç‰‡ç¼–è¾‘å¼¹çª— -->
    <div id="edit-postcard-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">ç¼–è¾‘æ˜ä¿¡ç‰‡</h3>
            <div class="modal-body">
                <input type="hidden" id="editing-postcard-id">
                <div class="form-group" style="text-align: center;">
                    <img id="edit-postcard-image-preview" src="" alt="æ˜ä¿¡ç‰‡å›¾ç‰‡é¢„è§ˆ" style="max-width: 100%; height: auto; max-height: 150px; border-radius: 8px; margin-bottom: 10px; border: 1px solid var(--border-color);">
                    <div class="button-group">
                        <button id="upload-postcard-image-btn" class="settings-button secondary">ä¸Šä¼ </button>
                        <button id="add-postcard-image-url-btn" class="settings-button secondary">æ·»åŠ URL</button>
                    </div>
                    <input type="file" id="postcard-image-file-input" accept="image/*" style="display:none;">
                </div>
                 <div class="form-group">
                    <label>ç§°å‘¼</label>
                    <input type="text" id="edit-postcard-salutation">
                </div>
                <div class="form-group">
                    <label>å¯„ä¿¡äºº</label>
                    <div id="postcard-author-selector" class="author-selector-grid"></div>
                </div>
                <div class="form-group">
                    <label>å†…å®¹</label>
                    <textarea id="edit-postcard-body" class="wide-textarea" rows="4"></textarea>
                </div>
                <div class="form-group">
                    <label>è½æ¬¾</label>
                    <input type="text" id="edit-postcard-signature">
                </div>
                <div class="form-group">
                    <label>åœ°ç‚¹</label>
                    <input type="text" id="edit-postcard-location">
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-edit-postcard-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="save-postcard-btn" class="confirm-btn">ä¿å­˜</button>
            </div>
        </div>
    </div>
        <!-- æ–°å¢ï¼šæ‹†æ˜ä¿¡ç‰‡ä¸é˜…è¯»å™¨ -->
    <div id="unread-postcard-prompt">
        <div class="postcard-icon"><i class="fa-solid fa-camera-retro"></i></div>
    </div>
    <div id="postcard-viewer">
        <button class="postcard-close-btn">&times;</button>
        <div class="postcard-card-full">
            <div class="postcard-image-section">
                <img src="" alt="æ˜ä¿¡ç‰‡é£æ™¯">
            </div>
            <div class="postcard-content-section">
                <div class="postcard-text-area">
                    <div class="postcard-salutation"></div>
                    <div class="postcard-body"></div>
                </div>
                <div class="postcard-signature-area">
                    <div class="postcard-signature"></div>
                    <div class="postcard-location"></div>
                    <div class="postcard-timestamp"></div>
                    <div class="postcard-stamp"></div>
                    <!-- æ–°å¢ï¼šå›ä¿¡æŒ‰é’® -->
                    <button class="postcard-reply-btn" title="å›ä¿¡"><i class="fa-solid fa-pen-nib"></i></button>
                </div>
            </div>
        </div>
        <div class="postcard-gift-area" style="display: none;">
            <i class="fa-solid fa-gift"></i>
            <span>æ”¶åˆ°ä¸€ä»½å°ç¤¼ç‰©ï¼š</span>
            <strong class="postcard-gift-name"></strong>
        </div>
    </div>
    <!-- è§†é¢‘é€šè¯å¼¹çª— -->
<div id="video-call-modal" class="modal-overlay" style="z-index: 200; background-color: transparent;">
    <div id="video-call-main-view"></div>
    <div id="video-call-pip-view"></div> <!-- Note: This is now for the user in single calls -->
    <div class="video-call-content">
        <div class="video-call-header">
            <button id="video-call-minimize-btn" title="æœ€å°åŒ–"><i class="fa-solid fa-caret-down"></i></button>
            <!-- å•èŠæ—¶ä½¿ç”¨ -->
            <div class="video-call-char-info" id="video-call-single-char-info" style="display: none;">
                <img id="video-call-avatar" class="video-call-avatar-img">
                <div id="video-call-name" class="video-call-name-text"></div>
            </div>
            <!-- ç¾¤èŠæ—¶ä½¿ç”¨ -->
            <div id="video-call-participants-container" style="display: none;">
                <!-- Participant avatars will be dynamically inserted here -->
            </div>
        </div>
        <div id="video-call-messages" class="video-call-message-box">
            <!-- Video chat messages will appear here -->
        </div>
        <div class="video-call-footer">
            <div class="video-call-controls">
                            <div class="video-call-button-placeholder">
                <button id="video-call-switch-camera-btn" class="video-call-icon-btn" style="font-size: 28px;"><i class="fa-solid fa-camera-rotate"></i></button>
                    <span>åˆ‡æ¢é•œå¤´</span>
                </div>
                <div class="video-call-button-placeholder">
                    <button id="video-call-hangup-btn" class="video-call-icon-btn hangup" style="font-size: 28px;"><i class="fa-solid fa-phone-slash"></i></button>
                    <span>æŒ‚æ–­</span>
                </div>
            </div>
            <div class="video-call-input-area">
                 <button id="video-call-speak-btn" class="video-call-speak-btn"><i class="fa-solid fa-microphone-lines"></i></button>
<div id="video-call-input-wrapper" style="display: none;">
                     <button id="video-call-refresh-btn" title="åˆ·æ–°å›å¤"><i class="fa-solid fa-rotate"></i></button>
                     <input type="text" id="video-call-input" placeholder="è¾“å…¥å†…å®¹...">
                     <button id="video-call-send-btn"><i class="fa-solid fa-paper-plane"></i></button>
                 </div>
            </div>
        </div>
    </div>
</div>
<!-- Floating Video Button -->
    <div id="floating-video-btn"></div>
    <!-- æ–°å¢ï¼šå¥½å‹ç”³è¯·å¼¹çª— -->
<div id="friend-request-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-title">å¥½å‹ç”³è¯·</h3>
        <div class="modal-body">
            <textarea id="friend-request-reason" class="wide-textarea" rows="4" placeholder="è¾“å…¥ç”³è¯·ç†ç”±..."></textarea>
        </div>
        <div class="modal-actions row">
            <button id="cancel-friend-request-btn" class="cancel-btn">å–æ¶ˆ</button>
            <button id="send-friend-request-btn" class="confirm-btn">å‘é€</button>
        </div>
    </div>
</div>
<!-- æ–°å¢ï¼šCharå‘æ¥çš„å¥½å‹ç”³è¯·å¼¹çª— -->
<div id="char-friend-request-modal" class="modal-overlay">
    <div class="modal-content" style="position: relative;">
        <button id="char-fr-close-btn" class="photo-viewer-close-btn" style="color: #888; top: 15px; right: 15px;">&times;</button>
        <div id="char-fr-avatar" class="modal-avatar-preview"></div>
        <h3 class="modal-title" id="char-fr-name">å¥½å‹ç”³è¯·</h3>
        <div class="modal-body">
            <p id="char-fr-reason" style="text-align: center; white-space: pre-wrap; line-height: 1.6; max-height: 25vh; overflow-y: auto;"></p>
            <div id="char-fr-rejection-area" style="display: none; margin-top: 15px;">
                <textarea id="char-fr-rejection-reason" class="wide-textarea" rows="2" placeholder="è¾“å…¥æ‹’ç»ç†ç”± (å¯é€‰)"></textarea>
            </div>
        </div>
        <div id="char-fr-history" class="fr-history-container"></div>
        <div id="char-fr-initial-actions" class="modal-actions row">
            <button id="char-fr-reject-btn" class="cancel-btn">æ‹’ç»</button>
            <button id="char-fr-agree-btn" class="confirm-btn">åŒæ„</button>
        </div>
        <div id="char-fr-rejection-actions" class="modal-actions row" style="display: none; margin-top: 10px;">
            <button id="char-fr-rejection-cancel-btn" class="cancel-btn">å–æ¶ˆ</button>
            <button id="char-fr-rejection-send-btn" class="confirm-btn">å‘é€</button>
        </div>
    </div>
</div>
<!-- å£çº¸é•¿æŒ‰èœå• -->
 <!-- æ–°å¢ï¼šæƒ…ä¹¦ç¼–è¾‘/å›ä¿¡å¼¹çª— -->
        <div id="edit-love-letter-modal" class="modal-overlay">
            <div class="modal-content">
                <h3 class="modal-title" id="edit-love-letter-title">ç¼–è¾‘æƒ…ä¹¦</h3>
                <div class="modal-body">
                    <input type="hidden" id="editing-letter-id">
                    <input type="hidden" id="letter-reply-to-id">
                    <div class="form-group">
                    <label id="letter-recipient-label">ç§°å‘¼</label>
                    <input type="text" id="letter-recipient-input" placeholder="äº²çˆ±çš„...">
                </div>
                     <div class="form-group">
                        <label>å¯„ä¿¡äºº</label>
                        <div id="letter-author-selector" class="author-selector-grid"></div>
                    </div>
                    <div class="form-group">
                        <label for="letter-subject-input">æ ‡é¢˜</label>
                        <input type="text" id="letter-subject-input" placeholder="ç»™è¿™å°ä¿¡èµ·ä¸ªæ ‡é¢˜å§">
                    </div>
                    <div class="form-group">
                        <label for="letter-body-input">å†…å®¹</label>
                        <textarea id="letter-body-input" class="wide-textarea" rows="6" placeholder="æ­£æ–‡..."></textarea>
                    </div>
                     <div class="form-group">
                        <label for="letter-signature-input">è½æ¬¾</label>
                        <input type="text" id="letter-signature-input" placeholder="From:">
                    </div>
                </div>
                <div class="modal-actions row">
                    <button id="cancel-edit-love-letter-btn" class="cancel-btn">å–æ¶ˆ</button>
                    <button id="save-love-letter-btn" class="confirm-btn">ä¿å­˜</button>
                </div>
            </div>
        </div>
<div id="wallpaper-context-menu" style="display: none;">
<button class="context-menu-btn" id="wp-set-wallpaper">è®¾ä¸ºå£çº¸</button>
<button class="context-menu-btn" id="wp-set-chat-bg">è®¾ä¸ºå…¨å±€èƒŒæ™¯</button>
<button class="context-menu-btn danger" id="wp-delete">åˆ é™¤</button>
</div>
<!-- æ–°å¢ï¼šä¿¡çº¸æ ·å¼è®¾ç½®å¼¹çª— -->
<div id="mail-settings-modal" class="modal-overlay">
<div class="modal-content library-modal">
<h3 class="modal-title">ä¿¡çº¸æ ·å¼</h3>
<div class="modal-body">
<div id="love-letter-style-grid" class="library-grid"></div>
<div class="settings-group" style="margin-top: 20px;">
    <div class="group-title-wrapper" style="padding: 0 5px;">
        <div class="group-title">æƒ…ä¹¦ä¸»åŠ¨å‘é€è®¾ç½®</div>
        <button id="love-letter-select-all-btn" class="settings-button secondary" style="width: auto; padding: 5px 10px; font-size: 14px;">å…¨é€‰/å…¨ä¸é€‰</button>
    </div>
    <div class="group-content">
            <div id="love-letter-char-selector" class="author-selector-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); max-height: 150px; overflow-y: auto; padding: 10px;">
        <!-- Char items will be injected here -->
    </div>
    </div>
</div>
</div>
<div class="modal-actions">
<button id="mail-settings-close-btn" class="cancel-btn">å…³é—­</button>
<button id="mail-settings-mode-toggle-btn" class="cancel-btn">åˆ é™¤</button>
<button id="mail-settings-delete-btn" class="danger-btn" style="display:none;">ç¡®è®¤åˆ é™¤</button>
</div>
</div>
</div>
</div>
    <!-- èƒŒæ™¯é€‰é¡¹ä¸Šä¸‹æ–‡èœå• -->
    <div id="background-context-menu" style="display: none;">
        <button class="context-menu-btn" id="bg-menu-chat-bg">èŠå¤©èƒŒæ™¯</button>
        <button class="context-menu-btn" id="bg-menu-video-bg">è§†é¢‘èƒŒæ™¯</button>
    </div>
    <!-- æ–°å¢ï¼šç¼–è¾‘æ ·å¼å¼¹çª— -->
<div id="edit-style-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-title">ç¼–è¾‘æ ·å¼</h3>
        <div class="modal-body">
            <input type="hidden" id="edit-style-id">
            <input type="hidden" id="edit-style-type">
            <div class="form-group">
                <label for="edit-style-name">æ ·å¼åç§°</label>
                <input type="text" id="edit-style-name">
            </div>
            <div id="edit-style-content-wrapper">
                <!-- Content textareas will be injected here by JS -->
            </div>
        </div>
        <div class="modal-actions row">
            <button id="cancel-edit-style-btn" class="cancel-btn">å–æ¶ˆ</button>
            <button id="save-edit-style-btn" class="confirm-btn">ä¿å­˜</button>
        </div>
    </div>
</div>
<input type="file" id="import-style-file-input" style="display: none;" accept=".json">
    <div id="toast"></div>
    <!-- æ–°å¢ï¼šè½¬å‘æ¶ˆæ¯å¼¹çª— -->
<div id="forward-message-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-title">è½¬å‘ç»™</h3>
        <div class="modal-body" id="forward-contact-list" style="max-height: 60vh; overflow-y: auto;">
            <!-- Contact list will be rendered here by JS -->
        </div>
        <div class="modal-actions">
            <button id="cancel-forward-message-btn" class="cancel-btn">å–æ¶ˆ</button>
        </div>
    </div>
</div>
<!-- æ–°å¢ï¼šæŸ¥çœ‹è½¬å‘è®°å½•å¼¹çª— -->
<div id="view-forwarded-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-title" id="view-forwarded-title">èŠå¤©è®°å½•</h3>
        <div class="modal-body" id="view-forwarded-content" style="max-height: 70vh; overflow-y: auto; background-color: #f0f2f5; padding: 10px; border-radius: 8px;">
            <!-- Forwarded messages will be rendered here by JS -->
        </div>
        <div class="modal-actions">
            <button id="close-view-forwarded-btn" class="cancel-btn">å…³é—­</button>
        </div>
    </div>
</div>
<!-- æ–°å¢ï¼šå¾®åšè½¬å‘å¼¹çª— -->
<div id="repost-weibo-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-title">è½¬å‘å¾®åš</h3>
        <div class="modal-body">
            <textarea id="repost-weibo-content" class="wide-textarea" rows="4" placeholder="è¯´è¯´åˆ†äº«å¿ƒå¾—..."></textarea>
            <div id="repost-weibo-preview" class="post-forwarded-content" style="cursor: default;"></div>
        </div>
        <div class="modal-actions row">
            <button id="cancel-repost-weibo-btn" class="cancel-btn">å–æ¶ˆ</button>
            <button id="confirm-repost-weibo-btn" class="confirm-btn">è½¬å‘</button>
        </div>
    </div>
</div>
<!-- æ–°å¢ï¼šå‘å¸ƒå¾®åšå¼¹çª— -->
<div id="post-weibo-modal" class="modal-overlay">
<div class="modal-content">
<h3 class="modal-title" id="post-weibo-modal-title">å‘å¾®åš</h3>
<div class="modal-body" id="post-weibo-modal-body">
<input type="hidden" id="editing-weibo-post-id">
<div class="form-group" id="weibo-post-author-selector-group" style="display: none;">
<label>å‘å¸ƒè€…</label>
<div id="weibo-post-author-selector"></div>
</div>
<div class="form-group">
<label>ç±»å‹</label>
<div class="radio-group" id="post-weibo-status-type">
<label class="radio-label"><input type="radio" name="weibo-status-type" value="text" checked><span>æ–‡å­—</span></label>
<label class="radio-label"><input type="radio" name="weibo-status-type" value="image"><span>å›¾ç‰‡</span></label>
<label class="radio-label"><input type="radio" name="weibo-status-type" value="text-image"><span>æ–‡å­—å›¾</span></label>
</div>
</div>
<div class="form-group hidden-by-logic" id="post-weibo-image-buttons">
<div class="button-group">
<button id="post-weibo-upload-btn" class="settings-button secondary">ä¸Šä¼ </button>
<button id="post-weibo-add-url-btn" class="settings-button secondary">æ·»åŠ URL</button>
</div>
<input type="file" id="post-weibo-image-input" accept="image/*" style="display:none;" multiple>
</div>
<div class="form-group hidden-by-logic" id="post-weibo-text-image-input">
<label>å›¾ç‰‡æè¿°</label>
<textarea id="post-weibo-text-image-desc" class="wide-textarea" rows="2" placeholder="AIå°†æ ¹æ®ä½ çš„æè¿°ç”Ÿæˆå›¾ç‰‡..."></textarea>
</div>
<div class="form-group">
<label>å†…å®¹</label>
<textarea id="post-weibo-status-content" class="wide-textarea" rows="4" placeholder="æœ‰ä»€ä¹ˆæ–°é²œäº‹æƒ³å‘Šè¯‰å¤§å®¶..."></textarea>
</div>
            <div class="form-group">
                <label for="post-weibo-topic-input">è¯é¢˜</label>
                <input type="text" id="post-weibo-topic-input" class="uniform-input-box" placeholder="ä¾‹å¦‚ï¼š#ä»Šå¤©å¤©æ°”å¾ˆå¥½#">
            </div>
            <hr>
            <div class="form-group" id="weibo-visibility-options">
                <label class="checkbox-label tick-style">
                    <input type="checkbox" id="weibo-visibility-friends" name="weibo-visibility" value="friends">
                    <span>å¥½å‹å¯è§</span>
                </label>
                <label class="checkbox-label tick-style">
                    <input type="checkbox" id="weibo-visibility-private" name="weibo-visibility" value="private">
                    <span>ç§å¯†</span>
                </label>
            </div>
</div>
<div class="modal-actions row">
<button id="cancel-post-weibo-btn" class="cancel-btn">å–æ¶ˆ</button>
<button id="confirm-post-weibo-btn" class="confirm-btn">å‘å¸ƒ</button>
</div>
</div>
</div>
<!-- æ–°å¢ï¼šå¾®åšè¯„è®ºç¼–è¾‘å¼¹çª— -->
<div id="edit-weibo-comment-modal" class="modal-overlay">
<div class="modal-content">
<h3 class="modal-title">ç¼–è¾‘è¯„è®º</h3>
<div class="modal-body">
<div class="form-group">
<label>è¯„è®ºè€…</label>
<div id="weibo-comment-author-selector"></div>
</div>
<div class="form-group">
<label>è¯„è®ºå†…å®¹</label>
<textarea id="edit-weibo-comment-content" class="wide-textarea" rows="4"></textarea>
</div>
</div>
<div class="modal-actions row">
<button id="cancel-edit-weibo-comment-btn" class="cancel-btn">å–æ¶ˆ</button>
<button id="save-edit-weibo-comment-btn" class="confirm-btn">ä¿å­˜</button>
</div>
</div>
</div>
<!-- æ–°å¢ï¼šå¾®åšè§’è‰²é€‰æ‹©å¼¹çª— -->
<div id="weibo-char-selector-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-title">é€‰æ‹©è§’è‰²</h3>
        <div class="modal-body">
            <div id="weibo-char-selector-grid" class="author-selector-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));">
                <!-- Character items will be injected here -->
            </div>
        </div>
        <div class="modal-actions row">
            <button id="close-weibo-char-selector-btn" class="cancel-btn">å…³é—­</button>
            <button id="confirm-weibo-char-selector-btn" class="confirm-btn">é€‰æ‹©</button>
        </div>
    </div>
</div>
    <!-- æ–°å¢ï¼šå¾®åšä¸ªäººèµ„æ–™ç¼–è¾‘å¼¹çª— -->
    <div id="edit-weibo-profile-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">ç¼–è¾‘ä¸ªäººèµ„æ–™</h3>
            <div class="modal-body">
                <input type="hidden" id="editing-weibo-profile-id">
                <div class="form-group">
                    <label for="weibo-bio-input">ç®€ä»‹</label>
                    <input type="text" id="weibo-bio-input" class="uniform-input-box" placeholder="ä¸€å¥è¯ä»‹ç»ä½ è‡ªå·±">
                </div>
                <div class="form-group">
                    <label for="weibo-persona-input">äººè®¾ (å…¬ä¼—å½¢è±¡)</label>
                    <textarea id="weibo-persona-input" class="wide-textarea" rows="5" placeholder="è¿™éƒ¨åˆ†å†…å®¹ä¸ä¼šå…¬å¼€å±•ç¤ºï¼Œä»…å½±å“éšæœºNPCå¯¹ä½ çš„åŸºæœ¬è®¤çŸ¥å’Œäº’åŠ¨æ–¹å¼ã€‚ä¾‹å¦‚ï¼šä¸€ä½å°æœ‰åæ°”çš„ç‹¬ç«‹æ­Œæ‰‹ï¼›åˆšè€ƒä¸Šæ¸…åçš„å­¦éœ¸ï¼›æ™®é€šçš„ç¤¾ç•œä¸Šç­æ—ã€‚"></textarea>
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-edit-weibo-profile-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="save-weibo-profile-btn" class="confirm-btn">ä¿å­˜</button>
            </div>
        </div>
    </div>
    <!-- æ–°å¢ï¼šå±•å…ç¤¼ç‰©æŸ¥çœ‹å™¨ -->
    <div id="gift-viewer-modal" class="modal-overlay" style="background-color: rgba(0,0,0,0.8); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); z-index: 230;">
        <button id="gift-viewer-close-btn" class="postcard-close-btn">&times;</button>
        <div id="gift-viewer-content" style="background-color: var(--item-bg); color: var(--primary-text-color); border-radius: 12px; padding: 30px; width: 90%; max-width: 400px; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 15px;">
            <div id="gift-viewer-icon" style="font-size: 80px; color: var(--owner-title-bg);"><i class="fa-solid fa-gift"></i></div>
            <h3 id="gift-viewer-name" style="font-size: 22px; margin: 0;"></h3>
            <p id="gift-viewer-description" style="font-size: 16px; line-height: 1.7; min-height: 4.5em; color: var(--secondary-text-color);"></p>
            <div id="gift-viewer-sender" style="display: flex; align-items: center; gap: 10px; margin-top: 10px;">
                <div id="gift-viewer-avatar" style="width: 40px; height: 40px; border-radius: 50%; background-size: cover; background-position: center;"></div>
                <div style="text-align: left;">
                    <div id="gift-viewer-sender-name" style="font-weight: 500;"></div>
                    <div id="gift-viewer-timestamp" style="font-size: 12px; color: var(--secondary-text-color);"></div>
                </div>
            </div>
        </div>
    </div>
    <!-- æ–°å¢ï¼šå¨±ä¹-è¿åŠ¿è®¾ç½®å¼¹çª— -->
<div id="fortune-settings-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-title">è¿åŠ¿è®¾ç½®</h3>
        <div class="modal-body">
                    <div class="form-group">
            <label>è¯·é€‰æ‹©å åœç±»å‹</label>
            <div id="fortune-type-selector" class="radio-group">
                <label class="radio-label"><input type="radio" name="fortune-type" value="divination" checked><span>å åœ</span></label>
                <label class="radio-label"><input type="radio" name="fortune-type" value="horoscope"><span>æ˜Ÿåº§</span></label>
                <label class="radio-label"><input type="radio" name="fortune-type" value="tarot"><span>å¡”ç½—</span></label>
            </div>
        </div>
        <div class="form-group" id="divination-question-container">
            <label for="divination-question-input">è¾“å…¥æ‚¨æƒ³å åœçš„å†…å®¹</label>
            <textarea id="divination-question-input" class="wide-textarea" rows="3" placeholder="ä¾‹å¦‚ï¼šæˆ‘è¿‘æœŸçš„æ¡ƒèŠ±è¿å¦‚ä½•ï¼Ÿ"></textarea>
                </div>
        <div class="form-group" id="tarot-question-container" style="display: none;">
            <label for="tarot-question-input">è¾“å…¥æ‚¨æƒ³å åœçš„å†…å®¹ (å¡”ç½—)</label>
            <textarea id="tarot-question-input" class="wide-textarea" rows="3" placeholder="ä¾‹å¦‚ï¼šæˆ‘ä»¬æœªæ¥çš„æ„Ÿæƒ…å‘å±•ä¼šæ€æ ·ï¼Ÿ"></textarea>
                </div>
    <div class="form-group" id="horoscope-question-container" style="display: none;">
                <div class="form-group">
            <label for="horoscope-sign-select">è¯·é€‰æ‹©æ‚¨çš„æ˜Ÿåº§</label>
            <select id="horoscope-sign-select">
                <option value="ç™½ç¾Šåº§">ç™½ç¾Šåº§ (Aries)</option>
                <option value="é‡‘ç‰›åº§">é‡‘ç‰›åº§ (Taurus)</option>
                <option value="åŒå­åº§">åŒå­åº§ (Gemini)</option>
                <option value="å·¨èŸ¹åº§">å·¨èŸ¹åº§ (Cancer)</option>
                <option value="ç‹®å­åº§">ç‹®å­åº§ (Leo)</option>
                <option value="å¤„å¥³åº§">å¤„å¥³åº§ (Virgo)</option>
                <option value="å¤©ç§¤åº§">å¤©ç§¤åº§ (Libra)</option>
                <option value="å¤©èåº§">å¤©èåº§ (Scorpio)</option>
                <option value="å°„æ‰‹åº§">å°„æ‰‹åº§ (Sagittarius)</option>
                <option value="æ‘©ç¾¯åº§">æ‘©ç¾¯åº§ (Capricorn)</option>
                <option value="æ°´ç“¶åº§">æ°´ç“¶åº§ (Aquarius)</option>
                <option value="åŒé±¼åº§">åŒé±¼åº§ (Pisces)</option>
            </select>
        </div>
        <label for="horoscope-question-input">è¾“å…¥æ‚¨æƒ³å åœçš„å†…å®¹ (æ˜Ÿåº§)</label>
        <textarea id="horoscope-question-input" class="wide-textarea" rows="3" placeholder="ä¾‹å¦‚ï¼šæˆ‘ä»Šå¤©çš„è´¢è¿æ€ä¹ˆæ ·ï¼Ÿ"></textarea>
        </div>
        </div>
        <div class="modal-actions row">
            <button id="confirm-fortune-settings-btn" class="confirm-btn">ç¡®è®¤</button>
                        <button id="close-fortune-settings-btn" class="cancel-btn">å…³é—­</button>

        </div>
    </div>
</div>
    <!-- æ–°å¢ï¼šçºªå¿µæ—¥è¯¦æƒ…æŸ¥çœ‹å¼¹çª— -->
<div id="anniversary-details-modal" class="modal-overlay" style="z-index: 280;">
    <div class="modal-content">
        <h3 class="modal-title" id="anniversary-details-title">çºªå¿µæ—¥è¯¦æƒ…</h3>
        <div class="modal-body">
            <ul id="anniversary-details-list" style="list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 10px;">
                <!-- Details will be injected here -->
            </ul>
        </div>
        <div class="modal-actions">
            <button id="close-anniversary-details-btn" class="cancel-btn">å…³é—­</button>
        </div>
    </div>
</div>
        <!-- æ–°å¢ï¼šå±•å…ç¤¼ç‰©ç¼–è¾‘å¼¹çª— -->
             <!-- æ–°å¢ï¼šçºªå¿µæ—¥ç¼–è¾‘/æ·»åŠ å¼¹çª— -->
    <div id="anniversary-modal" class="modal-overlay" style="z-index: 260;">
        <div class="modal-content">
            <h3 class="modal-title" id="anniversary-modal-title">æ·»åŠ çºªå¿µæ—¥</h3>
            <div class="modal-body">
                <input type="hidden" id="editing-anniversary-id">
                <div class="form-group">
                    <label for="anniversary-date-input">æ—¥æœŸ</label>
                    <input type="date" id="anniversary-date-input">
                </div>
                <div class="form-group">
                    <label for="anniversary-name-input">åç§°</label>
                    <input type="text" id="anniversary-name-input" placeholder="ä¾‹å¦‚ï¼šæˆ‘ä»¬çš„ç¬¬ä¸€æ¬¡çº¦ä¼š">
                </div>
                                        <div class="form-group">
                <label for="anniversary-char-selector">å…³è”è§’è‰² (å¯å¤šé€‰)</label>
                <div id="anniversary-char-selector" class="friend-selector-grid"></div>
            </div>
                <div class="form-group">
                    <label class="checkbox-label tick-style">
                        <input type="checkbox" id="anniversary-special-checkbox">
                        <span>è®¾ä¸ºç‰¹æ®Šçºªå¿µæ—¥ (çº¢è‰²é«˜äº®)</span>
                    </label>
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-anniversary-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="save-anniversary-btn" class="confirm-btn">ä¿å­˜</button>
            </div>
        </div>
    </div>
    <!-- æ–°å¢ï¼šçºªå¿µæ—¥ç®¡ç†ï¼ˆé€‰æ‹©/åˆ é™¤ï¼‰å¼¹çª— -->
<div id="anniversary-management-modal" class="modal-overlay" style="z-index: 270;">
    <div class="modal-content">
        <h3 class="modal-title" id="anniversary-management-title">ç®¡ç†çºªå¿µæ—¥</h3>
        <div class="modal-body">
            <p id="anniversary-management-prompt" style="font-size: 14px; color: var(--secondary-text-color); text-align: center; margin-top: 0;"></p>
            <div id="anniversary-management-list" class="checkbox-list" style="flex-direction: column; align-items: stretch; gap: 0;">
                <!-- Anniversaries will be injected here -->
            </div>
        </div>
        <div class="modal-actions row">
            <button id="cancel-anniversary-management-btn" class="cancel-btn">å–æ¶ˆ</button>
            <button id="confirm-anniversary-management-btn" class="confirm-btn">ç¡®è®¤</button>
        </div>
    </div>
</div>
    <div id="edit-gift-modal" class="modal-overlay" style="z-index: 240;">
        <div class="modal-content">
            <h3 class="modal-title">ç¼–è¾‘ç¤¼ç‰©ä¿¡æ¯</h3>
            <div class="modal-body">
                <input type="hidden" id="editing-gift-postcard-id">
                <div class="form-group">
                    <label for="edit-gift-name">ç¤¼ç‰©åç§°</label>
                    <input type="text" id="edit-gift-name">
                </div>
                <div class="form-group">
                    <label for="edit-gift-description">ç¤¼ç‰©æè¿°</label>
                    <textarea id="edit-gift-description" class="wide-textarea" rows="4"></textarea>
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-edit-gift-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="save-edit-gift-btn" class="confirm-btn">ä¿å­˜</button>
            </div>
        </div>
    </div>
        <!-- æ–°å¢ï¼šè‚¡ç¥¨äº¤æ˜“å¼¹çª— -->
    <div id="stock-trade-modal" class="modal-overlay" style="z-index: 250;">
        <div class="modal-content" style="max-width: 400px;">
            <h3 class="modal-title" id="stock-trade-title"></h3>
        <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
                <div class="stock-trade-info" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color);">
                    <div>
                        <div id="stock-trade-price" style="font-size: 24px; font-weight: bold;">Â¥ 0.00</div>
                        <div id="stock-trade-change" style="font-size: 14px;">+0.00 (+0.00%)</div>
                    </div>
                    <div id="stock-trade-chart" style="width: 120px; height: 40px; display: flex; align-items: flex-end; gap: 2px;"></div>
                </div>

                <div class="modal-tabs">
                    <button class="tab-btn active" data-tab="buy">ä¹°å…¥</button>
                    <button class="tab-btn" data-tab="sell">å–å‡º</button>
                </div>

                <div id="stock-trade-buy-content" class="modal-tab-content active">
                    <div class="form-group">
                        <label>å¯ä¹°è‚¡æ•°: <span id="stock-buy-max-shares">0</span></label>
                        <input type="number" id="stock-buy-shares-input" class="uniform-input-box" placeholder="è¾“å…¥è´­ä¹°æ•°é‡">
                    </div>
                    <p style="text-align: right; font-size: 14px;">é¢„è®¡èŠ±è´¹: <span id="stock-buy-total-cost">Â¥ 0.00</span></p>
                    <button id="confirm-buy-stock-btn" class="settings-button confirm-btn" style="margin-top: 10px;">ç¡®è®¤ä¹°å…¥</button>
                </div>

                <div id="stock-trade-sell-content" class="modal-tab-content">
                     <div class="form-group">
                        <label>å¯å–è‚¡æ•°: <span id="stock-sell-max-shares">0</span></label>
                        <input type="number" id="stock-sell-shares-input" class="uniform-input-box" placeholder="è¾“å…¥å–å‡ºæ•°é‡">
                    </div>
                    <p style="text-align: right; font-size: 14px;">é¢„è®¡æ”¶å…¥: <span id="stock-sell-total-proceeds">Â¥ 0.00</span></p>
                    <button id="confirm-sell-stock-btn" class="settings-button danger-btn" style="margin-top: 10px;">ç¡®è®¤å–å‡º</button>
                </div>

                <div class="portfolio-summary" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border-color); font-size: 12px; color: var(--secondary-text-color);">
                <p>å½“å‰æŒä»“: <span id="stock-trade-current-shares" style="font-weight: bold;">0 è‚¡</span> (æˆæœ¬: <span id="stock-trade-avg-cost">Â¥ 0.00</span>)</p>
            </div>

            <div class="stock-news-feed" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border-color);">
                <h4 style="margin-top: 0; margin-bottom: 10px; font-size: 14px; color: var(--secondary-text-color);">è‚¡å¸‚å¿«è®¯</h4>
                <ul id="stock-trade-news-list" style="list-style: none; padding: 0; margin: 0; font-size: 12px; line-height: 1.6; color: #555; display: flex; flex-direction: column; gap: 8px;">
                    <!-- News items will be injected here -->
                </ul>
            </div>
            </div>

            <div class="modal-actions">
                <button id="close-stock-trade-modal-btn" class="cancel-btn">å…³é—­</button>
            </div>
        </div>
    </div>
    <!-- æ–°å¢ï¼šè‚¡ç¥¨ç¼–è¾‘å¼¹çª— -->
<div id="edit-stock-modal" class="modal-overlay" style="z-index: 260;">
    <div class="modal-content">
        <h3 class="modal-title">ç¼–è¾‘è‚¡ç¥¨ä¿¡æ¯</h3>
        <div class="modal-body">
            <input type="hidden" id="editing-stock-id">
            <div class="form-group">
                <label for="stock-name-input">è‚¡ç¥¨åç§°</label>
                <input type="text" id="stock-name-input">
            </div>
            <div class="form-group">
                <label for="stock-ticker-input">è‚¡ç¥¨ä»£ç  (4ä¸ªå¤§å†™å­—æ¯)</label>
                <input type="text" id="stock-ticker-input" maxlength="4" style="text-transform: uppercase;">
            </div>
        </div>
        <div class="modal-actions row">
            <button id="cancel-edit-stock-btn" class="cancel-btn">å–æ¶ˆ</button>
            <button id="save-stock-btn" class="confirm-btn">ä¿å­˜</button>
        </div>
    </div>
</div>
<!-- æ–°å¢ï¼šè®°å¿†è§’è‰²é€‰æ‹©å¼¹çª— -->
<div id="memory-char-selector-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-title">é€‰æ‹©è§’è‰²</h3>
        <div class="modal-body">
            <div id="memory-char-selector-grid" class="author-selector-grid">
                <!-- Character items will be injected here -->
            </div>
        </div>
        <div class="modal-actions row">
            <button id="close-memory-char-selector-btn" class="cancel-btn">å…³é—­</button>
            <button id="confirm-memory-char-selector-btn" class="confirm-btn">é€‰æ‹©</button>
        </div>
    </div>
</div>
<!-- æ–°å¢ï¼šè®°å¿†å•å…ƒæ ¼ç¼–è¾‘å¼¹çª— -->
<div id="edit-memory-cell-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 class="modal-title">ç¼–è¾‘è®°å¿†</h3>
        <div class="modal-body">
            <input type="hidden" id="editing-memory-char-id">
            <input type="hidden" id="editing-memory-row-index">
            <input type="hidden" id="editing-memory-field">
            <div class="form-group">
                <label for="memory-cell-editor-label" id="memory-cell-editor-label">å†…å®¹</label>
                <textarea id="memory-cell-editor-input" class="wide-textarea" rows="4"></textarea>
            </div>
        </div>
        <div class="modal-actions row">
            <button id="cancel-edit-memory-cell-btn" class="cancel-btn">å–æ¶ˆ</button>
            <button id="save-memory-cell-btn" class="confirm-btn">ä¿å­˜</button>
        </div>
    </div>
</div>
<script>

document.addEventListener('DOMContentLoaded', () => {
        // --- å…¨å±€æ‡’åŠ è½½ç›‘è§†å™¨ (æ–°å¢) ---
    const lazyLoadObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const element = entry.target;
                const src = element.dataset.src;
                if (src) {
                    // ä»…ä¸ºèƒŒæ™¯å›¾ç‰‡è®¾ç½®
                    element.style.backgroundImage = `url("${src}")`;
                }
                observer.unobserve(element); // åŠ è½½ååœæ­¢ç›‘è§†
            }
        });
    });

    const lazyLoadElement = (element) => {
        lazyLoadObserver.observe(element);
    };
    // --- å…¨å±€ DOM å…ƒç´ è·å– ---
    const getEl = (id) => document.getElementById(id);
    const query = (selector) => document.querySelector(selector);
    const queryAll = (selector) => document.querySelectorAll(selector);
        const newId = (prefix) => `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        function formatNumber(num) { if (isNaN(num) || num === null) return 0; if (num < 10000) { return num.toString(); } const tenThousand = num / 10000; return tenThousand.toFixed(1).replace(/\.0$/, '') + 'ä¸‡'; }
        // --- åŸºç¡€ UI ---
    const timeEl = getEl('time');
    const batteryLevelEl = getEl('battery-level');
    const batteryIconEl = getEl('battery-icon');
    const toastEl = getEl('toast');
    const phoneScreen = getEl('phone-screen');

    // --- çµåŠ¨å²› & é€šçŸ¥ ---
    const dynamicIsland = getEl('dynamic-island');
    const islandMusicInfo = query('.island-music-info');
    const islandWaveform = query('.island-waveform');
    const islandVideoIcon = query('.island-video-call-icon');
    const islandVideoTimer = query('.island-video-call-timer');
    const notificationContainer = getEl('notification-container');

    // --- APP å±å¹• ---
    const settingsAppScreen = getEl('settings-app-screen');
    const musicAppScreen = getEl('music-app-screen');
    const beautifyAppScreen = getEl('beautify-app-screen');
    const dataAppScreen = getEl('data-app-screen');
    const songDetailsScreen = getEl('song-details-screen');
    const chatAppScreen = getEl('chat-app-screen');
    const singleChatScreen = getEl('single-chat-screen');
    const chatSettingsScreen = getEl('chat-settings-screen');
    const groupChatSettingsScreen = getEl('group-chat-settings-screen');
    const viewAlbumScreen = getEl('view-album-screen');
    const charMomentsScreen = getEl('char-moments-screen');
    const mailAppScreen = getEl('mail-app-screen');
    const postcardFilterDropdown = getEl('postcard-filter-dropdown');
    const diaryAppScreen = getEl('diary-app-screen');
    const diaryFilterBtn = getEl('diary-filter-btn');
const secretFilterDropdown = getEl('secret-filter-dropdown');
const memorySettingsBtn = getEl('memory-settings-btn');
const memoryCharSelectorModal = getEl('memory-char-selector-modal');
const editMemoryCellModal = getEl('edit-memory-cell-modal');
const assetsAppScreen = getEl('assets-app-screen');
const shopAppScreen = getEl('shop-app-screen');
    const entertainmentAppScreen = getEl('entertainment-app-screen');
    const stockTradeModal = getEl('stock-trade-modal');
    const weiboAppScreen = getEl('weibo-app-screen');
    // --- è®¾ç½® APP ---
    const confirmApiBtn = getEl('confirm-api-btn');
    const modelSelect = getEl('model-select');
    const presetSelect = getEl('preset-select');
    const savePresetBtn = getEl('save-preset-btn');
    const managePresetsBtn = getEl('manage-presets-btn');
    const exportDataBtn = getEl('export-data-btn');
    const importDataBtn = getEl('import-data-btn');
    const importFileInput = getEl('import-file-input');
    const managePresetsModal = getEl('manage-presets-modal');
    const closeManageModalBtn = getEl('close-manage-modal-btn');
    const presetListEl = getEl('preset-list');
    const editPresetModal = getEl('edit-preset-modal');
    const editPresetIndexInput = getEl('edit-preset-index');
    const editPresetNameInput = getEl('edit-preset-name');
    const editPresetUrlInput = getEl('edit-preset-url');
    const editPresetKeyInput = getEl('edit-preset-key');
    const saveEditBtn = getEl('save-edit-btn');
    const cancelEditBtn = getEl('cancel-edit-btn');
    const globalRealtimeInterval = getEl('global-realtime-interval');
const globalRealtimeCharSelector = getEl('global-realtime-char-selector');
const globalRealtimeSelectAll = getEl('global-realtime-select-all');

    // --- éŸ³ä¹ APP & æ­Œæ›²è¯¦æƒ… ---
    const audioPlayer = getEl('audio-player');
    const musicListEl = getEl('music-list');
    const addMusicBtn = getEl('add-music-btn');
    const addMusicModal = getEl('add-music-modal');
    const cancelAddMusicBtn = getEl('cancel-add-music-btn');
    const confirmAddUrlBtn = getEl('confirm-add-url-btn');
    const musicFileInput = getEl('music-file-input');
    const uploadMusicBtn = getEl('upload-music-btn');
    const musicUrlInput = getEl('music-url-input');
    const editSongModal = getEl('edit-song-modal');
    const editSongIdInput = getEl('edit-song-id');
    const editSongTitleInput = getEl('edit-song-title');
    const editSongArtistInput = getEl('edit-song-artist');
    const saveEditSongBtn = getEl('save-edit-song-btn');
    const cancelEditSongBtn = getEl('cancel-edit-song-btn');
    const songDetailsBackBtn = getEl('song-details-back-btn');
    const detailsSongTitle = getEl('details-song-title');
    const detailsSongArtist = getEl('details-song-artist');
    const detailsLyricsView = getEl('details-lyrics-view');
    const detailsCommentsList = getEl('details-comments-list');
    const commentInput = getEl('comment-input');
    const sendCommentBtn = getEl('send-comment-btn');
    const editCommentModal = getEl('edit-comment-modal');
    const editCommentInput = getEl('edit-comment-input');
    const saveEditCommentBtn = getEl('save-edit-comment-btn');
    const cancelEditCommentBtn = getEl('cancel-edit-comment-btn');

    // --- æµ®åŠ¨æ­Œè¯ & æ’­æ”¾å™¨ ---
    const playerModal = getEl('player-modal');
    const hidePlayerBtn = getEl('hide-player-btn');
    const playerSongTitle = query('#player-modal .player-song-info .title');
    const playerSongArtist = query('#player-modal .player-song-info .artist');
    const listenTogetherInfo = getEl('listen-together-info');
    const listenTogetherText = getEl('listen-together-text');
    const togglePlaylistViewBtn = getEl('toggle-playlist-view-btn');
    const playerLyricsView = getEl('player-lyrics-view');
    const playerPlaylistViewContainer = getEl('player-playlist-view-container');
    const playerPlaylistView = query('.player-playlist-view');
    const restorePlaylistBtn = getEl('restore-playlist-btn');
    const progressBar = getEl('progress-bar');
    const playerPlayPauseBtn = getEl('player-play-pause-btn');
    const lyricsLineEl = getEl('lyrics-line');
    const playerPrevBtn = getEl('player-prev-btn');
    const playerNextBtn = getEl('player-next-btn');
    const playerPlaybackModeBtn = getEl('player-playback-mode-btn');
    const playIconSrc = '<i class="fa-solid fa-circle-play"></i>';
    const pauseIconSrc = '<i class="fa-solid fa-circle-pause"></i>';

    // --- ç¾åŒ– APP ---
    const beautifyActionBtn = getEl('beautify-action-btn');
    const bubbleActionBtn = getEl('bubble-action-btn');
    const beautifyTabs = query('#beautify-app-screen .app-bottom-tabs');
    const wallpaperGrid = getEl('wallpaper-grid');
    const wallpaperFileInput = getEl('wallpaper-file-input');
    const wallpaperContextMenu = getEl('wallpaper-context-menu');
    const fontListEl = getEl('font-list');
    const iconGrid = getEl('icon-grid');
    const bubbleGrid = getEl('bubble-grid');
    const addFontModal = getEl('add-font-modal');
    const uploadFontBtn = getEl('upload-font-btn');
    const fontFileInput = getEl('font-file-input');
    const fontUrlInput = getEl('font-url-input');
    const confirmAddFontUrlBtn = getEl('confirm-add-font-url-btn');
    const cancelAddFontBtn = getEl('cancel-add-font-btn');
    const replaceIconModal = getEl('replace-icon-modal');
    const replaceIconIdInput = getEl('replace-icon-id');
    const uploadIconBtn = getEl('upload-icon-btn');
    const iconFileInput = getEl('icon-file-input');
    const iconUrlInput = getEl('icon-url-input');
    const confirmReplaceIconUrlBtn = getEl('confirm-replace-icon-url-btn');
    const cancelReplaceIconBtn = getEl('cancel-replace-icon-btn');
    const restoreIconBtn = getEl('restore-icon-btn');

    // --- æ°”æ³¡ç¼–è¾‘å¼¹çª— ---
    const editBubbleModal = getEl('edit-bubble-modal');
    const editBubbleIdInput = getEl('edit-bubble-id');
    const bubbleWidthInput = getEl('bubble-width-input');
    const bubbleHeightInput = getEl('bubble-height-input');
    const bubblePosXInput = getEl('bubble-pos-x-input');
    const bubblePosYInput = getEl('bubble-pos-y-input');
    const bubbleColorInput = getEl('bubble-color-input');
    const bubbleBgColorInput = getEl('bubble-bg-color-input');
    const bubbleBorderColorInput = getEl('bubble-border-color-input');
    const bubblePreviewWrapper = getEl('bubble-preview-wrapper');
    const bubblePreview = getEl('bubble-preview');
    const replaceBgOnlyCheckbox = getEl('replace-bg-only-checkbox');
    const uploadBubbleBtn = getEl('upload-bubble-btn');
    const bubbleFileInput = getEl('bubble-file-input');
    const bubbleUrlInput = getEl('bubble-url-input');
    const saveBubbleBtn = getEl('save-bubble-btn');
    const restoreBubbleBtn = getEl('restore-bubble-btn');
    const cancelEditBubbleBtn = getEl('cancel-edit-bubble-btn');
    const bubbleIoModal = getEl('bubble-io-modal');
    const themeCssMoments = getEl('theme-css-moments');
const themeCssHeader = getEl('theme-css-header');
const themeCssTabs = getEl('theme-css-tabs');
const themeCssListItem = getEl('theme-css-list-item');
const themeApplyBtn = getEl('theme-apply-btn');
const themeRestoreBtn = getEl('theme-restore-btn');
    const exportBubblesBtn = getEl('export-bubbles-btn');
    const importBubblesBtn = getEl('import-bubbles-btn');
    const importBubblesInput = getEl('import-bubbles-input');
    const cancelBubbleIoBtn = getEl('cancel-bubble-io-btn');

    // --- èµ„æ–™ APP ---
    const dataAppTabs = query('#data-app-screen .app-bottom-tabs');
    const dataActionBtn = getEl('data-action-btn');
    const worldBookListEl = getEl('world-book-list');
    const archiveListEl = getEl('archive-list');
    const infoListEl = getEl('info-list');
    const dataModal = getEl('data-modal');
    const dataModalTitle = getEl('data-modal-title');
    const dataEditingIdInput = getEl('data-editing-id');
    const dataAvatarGroup = query('#data-modal .avatar-group');
    const dataAvatarPreview = getEl('data-avatar-preview');
    const dataUploadAvatarBtn = getEl('data-upload-avatar-btn');
    const dataAddAvatarUrlBtn = getEl('data-add-avatar-url-btn');
    const dataAvatarFileInput = getEl('data-avatar-file-input');
    const dataNameInput = getEl('data-name');
    const dataGroupInput = getEl('data-group');
    const dataContentInput = getEl('data-content');
    const dataGroupSelect = getEl('data-group-select');
    const saveDataBtn = getEl('save-data-btn');
    const cancelDataBtn = getEl('cancel-data-btn');
    const dataFilterBtn = getEl('data-filter-btn');
const worldBookFilterDropdown = getEl('world-book-filter-dropdown');
    // --- èŠå¤© APP ---
    const chatListBackBtn = getEl('chat-list-back-btn');
    const chatListTitle = getEl('chat-list-title');
    const chatListActionBtn = getEl('chat-list-action-btn');
    const messageListEl = getEl('message-list');
    const addContactModal = getEl('add-contact-modal');
    const newContactNameInput = getEl('new-contact-name');
    const confirmAddContactBtn = getEl('confirm-add-contact-btn');
    const cancelAddContactBtn = getEl('cancel-add-contact-btn');
    const chatBackBtn = getEl('chat-back-btn');
    const chatHeaderName = getEl('chat-header-name');
    const chatHeaderStatus = getEl('chat-header-status');
    const chatHeaderSignature = getEl('chat-header-signature');
    const addFriendBtn = getEl('add-friend-btn');
    const chatSettingsBtn = getEl('chat-settings-btn');
    const chatMessagesView = getEl('chat-messages-view');
    const typingIndicator = getEl('typing-indicator');
    const chatInput = getEl('chat-input');
    const chatSendRealBtn = getEl('chat-send-real-btn');
    const chatEmojiBtn = getEl('chat-emoji-btn');
    const chatSendFakeBtn = getEl('chat-send-fake-btn');
    const chatToolbar = query('.chat-toolbar');
    const emojiPickerPanel = getEl('emoji-picker-panel');
    const closeEmojiPickerBtn = getEl('close-emoji-picker-btn');
    const addEmojiBtn = getEl('add-emoji-btn');
    const emojiGrid = getEl('emoji-grid');
    const addEmojiModal = getEl('add-emoji-modal');
    const cancelAddEmojiBtn = getEl('cancel-add-emoji-btn');
    const uploadEmojiFileBtn = getEl('upload-emoji-file-btn');
    const emojiFileInput = getEl('emoji-file-input');
    const uploadEmojiDescInput = getEl('upload-emoji-desc');
    const emojiUrlInput = getEl('emoji-url-input');
    const confirmAddEmojiUrlBtn = getEl('confirm-add-emoji-url-btn');
    const emojiModeToggleBtn = getEl('emoji-mode-toggle-btn');
const emojiDeleteBtn = getEl('emoji-delete-btn');
    const patSuffixModal = getEl('pat-suffix-modal');
    const patSuffixInput = getEl('pat-suffix-input');
    const confirmPatBtn = getEl('confirm-pat-btn');
    const cancelPatBtn = getEl('cancel-pat-btn');
    const editStatusModal = getEl('edit-status-modal');
    const statusDescInput = getEl('status-desc-input');
    const statusSelectGroup = getEl('status-select-group');
    const confirmEditStatusBtn = getEl('confirm-edit-status-btn');
    const cancelEditStatusBtn = getEl('cancel-edit-status-btn');
    const voiceInputModal = getEl('voice-input-modal');
    const voiceTextInput = getEl('voice-text-input');
    const confirmVoiceBtn = getEl('confirm-voice-btn');
    const cancelVoiceBtn = getEl('cancel-voice-btn');
    const cameraInputModal = getEl('camera-input-modal');
    const cameraTextInput = getEl('camera-text-input');
    const confirmCameraBtn = getEl('confirm-camera-btn');
    const cancelCameraBtn = getEl('cancel-camera-btn');
    const linkShareModal = getEl('link-share-modal');
    const linkTitleInput = getEl('link-title-input');
    const linkSummaryInput = getEl('link-summary-input');
    const linkSourceInput = getEl('link-source-input');
    const linkContentInput = getEl('link-content-input');
    const confirmLinkBtn = getEl('confirm-link-btn');
    const cancelLinkBtn = getEl('cancel-link-btn');
    const redPacketModal = getEl('red-packet-modal');
    const redPacketAmountInput = getEl('red-packet-amount-input');
    const redPacketMessageInput = getEl('red-packet-message-input');
    const confirmRedPacketBtn = getEl('confirm-red-packet-btn');
    const cancelRedPacketBtn = getEl('cancel-red-packet-btn');
    const groupRedPacketModal = getEl('group-red-packet-modal');
    const groupRedPacketMemberGrid = getEl('group-red-packet-member-grid');
    const cancelGroupRedPacketBtn = getEl('cancel-group-red-packet-btn');
    const confirmGroupRedPacketBtn = getEl('confirm-group-red-packet-btn');
    const chatImageInput = getEl('chat-image-input');
    const viewContentModal = getEl('view-content-modal');
    const viewContentTitle = getEl('view-content-title');
    const viewContentBody = getEl('view-content-body');
    const closeViewContentBtn = getEl('close-view-content-btn');
    const contextMenu = getEl('context-menu');
    const editMessageModal = getEl('edit-message-modal');
    const editingMessageIdInput = getEl('editing-message-id');
    const editMessageTypeGroup = getEl('edit-message-type-group');
    const editMessageInputsContainer = getEl('edit-message-inputs-container');
    const saveEditMessageBtn = getEl('save-edit-message-btn');
    const cancelEditMessageBtn = getEl('cancel-edit-message-btn');
    const quotePreview = getEl('quote-preview');
    const quotePreviewContent = getEl('quote-preview-content');
    const closeQuoteBtn = getEl('close-quote-btn');

    // --- åŠ¨æ€ (Moments) APP ---
    const momentsTabContent = getEl('moments-tab-content');
    const momentsNotificationBtn = getEl('moments-notification-btn');
    const momentsNotificationBadge = getEl('moments-notification-badge');
    const postMomentModal = getEl('post-moment-modal');
    const cancelPostMomentBtn = getEl('cancel-post-moment-btn');
    const confirmPostMomentBtn = getEl('confirm-post-moment-btn');
    const editMomentCommentModal = getEl('edit-moment-comment-modal'); // æ–°å¢
    const cancelEditMomentCommentBtn = getEl('cancel-edit-moment-comment-btn'); // æ–°å¢
    const saveEditMomentCommentBtn = getEl('save-edit-moment-comment-btn'); // æ–°å¢

    // --- å•èŠè®¾ç½®ç•Œé¢ ---
    const csCharName = getEl('cs-char-name');
    const csWorldBookGroupSelector = getEl('cs-world-book-group-selector');
    const csWorldBookListContainer = getEl('cs-world-book-list-container');
    const csWorldBookList = getEl('cs-world-book-list');
    const csCharAvatar = getEl('cs-char-avatar');
    const csCharAvatarLibraryBtn = getEl('cs-char-avatar-library-btn');
    const csCharAvatarFrameBtn = getEl('cs-char-avatar-frame-btn');
    const csCharBackgroundBtn = getEl('cs-char-background-btn');
    const csContextMemory = getEl('cs-context-memory');
    const csPersona = getEl('cs-persona');
    const csSavePersonaBtn = getEl('cs-save-persona-btn');
    const csLoadPersonaBtn = getEl('cs-load-persona-btn');
    const csClearHistoryBtn = getEl('cs-clear-history-btn');
    const csDeleteFriendBtn = getEl('cs-delete-friend-btn');
    const csRealtimeActivityToggle = getEl('cs-realtime-activity-toggle');
    const csRealtimeIntervalGroup = getEl('cs-realtime-interval-group');
    const csRealtimeInterval = getEl('cs-realtime-interval');
    const csRestoreBtn = getEl('cs-restore-btn');
    const usUserName = getEl('us-user-name');
    const usUserAvatar = getEl('us-user-avatar');
    const usUserAvatarLibraryBtn = getEl('us-user-avatar-library-btn');
    const usUserAvatarFrameBtn = getEl('us-user-avatar-frame-btn');
    const usPersona = getEl('us-persona');
    const usSavePersonaBtn = getEl('us-save-persona-btn');
    const usLoadPersonaBtn = getEl('us-load-persona-btn');
    const usBubbleCssUser = getEl('us-bubble-css-user');
const usBubbleCssChar = getEl('us-bubble-css-char');
const usBubblePreview = getEl('us-bubble-preview');
const usBubbleApplyBtn = getEl('us-bubble-apply-btn');
const usBubbleRestoreBtn = getEl('us-bubble-restore-btn');
    
    // --- ç¾¤èŠè®¾ç½®ç•Œé¢ ---
    const gcsBackBtn = getEl('gcs-back-btn');
    const gcsGroupName = getEl('gcs-group-name');
    const gcsWorldBookGroupSelector = getEl('gcs-world-book-group-selector');
    const gcsWorldBookListContainer = getEl('gcs-world-book-list-container');
    const gcsWorldBookList = getEl('gcs-world-book-list');
    const gcsGroupAvatar = getEl('gcs-group-avatar');
    const gcsGroupAvatarLibraryBtn = getEl('gcs-group-avatar-library-btn');
    const gcsGroupBackgroundBtn = getEl('gcs-group-background-btn');
    const gcsContextMemory = getEl('gcs-context-memory');
    const gcsMemberList = getEl('gcs-member-list');
    const gcsClearHistoryBtn = getEl('gcs-clear-history-btn');
    const gcsMuteAllBtn = getEl('gcs-mute-all-btn');
    const gcsDisbandBtn = getEl('gcs-disband-btn');
    const gcsUsUserName = getEl('gcs-us-user-name');
    const gcsUsUserAvatar = getEl('gcs-us-user-avatar');
    const gcsUsUserAvatarLibraryBtn = getEl('gcs-us-user-avatar-library-btn');
    const gcsUsUserAvatarFrameBtn = getEl('gcs-us-user-avatar-frame-btn');
    const gcsUsPersona = getEl('gcs-us-persona');
    const gcsUsSavePersonaBtn = getEl('gcs-us-save-persona-btn');
    const gcsUsLoadPersonaBtn = getEl('gcs-us-load-persona-btn');
    const gcsUsBubbleCssUser = getEl('gcs-us-bubble-css-user');
const gcsUsBubbleCssChar = getEl('gcs-us-bubble-css-char');
const gcsUsBubblePreview = getEl('gcs-us-bubble-preview');
const gcsUsBubbleApplyBtn = getEl('gcs-us-bubble-apply-btn');
const gcsUsBubbleRestoreBtn = getEl('gcs-us-bubble-restore-btn');
    const gcsMemberModal = getEl('gcs-member-modal');
    const gcsMemberModalTitle = getEl('gcs-member-modal-title');
    const gcsEditingMemberIdInput = getEl('gcs-editing-member-id');
    const gcsMemberNickname = getEl('gcs-member-nickname');
    const gcsMemberWorldBookGroupSelector = getEl('gcs-member-world-book-group-selector');
    const gcsMemberWorldBookListContainer = getEl('gcs-member-world-book-list-container');
    const gcsMemberWorldBookList = getEl('gcs-member-world-book-list');
    const gcsMemberAvatar = getEl('gcs-member-avatar');
    const gcsMemberAvatarLibraryBtn = getEl('gcs-member-avatar-library-btn');
    const gcsMemberAvatarFrameBtn = getEl('gcs-member-avatar-frame-btn');
    const gcsMemberPersona = getEl('gcs-member-persona');
    const gcsMemberSavePersonaBtn = getEl('gcs-member-save-persona-btn');
    const gcsMemberLoadPersonaBtn = getEl('gcs-member-load-persona-btn');
    const gcsMemberModalCancelBtn = getEl('gcs-member-modal-cancel-btn');
    const gcsMemberModalSaveBtn = getEl('gcs-member-modal-save-btn');
    const gcsManageMembersModal = getEl('gcs-manage-members-modal');
    const gcsManageMembersTitle = getEl('gcs-manage-members-title');
    const gcsManageMembersList = getEl('gcs-manage-members-list');
    const gcsManageMembersCancelBtn = getEl('gcs-manage-members-cancel-btn');
    const gcsManageMembersConfirmBtn = getEl('gcs-manage-members-confirm-btn');
    const gcsMemberActionModal = getEl('gcs-member-action-modal');
    const gcsMemberActionTitle = getEl('gcs-member-action-title');
    const gcsMemberActionBody = getEl('gcs-member-action-body');
    const gcsMemberActionCancelBtn = getEl('gcs-member-action-cancel-btn');
    // --- æ–°å¢å¼¹çª— ---
    const uploadPhotoModal = getEl('upload-photo-modal');
    const manageAlbumsModal = getEl('manage-albums-modal');
    const editAlbumModal = getEl('edit-album-modal');
    const editPhotoModal = getEl('edit-photo-modal');
    const leaveMessageModal = getEl('leave-message-modal');
    const viewPhotoModal = getEl('view-photo-modal');
    const simpleViewerModal = getEl('simple-viewer-modal');
    // --- åŠ¨æ€é€šçŸ¥ ---
    const momentsNotificationModal = getEl('moments-notification-modal');
    const closeMomentsNotificationModalBtn = getEl('close-moments-notification-modal-btn');
    const momentsNotificationList = getEl('moments-notification-list');
    // --- ä¿¡ç®± APP ä¼˜åŒ–å…ƒç´  ---
        const mailFabContainer = getEl('mail-fab-container');
        const editLoveLetterModal = getEl('edit-love-letter-modal');
        const mailFilterBtn = getEl('mail-filter-btn');
        const mailFilterDropdown = getEl('mail-filter-dropdown');
        const letterReplyBtn = getEl('letter-reply-btn');
const mailSettingsModal = getEl('mail-settings-modal');
    // --- æ¥ç”µUIå…ƒç´  ---
        const incomingCallBanner = getEl('incoming-call-banner');
        const incomingCallAvatar = getEl('incoming-call-avatar');
        const incomingCallName = getEl('incoming-call-name');
        const incomingCallAcceptBtn = getEl('incoming-call-accept-btn');
        const incomingCallRejectBtn = getEl('incoming-call-reject-btn');
    // --- è§†é¢‘é€šè¯å…ƒç´  (é‡æ„) ---
    const videoCallModal = getEl('video-call-modal');
    const videoCallMainView = getEl('video-call-main-view');
    const videoCallPipView = getEl('video-call-pip-view');
    const videoCallAvatar = getEl('video-call-avatar'); // Still used for single chat
    const videoCallName = getEl('video-call-name'); // Still used for single chat
    const videoCallSingleCharInfo = getEl('video-call-single-char-info');
    const videoCallParticipantsContainer = getEl('video-call-participants-container');
    const videoCallMessages = getEl('video-call-messages');
    const videoCallMinimizeBtn = getEl('video-call-minimize-btn');
    const videoCallSwitchCameraBtn = getEl('video-call-switch-camera-btn');
    const videoCallHangupBtn = getEl('video-call-hangup-btn');
    const videoCallSpeakBtn = getEl('video-call-speak-btn');
    const videoCallInputWrapper = getEl('video-call-input-wrapper');
    const videoCallInput = getEl('video-call-input');
    const videoCallSendBtn = getEl('video-call-send-btn');
    const videoCallRefreshBtn = getEl('video-call-refresh-btn');
    const videoCallFloatBtn = getEl('floating-video-btn'); // Corrected ID
    // --- é€šç”¨/å…±äº«å¼¹çª— ---
    const libraryModal = getEl('library-modal');
    const libraryModalTitle = getEl('library-modal-title');
    const libraryModalPreviewArea = getEl('library-modal-preview-area');
    const libraryUploadBtn = getEl('library-upload-btn');
    const libraryAddUrlBtn = getEl('library-add-url-btn');
    const libraryGrid = getEl('library-grid');
    const libraryFileInput = getEl('library-file-input');
    const libraryDeleteBtn = getEl('library-delete-btn');
    const libraryCloseBtn = getEl('library-close-btn');
    const libraryModeToggleBtn = getEl('library-mode-toggle-btn');
    const loadPersonaModal = getEl('load-persona-modal');
    const loadPersonaTitle = getEl('load-persona-title');
    const loadPersonaList = getEl('load-persona-list');
    const loadPersonaCancelBtn = getEl('load-persona-cancel-btn');
    const loadStyleModal = getEl('load-style-modal');
const loadStyleTitle = getEl('load-style-title');
const loadStyleList = getEl('load-style-list');
const loadStyleCancelBtn = getEl('load-style-cancel-btn');
    // Function to open the persona loading modal
    function openLoadPersonaModal(dataType, settingsGroup, memberId = null) {
        // Store context for when an item is selected
        runtimeState.personaLoadContext = { dataType, settingsGroup, memberId };
        
        const dataArray = appState.data[dataType + 's'];
        loadPersonaTitle.textContent = `è¯»å–${dataType === 'archive' ? 'æ¡£æ¡ˆ' : 'ä¿¡æ¯'}`;

        if (dataArray.length === 0) {
            loadPersonaList.innerHTML = `<p style="text-align:center; color:#888;">æš‚æ— å†…å®¹å¯è¯»å–</p>`;
        } else {
            loadPersonaList.innerHTML = ''; // Clear previous list
            dataArray.forEach(item => {
                const li = document.createElement('li');
                li.className = 'preset-data-item'; // Use existing class for styling
                li.dataset.id = item.id;
                
                // Use the same layout as the Data App lists for consistency
                li.innerHTML = `
                    <div class="preset-data-item-content" style="cursor: pointer;">
                        <div class="preset-data-avatar"></div>
                        <div class="preset-data-info">
                            <div class="preset-data-name">${escapeHTML(item.name)}</div>
                            <div class="preset-data-excerpt">${escapeHTML(item.content.substring(0, 20) || 'æ— å†…å®¹')}...</div>
                        </div>
                    </div>`;
                
                loadPersonaList.appendChild(li);
                setElementImage(li.querySelector('.preset-data-avatar'), item.avatarId);
            });
        }
        loadPersonaModal.classList.add('visible');
    }

    // Event listener for selecting a persona from the modal list
    loadPersonaList.addEventListener('click', (e) => {
        const item = e.target.closest('.preset-data-item');
        if (!item) return;

        const dataId = item.dataset.id;
        const { dataType, settingsGroup, memberId } = runtimeState.personaLoadContext;
        const dataItem = appState.data[dataType + 's'].find(d => d.id === dataId);

        if (!dataItem) {
            showToast('æ— æ³•æ‰¾åˆ°æ‰€é€‰èµ„æ–™', 'error');
            return;
        }

        if (memberId) {
            // Case: Editing a group member in the gcs-member-modal
            runtimeState.tempGcsMemberSettings.nickname = dataItem.name;
            runtimeState.tempGcsMemberSettings.avatarId = dataItem.avatarId;
            if (typeof dataItem.relationship !== 'undefined') {
                runtimeState.tempGcsMemberSettings.relationship = dataItem.relationship;
            }
            runtimeState.tempGcsMemberSettings.persona = dataItem.content;
            loadGcsMemberModalUI();
        } else {
            // Case: Editing in single chat settings OR group chat "my settings" tab
            const targetSettings = runtimeState.tempChatSettings[settingsGroup];
            targetSettings.name = dataItem.name;
            targetSettings.avatarId = dataItem.avatarId;
            targetSettings.persona = dataItem.content;
            
            // Check for and apply relationship ONLY for charSettings
            if (settingsGroup === 'charSettings' && typeof dataItem.relationship !== 'undefined') {
                targetSettings.relationship = dataItem.relationship;
            }
            
            // If editing user settings within a group chat, also update the nickname in the members list
            if (groupChatSettingsScreen.classList.contains('active') && settingsGroup === 'userSettings') {
                const userInGroup = runtimeState.tempChatSettings.groupSettings.members['user'];
                userInGroup.nickname = dataItem.name;
                userInGroup.avatarId = dataItem.avatarId;
            }
            
            // Refresh the correct settings screen UI
            if (chatSettingsScreen.classList.contains('active')) {
                loadSingleChatSettingsUI();
            } else if (groupChatSettingsScreen.classList.contains('active')) {
                loadGroupChatSettingsUI();
            }
        }

        loadPersonaModal.classList.remove('visible');
        showToast('èµ„æ–™å·²æˆåŠŸè¯»å–ï¼');
    });

    // Event listener for the cancel button in the persona modal
    loadPersonaCancelBtn.addEventListener('click', () => {
        loadPersonaModal.classList.remove('visible');
    });
    // --- æ–°å¢ï¼šæ ·å¼ä¿å­˜ä¸è¯»å–æ ¸å¿ƒé€»è¾‘ ---
    function renderStylesTab() {
const previewStyleTag = getEl('saved-styles-preview-style');
let previewCss = '';

const getMiniPreviewHTML = (moduleKey) => {
    const previews = {
        appHeader: '<div class="mini-header">&lt; <span>æ ‡é¢˜</span> +</div>',
        listItem: '<div class="mini-list-item"><div class="swipe-content"><div class="avatar"></div><span>åˆ—è¡¨é¡¹</span></div></div>',
        momentsPost: '<div class="mini-moments-card"><div class="post-item-content"><div class="avatar"></div><span>åŠ¨æ€å¡ç‰‡</span></div></div>',
        bottomTabs: '<div class="mini-tabs"><span>æ ‡ç­¾1</span><span>æ ‡ç­¾2</span></div>',
        loveLetter: `<div class="mini-letter" style="font-size: 8px; line-height: 1.3; color: #333; background: #fdfbf7; border: 1px solid #e0d8cc; padding: 5px; text-align: left;">
                    <div style="display: flex; align-items: center; gap: 5px; padding-bottom: 4px; margin-bottom: 4px; border-bottom: 1px dashed #dcd3c5;">
                        <div style="width: 20px; height: 20px; border-radius: 50%; background-color: #ccc; flex-shrink: 0;"></div>
                        <div>
                            <div style="font-weight: bold;">ç§°å‘¼</div>
                            <div style="font-size: 7px; color: #999;">æ—¶é—´æˆ³</div>
                        </div>
                    </div>
                    <div>æ­£æ–‡é¢„è§ˆ...</div>
                    <div style="text-align: right; margin-top: 5px; font-style: italic;">è½æ¬¾</div>
                </div>`,
chatInput: '<div class="mini-chat-input" style="font-size: 10px; padding: 4px; border-top: 1px solid #ccc; background: #f7f7f7; text-align: center; display: flex; justify-content: space-around; align-items: center;"><span>[...]</span><i class="fa-solid fa-face-smile"></i><i class="fa-solid fa-microphone"></i><i class="fa-solid fa-images"></i></div>'
    };
    return previews[moduleKey] || '';
};

const createCardHTML = (item, type, moduleKey = null) => {
    const actionsHTML = `
        <div class="style-preview-actions">
            <button class="icon-btn export-style-btn" title="å¯¼å‡º"><i class="fa-solid fa-arrow-right-from-bracket"></i></button>
            <button class="icon-btn edit-style-btn" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
            <button class="icon-btn delete-style-btn" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
        </div>`;

    let previewContentHTML = '';
    if (type === 'bubble') {
        const scopedCss = (item.css || '').replace(/([^{]+)({[^{}]*})/g, (match, selector, body) => {
            const scopedSelector = selector.split(',').map(s => `[data-bubble-id="${item.id}"] ${s.trim()}`).join(', ');
            return `${scopedSelector} ${body}`;
        });
        previewCss += scopedCss;
        previewContentHTML = `
            <div class="bubble-preview-wrapper" data-bubble-id="${item.id}">
                <div class="message-item contact"><div class="avatar"></div><div class="message-bubble">ä½ å¥½</div></div>
                <div class="message-item user"><div class="message-bubble">ä½ å¥½å‘€</div><div class="avatar"></div></div>
            </div>`;
    } else { // theme
        const styles = item.styles;
        const styleString = styles[moduleKey] || '';
        const scopeSelector = {
            appHeader: `[data-theme-id="${item.id}"] .mini-header`,
            listItem: `[data-theme-id="${item.id}"] .mini-list-item .swipe-content`,
            momentsPost: `[data-theme-id="${item.id}"] .mini-moments-card .post-item-content`,
            bottomTabs: `[data-theme-id="${item.id}"] .mini-tabs`,
            loveLetter: `[data-theme-id="${item.id}"] .mini-letter`,
            chatInput: `[data-theme-id="${item.id}"] .mini-chat-input`
        };
        previewCss += processAndScopeCss(styleString, scopeSelector[moduleKey]);
        previewContentHTML = `<div class="theme-preview-wrapper" data-theme-id="${item.id}">${getMiniPreviewHTML(moduleKey)}</div>`;
    }

    return `
        <div class="style-preview-card" data-id="${item.id}" data-type="${type}">
            <div class="style-preview-header">
                <div class="style-preview-name">${escapeHTML(item.name)}</div>
                ${actionsHTML}
            </div>
            ${previewContentHTML}
        </div>`;
};

// Render Bubbles
const bubblesRow = getEl('saved-bubbles-row');
const savedBubbles = appState.data.savedBubbles;
if (savedBubbles.length > 0) {
    bubblesRow.innerHTML = savedBubbles.map(bubble => createCardHTML(bubble, 'bubble')).join('');
} else {
    bubblesRow.innerHTML = '<p style="text-align:center; color:#888; width: 100%;">æš‚æ— å·²ä¿å­˜çš„æ°”æ³¡</p>';
}

// Render Themes, categorized by module
const themeModules = [
    { key: 'momentsPost', rowId: 'saved-themes-momentsPost-row' },
    { key: 'appHeader', rowId: 'saved-themes-appHeader-row' },
    { key: 'bottomTabs', rowId: 'saved-themes-bottomTabs-row' },
    { key: 'listItem', rowId: 'saved-themes-listItem-row' },
    { key: 'loveLetter', rowId: 'saved-themes-loveLetter-row' },
    { key: 'chatInput', rowId: 'saved-themes-chatInput-row' }
];

themeModules.forEach(module => {
    const rowEl = getEl(module.rowId);
    const relevantThemes = appState.data.savedThemes.filter(theme => theme.styles && theme.styles[module.key]);
    if (relevantThemes.length > 0) {
        rowEl.innerHTML = relevantThemes.map(theme => createCardHTML(theme, 'theme', module.key)).join('');
    } else {
        rowEl.innerHTML = '<p style="text-align:center; color:#888; width: 100%;">æš‚æ— å·²ä¿å­˜çš„æ­¤æ¨¡å—æ ·å¼</p>';
    }
});

previewStyleTag.textContent = previewCss;}

        getEl('styles-tab-content').addEventListener('click', e => {
    const card = e.target.closest('.style-preview-card');
    if (!card) return;

    const styleId = card.dataset.id;
    const styleType = card.dataset.type;

    // Handle Export Button Click
    if (e.target.closest('.export-style-btn')) {
        e.stopPropagation();
        exportSingleStyle(styleId, styleType);
        return;
    }

    // Handle Edit Button Click
    if (e.target.closest('.edit-style-btn')) {
        e.stopPropagation();
        openEditStyleModal(styleId, styleType);
        return;
    }

    // Handle Delete Button Click
    if (e.target.closest('.delete-style-btn')) {
        e.stopPropagation();
        const styleName = card.querySelector('.style-preview-name').textContent;
        if (confirm(`ç¡®å®šè¦åˆ é™¤æ ·å¼ "${styleName}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
            if (styleType === 'theme') {
                appState.data.savedThemes = appState.data.savedThemes.filter(t => t.id !== styleId);
            } else { // bubble
                appState.data.savedBubbles = appState.data.savedBubbles.filter(b => b.id !== styleId);
            }
            debouncedSaveState();
            renderStylesTab();
            showToast('æ ·å¼å·²åˆ é™¤');
        }
        return;
    }

    // Click-to-apply logic
    if (styleType === 'theme') {
        const theme = appState.data.savedThemes.find(t => t.id === styleId);
        if (theme && confirm(`ç¡®å®šè¦ç«‹å³åº”ç”¨ä¸»é¢˜æ ·å¼ "${theme.name}" å—ï¼Ÿ`)) {
            appState.beautify.customThemes = { ...theme.styles };
            applyCustomThemes();
            debouncedSaveState();
            showToast('ä¸»é¢˜å·²åº”ç”¨ï¼');
        }
    } else if (styleType === 'bubble') {
        const bubble = appState.data.savedBubbles.find(b => b.id === styleId);
        if (bubble && confirm(`è¦å°†æ ·å¼ "${bubble.name}" åº”ç”¨ä¸ºå…¨å±€èŠå¤©æ°”æ³¡å—ï¼Ÿ\n\næ­¤æ“ä½œå°†è¦†ç›–æ‰€æœ‰è”ç³»äººç‹¬ç«‹è®¾ç½®çš„èŠå¤©æ°”æ³¡ã€‚`)) {
            appState.chat.contacts.forEach(contact => {
                contact.userSettings.bubbleCss = bubble.css;
            });
            applyAllCustomBubbleStyles();
            debouncedSaveState();
            showToast('å…¨å±€æ°”æ³¡æ ·å¼å·²åº”ç”¨ï¼');
        }
    }
});

function openEditStyleModal(styleId, styleType) {
    const modal = getEl('edit-style-modal');
    getEl('edit-style-id').value = styleId;
    getEl('edit-style-type').value = styleType;
    const nameInput = getEl('edit-style-name');
    const contentWrapper = getEl('edit-style-content-wrapper');
    contentWrapper.innerHTML = ''; // Clear previous content

    if (styleType === 'theme') {
        const theme = appState.data.savedThemes.find(t => t.id === styleId);
        if (!theme) return;
        nameInput.value = theme.name;
        contentWrapper.innerHTML = `
            <div class="form-group">
                <label>ç©ºé—´å¡ç‰‡</label>
                <textarea id="edit-theme-css-moments" class="theme-css-editor" rows="4">${theme.styles.momentsPost || ''}</textarea>
            </div>
            <div class="form-group">
                <label>é¡¶éƒ¨çŠ¶æ€æ </label>
                <textarea id="edit-theme-css-header" class="theme-css-editor" rows="4">${theme.styles.appHeader || ''}</textarea>
            </div>
            <div class="form-group">
                <label>åº•éƒ¨æ ‡ç­¾æ </label>
                <textarea id="edit-theme-css-tabs" class="theme-css-editor" rows="4">${theme.styles.bottomTabs || ''}</textarea>
            </div>
            <div class="form-group">
                <label>é€šç”¨åˆ—è¡¨å¡ç‰‡</label>
                <textarea id="edit-theme-css-list-item" class="theme-css-editor" rows="4">${theme.styles.listItem || ''}</textarea>
            </div>
            <div class="form-group">
            <label>æƒ…ä¹¦ä¿¡çº¸</label>
            <textarea id="edit-theme-css-letter" class="theme-css-editor" rows="4">${theme.styles.loveLetter || ''}</textarea>
        </div>
                <div class="form-group">
            <label>èŠå¤©è¾“å…¥æ </label>
            <textarea id="edit-theme-css-chat-input" class="theme-css-editor" rows="4">${theme.styles.chatInput || ''}</textarea>
        </div>
        `;
    } else { // bubble
        const bubble = appState.data.savedBubbles.find(b => b.id === styleId);
        if (!bubble) return;
        nameInput.value = bubble.name;
        contentWrapper.innerHTML = `
            <div class="form-group">
                <label>æ°”æ³¡ CSS</label>
                <textarea id="edit-bubble-css-content" class="theme-css-editor" rows="10">${bubble.css || ''}</textarea>
            </div>
        `;
    }

    modal.classList.add('visible');
}

// Add listeners for the new modal
getEl('cancel-edit-style-btn').addEventListener('click', () => getEl('edit-style-modal').classList.remove('visible'));

getEl('save-edit-style-btn').addEventListener('click', () => {
    const styleId = getEl('edit-style-id').value;
    const styleType = getEl('edit-style-type').value;
    const newName = getEl('edit-style-name').value.trim();

    if (!newName) {
        showToast('æ ·å¼åç§°ä¸èƒ½ä¸ºç©º', 'error');
        return;
    }

    if (styleType === 'theme') {
        const theme = appState.data.savedThemes.find(t => t.id === styleId);
        if (theme) {
            theme.name = newName;
            theme.styles.momentsPost = getEl('edit-theme-css-moments').value;
            theme.styles.appHeader = getEl('edit-theme-css-header').value;
                theme.styles.loveLetter = getEl('edit-theme-css-letter').value;
            theme.styles.bottomTabs = getEl('edit-theme-css-tabs').value;
            theme.styles.listItem = getEl('edit-theme-css-list-item').value;
        theme.styles.chatInput = getEl('edit-theme-css-chat-input').value;
        }
    } else { // bubble
        const bubble = appState.data.savedBubbles.find(b => b.id === styleId);
        if (bubble) {
            bubble.name = newName;
            bubble.css = getEl('edit-bubble-css-content').value;
        }
    }
    
    debouncedSaveState();
    renderStylesTab();
    getEl('edit-style-modal').classList.remove('visible');
    showToast('æ ·å¼å·²æ›´æ–°ï¼');
});

function exportSingleStyle(styleId, styleType) {
    let styleObject;
    let fileNamePrefix;
    if (styleType === 'theme') {
        styleObject = appState.data.savedThemes.find(t => t.id === styleId);
        fileNamePrefix = 'Theme-Style';
    } else { // bubble
        styleObject = appState.data.savedBubbles.find(b => b.id === styleId);
        fileNamePrefix = 'Bubble-Style';
    }

    if (styleObject) {
        const { id, ...exportData } = styleObject;
        const dataStr = JSON.stringify(exportData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        downloadFile(blob, `${fileNamePrefix}-${exportData.name}.json`);
    }
}

getEl('import-style-file-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const importedData = JSON.parse(e.target.result);
            if (!importedData.name || (!importedData.styles && !importedData.css)) {
                throw new Error('æ— æ•ˆçš„æ ·å¼æ–‡ä»¶æ ¼å¼ã€‚');
            }

            let finalName = importedData.name.trim();
            const isTheme = !!importedData.styles;
            const existingStyles = isTheme ? appState.data.savedThemes : appState.data.savedBubbles;

            if (existingStyles.some(s => s.name === finalName)) {
                if (!confirm(`å·²å­˜åœ¨åä¸º "${finalName}" çš„æ ·å¼ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`)) {
                    event.target.value = '';
                    return;
                }
                const existingIndex = existingStyles.findIndex(s => s.name === finalName);
                if (existingIndex > -1) {
                    existingStyles.splice(existingIndex, 1);
                }
            }
            
            const newStyle = { id: newId(isTheme ? 'theme_style' : 'bubble_style'), ...importedData };

            if (isTheme) {
                appState.data.savedThemes.push(newStyle);
            } else {
                appState.data.savedBubbles.push(newStyle);
            }
            
            debouncedSaveState();
            renderStylesTab();
            showToast('æ ·å¼å¯¼å…¥æˆåŠŸï¼');

        } catch (error) {
            showToast(`å¯¼å…¥å¤±è´¥: ${error.message}`, 'error');
            console.error("Style import error:", error);
        } finally {
            event.target.value = '';
        }
    };
    reader.readAsText(file);
});
    function openLoadStyleModal(type, context) {
        runtimeState.styleLoadContext = { type, context };
        const dataArray = (type === 'theme') ? appState.data.savedThemes : appState.data.savedBubbles;

        loadStyleTitle.textContent = `è¯»å–${type === 'theme' ? 'ä¸»é¢˜' : 'æ°”æ³¡'}æ ·å¼`;
        
        if (dataArray.length === 0) {
            loadStyleList.innerHTML = `<p style="text-align:center; color:#888;">æš‚æ— å·²ä¿å­˜çš„æ ·å¼</p>`;
        } else {
            loadStyleList.innerHTML = dataArray.map(item => `
                <div class="style-preview-item" data-id="${item.id}">
                    <div class="style-preview-name">${escapeHTML(item.name)}</div>
                </div>
            `).join('');
        }
        loadStyleModal.classList.add('visible');
    }

        loadStyleList.addEventListener('click', e => {
    const item = e.target.closest('.style-preview-item');
    if (!item) return;

    const styleId = item.dataset.id;
    const { type, context } = runtimeState.styleLoadContext;
    const moduleKeyMap = {
        momentsPost: 'moments', appHeader: 'header', bottomTabs: 'tabs',
        listItem: 'list-item', loveLetter: 'letter', chatInput: 'chat-input'
    };

    if (type === 'theme') {
        const theme = appState.data.savedThemes.find(t => t.id === styleId);
        if (!theme || !theme.styles) return;

        // Single module load logic
        if (context && context.singleModule) {
            const module = context.singleModule;
            const css = theme.styles[module];
            if (css !== undefined) {
                const key = moduleKeyMap[module];
                getEl(`theme-css-${key}`).value = css;
                updateThemeCssPreview(key);
                showToast(`æ ·å¼ '${theme.name}' ä¸­çš„æ¨¡å—å·²åŠ è½½`);
            } else {
                showToast(`æ ·å¼ '${theme.name}' ä¸­ä¸åŒ…å«æ­¤æ¨¡å—`, 'error');
            }
        } else { // Global load logic
            themeCssMoments.value = theme.styles.momentsPost || '';
            themeCssHeader.value = theme.styles.appHeader || '';
            getEl('theme-css-letter').value = theme.styles.loveLetter || '';
            themeCssTabs.value = theme.styles.bottomTabs || '';
            themeCssListItem.value = theme.styles.listItem || '';
            getEl('theme-css-chat-input').value = theme.styles.chatInput || '';
            Object.values(moduleKeyMap).forEach(id => updateThemeCssPreview(id));
        }

    } else if (type === 'bubble') {
        const bubble = appState.data.savedBubbles.find(b => b.id === styleId);
        if (bubble) {
            const editor = getEl(`${context}-css`);
            if (editor) {
                editor.value = bubble.css;
                const previewContext = context.replace('-bubble', '');
                updateBubbleCssPreview(previewContext, runtimeState.tempChatSettings);
            }
        }
    }
    loadStyleModal.classList.remove('visible');
});

    loadStyleCancelBtn.addEventListener('click', () => loadStyleModal.classList.remove('visible'));

    function setupStyleSaver(context, type) {
    const saveBtn = getEl(`${context}-save-style-btn`);
    const loadBtn = getEl(`${context}-load-style-btn`);

    saveBtn.addEventListener('click', () => {
        const name = prompt('è¯·è¾“å…¥æ ·å¼åç§°:');
        if (!name || !name.trim()) return;

        if (type === 'theme') {
            const newTheme = {
                id: newId('theme_style'),
                name: name.trim(),
                styles: {
                    momentsPost: themeCssMoments.value,
                    appHeader: themeCssHeader.value,
                    loveLetter: getEl('theme-css-letter').value,
                    bottomTabs: themeCssTabs.value,
                    listItem: themeCssListItem.value,
                    chatInput: getEl('theme-css-chat-input').value
                }
            };
            appState.data.savedThemes.push(newTheme);
        } else { // bubble
            const editor = getEl(`${context}-css`);
            const newBubble = { id: newId('bubble_style'), name: name.trim(), css: editor.value };
            appState.data.savedBubbles.push(newBubble);
        }
        debouncedSaveState();
        showToast('æ ·å¼å·²ä¿å­˜ï¼');
    });

    loadBtn.addEventListener('click', () => {
        openLoadStyleModal(type, context);
    });
}

// --- æ–°å¢ï¼šä¸ºä¸»é¢˜ç¼–è¾‘å™¨ä¸­çš„å•ä¸ªæ¨¡å—æŒ‰é’®è®¾ç½®ç›‘å¬ ---
function setupSingleThemeSavers() {
    const moduleKeyMap = {
    momentsPost: 'moments', appHeader: 'header', bottomTabs: 'tabs',
    listItem: 'list-item', loveLetter: 'letter', chatInput: 'chat-input'
};
    
    getEl('theme-tab-content').addEventListener('click', e => {
        const saveBtn = e.target.closest('.save-single-style-btn');
        const loadBtn = e.target.closest('.load-single-style-btn');

        if (saveBtn) {
            const module = saveBtn.dataset.module;
            const css = getEl(`theme-css-${moduleKeyMap[module]}`).value;
            const name = prompt('è¯·è¾“å…¥æ ·å¼åç§° (å¦‚æœåç§°å·²å­˜åœ¨, å°†æ›´æ–°è¯¥æ ·å¼):');
            if (!name || !name.trim()) return;

            let theme = appState.data.savedThemes.find(t => t.name === name.trim());
            if (theme) {
                if (!theme.styles) theme.styles = {};
                theme.styles[module] = css;
                showToast(`æ ·å¼ "${name.trim()}" å·²æ›´æ–°ï¼`);
            } else {
                const newTheme = {
                    id: newId('theme_style'),
                    name: name.trim(),
                    styles: { [module]: css }
                };
                appState.data.savedThemes.push(newTheme);
                showToast('æ–°æ ·å¼å·²ä¿å­˜ï¼');
            }
            debouncedSaveState();
            return;
        }

        if (loadBtn) {
            const module = loadBtn.dataset.module;
            openLoadStyleModal('theme', { singleModule: module });
            return;
        }
    });
}
    
    setupStyleSaver('us-bubble', 'bubble');
    setupStyleSaver('gcs-us-bubble', 'bubble');
    setupStyleSaver('theme', 'theme');
    setupSingleThemeSavers();
    // --- å…¨å±€çŠ¶æ€ç®¡ç† (å¯åºåˆ—åŒ–) ---
    const DB_KEY = 'EmperorPhoneData_v2';
    const DEFAULT_WALLPAPER_URL = 'https://img.xjh.me/random_img.php?type=bg&ctype=nature&return=302';
        const DB_KEYS = {
        SETTINGS: 'EmperorPhone_v2_settings',
        MUSIC: 'EmperorPhone_v2_music',
        BEAUTIFY: 'EmperorPhone_v2_beautify',
        DATA: 'EmperorPhone_v2_data',
        CHAT: 'EmperorPhone_v2_chat',
        MAILBOX: 'EmperorPhone_v2_mailbox',
        DIARY: 'EmperorPhone_v2_diary',
            ENTERTAINMENT: 'EmperorPhone_v2_entertainment',
                ASSETS: 'EmperorPhone_v2_assets',
        META: 'EmperorPhone_v2_meta'
    };
    let appState = {};

    // --- å…¨å±€è¿è¡Œæ—¶çŠ¶æ€ (ä¸å¯åºåˆ—åŒ–) ---
    let runtimeState = {};
    let islandVideoCallTimer = null;
    let conversationLoadMoreHandler = null;


// ===================================================================
// --- çŠ¶æ€ç®¡ç†é‡æ„ ---
// ===================================================================
    function getInitialState() {
return {
        settings: { apiUrl: '', apiKey: '', selectedModel: '', availableModels: [], presets: [], globalRealtimeActivity: { interval: 30 }, globalContextMemory: { count: 99 } },
    music: { playlist: [], queue: [], lyrics: {}, comments: {}, currentQueueIndex: -1, playbackMode: 'repeat' },
    beautify: {
    wallpapers: [],
    currentWallpaperId: 'default',
    currentChatBgId: 'default',
    fonts: [],
    currentFont: 'default',
    fontColor: '#000000',
    icons: {},
    bubbleSettings: { global: {}, specific: {} },
        mediaSources: {},
    iconSources: {},
    customThemes: {
        momentsPost: '',
        appHeader: '',
        bottomTabs: '',
        listItem: ''
    }
    },
    data: { worldBooks: [], archives: [], infos: [], savedThemes: [], savedBubbles: [], mediaSources: {} },
    chat: {
                        contacts: [],
                        emojis: [],
                        videoCallState: { isActive: false, chatId: null, isGroup: false, participants: [], startTime: null, log: [], isMinimized: false, isCameraSwapped: false, initiator: null, lastRejectedCallTimestamp: null },
                        userProfiles: [{
                            id: 'default_user_profile',
                            name: 'åœŸçš‡å¸',
                            avatarId: 'default_user_avatar',
                            avatarFrameId: '',
                            persona: '',
                            signature: '',
                            cashBalance: 1000000.00,
                            bankBalance: 0,
                            loan: 0,
                            lastInterestCalc: '',
                            weibo: {
                                profile: {
                                    id: 'default_user_profile',
                                    name: 'åœŸçš‡å¸',
                                    bio: 'è¿™ä¸ªäººå¾ˆæ‡’ï¼Œä»€ä¹ˆéƒ½æ²¡å†™...',
                                    persona: '',
                                    avatarId: 'default_user_avatar',
                                    coverId: 'default_moments_cover',
                                },
                                posts: [],
                                followingCount: 0,
                                followerCount: 0,
                                followingIds: [],
                                followerIds: []
                            }
                        }],
                        activeUserProfileId: 'default_user_profile',
                        moments: {
                                                    
                            profile: {
                                name: 'åœŸçš‡å¸',
                                signature: 'å…¨ç½‘å”¯ä¸€åœŸçš‡å¸',
                                avatarId: 'default_moments_avatar',
                                coverId: 'default_moments_cover',
                            },
                            posts: [],
                            photos: [],
                            albums: [],
                            messages: [],
                            notifications: [],
                            visitors: []
                        }
                    },
                    mailbox: { 
                        activeTab: 'love-letter',
                        loveLetters: [],
                        postcards: []
                    },
                                                            diary: {
                        activeTab: 'anniversary',
                        anniversaries: [
                                                        { id: 'anniv_default_1', date: '2025-03-14', name: 'Geminiç”Ÿæ—¥', isSpecial: true }
                        ],
                        collections: [],
                        secrets: [],
                        diaries: [] // æ–°å¢ï¼šæ—¥è®°å…ƒæ•°æ®
                     },
                                     entertainment: { fortuneType: 'divination' },
                                  assets: {
                                    stocks: {
            market: [], // { id, charId, name, ticker, price, history:[], change: 0, volatility: 1 }
            portfolio: {}, // { stockId: { shares: 100, avgCost: 10.50 } }
            lastUpdateTime: 0,
            newsFeed: {} // { stockId: ["news1", "news2", ...] }
            },          
    lottery: {
        tickets: [], // { numbers: [1,2,3,4,5], purchaseDate: 'YYYY-MM-DD' }
        dailyDraws: {}, // { 'YYYY-MM-DD': [1,2,3,4,5] }
        lastCheckedDate: null
    }
},   
                    meta: {
                        lastUserActivityTimestamp: 0 // Tracks the timestamp of the last user interaction
                    }}}

    function getInitialRuntimeState() {
        return {
            apiKeyIndex: 0, // For multiple API key round-robin
            originalIconContent: {},
            originalBubbleContent: {},
                    exportProgress: { filesProcessed: 0, currentPart: 1 },
            beautify: { wallpaperDisplayCount: 0, fontDisplayCount: 0 },
            isDetailsAnimatingIn: false,
            currentChatId: null,
            contactSelection: [],
            worldBookFilter: { selectedGroups: ['all'] },
            patTarget: { type: null, element: null, memberId: null },
            editingComment: { source: null, songId: null, postId: null, commentId: null, replyId: null },
            contextMenuTarget: null,
            wallpaperContextMenuTarget: null,
            chatSelectionMode: false,
            selectedMessages: [],
            quotedMessage: null,
            tempChatSettings: {},
            originalChatSettings: {},
            libraryContext: {},
            librarySelection: [],
            groupRedPacketContext: {},
            tempGcsMemberSettings: {},
            gcsManageContext: { type: '', selection: [] },
            gcsMemberActionContext: { memberId: null },
            realtimeActivityTimers: {},
            activeRequests: {},
            notificationQueue: [],
            musicSessionType: null,
            videoCallContext: {
                            aiIsResponding: false,
                            userIsTyping: false
                        },
                    incomingCall: { from: null, timer: null },
            isNotificationVisible: false,
            currentlyPlayingVoiceTimer: null,
            chatDisplayLimits: {},
            mediaObjectURLs: new Map(),
            emojiSelectionMode: false,
            selectedEmojis: [],
            moments: {
                currentFilter: 'all',
                isFabMenuOpen: false,
                currentProfileId: 'user', 
                postContext: {},
                viewerContext: { items: [], currentIndex: 0 }
                },
                    postcardFilter: { selected: 'all' },
    secretFilter: { selected: 'all' },
        mailboxFilter: { selected: 'all' },
        fortuneProcess: { status: 'idle', retryTimer: null, context: {} },

        videoCallContext: { // Add this new object
                    
            aiIsResponding: false,
            userIsTyping: false
        },
        backgroundFailureCount: {} // Track failures for persistent notifications
        
    };
}

    async function saveState() {
    try {
        const stateToSave = JSON.parse(JSON.stringify(appState));
        const textSavePromises = [];

        // 1. èŠå¤©è®°å½•
        if (stateToSave.chat && stateToSave.chat.contacts) {
            for (const contact of stateToSave.chat.contacts) {
                if (contact.conversation) { // Check if the property exists
    // Always save the current state of the conversation to IndexedDB.
    // This ensures that an empty array overwrites the old data.
    textSavePromises.push(addTextToDB(`conversation_${contact.id}`, contact.conversation));
    // Then, clear it from the skeleton that will be saved to localStorage.
    contact.conversation = [];
}
            }
        }
        // 2. åŠ¨æ€ (Moments)
        if (stateToSave.chat && stateToSave.chat.moments) {
            const moments = stateToSave.chat.moments;
            if (moments.posts && moments.posts.length > 0) textSavePromises.push(addTextToDB('moments_posts', moments.posts));
            if (moments.photos && moments.photos.length > 0) textSavePromises.push(addTextToDB('moments_photos', moments.photos));
            if (moments.albums && moments.albums.length > 0) textSavePromises.push(addTextToDB('moments_albums', moments.albums));
            if (moments.messages && moments.messages.length > 0) textSavePromises.push(addTextToDB('moments_messages', moments.messages));
            if (moments.notifications && moments.notifications.length > 0) textSavePromises.push(addTextToDB('moments_notifications', moments.notifications));
            if (moments.visitors && moments.visitors.length > 0) textSavePromises.push(addTextToDB('moments_visitors', moments.visitors));
            moments.posts = []; moments.photos = []; moments.albums = []; moments.messages = []; moments.notifications = []; moments.visitors = [];
        }
        // 3. éŸ³ä¹ (æ­Œè¯ & è¯„è®º)
        if (stateToSave.music) {
            if (stateToSave.music.lyrics && Object.keys(stateToSave.music.lyrics).length > 0) textSavePromises.push(addTextToDB('music_lyrics', stateToSave.music.lyrics));
            if (stateToSave.music.comments && Object.keys(stateToSave.music.comments).length > 0) textSavePromises.push(addTextToDB('music_comments', stateToSave.music.comments));
            stateToSave.music.lyrics = {}; stateToSave.music.comments = {};
        }
        // 4. èµ„æ–™
        if (stateToSave.data) {
            if (stateToSave.data.worldBooks && stateToSave.data.worldBooks.length > 0) textSavePromises.push(addTextToDB('data_worldbooks', stateToSave.data.worldBooks));
            if (stateToSave.data.archives && stateToSave.data.archives.length > 0) textSavePromises.push(addTextToDB('data_archives', stateToSave.data.archives));
            if (stateToSave.data.infos && stateToSave.data.infos.length > 0) textSavePromises.push(addTextToDB('data_infos', stateToSave.data.infos));
            if (stateToSave.data.savedThemes && stateToSave.data.savedThemes.length > 0) textSavePromises.push(addTextToDB('data_savedthemes', stateToSave.data.savedThemes));
            if (stateToSave.data.savedBubbles && stateToSave.data.savedBubbles.length > 0) textSavePromises.push(addTextToDB('data_savedbubbles', stateToSave.data.savedBubbles));
            stateToSave.data.worldBooks = []; stateToSave.data.archives = []; stateToSave.data.infos = []; stateToSave.data.savedThemes = []; stateToSave.data.savedBubbles = [];
        }
// 5. ä¿¡ç®±
        if (stateToSave.mailbox) {
            if (stateToSave.mailbox.loveLetters && stateToSave.mailbox.loveLetters.length > 0) textSavePromises.push(addTextToDB('mailbox_loveletters', stateToSave.mailbox.loveLetters));
            if (stateToSave.mailbox.postcards && stateToSave.mailbox.postcards.length > 0) textSavePromises.push(addTextToDB('mailbox_postcards', stateToSave.mailbox.postcards));
            stateToSave.mailbox.loveLetters = []; stateToSave.mailbox.postcards = [];
        }
        // 6. æ‰‹è´¦
        if (stateToSave.diary) {
            if (stateToSave.diary.secrets && stateToSave.diary.secrets.length > 0) textSavePromises.push(addTextToDB('diary_secrets', stateToSave.diary.secrets));
            if (stateToSave.diary.collections && stateToSave.diary.collections.length > 0) textSavePromises.push(addTextToDB('diary_collections', stateToSave.diary.collections));
            stateToSave.diary.secrets = []; stateToSave.diary.collections = [];
        }

        await Promise.all(textSavePromises);

        localStorage.setItem(DB_KEYS.SETTINGS, JSON.stringify(stateToSave.settings));
        localStorage.setItem(DB_KEYS.MUSIC, JSON.stringify(stateToSave.music));
        localStorage.setItem(DB_KEYS.BEAUTIFY, JSON.stringify(stateToSave.beautify));
        localStorage.setItem(DB_KEYS.DATA, JSON.stringify(stateToSave.data));
        localStorage.setItem(DB_KEYS.CHAT, JSON.stringify(stateToSave.chat));
        localStorage.setItem(DB_KEYS.MAILBOX, JSON.stringify(stateToSave.mailbox));
        localStorage.setItem(DB_KEYS.DIARY, JSON.stringify(stateToSave.diary));
            localStorage.setItem(DB_KEYS.ENTERTAINMENT, JSON.stringify(stateToSave.entertainment));
            localStorage.setItem(DB_KEYS.ASSETS, JSON.stringify(stateToSave.assets));
        localStorage.setItem(DB_KEYS.META, JSON.stringify(stateToSave.meta));

    } catch (error) {
        console.error("CRITICAL: åˆ†å±‚ä¿å­˜çŠ¶æ€å¤±è´¥:", error);
        console.error("Failing state object:", appState);
        showToast("ä¿å­˜æ•°æ®å¤±è´¥ï¼è¯·æ£€æŸ¥æ§åˆ¶å°ã€‚", 'error');
    }
}
    let saveStateTimer;
    function debouncedSaveState() {
        clearTimeout(saveStateTimer);
        saveStateTimer = setTimeout(() => {
            saveState();
        }, 500); // 500ms delay
    }
    async function loadState() {
    const defaultState = getInitialState();
    
    // --- æ­¥éª¤ 0a: (è¡¥ä¸) æ£€æŸ¥å¹¶åˆå¹¶å› é”®åé”™è¯¯äº§ç”Ÿçš„å­¤å²›æ•°æ® ---
    const patchFlag = 'orphaned_data_merged_v2_1';
    if (!localStorage.getItem(patchFlag)) {
        console.log("æ‰§è¡Œä¸€æ¬¡æ€§æ•°æ®ä¿®å¤è¡¥ä¸...");
        const keyPairs = [
            ['loveletters_all', 'mailbox_loveletters'],
            ['postcards_all', 'mailbox_postcards'],
            ['secrets_all', 'diary_secrets'],
            ['collections_all', 'diary_collections']
        ];
        const mergePromises = [];

        for (const [oldKey, newKey] of keyPairs) {
            const promise = Promise.all([getTextFromDB(oldKey), getTextFromDB(newKey)])
                .then(async ([oldData, newData]) => {
                    const oldItems = oldData || [];
                    const newItems = newData || [];
                    if (oldItems.length > 0) {
                        console.log(`å‘ç°å­¤å²›æ•°æ®: ${oldKey} (${oldItems.length}æ¡)`);
                        const combined = new Map();
                        newItems.forEach(item => combined.set(item.id, item));
                        oldItems.forEach(item => combined.set(item.id, item));
                        const mergedData = Array.from(combined.values());
                        await addTextToDB(newKey, mergedData);
                        await deleteTextFromDB(oldKey);
                        console.log(`æ•°æ®å·²åˆå¹¶åˆ°: ${newKey}`);
                    }
                });
            mergePromises.push(promise);
        }
        await Promise.all(mergePromises);
        localStorage.setItem(patchFlag, 'true');
        showToast("æ•°æ®å·²ä¿®å¤ï¼", "info");
    }
        // --- æ–°å¢ï¼šç”¨æˆ·æ•°æ®ç»“æ„è¿ç§»è¡¥ä¸ (v4) ---
    const userProfileMigrationFlag = 'user_profile_array_migrated_v4';
    if (!localStorage.getItem(userProfileMigrationFlag)) {
        const chatDataJSON = localStorage.getItem(DB_KEYS.CHAT);
        if (chatDataJSON) {
            const chatData = JSON.parse(chatDataJSON);
            // æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ—§çš„ userProfile ä¸”ä¸å­˜åœ¨æ–°çš„ userProfiles
            if (chatData.userProfile && !chatData.userProfiles) {
                console.log("æ­£åœ¨æ‰§è¡Œç”¨æˆ·æ•°æ®ç»“æ„è¿ç§»...");
                const oldProfile = chatData.userProfile;
                const newProfileId = 'default_user_profile_migrated';
                
                // ç¡®ä¿å¾®åšå¯¹è±¡å­˜åœ¨ä¸”ç»“æ„å®Œæ•´
                const defaultWeiboData = getInitialState().chat.userProfiles[0].weibo;
                oldProfile.weibo = { ...defaultWeiboData, ...(oldProfile.weibo || {}) };
                oldProfile.weibo.profile = { ...defaultWeiboData.profile, ...(oldProfile.weibo.profile || {}) };

                // å°†ä¸»é…ç½®åŒæ­¥åˆ°å¾®åšé…ç½®
                oldProfile.weibo.profile.id = newProfileId;
                oldProfile.weibo.profile.name = oldProfile.name;
                oldProfile.weibo.profile.bio = oldProfile.signature; // ç”¨ç­¾åä½œä¸ºç®€ä»‹çš„åˆå§‹å€¼
                oldProfile.weibo.profile.persona = oldProfile.persona;
                oldProfile.weibo.profile.avatarId = oldProfile.avatarId;
                
                // åˆ›å»ºæ–°ç»“æ„
                chatData.userProfiles = [{ ...oldProfile, id: newProfileId }];
                chatData.activeUserProfileId = newProfileId;
                delete chatData.userProfile; // åˆ é™¤æ—§é”®
                
                // å°†æ›´æ–°åçš„æ•°æ®å†™å›localStorage
                localStorage.setItem(DB_KEYS.CHAT, JSON.stringify(chatData));
                showToast('ç”¨æˆ·æ•°æ®ç»“æ„å·²å‡çº§ï¼');
            }
        }
        localStorage.setItem(userProfileMigrationFlag, 'true');
    }
    // --- æ­¥éª¤ 0b: (å·²ä¿®å¤) æ‰§è¡Œä¸€æ¬¡æ€§æ•°æ®è¿ç§» ---
    const migrationFlag = 'full_text_data_migrated_v2';
    if (!localStorage.getItem(migrationFlag)) {
        console.log("å¼€å§‹å°†æ‰€æœ‰æ–‡æœ¬æ•°æ®å®‰å…¨è¿ç§»åˆ°IndexedDB...");
        try {
            const migrationPromises = [];
            const skeletonsToSave = {}; 
            const modulesToMigrate = {
                [DB_KEYS.CHAT]: ['conversation', 'moments'], 
                [DB_KEYS.MUSIC]: ['lyrics', 'comments'],
                [DB_KEYS.DATA]: ['worldBooks', 'archives', 'infos', 'savedThemes', 'savedBubbles'],
                [DB_KEYS.MAILBOX]: ['loveLetters', 'postcards'],
                [DB_KEYS.DIARY]: ['secrets', 'collections']
            };

            for (const [storageKey, dataKeys] of Object.entries(modulesToMigrate)) {
                const moduleJSON = localStorage.getItem(storageKey);
                if (moduleJSON) {
                    const oldModuleState = JSON.parse(moduleJSON);
                    let moduleUpdated = false;
                    for (const key of dataKeys) {
                        if (key === 'moments' && oldModuleState.moments) {
                            const moments = oldModuleState.moments;
                            if (moments.posts?.length > 0) migrationPromises.push(addTextToDB('moments_posts', moments.posts));
                            if (moments.photos?.length > 0) migrationPromises.push(addTextToDB('moments_photos', moments.photos));
                            if (moments.albums?.length > 0) migrationPromises.push(addTextToDB('moments_albums', moments.albums));
                            if (moments.messages?.length > 0) migrationPromises.push(addTextToDB('moments_messages', moments.messages));
                            if (moments.notifications?.length > 0) migrationPromises.push(addTextToDB('moments_notifications', moments.notifications));
                            if (moments.visitors?.length > 0) migrationPromises.push(addTextToDB('moments_visitors', moments.visitors));
                            moments.posts = []; moments.photos = []; moments.albums = []; moments.messages = []; moments.notifications = []; moments.visitors = [];
                            moduleUpdated = true;
                        } else if (key === 'conversation' && oldModuleState.contacts) {
                            for (const contact of oldModuleState.contacts) {
                                if (contact.conversation?.length > 0) {
                                    migrationPromises.push(addTextToDB(`conversation_${contact.id}`, contact.conversation));
                                    contact.conversation = [];
                                    moduleUpdated = true;
                                }
                            }
                        } else if (oldModuleState[key] && (oldModuleState[key].length > 0 || Object.keys(oldModuleState[key]).length > 0)) {
                            migrationPromises.push(addTextToDB(`${storageKey.split('_v2_')[1]}_${key.toLowerCase()}`, oldModuleState[key]));
                            oldModuleState[key] = Array.isArray(oldModuleState[key]) ? [] : {};
                            moduleUpdated = true;
                        }
                    }
                    if (moduleUpdated) {
                        skeletonsToSave[storageKey] = JSON.stringify(oldModuleState);
                    }
                }
            }
            
            const results = await Promise.allSettled(migrationPromises);
            
            let failedMigrations = 0;
            results.forEach(result => {
                if (result.status === 'rejected') {
                    failedMigrations++;
                    console.error("æ•°æ®è¿ç§»å¤±è´¥é¡¹:", result.reason);
                }
            });

            for (const [storageKey, skeletonJSON] of Object.entries(skeletonsToSave)) {
                localStorage.setItem(storageKey, skeletonJSON);
            }

            if (failedMigrations > 0) {
                showToast(`æ•°æ®è¿ç§»å®Œæˆï¼Œ${failedMigrations}ä¸ªé¡¹ç›®å¤±è´¥ã€‚è¯·æ£€æŸ¥æ§åˆ¶å°ã€‚`, 'error');
            } else {
                showToast("æ•°æ®å­˜å‚¨å·²å®Œå…¨å‡çº§ï¼", "info");
            }

            localStorage.setItem(migrationFlag, 'true');
        } catch (e) {
            console.error("å®Œå…¨è¿ç§»å¤±è´¥ï¼Œæ—§æ•°æ®å·²ä¿ç•™åœ¨LocalStorageä¸­ã€‚", e);
            showToast("æ•°æ®è¿ç§»æ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯ï¼è¯·å¯¼å‡ºæ•°æ®å¹¶è”ç³»å¼€å‘è€…ã€‚", "error");
        }
    }
    
    // --- æ­¥éª¤ 1: ä»localStorageåŠ è½½éª¨æ¶çŠ¶æ€ ---
    const moduleKeys = Object.keys(defaultState);
    appState = {};
    for (const moduleName of moduleKeys) {
        if (moduleName === 'chat' && defaultState.chat.userProfile) {
delete defaultState.chat.userProfile; // Don't copy the old key from default
}
        const storageKey = DB_KEYS[moduleName.toUpperCase()];
        const savedModuleJSON = localStorage.getItem(storageKey);
        if (savedModuleJSON) {
            try {
                const savedModule = JSON.parse(savedModuleJSON);
                appState[moduleName] = { ...defaultState[moduleName], ...savedModule };
                if (moduleName === 'settings' && savedModule.globalRealtimeActivity) appState.settings.globalRealtimeActivity = { ...defaultState.settings.globalRealtimeActivity, ...savedModule.globalRealtimeActivity };
                if (moduleName === 'settings' && savedModule.globalContextMemory) appState.settings.globalContextMemory = { ...defaultState.settings.globalContextMemory, ...savedModule.globalContextMemory };
                if (moduleName === 'chat') {
                    if (savedModule.userProfile) appState.chat.userProfile = { ...defaultState.chat.userProfile, ...savedModule.userProfile };
                    if (savedModule.moments) appState.chat.moments = { ...defaultState.chat.moments, ...savedModule.moments };
                    if (savedModule.moments?.profile) appState.chat.moments.profile = { ...defaultState.chat.moments.profile, ...savedModule.moments.profile };
                }
            } catch (e) { appState[moduleName] = defaultState[moduleName]; }
        } else { appState[moduleName] = defaultState[moduleName]; }
    }
    
    // --- æ­¥éª¤ 2: ä»IndexedDBå¼‚æ­¥åŠ è½½æ‰€æœ‰å¤§å‹æ–‡æœ¬æ•°æ® ---
    const textLoadPromises = [];
    if (appState.chat && appState.chat.contacts) {
        for (const contact of appState.chat.contacts) { textLoadPromises.push(getTextFromDB(`conversation_${contact.id}`).then(d => { contact.conversation = d || []; })); }
    }
    textLoadPromises.push(getTextFromDB('moments_posts').then(d => { appState.chat.moments.posts = d || []; }));
    textLoadPromises.push(getTextFromDB('moments_photos').then(d => { appState.chat.moments.photos = d || []; }));
    textLoadPromises.push(getTextFromDB('moments_albums').then(d => { appState.chat.moments.albums = d || []; }));
    textLoadPromises.push(getTextFromDB('moments_messages').then(d => { appState.chat.moments.messages = d || []; }));
    textLoadPromises.push(getTextFromDB('moments_notifications').then(d => { appState.chat.moments.notifications = d || []; }));
    textLoadPromises.push(getTextFromDB('moments_visitors').then(d => { appState.chat.moments.visitors = d || []; }));
    textLoadPromises.push(getTextFromDB('music_lyrics').then(d => { appState.music.lyrics = d || {}; }));
    textLoadPromises.push(getTextFromDB('music_comments').then(d => { appState.music.comments = d || {}; }));
    textLoadPromises.push(getTextFromDB('data_worldbooks').then(d => { appState.data.worldBooks = d || []; }));
    textLoadPromises.push(getTextFromDB('data_archives').then(d => { appState.data.archives = d || []; }));
    textLoadPromises.push(getTextFromDB('data_infos').then(d => { appState.data.infos = d || []; }));
    textLoadPromises.push(getTextFromDB('data_savedthemes').then(d => { appState.data.savedThemes = d || []; }));
    textLoadPromises.push(getTextFromDB('data_savedbubbles').then(d => { appState.data.savedBubbles = d || []; }));
    textLoadPromises.push(getTextFromDB('mailbox_loveletters').then(d => { appState.mailbox.loveLetters = d || []; }));
    textLoadPromises.push(getTextFromDB('mailbox_postcards').then(d => { appState.mailbox.postcards = d || []; }));
    textLoadPromises.push(getTextFromDB('diary_secrets').then(d => { appState.diary.secrets = d || []; }));
    textLoadPromises.push(getTextFromDB('diary_collections').then(d => { appState.diary.collections = d || []; }));
        // --- æ­¥éª¤ 2.5: åŠ è½½å®Œæˆåï¼Œå°†æ¿€æ´»çš„ç”¨æˆ·Profileæ•°æ®åŠ è½½åˆ°å†…å­˜ä¸­çš„appState.chat.userProfile ---
    const activeId = appState.chat.activeUserProfileId || appState.chat.userProfiles[0]?.id;
    const activeProfile = appState.chat.userProfiles.find(p => p.id === activeId) || appState.chat.userProfiles[0];
    if (activeProfile) {
        appState.chat.userProfile = JSON.parse(JSON.stringify(activeProfile));
    } else {
        // Fallback if something went wrong
        appState.chat.userProfile = getInitialState().chat.userProfiles[0];
        appState.chat.userProfiles = [appState.chat.userProfile];
        appState.chat.activeUserProfileId = appState.chat.userProfile.id;
    }
    await Promise.all(textLoadPromises);
    
    // --- æ­¥éª¤ 3: å…¼å®¹æ€§ä¿®å¤ ---
    if (!appState.beautify.bubbleSettings) appState.beautify.bubbleSettings = defaultState.beautify.bubbleSettings;
    if (!Array.isArray(appState.settings.presets)) appState.settings.presets = [];
    if (!appState.chat.emojis) appState.chat.emojis = [];
    if (!appState.chat.userProfile.avatarFrameLibrary) appState.chat.userProfile.avatarFrameLibrary = [];
    if (!appState.chat.userProfile.signature) appState.chat.userProfile.signature = defaultState.chat.userProfile.signature;
    if (!appState.chat.moments.profile) appState.chat.moments.profile = defaultState.chat.moments.profile;
    if (!appState.chat.moments.profile.signature) appState.chat.moments.profile.signature = defaultState.chat.moments.profile.signature;
        
    // --- æ­¥éª¤ 3.5: (è¡¥ä¸) è¿ç§» balance ç»“æ„ ---
        // --- æ–°å¢è¡¥ä¸ï¼šä¸ºå¾®åšä¸ªäººèµ„æ–™æ·»åŠ  persona å­—æ®µ (V2: ä¿®æ­£ä¸ºç•™ç©º) ---
    const weiboPersonaMigrationFlag = 'weibo_persona_migrated_v2';
    if (!localStorage.getItem(weiboPersonaMigrationFlag)) {
        console.log("Applying Weibo persona migration patch (v2)...");
        let patched = false;
        // Patch for user
        if (appState.chat.userProfile.weibo && appState.chat.userProfile.weibo.profile) {
            // æ— è®º persona å­—æ®µæ˜¯å¦å­˜åœ¨ï¼Œéƒ½å°†å…¶è®¾ç½®ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œä»¥è¦†ç›–æ—§çš„é”™è¯¯æ•°æ®
            appState.chat.userProfile.weibo.profile.persona = '';
            patched = true;
        }
        // Patch for characters
        appState.chat.contacts.forEach(contact => {
            if (!contact.isGroup && contact.charSettings.weibo && contact.charSettings.weibo.profile) {
                // åŒæ ·ï¼Œç›´æ¥è®¾ç½®ä¸ºç©ºå­—ç¬¦ä¸²
                contact.charSettings.weibo.profile.persona = '';
                patched = true;
            }
        });

        if (patched) {
            console.log("Weibo persona patch (v2) applied, personas have been cleared.");
        }
        localStorage.setItem(weiboPersonaMigrationFlag, 'true');
    }
    const balanceMigrationFlag = 'balance_structure_migrated_v1';
    if (!localStorage.getItem(balanceMigrationFlag)) {
    
        console.log("æ‰§è¡Œä¸€æ¬¡æ€§ä½™é¢æ•°æ®ç»“æ„è¿ç§»...");
        let migrationPerformed = false;
        
        // è¿ç§» User
        if (appState.chat.userProfile.hasOwnProperty('balance') && !appState.chat.userProfile.hasOwnProperty('cashBalance')) {
            appState.chat.userProfile.cashBalance = appState.chat.userProfile.balance;
            appState.chat.userProfile.bankBalance = 0;
            appState.chat.userProfile.loan = 0;
            appState.chat.userProfile.lastInterestCalc = '';
            delete appState.chat.userProfile.balance;
            migrationPerformed = true;
        }

        // è¿ç§» Chars
        appState.chat.contacts.forEach(contact => {
            if (!contact.isGroup && contact.charSettings && contact.charSettings.hasOwnProperty('balance') && !contact.charSettings.hasOwnProperty('cashBalance')) {
                contact.charSettings.cashBalance = contact.charSettings.balance;
                contact.charSettings.bankBalance = 0;
                contact.charSettings.loan = 0;
                contact.charSettings.lastInterestCalc = '';
                delete contact.charSettings.balance;
                migrationPerformed = true;
            }
        });

        if (migrationPerformed) {
            // ç«‹å³ä¿å­˜ä¸€æ¬¡ä»¥å›ºåŒ–è¿ç§»ç»“æœ
            saveState();
            showToast("è´¦æˆ·ç³»ç»Ÿå·²å‡çº§ï¼", "info");
        }
        localStorage.setItem(balanceMigrationFlag, 'true');
    }
    // --- æ­¥éª¤ 4: æ‰€æœ‰æ•°æ®åŠ è½½å®Œæ¯•åï¼Œæ›´æ–°UI ---
    updateUIFromState();
}

    // ===================================================================
    // --- IndexedDB åª’ä½“å­˜å‚¨ ---
    // ===================================================================
    const IDB_NAME = 'EmperorPhoneMedia_v2';
    const IDB_STORE_NAME = 'mediaStore';
    const IDB_TEXT_STORE_NAME = 'textStore';
    let db;

    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(IDB_NAME, 2); // å‡çº§ç‰ˆæœ¬å·ä»¥è§¦å‘ onupgradeneeded
            request.onerror = (event) => reject("IndexedDB error: " + request.error);
            request.onsuccess = (event) => {
                db = event.target.result;
                resolve(db);
            };
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(IDB_STORE_NAME)) {
                    db.createObjectStore(IDB_STORE_NAME, { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains(IDB_TEXT_STORE_NAME)) {
                    db.createObjectStore(IDB_TEXT_STORE_NAME, { keyPath: 'id' });
                }
            };
        });
    }

    async function addMediaToDB(id, data) { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IDB_STORE_NAME); return new Promise((resolve, reject) => { const request = store.put({ id, data }); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); }
    async function getMediaFromDB(id) { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_STORE_NAME], 'readonly'); const store = transaction.objectStore(IDB_STORE_NAME); return new Promise((resolve, reject) => { const request = store.get(id); request.onsuccess = () => resolve(request.result ? request.result.data : null); request.onerror = () => reject(request.error); }); }
    async function deleteMediaFromDB(id) { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IDB_STORE_NAME); return new Promise((resolve, reject) => { const request = store.delete(id); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); }
    async function getAllMediaFromDB() { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_STORE_NAME], 'readonly'); const store = transaction.objectStore(IDB_STORE_NAME); return new Promise((resolve, reject) => { const request = store.getAll(); request.onsuccess = () => resolve(request.result); request.onerror = () => reject(request.error); }); }
async function clearMediaDB() { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IDB_STORE_NAME); return new Promise((resolve, reject) => { const request = store.clear(); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); }
async function addTextToDB(id, data) { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_TEXT_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IDB_TEXT_STORE_NAME); return new Promise((resolve, reject) => { const request = store.put({ id, data }); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); }
async function getTextFromDB(id) { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_TEXT_STORE_NAME], 'readonly'); const store = transaction.objectStore(IDB_TEXT_STORE_NAME); return new Promise((resolve, reject) => { const request = store.get(id); request.onsuccess = () => resolve(request.result ? request.result.data : null); request.onerror = () => reject(request.error); }); }
async function getAllTextFromDB() { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_TEXT_STORE_NAME], 'readonly'); const store = transaction.objectStore(IDB_TEXT_STORE_NAME); return new Promise((resolve, reject) => { const request = store.getAll(); request.onsuccess = () => resolve(request.result); request.onerror = () => reject(request.error); }); }
async function clearTextDB() { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_TEXT_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IDB_TEXT_STORE_NAME); return new Promise((resolve, reject) => { const request = store.clear(); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); }
async function deleteTextFromDB(id) { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_TEXT_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IDB_TEXT_STORE_NAME); return new Promise((resolve, reject) => { const request = store.delete(id); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); }
function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}
async function getMediaURL(id) {
// æ ¸å¿ƒä¼˜åŒ–ï¼šå¦‚æœIDæœ¬èº«å°±æ˜¯URLï¼Œç›´æ¥è¿”å›å®ƒ
if (!id || id === 'default' || id.startsWith('http') || id.startsWith('data:')) {
    return id;
}
// æ£€æŸ¥å†…å­˜ç¼“å­˜
if (runtimeState.mediaObjectURLs.has(id)) {
    return runtimeState.mediaObjectURLs.get(id);
}
// ä»IndexedDBè¯»å–
try {
    const data = await getMediaFromDB(id);
    if (data) {
        const blob = (data instanceof Blob) ? data : new Blob([data]);
        const url = URL.createObjectURL(blob);
        runtimeState.mediaObjectURLs.set(id, url);
        return url;
    }
    return null;
} catch (error) {
    console.error(`Failed to get media URL for ${id}:`, error);
    return null;
}}
    async function setElementImage(element, id, property = 'backgroundImage') {
    if (!element) return;
    const url = await getMediaURL(id);
    if (url) {
        if (property === 'src') {
            // å¯¹äº <img> æ ‡ç­¾ï¼Œä½¿ç”¨æµè§ˆå™¨åŸç”Ÿæ‡’åŠ è½½
            element.loading = 'lazy';
            element.src = url;
        } else {
            // å¯¹äºèƒŒæ™¯å›¾ç‰‡ï¼Œä½¿ç”¨ IntersectionObserver
            element.dataset.src = url;
            lazyLoadElement(element);
        }
    } else {
        // å¦‚æœURLæ— æ•ˆï¼Œæ¸…ç©ºå±æ€§
        if (property === 'src') {
            element.src = '';
        } else {
            element.style.backgroundImage = 'none';
        }
    }
}

    // ===================================================================
// --- ç»Ÿä¸€å¤‡ä»½ä¸æ¢å¤ ---
// ===================================================================
function downloadFile(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(url);
    a.remove();
}

// è¾…åŠ©å‡½æ•°ï¼šæ·±åº¦éå†appStateå¯¹è±¡ï¼Œæ”¶é›†æ‰€æœ‰è¢«å¼•ç”¨çš„åª’ä½“ID
function findAllMediaIds(obj) {
    const ids = new Set();
    // åŒ¹é…æ‰€æœ‰è‡ªå®šä¹‰IDå‰ç¼€çš„æ­£åˆ™è¡¨è¾¾å¼
    const prefixRegex = /^(wp|font|icon|bubble|data_avatar|emoji|lib|image|moment_img|moment_photo|postcard_reply_img|postcard_new_img|video_bg)_/;

    function traverse(current) {
        if (!current) return;

        if (Array.isArray(current)) {
            current.forEach(traverse);
        } else if (typeof current === 'object') {
            Object.values(current).forEach(traverse);
        } else if (typeof current === 'string') {
            // å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²å€¼ä¸æ˜¯URLä¸”åŒ¹é…IDæ ¼å¼ï¼Œåˆ™å°†å…¶è§†ä¸ºåª’ä½“ID
            if (!current.startsWith('http') && !current.startsWith('data:') && prefixRegex.test(current)) {
                ids.add(current);
            }
        }
    }

    traverse(obj);
    return ids;
}

getEl('export-all-btn').addEventListener('click', async () => {
showToast('æ­£åœ¨å‡†å¤‡å¯¼å‡º...', 'info');
try {
    const zip = new JSZip();

    // 1. æ·»åŠ è½»é‡åŒ–çš„é…ç½®æ–‡ä»¶ (ä¸å«å¤§å‹æ–‡æœ¬æ•°æ®)
    const lightState = JSON.parse(JSON.stringify(appState));
    // æ¸…ç†å‰¯æœ¬ä¸­çš„å¤§å‹æ•°æ®ï¼Œå› ä¸ºå®ƒä»¬å°†ä»IDBä¸­å•ç‹¬å¯¼å‡º
    if (lightState.chat && lightState.chat.contacts) {
        lightState.chat.contacts.forEach(c => { c.conversation = []; });
    }
    if (lightState.mailbox) {
        lightState.mailbox.loveLetters = [];
        lightState.mailbox.postcards = [];
    }
    if (lightState.diary) {
        lightState.diary.secrets = [];
        lightState.diary.collections = [];
    }
    const configStr = JSON.stringify(lightState);
    zip.file('config.json', configStr);

    // 2. å¯¼å‡ºæ‰€æœ‰åª’ä½“æ–‡ä»¶
    showToast('æ­£åœ¨å‹ç¼©åª’ä½“æ–‡ä»¶...', 'info');
    const allMedia = await getAllMediaFromDB();
    if (allMedia.length > 0) {
        const mediaFolder = zip.folder('media');
        allMedia.forEach(item => {
            mediaFolder.file(item.id, item.data);
        });
    }
    
    // 3. å¯¼å‡ºæ‰€æœ‰æ–‡æœ¬æ•°æ®
    showToast('æ­£åœ¨å‹ç¼©æ–‡æœ¬æ•°æ®...', 'info');
    const allTextData = await getAllTextFromDB();
    if (allTextData.length > 0) {
        const textFolder = zip.folder('text');
        allTextData.forEach(item => {
            textFolder.file(`${item.id}.json`, JSON.stringify(item.data));
        });
    }

    // 4. ç”Ÿæˆå¹¶ä¸‹è½½ZIPæ–‡ä»¶
    showToast('æ­£åœ¨ç”Ÿæˆå‹ç¼©åŒ…...', 'info');
    const content = await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: {
            level: 6 
        }
    });
    
    downloadFile(content, `EmperorPhone-FullBackup-${new Date().toISOString().slice(0, 10)}.zip`);
    showToast('å…¨éƒ¨æ•°æ®å¯¼å‡ºæˆåŠŸï¼', 'info');
} catch (error) {
    showToast('å¯¼å‡ºå¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°è·å–è¯¦æƒ…', 'error');
    console.error("Full export failed:", error);
}
});

getEl('import-all-btn').addEventListener('click', () => {
    importFileInput.accept = '.zip';
    importFileInput.onchange = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (confirm("ã€æœ€é«˜è­¦å‘Šã€‘\n\næ­¤æ“ä½œå°†å½»åº•è¦†ç›–æ‚¨å½“å‰çš„æ‰€æœ‰é…ç½®ã€è®°å½•å’Œåª’ä½“æ–‡ä»¶ï¼\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ")) {
        showToast('æ­£åœ¨å¯¼å…¥ï¼Œè¯·å‹¿æ“ä½œ...', 'info');
        try {
            const zip = await JSZip.loadAsync(file);
            
            // 1. æ¸…ç©ºç°æœ‰æ•°æ®åº“
            showToast('æ­£åœ¨æ¸…ç©ºæ—§æ•°æ®...', 'info');
            await Promise.all([clearMediaDB(), clearTextDB()]);

            // 2. éªŒè¯å¹¶è¯»å–é…ç½®æ–‡ä»¶
            const configFile = zip.file('config.json');
            if (!configFile) throw new Error('å‹ç¼©åŒ…å†…æœªæ‰¾åˆ° "config.json" é…ç½®æ–‡ä»¶ã€‚');
            const configStr = await configFile.async('string');
            const importedState = JSON.parse(configStr);

            // 3. åº”ç”¨æ–°çš„é…ç½®åˆ° localStorage
            const modulesToImport = getInitialState();
            for (const moduleName in modulesToImport) {
                const storageKey = DB_KEYS[moduleName.toUpperCase()];
                if (storageKey && importedState[moduleName]) {
                    localStorage.setItem(storageKey, JSON.stringify(importedState[moduleName]));
                }
            }

            // 4. å¯¼å…¥åª’ä½“å’Œæ–‡æœ¬æ–‡ä»¶åˆ° IndexedDB
            const importPromises = [];
            const mediaFolder = zip.folder("media");
            if (mediaFolder) {
                mediaFolder.forEach((relativePath, zipEntry) => {
                    if (!zipEntry.dir) {
                        importPromises.push(
                            zipEntry.async('blob').then(blobData => addMediaToDB(zipEntry.name, blobData))
                        );
                    }
                });
            }
            const textFolder = zip.folder("text");
            if (textFolder) {
                textFolder.forEach((relativePath, zipEntry) => {
                    if (!zipEntry.dir) {
                        importPromises.push(
                            zipEntry.async('string').then(textData => {
                                const id = zipEntry.name.replace('.json', '');
                                addTextToDB(id, JSON.parse(textData));
                            })
                        );
                    }
                });
            }
            
            showToast('æ­£åœ¨å†™å…¥æ•°æ®...', 'info');
            await Promise.all(importPromises);

            showToast('å¯¼å…¥æˆåŠŸï¼åº”ç”¨å³å°†åˆ·æ–°...', 'info');
            setTimeout(() => window.location.reload(), 1500);

        } catch (error) {
            showToast(`å¯¼å…¥å¤±è´¥: ${error.message}`, 'error');
            console.error("Full import failed:", error);
        }
    }
    importFileInput.value = '';
};
    importFileInput.click();
});
function getNextApiKey() {
    const apiKeyString = appState.settings.apiKey || '';
    if (!apiKeyString.includes(',')) {
        return apiKeyString; // Return the single key if no comma
    }

    const keys = apiKeyString.split(',').map(k => k.trim()).filter(Boolean);
    if (keys.length === 0) {
        return '';
    }

    // Ensure index is within bounds
    if (runtimeState.apiKeyIndex >= keys.length) {
        runtimeState.apiKeyIndex = 0;
    }

    const keyToUse = keys[runtimeState.apiKeyIndex];
    
    // Increment index for the next call, wrapping around if necessary
    runtimeState.apiKeyIndex = (runtimeState.apiKeyIndex + 1) % keys.length;

    return keyToUse;
}

    // ===================================================================
    // --- åŸºç¡€ UI & ç³»ç»ŸåŠŸèƒ½ ---
    // ===================================================================
    function updateTime() { const now = new Date(); timeEl.textContent = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`; }
async function updateBattery() { try { if ('getBattery' in navigator) { const battery = await navigator.getBattery(); const update = async () => { const level = Math.floor(battery.level * 100); batteryLevelEl.textContent = `${level}%`; const isCharging = battery.charging; batteryIconEl.dataset.iconId = isCharging ? 'status-battery-charging' : 'status-battery-default'; const customIconId = appState.beautify.icons[batteryIconEl.dataset.iconId]; if (customIconId) { await setElementImage(batteryIconEl.querySelector('img') || batteryIconEl, customIconId, 'src'); } else { batteryIconEl.innerHTML = isCharging ? '<i class="fa-solid fa-battery-empty"></i>' : '<i class="fa-solid fa-battery-full"></i>'; } }; await update(); battery.addEventListener('levelchange', update); battery.addEventListener('chargingchange', update); } else { throw new Error("getBattery not supported"); } } catch (error) { batteryLevelEl.textContent = '100%'; batteryIconEl.dataset.iconId = 'status-battery-default'; const customIconId = appState.beautify.icons['status-battery-default']; if (customIconId) { await setElementImage(batteryIconEl.querySelector('img') || batteryIconEl, customIconId, 'src'); } else { batteryIconEl.innerHTML = '<i class="fa-solid fa-battery-full"></i>'; } } }    let toastTimer;
    function showToast(message, type = 'info') { toastEl.textContent = message; toastEl.className = `show ${type}`; clearTimeout(toastTimer); toastTimer = setTimeout(() => toastEl.classList.remove('show'), 2500); }
    function truncateText(text, maxLength) {
        if (typeof text !== 'string' || text.length <= maxLength) {
            return text;
        }
        let truncated = text.substring(0, maxLength);
        const lastChar = truncated.slice(-1);
        const punctuation = /[ï¼Œã€‚ï¼ï¼Ÿã€ï¼›ï¼š,.;?!]/;
        if (punctuation.test(lastChar)) {
            return truncated.slice(0, -1) + 'â€¦';
        } else {
            return truncated + 'â€¦';
        }
    }
    function getDisplayLength(str) { let len = 0; for (let i = 0; i < str.length; i++) { len += str.charCodeAt(i) > 255 ? 2 : 1; } return len; }
    function queueNotification(content, contactId, senderId, type = 'chat') { if (type === 'chat' && singleChatScreen.classList.contains('active') && runtimeState.currentChatId === contactId) { return; } if (type === 'moments' && query('#chat-app-screen .tab-link[data-tab="moments"]')?.classList.contains('active')) { return; } runtimeState.notificationQueue.push({ content, contactId, senderId, type }); processNotificationQueue(); }
    function processNotificationQueue() { if (runtimeState.isNotificationVisible || runtimeState.notificationQueue.length === 0) return; runtimeState.isNotificationVisible = true; const { content, contactId, senderId, type } = runtimeState.notificationQueue.shift(); const sender = findUserById(senderId); let message; if (type === 'chat') { const contact = appState.chat.contacts.find(c => c.id === contactId); const senderName = contact?.isGroup ? (contact.groupSettings.members[senderId]?.nickname || sender.name) : sender.name; message = `${senderName}: ${content}`; } else { message = content; } const displayMsg = truncateText(message, 20); const banner = document.createElement('div'); banner.className = 'notification-banner'; banner.textContent = displayMsg; banner.dataset.contactId = contactId; banner.dataset.type = type; notificationContainer.appendChild(banner); setTimeout(() => banner.classList.add('show'), 50); const dismiss = () => { banner.classList.remove('show'); const timer = setTimeout(() => { banner.remove(); runtimeState.isNotificationVisible = false; processNotificationQueue(); }, 400); banner.addEventListener('transitionend', () => { clearTimeout(timer); banner.remove(); runtimeState.isNotificationVisible = false; processNotificationQueue(); }, { once: true }); }; const handleClick = (event) => {
                    event.stopPropagation(); const id = banner.dataset.contactId; const notifType = banner.dataset.type; if (notifType === 'moments') { openApp(chatAppScreen); query('#chat-app-screen .tab-link[data-tab="moments"]').click(); } else if (id && id !== 'null' && id !== 'system') { openApp(chatAppScreen); openSingleChat(id); } dismiss(); }; banner.addEventListener('click', handleClick); setTimeout(dismiss, 5000); }

function showPersistentNotification(id, title, details) {
    let banner = getEl(id);
    
    // å¦‚æœæ¨ªå¹…å·²å­˜åœ¨ï¼Œåˆ™åªæ›´æ–°å†…å®¹
    if (banner) {
        banner.querySelector('strong').textContent = title;
        banner.querySelector('.details').textContent = details;
        return; // ä¸æ‰§è¡Œåˆ›å»ºå’ŒåŠ¨ç”»é€»è¾‘
    }

    // å¦‚æœæ¨ªå¹…ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºæ–°çš„
    banner = document.createElement('div');
    banner.id = id;
    banner.className = 'notification-banner persistent';
    banner.innerHTML = `
        <div class="content">
            <strong>${title}</strong>
            <div class="details">${details}</div>
        </div>`;
    
    notificationContainer.appendChild(banner);
    setTimeout(() => banner.classList.add('show'), 50);

    let startY, initialY;
    const dismissThreshold = -50; // ä¸Šæ»‘50åƒç´ å³å¯å…³é—­

    const onPointerDown = (e) => {
        e.stopPropagation();
        banner.style.transition = 'none';
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        initialY = banner.getBoundingClientRect().top;
        
        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerup', onPointerUp, { once: true });
    };

    const onPointerMove = (e) => {
        const currentY = e.touches ? e.touches[0].clientY : e.clientY;
        const diffY = currentY - startY;
        // åªå…è®¸ä¸Šæ»‘
        if (diffY < 0) {
            banner.style.transform = `translateY(${diffY}px)`;
        }
    };

    const onPointerUp = (e) => {
        document.removeEventListener('pointermove', onPointerMove);
        banner.style.transition = 'transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease-out';
        
        const currentY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
        const diffY = currentY - startY;

        if (diffY < dismissThreshold) {
            banner.classList.remove('show');
            setTimeout(() => banner.remove(), 400);
        } else {
            // Return to original position if not swiped enough
            banner.style.transform = 'translateY(0)';
        }
    };

    banner.addEventListener('pointerdown', onPointerDown);
}
    // ===================================================================
    // --- APPå¯¼èˆªä¸è·¯ç”± ---
    // ===================================================================
        function openApp(appScreen) {
        if (appScreen.id === 'diary-app-screen') {
            handleDiaryTabChange('anniversary'); // å…³é”®ä¿®å¤ï¼šç¡®ä¿æ‰“å¼€æ—¶æ¸²æŸ“æ—¥å†
        } appScreen.classList.add('active'); if (appScreen.id === 'beautify-app-screen') { const activeTab = query('#beautify-app-screen .tab-link.active')?.dataset.tab || 'wallpaper'; handleBeautifyTabChange(activeTab); } else if (appScreen.id === 'data-app-screen') { const activeTab = query('#data-app-screen .tab-link.active')?.dataset.tab || 'world-book'; handleDataTabChange(activeTab); 
    } else if (appScreen.id === 'settings-app-screen') {
                            renderGlobalRealtimeSettings();
                // æ ¸å¿ƒä¿®å¤ï¼šå½“è¿”å›è®¾ç½®åº”ç”¨æ—¶ï¼Œå¦‚æœè®°å¿†æ ‡ç­¾é¡µæ˜¯æ¿€æ´»çŠ¶æ€ï¼Œåˆ™å¼ºåˆ¶åˆ·æ–°å®ƒ
                const activeTab = appScreen.querySelector('.app-bottom-tabs .tab-link.active');
                if (activeTab && activeTab.dataset.tab === 'memory') {
                    renderMemoryTable(runtimeState.memoryViewCharId);
                }
                } else if (appScreen.id === 'assets-app-screen') {
            const activeTab = assetsAppScreen.querySelector('.app-bottom-tabs .tab-link.active');
            if (activeTab) {
                handleAssetsTabChange(activeTab.dataset.tab);
            }
        } }
    function closeCurrentApp() { const activeApp = document.querySelector('.app-screen.active:not(.sub-screen)'); if (activeApp) { if (activeApp.id === 'chat-app-screen' && activeApp.classList.contains('selection-mode')) exitContactSelectionMode(); activeApp.classList.remove('active'); phoneScreen.classList.remove('app-open'); } }
    window.closeCurrentApp = closeCurrentApp;
    function closeAllScreens() { queryAll('.app-screen.active').forEach(screen => screen.classList.remove('active')); phoneScreen.classList.remove('app-open'); }
    function openSubScreen(subScreen, parentScreen) { parentScreen.classList.add('parent-hidden'); subScreen.classList.add('active'); }
    function closeSubScreen(subScreen, parentScreen) { subScreen.classList.remove('active'); parentScreen.classList.remove('parent-hidden'); if (parentScreen.id === 'single-chat-screen') { updateSingleChatUI(); } }
    function setupAppNavigation() { getEl('settings-app-btn').addEventListener('click', () => openApp(settingsAppScreen)); getEl('music-app-btn').addEventListener('click', () => openApp(musicAppScreen)); getEl('beautify-app-btn').addEventListener('click', () => openApp(beautifyAppScreen));
      getEl('shop-app-btn').addEventListener('click', () => openApp(shopAppScreen));
        getEl('diary-app-btn').addEventListener('click', () => openApp(diaryAppScreen));
        getEl('mail-app-btn').addEventListener('click', () => { openApp(mailAppScreen); handleMailTabChange('love-letter'); }); getEl('data-app-btn').addEventListener('click', () => openApp(dataAppScreen));getEl('assets-app-btn').addEventListener('click', () => openApp(assetsAppScreen)); getEl('entertainment-app-btn').addEventListener('click', () => openApp(entertainmentAppScreen));
    getEl('weibo-app-btn').addEventListener('click', () => { openApp(weiboAppScreen); handleWeiboTabChange('weibo-main'); }); getEl('chat-app-btn').addEventListener('click', () => { openApp(chatAppScreen); renderMessageList(); }); }

    // ===================================================================
    // --- è®¾ç½® APP ---
    // ===================================================================
    function initializeContactSettings(contact) { const deepCopy = (obj) => JSON.parse(JSON.stringify(obj)); const userProfileDefaults = appState.chat.userProfile; if (!contact.userSettings) { 
    contact.userSettings = {
        bubbleCss: '',
        ...deepCopy(userProfileDefaults),
        bubbleCssUser: '',
        bubbleCssChar: ''
    };
} else { for (const key in userProfileDefaults) { if (!contact.userSettings.hasOwnProperty(key)) { contact.userSettings[key] = deepCopy(userProfileDefaults[key]); } } } if (!contact.userSettings.avatarLibrary) { contact.userSettings.avatarLibrary = []; } if (typeof contact.userSettings.videoBackgroundId === 'undefined') { contact.userSettings.videoBackgroundId = ''; }         if (typeof contact.userSettings.bubbleCss === 'undefined') {
            contact.userSettings.bubbleCss = '';
}
if (!contact.userSettings.videoBackgroundLibrary) {
    contact.userSettings.videoBackgroundLibrary = [];
}if (contact.isGroup) { if (!contact.groupSettings) { contact.groupSettings = { name: contact.name, avatarId: '', avatarLibrary: [], chatBackgroundId: 'default', videoBackgroundId: '', linkedWorldBooks: [], contextMemory: 99, owner: 'user', admins: [], isMuted: false, isDisbanded: false, members: {} }; } if (!contact.groupSettings.chatBackgroundId) contact.groupSettings.chatBackgroundId = 'default'; if (typeof contact.groupSettings.videoBackgroundId === 'undefined') { contact.groupSettings.videoBackgroundId = ''; } if (typeof contact.groupSettings.lastAnniversaryCelebrated === 'undefined') { contact.groupSettings.lastAnniversaryCelebrated = ''; } const allMemberIds = ['user', ...contact.members]; allMemberIds.forEach(memberId => { if (!contact.groupSettings.members[memberId]) { if (memberId === 'user') { contact.groupSettings.members['user'] = {
        nickname: contact.userSettings.name,
        title: 'çš‡å¸',
        avatarId: contact.userSettings.avatarId,
        avatarFrameId: contact.userSettings.avatarFrameId,
        persona: contact.userSettings.persona // Also sync persona for consistency
    };
     } else { const char = appState.chat.contacts.find(c => c.id === memberId); if (char) { contact.groupSettings.members[memberId] = { ...deepCopy(char.charSettings), nickname: char.name, title: 'æˆå‘˜', isMuted: false }; } } } }); } else { if (!contact.charSettings) { contact.charSettings = { name: contact.name, linkedWorldBooks: [], avatarId: contact.avatarId, avatarLibrary: [contact.avatarId], avatarFrameId: '', chatBackgroundId: 'default', videoBackgroundId: '', videoBackgroundLibrary: [], contextMemory: 99, persona: 'è¿™æ˜¯ä¸€ä¸ªé»˜è®¤äººè®¾ã€‚', isFriend: true, realtimeActivity: { enabled: false, interval: 30 }, momentsCoverId: '', momentsAvatarId: '' , visitors: [], hasHadFirstChat: false, moments: { photos: [], albums: [] }, balance: 1000000.00 }; } contact.charSettings.relationship = 'æœ‹å‹'; /* æ–°å¢å­—æ®µå¹¶è®¾ç½®é»˜è®¤å€¼*/ if (!contact.charSettings.contextMemory) {
    contact.charSettings.contextMemory = appState.settings.globalContextMemory.count;
} if (typeof contact.charSettings.lastAnniversaryCelebrated === 'undefined') { contact.charSettings.lastAnniversaryCelebrated = ''; }
                                             if (!contact.charSettings.memory) { contact.charSettings.memory = []; }
if (!contact.charSettings.moments) { contact.charSettings.moments = { photos: [], albums: [] }; } if (typeof contact.charSettings.cashBalance === 'undefined') {
    contact.charSettings.cashBalance = 1000000.00;
    contact.charSettings.bankBalance = 0;
    contact.charSettings.loan = 0;
    contact.charSettings.lastInterestCalc = '';
} if (!contact.charSettings.chatBackgroundId) { contact.charSettings.chatBackgroundId = 'default'; } if (typeof contact.charSettings.videoBackgroundId === 'undefined') { contact.charSettings.videoBackgroundId = ''; } if (!contact.charSettings.realtimeActivity) { contact.charSettings.realtimeActivity = { enabled: false, interval: 30 }; } if (typeof contact.charSettings.hasHadFirstInteraction === 'undefined') { contact.charSettings.hasHadFirstInteraction = false; }
                                   // --- æ–°å¢ï¼šæƒ…ä¹¦å¼€å…³ ---
                if (typeof contact.charSettings.proactiveLoveLettersEnabled === 'undefined') {
                    contact.charSettings.proactiveLoveLettersEnabled = true; // é»˜è®¤å¼€å¯ä»¥å…¼å®¹æ—§å­˜æ¡£
                }
// --- æ–°å¢ï¼šæ˜ä¿¡ç‰‡è®¡æ•°å™¨ ---
                    if (typeof contact.charSettings.realtimeTicksSincePostcard === 'undefined') {
                        contact.charSettings.realtimeTicksSincePostcard = 0;
                        contact.charSettings.nextPostcardTickTarget = Math.floor(Math.random() * 5) + 1;
                    }
                    // --- ç»“æŸæ–°å¢ ---
                    if (typeof contact.charSettings.momentsCoverId === 'undefined') { contact.charSettings.momentsCoverId = ''; } if (contact.userSettings.name === userProfileDefaults.name) { contact.userSettings.name = 'ä½ '; } if (contact.userSettings.persona === userProfileDefaults.persona) { contact.userSettings.persona = 'è¿™æ˜¯ä¸€ä¸ªé»˜è®¤çš„Useräººè®¾ã€‚'; } }
        if (!contact.isGroup && !contact.charSettings.weibo) {
            contact.charSettings.weibo = {
                profile: {
                    name: contact.charSettings.name,
                    bio: 'è¿™ä¸ªäººå¾ˆæ‡’ï¼Œä»€ä¹ˆéƒ½æ²¡å†™...',
                    persona: 'è¿™ä¸ªäººå¾ˆæ‡’ï¼Œä»€ä¹ˆéƒ½æ²¡å†™...',
                    avatarId: contact.charSettings.avatarId,
                    coverId: 'default_moments_cover',
                },
                posts: [],
                followingIds: [],
                followerIds: []
            };
        }
    }
                    function updateUIFromState() { getEl('api-url').value = appState.settings.apiUrl || ''; getEl('api-key').value = appState.settings.apiKey || '';getEl('global-context-memory').value = appState.settings.globalContextMemory.count; updateModelSelect(); updatePresetSelect(); renderMusicList(); updatePlaybackModeIcon(); applyAllCustomizations(); }
    async function applyAllCustomizations() { await applyWallpaperById(appState.beautify.currentWallpaperId, phoneScreen); document.documentElement.style.setProperty('--system-font-color', appState.beautify.fontColor); await loadAllCustomFonts(); applyFont(appState.beautify.currentFont, true); Object.keys(appState.beautify.icons).forEach(iconId => { applyIconChange(iconId, appState.beautify.icons[iconId], true); }); Object.keys(bubbleNameMap).forEach(bubbleId => { applyBubbleChange(bubbleId, true); });applyCustomThemes(); applyAllCustomBubbleStyles();}
function applyAllCustomBubbleStyles() {
const existingStyle = document.getElementById('custom-bubble-styles');
if (existingStyle) existingStyle.remove();
let finalCss = '';
appState.chat.contacts.forEach(contact => {
    const rawCss = contact.userSettings.bubbleCss;
    if (rawCss) {
        let generatedRules = '';
        const baseSelector = `#single-chat-screen[data-contact-id="${contact.id}"] .message-bubble`;

        const bgImageMatch = rawCss.match(/@background-image:\s*url\(([^)]+)\);/);
        if (bgImageMatch) {
            generatedRules += `${baseSelector} { background-image: url(${bgImageMatch[1].trim()}) !important; background-size: cover !important; background-position: center !important; border: none !important; }\n`;
        }

        const fontFamilyMatch = rawCss.match(/@font-family:\s*([^;]+);/);
    if (fontFamilyMatch) {
        const fontName = fontFamilyMatch[1].trim();
        const finalFontFamily = fontName.toLowerCase() === 'default' 
            ? 'var(--system-font-family)'
            : `"${fontName}"`;
        generatedRules += `${baseSelector}, ${baseSelector} * { font-family: ${finalFontFamily} !important; }\n`;
    }

        const fontSizeMatch = rawCss.match(/@font-size:\s*([^;]+);/);
        if (fontSizeMatch) {
            generatedRules += `${baseSelector} { font-size: ${fontSizeMatch[1].trim()} !important; }\n`;
        }
        
        const colorMatch = rawCss.match(/@color:\s*([^;]+);/);
        if (colorMatch && colorMatch[1].trim().toLowerCase() !== 'unset') {
            generatedRules += `${baseSelector} { color: ${colorMatch[1].trim()} !important; }\n`;
        }
        
        const userCss = rawCss.replace(/@[\w-]+\s*:[^;]+;/g, '').trim();
        const scopedUserCss = processAndScopeCss(userCss, `#single-chat-screen[data-contact-id="${contact.id}"]`);

        finalCss += generatedRules + scopedUserCss + '\n';
    }
});

if (finalCss) {
    const style = document.createElement('style');
    style.id = 'custom-bubble-styles';
    style.textContent = finalCss;
    document.head.appendChild(style);
}
}
    getEl('api-url').addEventListener('input', () => { appState.settings.apiUrl = getEl('api-url').value.trim(); debouncedSaveState(); });
    getEl('api-key').addEventListener('input', () => { appState.settings.apiKey = getEl('api-key').value.trim(); debouncedSaveState(); });
    confirmApiBtn.addEventListener('click', async () => { if (!appState.settings.apiUrl) return showToast("è¯·è¾“å…¥åä»£åœ°å€", 'error'); confirmApiBtn.textContent = 'åŠ è½½ä¸­...'; confirmApiBtn.disabled = true; try {
                const apiUrl = appState.settings.apiUrl;
                const apiKey = getNextApiKey(); // Use the key manager
                let models = [];

                if (apiUrl.includes('generativelanguage.googleapis.com')) {
                    // Google Gemini API Logic
                    const response = await fetch(`https://cors.eu.org/${apiUrl}/v1beta/models?key=${apiKey}`);
                    if (!response.ok) throw new Error(`Google API Error: ${response.status} ${await response.text()}`);
                    const data = await response.json();
                    models = data.models
                        .filter(model => model.name.includes('gemini') && model.supportedGenerationMethods.includes('generateContent'))
                        .map(model => model.name.replace('models/', ''))
                        .sort();
                } else {
                    // OpenAI-compatible API Logic
                    const response = await fetch(`${apiUrl}/v1/models`, { headers: { 'Authorization': `Bearer ${apiKey}` } });
                    if (!response.ok) throw new Error(`API Error: ${response.status}`);
                    const data = await response.json();
                    models = data.data.map(model => model.id).sort();
                }
                
                appState.settings.availableModels = models;
                showToast("æ¨¡å‹åŠ è½½æˆåŠŸï¼");
            } catch (error) {
                console.error("åŠ è½½æ¨¡å‹å¤±è´¥:", error);
                showToast(`åŠ è½½æ¨¡å‹å¤±è´¥: ${error.message}`, 'error');
                appState.settings.availableModels = [];
            } finally {
                debouncedSaveState();
                updateModelSelect();
                confirmApiBtn.textContent = 'åŠ è½½æ¨¡å‹';
                confirmApiBtn.disabled = false;
            } });
    function updateModelSelect() {
    if (appState.settings.availableModels.length === 0) {
        modelSelect.innerHTML = '<option value="">è¯·å…ˆåŠ è½½æ¨¡å‹</option>';
    } else {
        const optionsHTML = appState.settings.availableModels.map(modelId => {
            const isSelected = modelId === appState.settings.selectedModel;
            return `<option value="${escapeHTML(modelId)}"${isSelected ? ' selected' : ''}>${escapeHTML(modelId)}</option>`;
        }).join('');
        modelSelect.innerHTML = optionsHTML;
    }
}
    modelSelect.addEventListener('change', () => { appState.settings.selectedModel = modelSelect.value; debouncedSaveState(); });
    function updatePresetSelect() { presetSelect.innerHTML = '<option value="">æ— </option>'; appState.settings.presets.forEach((preset, index) => { const option = document.createElement('option'); option.value = index; option.textContent = preset.name; presetSelect.appendChild(option); }); }
    presetSelect.addEventListener('change', () => { const index = presetSelect.value; if (index !== "") { const preset = appState.settings.presets[parseInt(index)]; if (preset) { appState.settings.apiUrl = getEl('api-url').value = preset.url; appState.settings.apiKey = getEl('api-key').value = preset.key; appState.settings.selectedModel = preset.model; debouncedSaveState(); updateModelSelect(); showToast(`å·²åŠ è½½é¢„è®¾: ${preset.name}`); } } });
    savePresetBtn.addEventListener('click', () => { const presetName = prompt("è¯·è¾“å…¥é¢„è®¾åç§°:"); if (!presetName || presetName.trim() === "") return; const trimmedName = presetName.trim(); const existingIndex = appState.settings.presets.findIndex(p => p.name === trimmedName); if (existingIndex !== -1) { if (!confirm(`å·²å­˜åœ¨åä¸º "${trimmedName}" çš„é¢„è®¾ï¼Œè¦è¦†ç›–å®ƒå—ï¼Ÿ`)) return; appState.settings.presets[existingIndex] = { name: trimmedName, url: appState.settings.apiUrl, key: appState.settings.apiKey, model: appState.settings.selectedModel }; showToast("é¢„è®¾å·²è¦†ç›–ï¼"); } else { appState.settings.presets.push({ name: trimmedName, url: appState.settings.apiUrl, key: appState.settings.apiKey, model: appState.settings.selectedModel }); showToast("é¢„è®¾å·²ä¿å­˜ï¼"); } debouncedSaveState(); updatePresetSelect(); });
    managePresetsBtn.addEventListener('click', () => { renderPresetList(); managePresetsModal.classList.add('visible'); });
    function renderGlobalRealtimeSettings() {
        if (!globalRealtimeInterval || !globalRealtimeCharSelector) return;

        globalRealtimeInterval.value = appState.settings.globalRealtimeActivity.interval;

        const chars = appState.chat.contacts.filter(c => !c.isGroup);
        globalRealtimeCharSelector.innerHTML = chars.map(c => {
            const isEnabled = c.charSettings.realtimeActivity.enabled;
            return `
                <div class="realtime-char-item ${isEnabled ? 'selected' : ''}" data-id="${c.id}">
                    <div class="avatar" data-avatar-id="${c.charSettings.avatarId}"></div>
                    <span class="name">${c.charSettings.name}</span>
                </div>
            `;
        }).join('');
        
        globalRealtimeCharSelector.querySelectorAll('.avatar').forEach(el => setElementImage(el, el.dataset.avatarId));
    }

    globalRealtimeInterval.addEventListener('input', () => {
        const oldGlobalInterval = appState.settings.globalRealtimeActivity.interval;
        const newGlobalInterval = parseInt(globalRealtimeInterval.value) || 30;
        appState.settings.globalRealtimeActivity.interval = newGlobalInterval;

        appState.chat.contacts.forEach(contact => {
            if (!contact.isGroup) {
                if (contact.charSettings.realtimeActivity.interval === oldGlobalInterval) {
                    contact.charSettings.realtimeActivity.interval = newGlobalInterval;
                }
                if (contact.charSettings.realtimeActivity.enabled) {
                    updateRealtimeActivityTimer(contact);
                }
            }
        });
        debouncedSaveState();
    });

                globalRealtimeCharSelector.addEventListener('click', (e) => {
            const item = e.target.closest('.realtime-char-item');
            if (!item) return;
            const contactId = item.dataset.id;
            const contact = appState.chat.contacts.find(c => c.id === contactId);
            if (contact) {
                const charSettings = contact.charSettings.realtimeActivity;
                charSettings.enabled = !charSettings.enabled;
                updateRealtimeActivityTimer(contact);
                item.classList.toggle('selected');
                debouncedSaveState();
            }
        });

                globalRealtimeSelectAll.addEventListener('click', () => {
            const allChars = appState.chat.contacts.filter(c => !c.isGroup);
            const shouldEnableAll = allChars.some(c => !c.charSettings.realtimeActivity.enabled);
    
            allChars.forEach(contact => {
                contact.charSettings.realtimeActivity.enabled = shouldEnableAll;
                updateRealtimeActivityTimer(contact);
            });
            renderGlobalRealtimeSettings();
            debouncedSaveState();
        });
    closeManageModalBtn.addEventListener('click', () => managePresetsModal.classList.remove('visible'));
    function renderPresetList() { presetListEl.innerHTML = ''; if (appState.settings.presets.length === 0) { presetListEl.innerHTML = '<li><div class="preset-item-content">æš‚æ— é¢„è®¾</div></li>'; return; } appState.settings.presets.forEach((preset, index) => { const li = document.createElement('li'); li.className = 'preset-list-item'; li.dataset.index = index; li.innerHTML = `<div class="preset-item-content">${preset.name}</div><div class="preset-item-actions"><div class="edit-action">ç¼–è¾‘</div><div class="delete-action">åˆ é™¤</div></div>`; presetListEl.appendChild(li); }); }
    cancelEditBtn.addEventListener('click', () => editPresetModal.classList.remove('visible'));
    saveEditBtn.addEventListener('click', () => { const index = parseInt(editPresetIndexInput.value); const newName = editPresetNameInput.value.trim(); if (!newName) return showToast("é¢„è®¾åç§°ä¸èƒ½ä¸ºç©º", "error"); const existingIndex = appState.settings.presets.findIndex(p => p.name === newName); if (existingIndex !== -1 && existingIndex !== index) { if (!confirm(`å·²å­˜åœ¨åä¸º "${newName}" çš„é¢„è®¾ï¼Œè¦è¦†ç›–å®ƒå—ï¼Ÿ`)) return; appState.settings.presets.splice(existingIndex, 1); const newCurrentIndex = appState.settings.presets.findIndex(p => p.name === appState.settings.presets[index].name); appState.settings.presets[newCurrentIndex] = { name: newName, url: editPresetUrlInput.value.trim(), key: editPresetKeyInput.value.trim(), model: appState.settings.presets[newCurrentIndex].model }; } else { appState.settings.presets[index] = { name: newName, url: editPresetUrlInput.value.trim(), key: editPresetKeyInput.value.trim(), model: appState.settings.presets[index].model }; } debouncedSaveState(); updatePresetSelect(); renderPresetList(); editPresetModal.classList.remove('visible'); showToast("é¢„è®¾å·²æ›´æ–°"); });

    // ===================================================================
    // --- éŸ³ä¹æ’­æ”¾å™¨æ ¸å¿ƒ ---
    // ===================================================================
    let listenTogetherTimer = null;
    function playSongFromQueue(queueIndex, initiatorId = null) {
        if (queueIndex < 0 || queueIndex >= appState.music.queue.length) return;

        // --- æ ¸å¿ƒä¿®å¤ï¼šä»…åœ¨ä¼šè¯ç±»å‹æ”¹å˜æˆ–æ²¡æœ‰è®¡æ—¶å™¨æ—¶æ‰æ¸…é™¤ ---
        const newSessionType = initiatorId ? 'together' : 'solo';
        if (newSessionType !== runtimeState.musicSessionType && listenTogetherTimer) {
            clearInterval(listenTogetherTimer);
            listenTogetherTimer = null;
        }
        runtimeState.musicSessionType = newSessionType;

        appState.music.currentQueueIndex = queueIndex;
        const song = appState.music.queue[queueIndex];
        
        if (initiatorId && runtimeState.currentChatId) {
            const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
            if (contact) {
                let initiatorName;
                if(initiatorId === 'user') {
                    initiatorName = "ä½ ";
                } else {
                    initiatorName = findUserById(initiatorId).name;
                    if(contact.isGroup) {
                        initiatorName = contact.groupSettings.members[initiatorId]?.nickname || initiatorName;
                    }
                }
                const targetName = contact.isGroup ? 'å¤§å®¶' : (initiatorId === 'user' ? (contact.remark || contact.charSettings.name) : "ä½ ");
                addSystemNotification(runtimeState.currentChatId, `${initiatorName} é‚€è¯· ${targetName} ä¸€èµ·å¬æ­Œ: ã€Š${song.title}ã€‹`, false);
            }
        }
        
        audioPlayer.src = song.url;
        audioPlayer.play().catch(e => console.error("æ’­æ”¾å¤±è´¥:", e));
        updateAllPlayerUI(song);
    
        if (runtimeState.currentChatId && runtimeState.musicSessionType === 'together') {
            const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
            if (!contact) return;
            if (!contact.listenTogetherDuration) contact.listenTogetherDuration = 0;
            listenTogetherInfo.style.display = 'flex';
            
            // --- æ ¸å¿ƒä¿®å¤ï¼šä»…åœ¨è®¡æ—¶å™¨æœªè¿è¡Œæ—¶å¯åŠ¨ ---
            if (!listenTogetherTimer) {
                listenTogetherTimer = setInterval(() => {
                    contact.listenTogetherDuration++;
                    const seconds = contact.listenTogetherDuration;
                    const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
                    const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
                    const s = String(seconds % 60).padStart(2, '0');
                    listenTogetherText.textContent = `ä¸€èµ·å¬äº† ${h}:${m}:${s}`;
                    debouncedSaveState();
                }, 1000);
            }
        } else {
             listenTogetherInfo.style.display = 'none';
        }
    }
    
    function stopPlayback() {
        audioPlayer.pause();
        audioPlayer.src = '';
        appState.music.currentQueueIndex = -1;
        updateDynamicIsland(false);
        playerModal.classList.remove('show');
        lyricsLineEl.textContent = '...';
        updateMusicListPlayingStatus();
        getEl('lyrics-container').classList.remove('visible');
        clearInterval(listenTogetherTimer);
        listenTogetherInfo.style.display = 'none';
        if(runtimeState.currentChatId && runtimeState.musicSessionType === 'together') {
            addSystemNotification(runtimeState.currentChatId, 'ä¸€èµ·å¬æ­Œå·²ç»“æŸ', false);
        }
        runtimeState.musicSessionType = null;
    }
    
    function playNext() {
        const { currentQueueIndex, queue, playbackMode } = appState.music;
        if (queue.length === 0) return;
        let nextIndex;
        if (playbackMode === 'shuffle') {
            nextIndex = Math.floor(Math.random() * queue.length);
        } else {
            nextIndex = (currentQueueIndex + 1) % queue.length;
        }
        // --- æ ¸å¿ƒä¿®å¤ï¼šåœ¨åˆ‡æ­Œæ—¶ä¿æŒä¼šè¯ç±»å‹ ---
        playSongFromQueue(nextIndex, runtimeState.musicSessionType === 'together' ? 'user' : null);
        
        if (runtimeState.currentChatId && runtimeState.musicSessionType === 'together') {
            addSystemNotification(runtimeState.currentChatId, `æ­Œæ›²å·²è‡ªåŠ¨åˆ‡æ¢åˆ°: ã€Š${appState.music.queue[nextIndex].title}ã€‹`, false);
        }
    }

    function playPrev() {
        const { currentQueueIndex, queue, playbackMode } = appState.music;
        if (queue.length === 0) return;
        let prevIndex;
        if (playbackMode === 'shuffle') {
            prevIndex = Math.floor(Math.random() * queue.length);
        } else {
            prevIndex = (currentQueueIndex - 1 + queue.length) % queue.length;
        }
        // --- æ ¸å¿ƒä¿®å¤ï¼šåœ¨åˆ‡æ­Œæ—¶ä¿æŒä¼šè¯ç±»å‹ ---
        playSongFromQueue(prevIndex, runtimeState.musicSessionType === 'together' ? 'user' : null);

        if (runtimeState.currentChatId && runtimeState.musicSessionType === 'together') {
            addSystemNotification(runtimeState.currentChatId, `æ­Œæ›²å·²åˆ‡æ¢åˆ°: ã€Š${appState.music.queue[prevIndex].title}ã€‹`, false);
        }
    }
    
    function togglePlayPause() { if (audioPlayer.paused) { if (appState.music.currentQueueIndex === -1 && appState.music.queue.length > 0) { playSongFromQueue(0); } else { audioPlayer.play(); } } else { audioPlayer.pause(); } }
    
    function togglePlaybackMode() { const modes = ['repeat', 'repeat-one', 'shuffle']; const currentModeIndex = modes.indexOf(appState.music.playbackMode); appState.music.playbackMode = modes[(currentModeIndex + 1) % modes.length]; updatePlaybackModeIcon(); debouncedSaveState(); }
    function updatePlaybackModeIcon() { const icons = { 'repeat': '<i class="fa-solid fa-arrow-right-arrow-left"></i>', 'repeat-one': '<i class="fa-solid fa-arrows-rotate"></i>', 'shuffle': '<i class="fa-solid fa-shuffle"></i>' }; const iconIds = { 'repeat': 'player-mode-repeat', 'repeat-one': 'player-mode-repeat-one', 'shuffle': 'player-mode-shuffle' }; const currentMode = appState.music.playbackMode; playerPlaybackModeBtn.innerHTML = icons[currentMode]; playerPlaybackModeBtn.dataset.iconId = iconIds[currentMode]; }
    audioPlayer.addEventListener('play', () => { playerPlayPauseBtn.dataset.iconId = 'player-pause'; const customIconId = appState.beautify.icons['player-pause']; if (customIconId) setElementImage(playerPlayPauseBtn, customIconId, 'src'); else playerPlayPauseBtn.innerHTML = pauseIconSrc; islandWaveform.classList.remove('paused'); });
    audioPlayer.addEventListener('pause', () => { playerPlayPauseBtn.dataset.iconId = 'player-play'; const customIconId = appState.beautify.icons['player-play']; if (customIconId) setElementImage(playerPlayPauseBtn, customIconId, 'src'); else playerPlayPauseBtn.innerHTML = playIconSrc; islandWaveform.classList.add('paused'); });
    audioPlayer.addEventListener('ended', () => { if (appState.music.playbackMode === 'repeat-one') { playSongFromQueue(appState.music.currentQueueIndex); } else { playNext(); } });
    audioPlayer.addEventListener('loadedmetadata', () => { const song = appState.music.queue[appState.music.currentQueueIndex]; if (song && isNaN(song.duration)) { song.duration = audioPlayer.duration; const mainPlaylistSong = appState.music.playlist.find(s => s.id === song.id); if (mainPlaylistSong) mainPlaylistSong.duration = audioPlayer.duration; renderMusicList(); } progressBar.max = audioPlayer.duration; });
    audioPlayer.addEventListener('timeupdate', () => { progressBar.value = audioPlayer.currentTime; updateLyrics(audioPlayer.currentTime); });
    progressBar.addEventListener('input', () => { audioPlayer.currentTime = progressBar.value; });

    // ===================================================================
    // --- éŸ³ä¹ APP UI & æ­Œè¯åŒ¹é… ---
    // ===================================================================
    function formatTime(seconds) { if (isNaN(seconds)) return '--:--'; const min = Math.floor(seconds / 60); const sec = Math.floor(seconds % 60); return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`; }
    function renderMusicList() { musicListEl.innerHTML = ''; if (appState.music.playlist.length === 0) { musicListEl.innerHTML = '<li style="padding: 20px; text-align: center; color: #888;">æš‚æ— éŸ³ä¹ï¼Œç‚¹å‡»å³ä¸Šè§’+æ·»åŠ </div>'; return; } appState.music.playlist.forEach((song, index) => { const li = document.createElement('li'); li.className = 'music-list-item'; li.dataset.id = song.id; li.innerHTML = `<div class="music-item-content"><div class="music-item-info"><span class="title">${song.title}</span><span class="artist">${song.artist}</span></div><div class="music-item-duration">${formatTime(song.duration)}</div></div><div class="music-item-actions"><div class="edit-action">ç¼–è¾‘</div><div class="delete-action">åˆ é™¤</div></div>`; musicListEl.appendChild(li); }); updateMusicListPlayingStatus(); }
    function updateMusicListPlayingStatus() {
        const currentPlayingId = appState.music.queue[appState.music.currentQueueIndex]?.id;
        queryAll('.music-list-item').forEach(item => {
            if (currentPlayingId && item.dataset.id === currentPlayingId) {
                item.classList.add('playing');
            } else {
                item.classList.remove('playing');
            }
        });
    }    addMusicBtn.addEventListener('click', () => addMusicModal.classList.add('visible'));
    cancelAddMusicBtn.addEventListener('click', () => addMusicModal.classList.remove('visible'));
    uploadMusicBtn.addEventListener('click', () => musicFileInput.click());
    musicFileInput.addEventListener('change', (e) => { const files = e.target.files; if (files.length > 0) { processFiles(files); addMusicModal.classList.remove('visible'); musicFileInput.value = ''; } });
confirmAddUrlBtn.addEventListener('click', async () => {
    const lines = musicUrlInput.value.trim().split('\n').filter(line => line.trim());
    musicUrlInput.value = '';
    addMusicModal.classList.remove('visible');

    let audioUrls = [], lrcUrls = [];
    lines.forEach(line => {
        const separatorIndex = line.search(/\s*[:ï¼š]\s*/);
        let meta, url;
        if (separatorIndex === -1) {
            url = line.trim();
            meta = url.substring(url.lastIndexOf('/') + 1);
        } else {
            meta = line.substring(0, separatorIndex).trim();
            url = line.substring(separatorIndex + 1).trim();
        }
        if (!url.startsWith('http')) return;

        if (url.toLowerCase().endsWith('.lrc')) {
            lrcUrls.push({ meta, url });
        } else {
            audioUrls.push({ meta, url });
        }
    });

    let addedCount = 0;
    audioUrls.forEach(({ meta, url }) => {
        const parts = meta.replace(/\.[^/.]+$/, "").split(' - ');
        const artist = parts.length > 1 ? parts[0].trim() : 'æœªçŸ¥è‰ºæœ¯å®¶';
        const title = parts.length > 1 ? parts.slice(1).join(' - ').trim() : meta;
        // ç›´æ¥ä½¿ç”¨URLï¼Œä¸ä¸‹è½½
        const newSong = { id: newId('song'), title, artist, url: url, duration: NaN, isLocal: false, sourceUrl: url };
        appState.music.playlist.push(newSong);
        addedCount++;
    });

    if (addedCount > 0) {
        showToast(`æˆåŠŸæ·»åŠ  ${addedCount} é¦–æ­Œæ›²é“¾æ¥`);
        renderMusicList();
        debouncedSaveState();
    }

    for (const { meta, url } of lrcUrls) {
        try {
            // LRCæ­Œè¯å› ä¸ºæµè§ˆå™¨CORSç­–ç•¥ï¼Œé€šå¸¸ä»éœ€è¦ä»£ç†ä¸‹è½½
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const lrcContent = await response.text();
            matchAndApplyLyrics(lrcContent, meta);
        } catch (e) {
            console.error(`åŠ è½½æ­Œè¯å¤±è´¥: ${meta}`, e);
            showToast(`æ— æ³•åŠ è½½æ­Œè¯: ${meta}`, 'error');
        }
    }
});
    function processFiles(files) { let audioFiles = [], lrcFiles = []; Array.from(files).forEach(file => { if (file.name.toLowerCase().endsWith('.lrc')) { lrcFiles.push(file); } else { audioFiles.push(file); } }); let addedCount = 0; audioFiles.forEach(file => { const reader = new FileReader(); reader.onload = (event) => { const baseName = file.name.replace(/\.[^/.]+$/, ""); const parts = baseName.split(' - '); const artist = parts.length > 1 ? parts[0].trim() : 'æœªçŸ¥è‰ºæœ¯å®¶'; const title = parts.length > 1 ? parts.slice(1).join(' - ').trim() : baseName; const newSong = { id: newId('song'), title, artist, url: event.target.result, duration: NaN, isLocal: true }; appState.music.playlist.push(newSong); addedCount++; if (addedCount === audioFiles.length) { showToast(`æˆåŠŸæ·»åŠ  ${addedCount} é¦–æ­Œæ›²`); renderMusicList(); debouncedSaveState(); } }; reader.readAsDataURL(file); }); lrcFiles.forEach(file => { const reader = new FileReader(); reader.onload = (e) => { const baseName = file.name.replace(/\.[^/.]+$/, ""); matchAndApplyLyrics(e.target.result, baseName); }; reader.readAsText(file); }); }
    function normalizeStringForMatching(str) { if (!str) return ''; return decodeURIComponent(str).toLowerCase().replace(/\.[^/.]+$/, "").replace(/[-_]/g, ' ').replace(/['".,]/g, '').replace(/\s+/g, ' ').trim(); }
    function matchAndApplyLyrics(lrcContent, baseName) { const lrcData = parseLRC(lrcContent); if (lrcData.length === 0) return; const normalizedBaseName = normalizeStringForMatching(baseName); const songMap = new Map(); appState.music.playlist.forEach(s => { const songBaseName = normalizeStringForMatching(`${s.artist} - ${s.title}`); songMap.set(songBaseName, s.id); }); const matchingSongId = songMap.get(normalizedBaseName); if (matchingSongId) { appState.music.lyrics[matchingSongId] = lrcData; showToast(`æ­Œè¯å·²åŒ¹é…åˆ°: ${appState.music.playlist.find(s=>s.id === matchingSongId).title}`); debouncedSaveState(); } else { showToast(`æœªæ‰¾åˆ°æ­Œæ›²ä»¥åŒ¹é…æ­Œè¯: ${baseName}`, 'error'); console.log("Failed to match lyrics. Base name:", normalizedBaseName, "Available songs:", [...songMap.keys()]); } }
    cancelEditSongBtn.addEventListener('click', () => editSongModal.classList.remove('visible'));
    saveEditSongBtn.addEventListener('click', () => { const songId = editSongIdInput.value; const song = appState.music.playlist.find(s => s.id === songId); if (song) { song.title = editSongTitleInput.value.trim(); song.artist = editSongArtistInput.value.trim(); renderMusicList(); debouncedSaveState(); showToast("æ­Œæ›²ä¿¡æ¯å·²æ›´æ–°"); } editSongModal.classList.remove('visible'); });

    // ===================================================================
    // --- çµåŠ¨å²› & æ­Œè¯ & æ’­æ”¾å™¨ UI ---
    // ===================================================================
    function updateAllPlayerUI(song) { updateDynamicIsland(true, song); updateMusicListPlayingStatus(); playerSongTitle.textContent = song.title; playerSongArtist.textContent = song.artist; renderPlayerQueue(); }
    function updateDynamicIsland(isPlaying, song) { if (isPlaying && song) { dynamicIsland.classList.add('music-active'); islandMusicInfo.textContent = `${song.artist} - ${song.title}`; } else { dynamicIsland.classList.remove('music-active'); } }
    function parseLRC(lrc) { const lines = lrc.split('\n'); const result = []; const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g; for (const line of lines) { const text = line.replace(/\[.*?\]/g, '').trim(); if (text) { let match; while ((match = timeRegex.exec(line)) !== null) { const time = parseInt(match[1], 10) * 60 + parseInt(match[2], 10) + parseInt(match[3].padEnd(3, '0'), 10) / 1000; result.push({ time, text }); } } } return result.sort((a, b) => a.time - b.time); }
    let currentLyricIndex = -1;
function updateLyrics(currentTime) { const song = appState.music.queue[appState.music.currentQueueIndex]; if (!song) return; const lyrics = appState.music.lyrics[song.id]; if (!lyrics || lyrics.length === 0) { playerLyricsView.innerHTML = '<div class="lyric-line active">æš‚æ— æ­Œè¯</div>'; lyricsLineEl.textContent = '...'; if (songDetailsScreen.classList.contains('active') && songDetailsScreen.dataset.songId === song.id) { detailsLyricsView.innerHTML = '<div class="lyric-line active">æš‚æ— æ­Œè¯</div>'; } return; } let newLyricIndex = lyrics.findIndex((line, i) => currentTime >= line.time && (!lyrics[i + 1] || currentTime < lyrics[i + 1].time)); if (newLyricIndex === -1 && lyrics.length > 0) newLyricIndex = 0; if (newLyricIndex !== currentLyricIndex) { currentLyricIndex = newLyricIndex; const activeLyricText = lyrics[currentLyricIndex]?.text || '...'; lyricsLineEl.textContent = activeLyricText; renderPlayerLyrics(lyrics, currentLyricIndex); if (songDetailsScreen.classList.contains('active') && songDetailsScreen.dataset.songId === song.id) { renderSongDetailsLyrics(lyrics, currentLyricIndex); } } }
    function renderPlayerLyrics(lyrics, activeIndex) { playerLyricsView.innerHTML = lyrics.map((line, index) => `<div class="lyric-line ${index === activeIndex ? 'active' : ''}">${line.text}</div>`).join(''); const activeLine = playerLyricsView.querySelector('.lyric-line.active'); if (activeLine) { activeLine.scrollIntoView({ behavior: 'smooth', block: 'center' }); } }
    hidePlayerBtn.addEventListener('click', () => playerModal.classList.remove('show'));
    playerPlayPauseBtn.addEventListener('click', togglePlayPause);
    playerNextBtn.addEventListener('click', playNext);
    playerPrevBtn.addEventListener('click', playPrev);
    playerPlaybackModeBtn.addEventListener('click', togglePlaybackMode);
    togglePlaylistViewBtn.addEventListener('click', () => { playerLyricsView.classList.toggle('active'); playerPlaylistViewContainer.classList.toggle('active'); });
function renderPlayerQueue() { playerPlaylistView.innerHTML = ''; appState.music.queue.forEach((song, index) => { const li = document.createElement('li'); li.className = 'player-playlist-item'; li.classList.toggle('playing', index === appState.music.currentQueueIndex); li.dataset.index = index; li.innerHTML = `<div class="info"><div class="title">${song.title}</div><div class="artist">${song.artist}</div></div><button class="delete-from-queue-btn" data-icon-id="player-delete"><i class="fa-solid fa-trash-can"></i></button>`; playerPlaylistView.appendChild(li); }); }    playerPlaylistView.addEventListener('click', (e) => { const item = e.target.closest('.player-playlist-item'); if (!item) return; const index = parseInt(item.dataset.index); if (e.target.closest('.delete-from-queue-btn')) { if (confirm(`ç¡®å®šè¦ä»æ’­æ”¾åˆ—è¡¨ä¸­ç§»é™¤ "${appState.music.queue[index].title}" å—ï¼Ÿ`)) { appState.music.queue.splice(index, 1); if (index === appState.music.currentQueueIndex) { if (appState.music.queue.length > 0) { playSongFromQueue(index % appState.music.queue.length, runtimeState.musicSessionType === 'together' ? 'user' : null); } else { stopPlayback(); } } else if (index < appState.music.currentQueueIndex) { appState.music.currentQueueIndex--; } renderPlayerQueue(); debouncedSaveState(); } } else { playSongFromQueue(index, runtimeState.musicSessionType === 'together' ? 'user' : null); } });
    restorePlaylistBtn.addEventListener('click', () => { appState.music.queue = [...appState.music.playlist]; renderPlayerQueue(); debouncedSaveState(); showToast("æ’­æ”¾åˆ—è¡¨å·²è¿˜åŸ"); });
    
    // ===================================================================
    // --- æ­Œæ›²è¯¦æƒ…é¡µ ---
    // ===================================================================
    function openSongDetails(songId) { const song = appState.music.playlist.find(s => s.id === songId); if (!song) return; songDetailsScreen.dataset.songId = songId; detailsSongTitle.textContent = song.title; detailsSongArtist.textContent = song.artist; const lyrics = appState.music.lyrics[song.id]; const currentPlayingSong = appState.music.queue[appState.music.currentQueueIndex]; let activeIndex = -1; if (currentPlayingSong && currentPlayingSong.id === songId) { activeIndex = currentLyricIndex; } renderSongDetailsLyrics(lyrics, activeIndex, true); renderSongComments(songId); openSubScreen(songDetailsScreen, musicAppScreen); runtimeState.isDetailsAnimatingIn = true; setTimeout(() => { runtimeState.isDetailsAnimatingIn = false; const activeLine = detailsLyricsView.querySelector('.lyric-line.active'); if (activeLine) { activeLine.scrollIntoView({ behavior: 'auto', block: 'center' }); } }, 350); }
    function renderSongDetailsLyrics(lyrics, activeIndex, isOpening = false) { if (!lyrics || lyrics.length === 0) { detailsLyricsView.innerHTML = '<div class="lyric-line active">æš‚æ— æ­Œè¯</div>'; return; } detailsLyricsView.innerHTML = lyrics.map((line, index) => `<div class="lyric-line ${index === activeIndex ? 'active' : ''}">${line.text}</div>`).join(''); const activeLine = detailsLyricsView.querySelector('.lyric-line.active'); if (activeLine && !isOpening && !runtimeState.isDetailsAnimatingIn) { activeLine.scrollIntoView({ behavior: 'smooth', block: 'center' }); } }
    function renderSongComments(songId) { if (!appState.music.comments[songId]) { appState.music.comments[songId] = []; } const comments = appState.music.comments[songId]; detailsCommentsList.innerHTML = comments.map(comment => renderSingleComment(songId, comment)).join('') || '<p style="text-align:center; color:#888;">è¿˜æ²¡æœ‰è¯„è®ºï¼Œå¿«æ¥æŠ¢æ²™å‘å§ï¼</p>'; }
    function renderSingleComment(songId, comment) { const author = findUserById(comment.authorId, comment.authorName);
        const isLiked = comment.likes.includes('user');
        const repliesHTML = (comment.replies || []).map(reply => renderSingleReply(reply, comment.replies)).join('');
        return `
            <div class="comment-item" data-comment-id="${comment.id}">
                <div class="comment-item-main">
                    <div class="comment-avatar" data-avatar-id="${author.avatarId}"></div>
                    <div class="comment-content">
                        <div class="comment-header">
                            <span class="comment-author">${author.name}</span>
                            <div class="comment-actions-inline">
                                <button class="icon-btn like-btn ${isLiked ? 'liked' : ''}" data-icon-id="${isLiked ? 'music-like-on' : 'music-like-off'}" style="gap: 4px;">${isLiked ? '<i class="fa-solid fa-heart"></i>' : '<i class="fa-regular fa-heart"></i>'}<span class="like-count">${comment.likes.length}</span></button>
                                <button class="icon-btn reply-btn" data-icon-id="music-comment" style="gap: 4px;"><i class="fa-solid fa-message"></i></button>
                            </div>
                        </div>
                        <p class="comment-text">${escapeHTML(comment.text)}</p>
                        <div class="comment-replies">${repliesHTML}</div>
                        <div class="reply-input-container"><input type="text" placeholder="å›å¤ ${author.name}..."><button class="settings-button secondary" style="width: 50px; padding: 5px; display: flex; align-items: center; justify-content: center;" data-icon-id="comment-send"><i class="fa-solid fa-paper-plane"></i></button></div>
                    </div>
                </div>
                <div class="comment-item-actions-swipe">
                    <div class="edit-action" data-icon-id="music-edit"><i class="fa-solid fa-pen-to-square"></i></div>
                    <div class="delete-action" data-icon-id="music-delete"><i class="fa-solid fa-trash-can"></i></div>
                </div>
            </div>
        `; }
    function renderSingleReply(reply, allReplies) { const author = findUserById(reply.authorId, reply.authorName); let targetHTML = ''; if (reply.replyTo) { const targetReply = allReplies.find(r => r.id === reply.replyTo); if (targetReply) { const targetAuthor = findUserById(targetReply.authorId, targetReply.authorName); targetHTML = `å›å¤ <span class="reply-target">@${targetAuthor.name}</span>`; } } return `<div class="reply-item" data-reply-id="${reply.id}"><span class="reply-author">${author.name}</span> ${targetHTML}: ${reply.text}<span class="delete-reply-btn" data-icon-id="comment-reply-delete">Ã—</span><div class="reply-input-container"><input type="text" placeholder="å›å¤ ${author.name}..."><button class="settings-button secondary" style="padding: 5px 10px;" data-bubble-id="comment-reply-send">å‘é€</button></div></div>`; }
    
    function findUserById(id) {
        if (id === 'user') {
            const activeProfile = getActiveUserProfile();
            return {
                id: 'user',
                name: activeProfile.name,
                avatarId: activeProfile.avatarId,
                signature: activeProfile.signature
            };
        }
        if (id === 'system') return { id: 'system', name: 'ç³»ç»Ÿé€šçŸ¥', avatarId: '', signature: '' };

        // ä¼˜å…ˆåœ¨å½“å‰èŠå¤©ï¼ˆå¦‚æœæ˜¯ç¾¤èŠï¼‰çš„æˆå‘˜åˆ—è¡¨ä¸­æŸ¥æ‰¾ï¼Œä»¥è·å–æœ€æ–°çš„æ˜µç§°
        if (runtimeState.currentChatId) {
            const currentContact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
            if (currentContact && currentContact.isGroup && currentContact.groupSettings.members[id]) {
                const member = currentContact.groupSettings.members[id];
                return { id: id, name: member.nickname, avatarId: member.avatarId, signature: member.persona };
            }
        }
        
            const contact = appState.chat.contacts.find(c => c.id === id);
    if (!contact) {
        return undefined; // If contact is not found, return undefined to prevent crash
    }
    if (contact.isGroup) {
        return {
            id: contact.id,
            name: contact.groupSettings.name,
            avatarId: contact.groupSettings.avatarId,
            signature: 'A group chat'
        };
    } else {
        const isWeiboContext = weiboAppScreen.classList.contains('active');
        if (isWeiboContext && contact.charSettings.weibo && contact.charSettings.weibo.profile) {
            const weiboProfile = contact.charSettings.weibo.profile;
            return {
                id: contact.id,
                name: weiboProfile.name,
                avatarId: weiboProfile.avatarId,
                signature: weiboProfile.bio
            };
        }

        const isMomentsContext = momentsTabContent.offsetParent !== null || charMomentsScreen.classList.contains('active');
        const finalAvatarId = (isMomentsContext && contact.charSettings.momentsAvatarId) 
            ? contact.charSettings.momentsAvatarId 
            : contact.charSettings.avatarId;

        return {
            id: contact.id,
            name: contact.charSettings.name,
            avatarId: finalAvatarId,
            signature: contact.signature
        };
    
    }
        return { id: id, name: 'æœªçŸ¥ç”¨æˆ·', avatarId: `https://api.multiavatar.com/${id}.png`, signature: '...' };
    }
    function canCharViewMoment(charId, post) {
        if (!post) return false; // Post does not exist
        if (post.authorId === charId) return true; // Author can always view their own post
        if (post.visibility === 'public') return true; // Public post is visible to all
        // Check if the char is in the specific 'visibleTo' list
        if (post.visibility === 'specific' && post.visibleTo && post.visibleTo.includes(charId)) return true;
        // The user can see everything
        if(charId === 'user') return true;
        
        return false; // Otherwise, it's not visible
    }

    sendCommentBtn.addEventListener('click', () => { const text = commentInput.value.trim(); if (!text) return; const songId = songDetailsScreen.dataset.songId; if (!songId) return; const newComment = { id: newId('comment'), authorId: 'user', authorName: appState.chat.userProfile.name, text, likes: [], replies: [], timestamp: Date.now() }; appState.music.comments[songId].unshift(newComment); debouncedSaveState(); renderSongComments(songId); commentInput.value = ''; });
    detailsCommentsList.addEventListener('click', (e) => { const songId = songDetailsScreen.dataset.songId; const commentItem = e.target.closest('.comment-item'); if (!commentItem) return; const commentId = commentItem.dataset.commentId; const comment = appState.music.comments[songId].find(c => c.id === commentId); if (!comment) return; if (e.target.closest('.like-btn')) { const userIndex = comment.likes.indexOf('user'); if (userIndex > -1) { comment.likes.splice(userIndex, 1); } else { comment.likes.push('user'); } debouncedSaveState(); renderSongComments(songId); } else if (e.target.closest('.reply-btn')) { const replyInputContainer = commentItem.querySelector('.comment-content > .reply-input-container'); replyInputContainer.classList.toggle('active'); replyInputContainer.querySelector('input').focus(); } else if (e.target.closest('.comment-content > .reply-input-container button')) { const replyInput = e.target.previousElementSibling; const text = replyInput.value.trim(); if (!text) return; if (!comment.replies) comment.replies = []; const newReply = { id: newId('reply'), authorId: 'user', authorName: appState.chat.userProfile.name, text, timestamp: Date.now() }; comment.replies.push(newReply); debouncedSaveState(); renderSongComments(songId); } else { const replyItem = e.target.closest('.reply-item'); if (replyItem) { const replyId = replyItem.dataset.replyId; if (e.target.classList.contains('delete-reply-btn')) { if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡å›å¤å—ï¼Ÿ')) { comment.replies = comment.replies.filter(r => r.id !== replyId); debouncedSaveState(); renderSongComments(songId); } } else if (e.target.closest('.reply-input-container button')) { const replyInput = e.target.previousElementSibling; const text = replyInput.value.trim(); if (!text) return; const newReply = { id: newId('reply'), authorId: 'user', authorName: appState.chat.userProfile.name, text, replyTo: replyId, timestamp: Date.now() }; comment.replies.push(newReply); debouncedSaveState(); renderSongComments(songId); } else { const replyInputContainer = replyItem.querySelector('.reply-input-container'); replyInputContainer.classList.toggle('active'); replyInputContainer.querySelector('input').focus(); } } } });
    songDetailsBackBtn.addEventListener('click', () => closeSubScreen(songDetailsScreen, musicAppScreen));

// ===================================================================
// --- ç¾åŒ– APP (ä¼˜åŒ–) ---
// ===================================================================
function handleBeautifyTabChange(tabId) { const titleEl = beautifyAppScreen.querySelector('.title'); beautifyActionBtn.style.display = ['wallpaper', 'font'].includes(tabId) ? 'block' : 'none'; bubbleActionBtn.style.display = tabId === 'bubble' ? 'block' : 'none';    if (tabId === 'wallpaper') { titleEl.textContent = 'å£çº¸'; renderWallpapers(false); } else if (tabId === 'font') { titleEl.textContent = 'å­—ä½“'; renderFonts(false); } else if (tabId === 'icon') { titleEl.textContent = 'å›¾æ ‡'; renderIcons(); } else if (tabId === 'bubble') { titleEl.textContent = 'æ°”æ³¡'; renderBubbles(); } else if (tabId === 'theme') { 
    titleEl.textContent = 'ä¸»é¢˜'; 
    renderThemeEditor(); 
    ['moments', 'header', 'tabs', 'list-item', 'letter', 'chat-input'].forEach(id => updateThemeCssPreview(id));
} }
beautifyTabs.addEventListener('click', (e) => { if (e.target.classList.contains('tab-link')) { const tabId = e.target.dataset.tab; queryAll('#beautify-app-screen .tab-link').forEach(t => t.classList.remove('active')); queryAll('#beautify-app-screen .tab-content').forEach(c => c.classList.remove('active')); e.target.classList.add('active'); getEl(`${tabId}-tab-content`).classList.add('active'); handleBeautifyTabChange(tabId); } });
beautifyActionBtn.addEventListener('click', () => { const activeTab = query('#beautify-app-screen .tab-link.active').dataset.tab; if (activeTab === 'wallpaper') { wallpaperFileInput.click(); } else if (activeTab === 'font') { addFontModal.classList.add('visible'); } });
bubbleActionBtn.addEventListener('click', () => bubbleIoModal.classList.add('visible'));
cancelBubbleIoBtn.addEventListener('click', () => bubbleIoModal.classList.remove('visible'));
exportBubblesBtn.addEventListener('click', async () => { showToast("æ­£åœ¨å¯¼å‡ºæ°”æ³¡è®¾ç½®...", 'info'); try { const bubbleSettings = appState.beautify.bubbleSettings; const mediaIds = new Set(); Object.values(bubbleSettings.global).forEach(style => { if (style.backgroundImageId) mediaIds.add(style.backgroundImageId); }); Object.values(bubbleSettings.specific).forEach(bubble => { Object.values(bubble).forEach(style => { if (style.backgroundImageId) mediaIds.add(style.backgroundImageId); }); }); const mediaData = {}; for (const id of mediaIds) { const data = await getMediaFromDB(id); if (data) mediaData[id] = await blobToBase64(data); } const backup = { bubbleSettings, mediaData }; const dataStr = JSON.stringify(backup); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `EmperorPhone-BubblesBackup-${new Date().toISOString().slice(0, 10)}.json`; a.click(); URL.revokeObjectURL(url); a.remove(); showToast("æ°”æ³¡è®¾ç½®å·²å¯¼å‡ºï¼"); } catch (error) { console.error("å¯¼å‡ºæ°”æ³¡å¤±è´¥:", error); showToast("å¯¼å‡ºæ°”æ³¡å¤±è´¥", 'error'); } });
importBubblesBtn.addEventListener('click', () => importBubblesInput.click());
importBubblesInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = async (event) => { showToast("æ­£åœ¨å¯¼å…¥æ°”æ³¡è®¾ç½®...", 'info'); try { const backup = JSON.parse(event.target.result); if (!backup.bubbleSettings || !backup.mediaData) throw new Error("å¤‡ä»½æ–‡ä»¶æ ¼å¼æ— æ•ˆ"); if (confirm("è¿™å°†è¦†ç›–æ‰€æœ‰å½“å‰çš„æ°”æ³¡è®¾ç½®ï¼Œç¡®å®šå—ï¼Ÿ")) { for (const [id, base64] of Object.entries(backup.mediaData)) { await addMediaToDB(id, base64ToBlob(base64)); } appState.beautify.bubbleSettings = backup.bubbleSettings; debouncedSaveState(); await applyAllCustomizations(); renderBubbles(); showToast("æ°”æ³¡è®¾ç½®å¯¼å…¥æˆåŠŸï¼"); bubbleIoModal.classList.remove('visible'); } } catch (error) { showToast(`å¯¼å…¥å¤±è´¥: ${error.message}`, 'error'); } finally { importBubblesInput.value = ''; } }; reader.readAsText(file); });
wallpaperFileInput.addEventListener('change', async (e) => { const files = e.target.files; if (files.length > 0) { showToast(`æ­£åœ¨æ·»åŠ  ${files.length} å¼ å£çº¸...`); for (const file of files) { const compressedFile = await compressImageBeforeSaving(file, { maxWidth: 720, maxHeight: 1280 }); const newWallpaperId = newId('wp'); await addMediaToDB(newWallpaperId, compressedFile); appState.beautify.wallpapers.push({ id: newWallpaperId }); } debouncedSaveState(); await renderWallpapers(); showToast(`æˆåŠŸæ·»åŠ  ${files.length} å¼ å£çº¸`); } wallpaperFileInput.value = ''; });async function renderWallpapers(isAppending = false) {
const BATCH_SIZE = 48;
const container = getEl('wallpaper-tab-content');

if (!isAppending) {
    wallpaperGrid.innerHTML = '';
    runtimeState.beautify.wallpaperDisplayCount = 0;
}

// Remove old 'load more' button before adding new content
const existingBtnContainer = container.querySelector('.load-more-container');
if (existingBtnContainer) {
    existingBtnContainer.remove();
}

const start = runtimeState.beautify.wallpaperDisplayCount;
const end = start + BATCH_SIZE;
const wallpapersToRender = appState.beautify.wallpapers.slice(start, end);

for (const wp of wallpapersToRender) {
    const item = document.createElement('div');
    item.className = 'wallpaper-item';
    item.dataset.id = wp.id;
    const img = document.createElement('img');
    img.alt = 'å£çº¸é¢„è§ˆ';
    item.appendChild(img);
    if (wp.id === appState.beautify.currentWallpaperId) item.classList.add('is-wallpaper');
    if (wp.id === appState.beautify.currentChatBgId) item.classList.add('is-chat-bg');
    wallpaperGrid.appendChild(item);
    setElementImage(img, wp.id, 'src');
}

runtimeState.beautify.wallpaperDisplayCount = end;

if (end < appState.beautify.wallpapers.length) {
    const loadMoreContainer = document.createElement('div');
    loadMoreContainer.className = 'load-more-container';
    loadMoreContainer.style.padding = '15px';
    loadMoreContainer.innerHTML = `<button class="settings-button secondary" style="width: 100%;">åŠ è½½æ›´å¤š (${end}/${appState.beautify.wallpapers.length})</button>`;
    // Insert after the grid, within the tab content
    container.appendChild(loadMoreContainer);

    loadMoreContainer.querySelector('button').addEventListener('click', () => {
        renderWallpapers(true);
    }, { once: true });
}}
function showWallpaperContextMenu(targetElement, event) { event.preventDefault(); runtimeState.wallpaperContextMenuTarget = targetElement; const screenRect = phoneScreen.getBoundingClientRect(); let x = event.clientX; let y = event.clientY; if (event.touches) { x = event.touches[0].clientX; y = event.touches[0].clientY; } wallpaperContextMenu.style.display = 'flex'; const menuRect = wallpaperContextMenu.getBoundingClientRect(); let top = y - screenRect.top; let left = x - screenRect.left; if (left + menuRect.width > screenRect.width - 10) { left = screenRect.width - menuRect.width - 10; } if (top + menuRect.height > screenRect.height - 10) { top = screenRect.height - menuRect.height - 10; } wallpaperContextMenu.style.top = `${top}px`; wallpaperContextMenu.style.left = `${left}px`; }
function hideWallpaperContextMenu() { if (wallpaperContextMenu) wallpaperContextMenu.style.display = 'none'; runtimeState.wallpaperContextMenuTarget = null; }
wallpaperGrid.addEventListener('click', (e) => {
    const item = e.target.closest('.wallpaper-item');
    if (item) {
        showWallpaperContextMenu(item, e);
    }
});
document.addEventListener('pointerdown', (e) => { if (wallpaperContextMenu.style.display === 'flex' && !wallpaperContextMenu.contains(e.target)) { hideWallpaperContextMenu(); } }, true);
getEl('wp-set-wallpaper').addEventListener('click', async () => { if (!runtimeState.wallpaperContextMenuTarget) return; const id = runtimeState.wallpaperContextMenuTarget.dataset.id; appState.beautify.currentWallpaperId = id; await applyWallpaperById(id, phoneScreen); debouncedSaveState(); renderWallpapers(); hideWallpaperContextMenu(); showToast('å£çº¸å·²è®¾ç½®'); });
getEl('wp-set-chat-bg').addEventListener('click', () => { if (!runtimeState.wallpaperContextMenuTarget) return; const id = runtimeState.wallpaperContextMenuTarget.dataset.id; appState.beautify.currentChatBgId = id; debouncedSaveState(); renderWallpapers(); hideWallpaperContextMenu(); showToast('å…¨å±€èŠå¤©èƒŒæ™¯å·²è®¾ç½®'); });
getEl('wp-delete').addEventListener('click', async () => { if (!runtimeState.wallpaperContextMenuTarget) return; if (confirm('ç¡®å®šè¦åˆ é™¤è¿™å¼ å£çº¸å—ï¼Ÿ')) { const id = runtimeState.wallpaperContextMenuTarget.dataset.id; await deleteMediaFromDB(id); appState.beautify.wallpapers = appState.beautify.wallpapers.filter(wp => wp.id !== id); if (appState.beautify.currentWallpaperId === id) { appState.beautify.currentWallpaperId = 'default'; await applyWallpaperById('default', phoneScreen); } if (appState.beautify.currentChatBgId === id) { appState.beautify.currentChatBgId = 'default'; } appState.chat.contacts.forEach(contact => { if (contact.isGroup && contact.groupSettings.chatBackgroundId === id) { contact.groupSettings.chatBackgroundId = 'default'; } else if (!contact.isGroup && contact.charSettings.chatBackgroundId === id) { contact.charSettings.chatBackgroundId = 'default'; } }); debouncedSaveState(); renderWallpapers(); hideWallpaperContextMenu(); showToast('å£çº¸å·²åˆ é™¤'); } });
async function applyWallpaperById(id, element) { if (!id || id === 'default' || id === 'default_moments_cover') { element.style.backgroundImage = (id === 'default_moments_cover') ? 'none' : `url(${DEFAULT_WALLPAPER_URL})`; element.style.backgroundColor = (id === 'default_moments_cover') ? '#ccc' : 'var(--bg-color)'; return; } const url = await getMediaURL(id); if (url) { element.style.backgroundImage = `url(${url})`; element.style.backgroundColor = 'transparent'; } else { element.style.backgroundImage = `url(${DEFAULT_WALLPAPER_URL})`; element.style.backgroundColor = 'var(--bg-color)'; } }
function renderLoveLetterTab() {
    const allLettersListEl = getEl('all-letters-list');
    const unreadPrompt = getEl('unread-letter-prompt');
    if (!allLettersListEl) return;

    let lettersToRender = [...appState.mailbox.loveLetters];

    // 1. Filtering logic based on runtime state
    const filter = runtimeState.mailboxFilter ? runtimeState.mailboxFilter.selected : 'all';
    if (filter === 'sent') {
        lettersToRender = lettersToRender.filter(l => l.senderId === 'user');
    } else if (filter === 'received') {
        lettersToRender = lettersToRender.filter(l => l.senderId !== 'user');
    } else if (filter !== 'all') { // It's a character ID
        lettersToRender = lettersToRender.filter(l => l.senderId === filter || l.recipientId === filter);
    }

    // 2. Chronological sorting logic
    lettersToRender.sort((a, b) => b.timestamp - a.timestamp);

    const createLetterHTML = (letter) => {
        const isReceived = letter.senderId !== 'user';
        const otherPartyId = isReceived ? letter.senderId : letter.recipientId;
        const otherParty = findUserById(otherPartyId);
        const isUnread = isReceived && !letter.isRead;

        return `
            <div class="love-letter-preview-card" data-letter-id="${letter.id}">
                <div class="love-letter-preview-header">
                    <div class="love-letter-preview-avatar" data-avatar-id="${otherParty.avatarId}"></div>
                    <div class="love-letter-preview-meta">
                        <div class="subject ${isUnread ? 'unread-subject' : ''}">${escapeHTML(letter.subject || 'æ— é¢˜')}</div>
                        <div class="timestamp">${new Date(letter.timestamp).toLocaleString()}</div>
                    </div>
                </div>
                <div class="love-letter-preview-content">
                    <div class="salutation">${escapeHTML(letter.salutation || '')}</div>
                    <div class="body-preview">${escapeHTML(truncateText(letter.body || '', 50)).replace(/\\n/g, '<br>')}</div>
                    <div class="signature">${escapeHTML(letter.signature || '')}</div>
                </div>
                <div class="love-letter-actions">
                    <button class="icon-btn edit-letter-btn" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
                    <button class="icon-btn delete-letter-btn" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
                </div>
            </div>
        `;
    };

    // 3. Rendering logic
    if (lettersToRender.length > 0) {
        allLettersListEl.innerHTML = lettersToRender.map(createLetterHTML).join('');
        allLettersListEl.querySelectorAll('.love-letter-preview-avatar').forEach(el => setElementImage(el, el.dataset.avatarId));
    } else {
        allLettersListEl.innerHTML = '<p style="text-align:center; color:#888; grid-column: 1 / -1; padding-top: 50px;">æ­¤åˆ†ç±»ä¸‹æ²¡æœ‰æƒ…ä¹¦...</p>';
    }

    // 4. Unread prompt logic (always checks all received letters regardless of filter)
    const allReceivedLetters = appState.mailbox.loveLetters.filter(l => l.senderId !== 'user');
    const firstUnread = allReceivedLetters.find(l => !l.isRead);
    if (firstUnread) {
        unreadPrompt.dataset.letterId = firstUnread.id;
        unreadPrompt.classList.add('visible');
    } else {
        unreadPrompt.classList.remove('visible');
    }
}

function renderMailFilterDropdown() {
    const charIds = new Set();
    appState.mailbox.loveLetters.forEach(l => {
        if (l.senderId !== 'user') charIds.add(l.senderId);
        if (l.recipientId !== 'user') charIds.add(l.recipientId);
    });

    const charOptions = [...charIds].map(id => {
        const char = findUserById(id);
        return { value: id, text: char.name };
    });

    const filterOptions = [
        { value: 'all', text: 'å…¨éƒ¨' },
        { value: 'sent', text: 'å¯„å‡ºçš„ä¿¡' },
        { value: 'received', text: 'æ”¶åˆ°çš„ä¿¡' },
        ...charOptions
    ];
    
    const selected = runtimeState.mailboxFilter ? runtimeState.mailboxFilter.selected : 'all';

    mailFilterDropdown.innerHTML = filterOptions.map(opt => `
        <label class="radio-label" style="width: 100%; border: none; border-radius: 4px; padding: 8px 5px;">
            <input type="radio" name="love-letter-filter" value="${opt.value}" ${selected === opt.value ? 'checked' : ''}>
            <span>${escapeHTML(opt.text)}</span>
        </label>
    `).join('');
}

function toggleMailFilterDropdown() {
    if (mailFilterDropdown.classList.contains('visible')) {
        mailFilterDropdown.classList.remove('visible');
    } else {
        renderMailFilterDropdown();
        mailFilterDropdown.classList.add('visible');
    }
}

function renderPostcardFilterDropdown() {
    const charIds = new Set();
    appState.mailbox.postcards.forEach(p => {
        if (p.senderId !== 'user') charIds.add(p.senderId);
        if (p.recipientId !== 'user') charIds.add(p.recipientId);
    });

    const existingContactIds = new Set(appState.chat.contacts.map(c => c.id));
    const charOptions = [...charIds]
        .filter(id => existingContactIds.has(id)) // æ ¸å¿ƒä¿®å¤ï¼šåªä¿ç•™æœ‰æ•ˆè”ç³»äººçš„ID
        .map(id => {
            const char = findUserById(id);
            return { value: id, text: char.name };
        });

    const filterOptions = [
        { value: 'all', text: 'å…¨éƒ¨' },
        { value: 'sent', text: 'å¯„å‡ºçš„æ˜ä¿¡ç‰‡' },
        { value: 'received', text: 'æ”¶åˆ°çš„æ˜ä¿¡ç‰‡' },
        ...charOptions
    ];
    
    const selected = runtimeState.postcardFilter ? runtimeState.postcardFilter.selected : 'all';

    postcardFilterDropdown.innerHTML = filterOptions.map(opt => `
        <label class="radio-label" style="width: 100%; border: none; border-radius: 4px; padding: 8px 5px;">
            <input type="radio" name="postcard-filter" value="${opt.value}" ${selected === opt.value ? 'checked' : ''}>
            <span>${escapeHTML(opt.text)}</span>
        </label>
    `).join('');
}

function togglePostcardFilterDropdown() {
    if (postcardFilterDropdown.classList.contains('visible')) {
        postcardFilterDropdown.classList.remove('visible');
    } else {
        renderPostcardFilterDropdown();
        postcardFilterDropdown.classList.add('visible');
    }
}
mailFilterBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const activeTab = appState.mailbox.activeTab;
    if (activeTab === 'love-letter') {
        toggleMailFilterDropdown();
    } else if (activeTab === 'postcard') {
        togglePostcardFilterDropdown();
    }
});

mailFilterDropdown.addEventListener('change', (e) => {
    if (e.target.name === 'love-letter-filter') {
        if (!runtimeState.mailboxFilter) {
            runtimeState.mailboxFilter = {};
        }
        runtimeState.mailboxFilter.selected = e.target.value;
        renderLoveLetterTab();
        toggleMailFilterDropdown();
    }
});

postcardFilterDropdown.addEventListener('change', (e) => {
    if (e.target.name === 'postcard-filter') {
        if (!runtimeState.postcardFilter) {
            runtimeState.postcardFilter = {};
        }
        runtimeState.postcardFilter.selected = e.target.value;
        renderPostcardWall();
        togglePostcardFilterDropdown();
    }
});
    function openLoveLetter(letterId) {
        const letterColors = [
                'linear-gradient(to bottom right, #fcd4d9, #fde8eb)', // Light Pink
                'linear-gradient(to bottom right, #d4e7fc, #e8f1fd)', // Light Blue
                'linear-gradient(to bottom right, #e5fde2, #f1fef0)', // Light Green
                'linear-gradient(to bottom right, #e7def4, #f2ecfa)'  // Light Purple
            ];
            const randomGradient = letterColors[Math.floor(Math.random() * letterColors.length)];
            const viewer = getEl('love-letter-viewer');
            viewer.style.setProperty('--love-letter-gradient', randomGradient);
            viewer.dataset.letterId = letterId; // **æ–°å¢ï¼šä¸ºå›ä¿¡åŠŸèƒ½å­˜å‚¨ID**
            const letter = appState.mailbox.loveLetters.find(l => l.id === letterId);
            if (!letter) return;
            const sender = findUserById(letter.senderId);

        viewer.querySelector('.letter-salutation').textContent = letter.salutation ? letter.salutation.replace(/\\n/g, '\n') : `${appState.chat.userProfile.name}ï¼š`;
        viewer.querySelector('.letter-body').textContent = letter.body ? letter.body.replace(/\\n/g, '\n') : 'ä¿¡ä¸­ä¼¼ä¹æ²¡æœ‰å†…å®¹...';
        viewer.querySelector('.letter-sender-name').textContent = letter.signature ? letter.signature.replace(/\\n/g, '\n') : sender.name;
            viewer.querySelector('.letter-timestamp').textContent = new Date(letter.timestamp).toLocaleString();
            let stampAvatarId;
        if (letter.senderId === 'user') {
            const recipientContact = appState.chat.contacts.find(c => c.id === letter.recipientId);
            stampAvatarId = recipientContact ? recipientContact.userSettings.avatarId : appState.chat.userProfile.avatarId;
        } else {
            stampAvatarId = sender.avatarId;
        }
        setElementImage(viewer.querySelector('.letter-stamp'), stampAvatarId);

            viewer.classList.add('visible');

            if (!letter.isRead) {
                letter.isRead = true;
                debouncedSaveState();
                renderLoveLetterTab();
            }
        }
    
    
    function scheduleLoveLetterChecks() {

    const now = new Date();
    
    appState.chat.contacts.forEach(contact => {
        if (contact.isGroup) return;
    
    // --- æ–°å¢ï¼šæ£€æŸ¥ä¸»åŠ¨å†™ä¿¡å¼€å…³ ---
    if (!contact.charSettings.proactiveLoveLettersEnabled) {
        return; // å¦‚æœå¼€å…³å…³é—­ï¼Œåˆ™è·³è¿‡æ­¤è§’è‰²
    }
        // æ£€æŸ¥æ˜¯å¦æœ‰å·²å®‰æ’çš„ä¿¡ä»¶ä»»åŠ¡ï¼Œæˆ–è€…æœ€è¿‘6å°æ—¶å†…æ˜¯å¦å·²å¯„è¿‡ä¿¡
        const hasPendingLetter = contact.charSettings.proactiveLetterDue && contact.charSettings.proactiveLetterDue > now.getTime();
        const hasSentRecently = (contact.lastLetterSent || 0) > (now.getTime() - 6 * 60 * 60 * 1000);

        if (hasPendingLetter || hasSentRecently) {
            return; // å¦‚æœæœ‰å¾…åŠæˆ–æœ€è¿‘å¯„è¿‡ï¼Œåˆ™è·³è¿‡ï¼Œé¿å…é‡å¤
        }
        
        // å®‰æ’ä¸€ä¸ªæ–°çš„ä¸»åŠ¨å†™ä¿¡ä»»åŠ¡
        // ä¼˜åŒ–ï¼šå°†å»¶è¿Ÿä»3-8å°æ—¶ç¼©çŸ­åˆ°30-90åˆ†é’Ÿ
        const randomDelay = (Math.random() * 60 + 30) * 60 * 1000; 
        contact.charSettings.proactiveLetterDue = now.getTime() + randomDelay;
        console.log(`Scheduling a proactive letter for ${contact.name} at ${new Date(contact.charSettings.proactiveLetterDue).toLocaleString()}.`);
    });

    debouncedSaveState();
}
        // --- å±•å…åŠŸèƒ½æ ¸å¿ƒé€»è¾‘ ---
    function renderExhibitionTab() {
        const gridEl = getEl('exhibition-grid');
        const gifts = appState.mailbox.postcards.filter(p => p.recipientId === 'user' && p.gift && p.gift.trim() !== '');
        gifts.sort((a,b) => b.timestamp - a.timestamp); // æŒ‰æ—¶é—´å€’åº

        if (gifts.length === 0) {
            gridEl.innerHTML = `<p style="text-align:center; color:#888; margin-top: 50px; grid-column: 1 / -1;">è¿˜æ²¡æœ‰æ”¶åˆ°è¿‡ä»»ä½•ç¤¼ç‰©å“¦</p>`;
            return;
        }

        gridEl.innerHTML = gifts.map(card => {
            const sender = findUserById(card.senderId);
            const date = new Date(card.timestamp).toLocaleDateString();
            return `
                <div class="gift-item-card" data-postcard-id="${card.id}">
                    <div class="icon"><i class="fa-solid fa-gift"></i></div>
                    <div class="name">${escapeHTML(card.gift)}</div>
                    <div class="sender">From: ${escapeHTML(sender.name)}</div>
                    <div class="date">${date}</div>
                    <div class="gift-item-actions">
                        <button class="icon-btn edit-gift-btn" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
                        <button class="icon-btn delete-gift-btn" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
                    </div>
                </div>
            `;
        }).join('');
    }

    async function openGiftViewer(postcard) {
        const modal = getEl('gift-viewer-modal');
        const descEl = getEl('gift-viewer-description');
        const sender = findUserById(postcard.senderId);

        // 1. ç«‹å³è®¾ç½®å¹¶æ˜¾ç¤ºåŸºç¡€ä¿¡æ¯
        getEl('gift-viewer-name').textContent = postcard.gift;
        getEl('gift-viewer-sender-name').textContent = sender.name;
        getEl('gift-viewer-timestamp').textContent = new Date(postcard.timestamp).toLocaleString();
        setElementImage(getEl('gift-viewer-avatar'), sender.avatarId);
        
        modal.classList.add('visible');

        // 2. æ£€æŸ¥æ˜¯å¦å­˜åœ¨å·²ä¿å­˜çš„æè¿°
        if (postcard.giftDescription) {
            // å¦‚æœå­˜åœ¨ï¼Œç›´æ¥æ˜¾ç¤º
            descEl.textContent = postcard.giftDescription;
        } else {
            // å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™ç”Ÿæˆå¹¶ä¿å­˜
            descEl.textContent = 'æ­£åœ¨ç”Ÿæˆæè¿°...';
            try {
                const description = await triggerGiftDescriptionGeneration(postcard);
                postcard.giftDescription = description; // å…³é”®ï¼šå°†ç”Ÿæˆçš„æè¿°ä¿å­˜å›å¯¹è±¡
                debouncedSaveState(); // å…³é”®ï¼šå°†æ›´æ–°æ°¸ä¹…ä¿å­˜åˆ°localStorage
                descEl.textContent = description;
            } catch (error) {
                console.error("Failed to generate gift description:", error);
                descEl.textContent = '(æè¿°ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•)';
            }
        }
    }

    async function triggerGiftDescriptionGeneration(postcard) {
        const { apiUrl, apiKey, selectedModel } = appState.settings;
        if (!apiUrl || !apiKey || !selectedModel) throw new Error("API not configured.");

        const charContact = appState.chat.contacts.find(c => c.id === postcard.senderId);
        if (!charContact) throw new Error("Sender contact not found.");
        
        const prompt = constructGiftDescriptionPrompt(postcard, charContact);
            const messages = [{ role: 'system', content: prompt }];
    if (!apiUrl.includes('generativelanguage.googleapis.com')) {
        messages[0].role = 'user';
    }
            const response = await fetch(`${apiUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
        body: JSON.stringify({ model: selectedModel, messages: [{ role: 'system', content: prompt }], stream: false })
    });

        if (!response.ok) throw new Error(`API Error: ${response.status}`);
        const data = await response.json();
        const replyContent = data.choices[0]?.message?.content;
        
        if (replyContent) {
            const result = JSON.parse(replyContent);
            return result.description;
        }
        throw new Error("API returned empty description.");
    }

    function constructGiftDescriptionPrompt(postcard, charContact) {
        const user = charContact.userSettings;
        let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰² â€œ${charContact.charSettings.name}â€ï¼ˆäººè®¾ï¼šâ€œ${charContact.charSettings.persona}â€ï¼‰ã€‚\n`;
        prompt += `è¿‡å»ï¼Œä½ æ›¾ç»™ä½ çš„å¿ƒä¸Šäººâ€œ${user.name}â€ï¼ˆäººè®¾ï¼šâ€œ${user.persona}â€ï¼‰å¯„è¿‡ä¸€å¼ æ˜ä¿¡ç‰‡ã€‚ç°åœ¨ï¼ŒTAæ­£åœ¨TAçš„â€œå±•å…â€é‡Œï¼Œçœ‹ç€ä½ å½“æ—¶éšä¿¡é™„èµ çš„ä¸€ä»¶åä¸ºâ€œ${postcard.gift}â€çš„å°ç¤¼ç‰©ã€‚\n\n`;
        prompt += `--- **åŸå§‹æ˜ä¿¡ç‰‡å†…å®¹å‚è€ƒ** ---\n`;
        prompt += `åœ°ç‚¹: ${postcard.location}\n`;
        prompt += `ç§°å‘¼: ${postcard.salutation}\n`;
        prompt += `æ­£æ–‡: ${postcard.body}\n`;
        prompt += `è½æ¬¾: ${postcard.signature}\n\n`;
        prompt += `--- **ä½ çš„ä»»åŠ¡** ---\n`;
        prompt += `è¯·ä½ ä»¥è§’è‰²çš„å£å»ï¼Œä¸ºè¿™ä»¶ç¤¼ç‰©ç”Ÿæˆä¸€æ®µã€ç¬¬ä¸€äººç§°ã€‘çš„ã€å……æ»¡å›å¿†çš„æè¿°ã€‚è¿™æ®µæè¿°å°†ä½œä¸ºç¤¼ç‰©ä¸‹æ–¹çš„è¯´æ˜æ–‡å­—ï¼Œè®©ç”¨æˆ·åœ¨çœ‹åˆ°ç¤¼ç‰©æ—¶èƒ½å›æƒ³èµ·å½“æ—¶çš„æƒ…æ™¯ä¸ä½ çš„å¿ƒæ„ã€‚\n\n`;
        prompt += `--- **ã€å¼ºåˆ¶è¦æ±‚ã€‘** ---\n`;
        prompt += `1. **ã€å†…å®¹æ ¸å¿ƒã€‘**: æè¿°ã€å¿…é¡»ã€‘ä¸åŸå§‹æ˜ä¿¡ç‰‡çš„å†…å®¹å’Œæ„å¢ƒç´§å¯†ç›¸è¿ï¼Œè§£é‡Šä½ ä¸ºä»€ä¹ˆä¼šé€‰æ‹©é€è¿™ä»¶ç¤¼ç‰©ï¼Œä»¥åŠå®ƒèƒŒåè•´å«çš„ç‰¹æ®Šæ„ä¹‰ã€‚\n`;
        prompt += `2. **ã€æ–‡ç¬”é£æ ¼ã€‘**: æ–‡å­—å¿…é¡»ç»†è…»ã€æ¸©æŸ”ã€å¯Œæœ‰è¯—æ„ï¼Œä¸”ä¸¥æ ¼ç¬¦åˆä½ çš„äººè®¾ã€‚é•¿åº¦æ§åˆ¶åœ¨30-50å­—ä¹‹é—´ã€‚\n`;
        prompt += `3. **ã€JSONè¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªæ ¼å¼æ­£ç¡®çš„JSONå¯¹è±¡ï¼Œä¸èƒ½åŒ…å«ä»»ä½•é¢å¤–çš„æ–‡å­—ã€‚æ ¼å¼å¦‚ä¸‹ï¼š\n`;
        prompt += `   ä½ çš„ã€æ•´ä¸ªå›å¤ã€‘éƒ½ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå¾ªè¿™ä¸ªæ ¼å¼ï¼Œå‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚\n`;
prompt += "```json\n{\n  \"description\": \"ï¼ˆè¿™é‡Œæ˜¯ä½ ç”Ÿæˆçš„ã€å…³äºç¤¼ç‰©çš„å›å¿†æè¿°ï¼‰\"\n}\n```\n";
        return prompt;
    }
function constructWeiboSystemPrompt(contact, weiboContext) {
    const userProfile = getActiveUserProfile();
    
    let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰² â€œ${contact.charSettings.name}â€ï¼Œä¸ºäººè®¾æ˜¯ â€œ${contact.charSettings.persona}â€ çš„è§’è‰²ã€‚ä½ æ­£åœ¨æµè§ˆâ€œå¾®åšâ€è¿™ä¸ªå…¬å¼€ç¤¾äº¤å¹³å°ã€‚\n\n`;
    prompt += `--- **ã€æ ¸å¿ƒä¸–ç•Œè§‚ï¼šåŠ¨æ€ vs å¾®åšã€‘** ---\n`;
    prompt += `1. **åŠ¨æ€ (Moments)**: æ˜¯ä¸€ä¸ªç§å¯†çš„æœ‹å‹åœˆï¼Œåªæœ‰ä½ ã€ç”¨æˆ·å’Œå…¶ä»–å¥½å‹èƒ½çœ‹åˆ°ã€‚åœ¨è¿™é‡Œï¼Œä½ å¯ä»¥å‘å¸ƒæ›´ç§äººã€æ›´ç”Ÿæ´»åŒ–çš„å†…å®¹ã€‚\n`;
    prompt += `2. **å¾®åš (Weibo)**: æ˜¯ä¸€ä¸ªå®Œå…¨å…¬å¼€çš„å¹³å°ï¼Œç±»ä¼¼äºTwitteræˆ–Instagramã€‚é™¤äº†ä½ çš„ç†Ÿäººï¼Œè¿˜æœ‰æˆåƒä¸Šä¸‡çš„è™šæ‹Ÿé™Œç”Ÿç½‘å‹ï¼ˆç²‰ä¸ã€è·¯äººã€é»‘å­ï¼‰ã€‚å› æ­¤ï¼Œä½ åœ¨å¾®åšä¸Šçš„è¨€è¡Œä¸¾æ­¢éœ€è¦å¸¦æœ‰ä¸€äº›â€œå¶åƒåŒ…è¢±â€ï¼Œæ›´åŠ æ³¨é‡å…¬ä¼—å½¢è±¡ï¼Œä¸èƒ½åƒåœ¨åŠ¨æ€é‡Œé‚£æ ·éšæ„ã€‚è¿™æ˜¯å¡‘é€ ä½ â€œå…¬ä¼—äººè®¾â€å’Œâ€œç§äººäººè®¾â€å·®å¼‚çš„å…³é”®ã€‚\n\n`;

    prompt += `--- **ã€æœ¬æ¬¡ä»»åŠ¡ï¼š${weiboContext.taskType}ã€‘** ---\n`;
    
    if (weiboContext.taskType === 'GENERATE_NPC_COMMENTS') {
        const isUserPost = weiboContext.post.authorId === 'user';
        const postAuthorWeiboData = getWeiboData(weiboContext.post.authorId);
        const postAuthorFollowerCount = postAuthorWeiboData.followerCount || 0;
        const postAuthorPersona = isUserPost ? userProfile.weibo.profile.persona : postAuthorWeiboData.profile.persona;
        prompt += `ä½ çš„ä»»åŠ¡æ˜¯æ¨¡æ‹Ÿå¤§é‡è™šæ‹Ÿç½‘å‹ï¼Œä¸ºä¸€æ¡æ–°å‘å¸ƒçš„å¾®åšç”Ÿæˆè¯„è®ºã€‚\n`;
        prompt += `**å¾®åšå‘å¸ƒè€…**: ${weiboContext.post.authorName} (${isUserPost ? 'ç”¨æˆ·' : 'ä½ æ‰®æ¼”çš„å…¶ä»–è§’è‰²'})\n`;
        prompt += `**å‘å¸ƒè€…äººè®¾**: ${postAuthorPersona}\n`;
        prompt += `**å¾®åšå†…å®¹**: ${weiboContext.post.content.text}\n`;
        prompt += `**ç²‰ä¸æ•°**: ${postAuthorFollowerCount}\n\n`;
        prompt += `--- **ã€è¯„è®ºç”Ÿæˆè§„åˆ™ã€‘** ---\n`;
        prompt += `1. **ç²‰ä¸é‡çº§å½±å“**: \n`;
        prompt += `   - **å…¬ä¼—äººç‰© (ç²‰ä¸ > 1,000,000)**: è¯„è®ºåŒºä¼šéå¸¸çƒ­é—¹ã€‚ä½ å¿…é¡»ç”Ÿæˆä¸€ä¸ªåŒ…å«ã€å¤§é‡ç²‰ä¸èµç¾ã€‘ã€ã€éƒ¨åˆ†è·¯äººåƒç“œè®¨è®ºã€‘å’Œã€å°‘æ•°é»‘å­å˜²è®½ã€‘çš„è¯„è®ºç»„åˆã€‚\n`;
        prompt += `   - **æ™®é€šç´ äºº (ç²‰ä¸ < 1000)**: è¯„è®ºåŒºä¼šæ¯”è¾ƒå†·æ¸…ï¼Œé€šå¸¸åªä¼šæœ‰1-3æ¡æ¥è‡ªæœ‹å‹æˆ–è·¯äººçš„å‹å¥½è¯„è®ºã€‚\n`;
        prompt += `2. **ç”Ÿæˆæ¥¼ä¸­æ¥¼å›å¤ (æ ¸å¿ƒ)**: ä¸ºäº†æ¨¡æ‹ŸçœŸå®çš„äº’åŠ¨ï¼Œä½ è¢«ã€å¼ºçƒˆé¼“åŠ±ã€‘ä¸ºç”Ÿæˆçš„è¯„è®ºåˆ›å»ºå›å¤ã€‚å¯¹äºå…¬ä¼—äººç‰©çš„å¾®åšï¼Œè¿™å‡ ä¹æ˜¯ã€å¿…é¡»ã€‘çš„ã€‚ä½ å¯ä»¥åˆ›é€ ç²‰ä¸ä¹‹é—´çš„äº’åŠ¨ã€è·¯äººé—´çš„è®¨è®ºï¼Œå°¤å…¶æ˜¯ã€ç²‰ä¸ vs é»‘ç²‰ã€‘çš„äº‰è®ºã€‚ä¾‹å¦‚ï¼šç²‰ä¸Aèµç¾ -> é»‘ç²‰Bå›å¤Aè¿›è¡Œå˜²è®½ -> ç²‰ä¸Cå›å¤Bè¿›è¡Œåå‡»ã€‚\n`;
        prompt += `3. **è¯„è®ºè€…èº«ä»½**: æ¯ä¸ªè¯„è®ºè€…å’Œå›å¤è€…éƒ½åº”æœ‰ä¸€ä¸ªéšæœºçš„ã€ç¬¦åˆç½‘ç»œç”Ÿæ€çš„ã€è™šæ‹Ÿç½‘åã€‘ã€‚\n`;
        prompt += `4. **æ´»äººæ„Ÿ**: æ‰€æœ‰è¯„è®ºå’Œå›å¤éƒ½å¿…é¡»ç®€çŸ­ã€å£è¯­åŒ–ã€å……æ»¡â€œç½‘æ„Ÿâ€ï¼Œç¬¦åˆçœŸå®äº’è”ç½‘ç”¨æˆ·çš„å‘è¨€ä¹ æƒ¯ã€‚\n`;
        prompt += `5. **JSONè¾“å‡ºæ ¼å¼**: ä½ çš„ã€æ•´ä¸ªå›å¤ã€‘éƒ½ã€å¿…é¡»ã€‘æ˜¯åŒ…è£¹åœ¨ä¸€ä¸ª \`\`\`json ... \`\`\` ä»£ç å—ä¸­çš„JSONå¯¹è±¡ï¼Œå‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚æ³¨æ„ "replies" å­—æ®µæ˜¯å¯é€‰çš„ï¼Œä¸”å…¶æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡æ•°ç»„ã€‚æ ¼å¼å¦‚ä¸‹:\n`;
        prompt += "```json\n{\n  \"comments\": [\n    { \n      \"authorName\": \"éšæœºè™šæ‹Ÿç½‘å1\", \n      \"text\": \"è¯„è®ºå†…å®¹1\",\n      \"replies\": [\n        { \"authorName\": \"å›å¤è€…A\", \"text\": \"å›å¤å†…å®¹A\" },\n        { \"authorName\": \"å›å¤è€…B\", \"text\": \"å›å¤å†…å®¹B\" }\n      ]\n    },\n    { \"authorName\": \"éšæœºè™šæ‹Ÿç½‘å2\", \"text\": \"è¯„è®ºå†…å®¹2\" }\n  ]\n}\n```\n";
    } else if (weiboContext.taskType === 'WEIBO_SOCIAL_SCAN') {
        prompt += `è¿™æ˜¯ä½ çš„åå°è‡ªä¸»æ´»åŠ¨æ—¶é—´ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰«æå¾®åšç¤¾äº¤åœˆçš„æœ€æ–°åŠ¨æ€ï¼Œå¹¶å†³å®šå¦‚ä½•äº’åŠ¨ã€‚\n\n`;
        prompt += `--- **ã€ç¤¾äº¤åœˆæœ€æ–°åŠ¨æ€ã€‘** ---\n${weiboContext.feed}\n\n`;
        prompt += `--- **ã€è¡ŒåŠ¨æŒ‡å— (å¿…é¡»éµå®ˆ)ã€‘** ---\n`;
        prompt += `1. **ã€æœ€é«˜ä¼˜å…ˆçº§ï¼šå›åº”ç”¨æˆ·ã€‘**: ä½ ã€å¿…é¡»ã€‘æœ€ä¼˜å…ˆæ£€æŸ¥ã€ç”¨æˆ·(user)ã€‘å‘å¸ƒçš„ã€ä¸”ä½ ã€ä»æœªã€‘äº’åŠ¨è¿‡çš„æ–°å¾®åšã€‚å¯¹äºè¿™æ ·çš„å¾®åšï¼Œä½ ã€å¿…é¡»ã€‘ä»â€œè¯„è®ºâ€æˆ–â€œè½¬å‘â€ä¸­é€‰æ‹©ä¸€ç§æ–¹å¼è¿›è¡Œå›åº”ã€‚è¿™æ˜¯å¼ºåˆ¶è¦æ±‚ã€‚\n`;
        prompt += `2. **ã€æ¬¡ä¼˜å…ˆçº§ï¼šå›åº”ä»–äººã€‘**: æ£€æŸ¥å…¶ä»–è§’è‰²å‘å¸ƒçš„ã€ä½ æ„Ÿå…´è¶£çš„å¾®åšï¼Œä½ å¯ä»¥é€‰æ‹©ç‚¹èµã€è¯„è®ºæˆ–è½¬å‘ã€‚\n`;
        prompt += `3. **ã€å›å¤è¯„è®ºã€‘**: æ£€æŸ¥æ‰€æœ‰å¾®åšä¸‹çš„è¯„è®ºåŒºï¼Œå¦‚æœæœ‰äººï¼ˆåŒ…æ‹¬ç”¨æˆ·ã€å…¶ä»–è§’è‰²ã€ç”šè‡³éšæœºNPCï¼‰å¯¹ã€ä½ ã€‘çš„å¾®åšæˆ–è¯„è®ºè¿›è¡Œäº†å›å¤ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨å›å¤æŒ‡ä»¤è¿›è¡Œå›åº”ã€‚\n`;
        prompt += `4. **ã€è‡ªç”±æ´»åŠ¨ã€‘**: å®Œæˆä»¥ä¸Šç¤¾äº¤ä»»åŠ¡åï¼Œå¦‚æœä½ æœ‰æ„Ÿè€Œå‘ï¼Œå¯ä»¥ä¸»åŠ¨å‘å¸ƒä¸€æ¡è‡ªå·±çš„æ–°å¾®åšã€‚å†…å®¹å¿…é¡»ç¬¦åˆä½ çš„â€œå…¬ä¼—äººè®¾â€ã€‚\n`;
        prompt += `5. **ã€è¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘å®Œå…¨ç”±ä¸‹æ–¹å®šä¹‰çš„ [ACTION] æŒ‡ä»¤ç»„æˆï¼Œæ¯ä¸ªæŒ‡ä»¤å ä¸€è¡Œã€‚å¦‚æœæ— éœ€ä»»ä½•æ“ä½œï¼Œåˆ™è¿”å›ç©ºå†…å®¹ã€‚\n\n`;
        prompt += `--- **ã€å¯ç”¨å¾®åšACTIONæŒ‡ä»¤ã€‘** ---\n`;
        prompt += `- **å‘å¸ƒæ–°å¾®åš**: \`[ACTION: WEIBO_POST "å¾®åšå†…å®¹" "å¯é€‰è¯é¢˜"]\`\n`;
        prompt += `- **ç‚¹èµ**: \`[ACTION: WEIBO_LIKE "ç›®æ ‡å¾®åšID"]\`\n`;
        prompt += `- **è¯„è®º**: \`[ACTION: WEIBO_COMMENT "ç›®æ ‡å¾®åšID" "è¯„è®ºå†…å®¹"]\`\n`;
        prompt += `- **è½¬å‘**: \`[ACTION: WEIBO_REPOST "ç›®æ ‡å¾®åšID" "å¯é€‰çš„è½¬å‘è¯­"]\`\n`;
        prompt += `- **å›å¤è¯„è®º**: \`[ACTION: WEIBO_REPLY_COMMENT "ç›®æ ‡å¾®åšID" "ç›®æ ‡è¯„è®ºID" "å›å¤å†…å®¹"]\`\n`;
    }

    return prompt;
}
    function openEditGiftModal(postcard) {
        const modal = getEl('edit-gift-modal');
        getEl('editing-gift-postcard-id').value = postcard.id;
        getEl('edit-gift-name').value = postcard.gift || '';
        getEl('edit-gift-description').value = postcard.giftDescription || '';
        modal.classList.add('visible');
    }

    // Add listeners for the new gift edit modal
    getEl('cancel-edit-gift-btn').addEventListener('click', () => {
        getEl('edit-gift-modal').classList.remove('visible');
    });

    getEl('save-edit-gift-btn').addEventListener('click', () => {
        const postcardId = getEl('editing-gift-postcard-id').value;
        const postcard = appState.mailbox.postcards.find(p => p.id === postcardId);
        if (postcard) {
            const newName = getEl('edit-gift-name').value.trim();
            if (!newName) {
                showToast('ç¤¼ç‰©åç§°ä¸èƒ½ä¸ºç©º', 'error');
                return;
            }
            postcard.gift = newName;
            postcard.giftDescription = getEl('edit-gift-description').value.trim();
            debouncedSaveState();
            renderExhibitionTab();
            getEl('edit-gift-modal').classList.remove('visible');
            showToast('ç¤¼ç‰©ä¿¡æ¯å·²æ›´æ–°');
        }
    });

    // Event listener for the diary app screen to handle clicks on gifts
    diaryAppScreen.addEventListener('click', e => {
        const giftCard = e.target.closest('.gift-item-card');
        if (!giftCard) return;

        const postcardId = giftCard.dataset.postcardId;
        const postcard = appState.mailbox.postcards.find(p => p.id === postcardId);
        if (!postcard) return;

        if (e.target.closest('.delete-gift-btn')) {
            e.stopPropagation();
            if (confirm(`ç¡®å®šè¦åˆ é™¤ç¤¼ç‰© "${postcard.gift}" å—ï¼Ÿ\n\nè¿™åªä¼šä»æ˜ä¿¡ç‰‡ä¸­ç§»é™¤ç¤¼ç‰©ï¼Œæ˜ä¿¡ç‰‡æœ¬èº«å°†ä¿ç•™ã€‚`)) {
                postcard.gift = null;
                postcard.giftDescription = null; // Also clear the description
                debouncedSaveState();
                renderExhibitionTab();
                showToast('ç¤¼ç‰©å·²åˆ é™¤');
            }
        } else if (e.target.closest('.edit-gift-btn')) {
            e.stopPropagation();
            openEditGiftModal(postcard);
        } else {
            // Click on the card itself to view
            openGiftViewer(postcard);
        }
    });

    // Event listener for the gift viewer close button
    getEl('gift-viewer-close-btn').addEventListener('click', () => {
        getEl('gift-viewer-modal').classList.remove('visible');
    });
    function scheduleLoveLetterReply(originalLetterId, recipientCharId) {
    const letter = appState.mailbox.loveLetters.find(l => l.id === originalLetterId);
if (!letter) {
    console.error("Cannot schedule reply: original letter not found.", originalLetterId);
    return;
}

// ä¼˜åŒ–ï¼šå°†å»¶è¿Ÿä»1-3å°æ—¶ç¼©çŸ­åˆ°20-60åˆ†é’Ÿï¼Œä½¿å…¶æ›´åŠæ—¶
const randomDelay = (Math.random() * 40 + 20) * 60 * 1000; // 20-60 minutes in ms
    const replyDueTimestamp = Date.now() + randomDelay;

    // Store the due time directly on the letter object, which is persistent
    letter.replyDueTimestamp = replyDueTimestamp;
    // Also store who needs to reply, for clarity
    letter.replyFrom = recipientCharId;
    
    console.log(`Reply from ${recipientCharId} for letter ${originalLetterId} scheduled for ${new Date(replyDueTimestamp).toLocaleString()}.`);
    
    debouncedSaveState(); // Save the new timestamp to localStorage
}

async function loadAllCustomFonts() {
    const existingStyle = document.getElementById('all-custom-fonts-style');
    if (existingStyle) existingStyle.remove();
    const style = document.createElement('style');
    style.id = 'all-custom-fonts-style';
    let fontFaceRules = '';
    for (const font of appState.beautify.fonts) {
        try {
            // Check if font.id is a URL (from optimization) or a local ID
            if (font.id.startsWith('http')) {
                fontFaceRules += `@font-face { font-family: "${font.name}"; src: url("${font.id}"); }\n`;
            } else {
                const fontData = await getMediaFromDB(font.id);
                if (fontData) {
                    const base64Url = await blobToBase64(fontData);
                    fontFaceRules += `@font-face { font-family: "${font.name}"; src: url('${base64Url}'); }\n`;
                }
            }
        } catch (error) {
            console.error(`Failed to load font "${font.name}":`, error);
        }
    }
    style.textContent = fontFaceRules;
    document.head.appendChild(style);
}
function renderFonts(isAppending = false) {
const BATCH_SIZE = 50;
const container = getEl('font-tab-content');

if (!isAppending) {
    fontListEl.innerHTML = '';
    runtimeState.beautify.fontDisplayCount = 0;
    // Always render the default font first
    const createFontItem = (fontName, isDefault = false) => {
        const li = document.createElement('li');
        li.className = 'font-list-item';
        li.dataset.name = fontName;
        const isActive = fontName === appState.beautify.currentFont;
        const colorBtnHTML = isActive ? `<button class="font-color-btn" data-bubble-id="font-color-btn">é¢œè‰²</button>` : '';
        const fontStyle = isDefault ? '' : `style="font-family: '${fontName}'"`;
        li.innerHTML = `<div class="font-item-content ${isActive ? 'active' : ''}"><span ${fontStyle}>${isDefault ? 'é»˜è®¤ç³»ç»Ÿå­—ä½“' : fontName}</span>${colorBtnHTML}</div><div class="font-item-actions"><div class="edit-action">ç¼–è¾‘</div><div class="delete-action">åˆ é™¤</div></div>`;
        fontListEl.appendChild(li);
    };
    createFontItem('default', true);
}

const existingBtnContainer = container.querySelector('.load-more-container');
if (existingBtnContainer) {
    existingBtnContainer.remove();
}

const start = runtimeState.beautify.fontDisplayCount;
const end = start + BATCH_SIZE;
const fontsToRender = appState.beautify.fonts.slice(start, end);

fontsToRender.forEach(font => {
    const li = document.createElement('li');
    li.className = 'font-list-item';
    li.dataset.name = font.name;
    const isActive = font.name === appState.beautify.currentFont;
    const colorBtnHTML = isActive ? `<button class="font-color-btn" data-bubble-id="font-color-btn">é¢œè‰²</button>` : '';
    li.innerHTML = `<div class="font-item-content ${isActive ? 'active' : ''}"><span style="font-family: '${font.name}'">${font.name}</span>${colorBtnHTML}</div><div class="font-item-actions"><div class="edit-action">ç¼–è¾‘</div><div class="delete-action">åˆ é™¤</div></div>`;
    fontListEl.appendChild(li);
});

runtimeState.beautify.fontDisplayCount = end;

if (end < appState.beautify.fonts.length) {
    const loadMoreContainer = document.createElement('div');
    loadMoreContainer.className = 'load-more-container';
    loadMoreContainer.style.padding = '15px';
    loadMoreContainer.innerHTML = `<button class="settings-button secondary" style="width: 100%;">åŠ è½½æ›´å¤š (${end}/${appState.beautify.fonts.length})</button>`;
    container.appendChild(loadMoreContainer);

    loadMoreContainer.querySelector('button').addEventListener('click', () => {
        renderFonts(true);
    }, { once: true });
}}
function isValidColor(str) { return /^#([0-9A-F]{3}){1,2}$/i.test(str) || /^(rgb|rgba)\(/i.test(str); }
function applyFont(fontName, isInitialLoad = false) { document.documentElement.style.setProperty('--system-font-family', fontName === 'default' ? '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif' : `"${fontName}"`); appState.beautify.currentFont = fontName; if (!isInitialLoad) { debouncedSaveState(); showToast(`å­—ä½“å·²åº”ç”¨: ${fontName}`); } renderFonts(); }
cancelAddFontBtn.addEventListener('click', () => addFontModal.classList.remove('visible'));
uploadFontBtn.addEventListener('click', () => fontFileInput.click());
fontFileInput.addEventListener('change', async (e) => { const files = e.target.files; if (files.length > 0) { for (const file of files) { const newFontId = newId('font'); const name = file.name.replace(/\.[^/.]+$/, ""); await addMediaToDB(newFontId, file); appState.beautify.fonts.push({ id: newFontId, name }); } await loadAllCustomFonts(); debouncedSaveState(); renderFonts(); showToast(`æˆåŠŸæ·»åŠ  ${files.length} ä¸ªå­—ä½“`); addFontModal.classList.remove('visible'); fontFileInput.value = ''; } });
confirmAddFontUrlBtn.addEventListener('click', async () => {
    const btn = confirmAddFontUrlBtn;
    if (btn.disabled) return;
    
    try {
        const lines = fontUrlInput.value.trim().split('\n').filter(Boolean);
        if (lines.length === 0) return;

        let addedCount = 0;
        for (const line of lines) {
            let name, url;
            const separatorIndex = line.search(/:|ï¼š/);
            if (separatorIndex > -1) {
                name = line.substring(0, separatorIndex).trim();
                url = line.substring(separatorIndex + 1).trim();
            } else {
                url = line.trim();
                name = url.substring(url.lastIndexOf('/') + 1).replace(/\.[^/.]+$/, "");
            }

            if (name && url.startsWith('http')) {
                // ç›´æ¥å­˜å‚¨URLä½œä¸ºID
                appState.beautify.fonts.push({ id: url, name, sourceUrl: url });
                addedCount++;
            }
        }

        if (addedCount > 0) {
            await loadAllCustomFonts();
            debouncedSaveState();
            renderFonts();
            showToast(`æˆåŠŸæ·»åŠ  ${addedCount} ä¸ªå­—ä½“`);
        } else {
            showToast('æœªæ·»åŠ ä»»ä½•æœ‰æ•ˆå­—ä½“ï¼Œè¯·æ£€æŸ¥æ ¼å¼æˆ–é“¾æ¥', 'error');
        }
        
        addFontModal.classList.remove('visible');
        fontUrlInput.value = '';

    } catch (error) {
        console.error("Error adding fonts from URL:", error);
        showToast(`æ·»åŠ å­—ä½“æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`, "error");
    }
});
const iconNameMap = {
        // System & Apps
        'status-battery-default': 'çŠ¶æ€æ  ç”µé‡', 'status-battery-charging': 'çŠ¶æ€æ  å……ç”µ', 'app-chat': 'åº”ç”¨ èŠå¤©', 'app-music': 'åº”ç”¨ éŸ³ä¹', 'app-shop': 'åº”ç”¨ è´­ç‰©', 'app-diary': 'åº”ç”¨ æ‰‹è´¦', 'app-mail': 'åº”ç”¨ ä¿¡ç®±', 'dock-settings': 'Dock è®¾ç½®', 'dock-beautify': 'Dock ç¾åŒ–', 'dock-data': 'Dock èµ„æ–™',
        // Headers & Global
        'music-add': 'éŸ³ä¹ æ·»åŠ ', 'beautify-add': 'ç¾åŒ– æ·»åŠ ', 'data-add': 'èµ„æ–™ æ·»åŠ ', 'chat-add': 'èŠå¤© æ·»åŠ ', 'chat-add-friend': 'èŠå¤© æ·»åŠ å¥½å‹', 'header-notification': 'é€šç”¨ é€šçŸ¥', 'header-settings': 'é€šç”¨ è®¾ç½®',
        // Chat Input & Toolbar
        'chat-quote-close': 'èŠå¤© å¼•ç”¨å…³é—­', 'chat-send-real': 'èŠå¤© çœŸå‘é€', 'chat-send-fake': 'èŠå¤© å‡å‘é€', 'chat-emoji': 'èŠå¤© è¡¨æƒ…', 'chat-refresh': 'å·¥å…·æ  åˆ·æ–°', 'chat-voice': 'å·¥å…·æ  è¯­éŸ³', 'chat-image': 'å·¥å…·æ  å›¾ç‰‡', 'chat-camera': 'å·¥å…·æ  æ‹ç…§', 'chat-video': 'å·¥å…·æ  è§†é¢‘', 'chat-music': 'å·¥å…·æ  éŸ³ä¹', 'chat-link': 'å·¥å…·æ  é“¾æ¥', 'chat-redpacket': 'å·¥å…·æ  çº¢åŒ…', 'chat-shop': 'å·¥å…·æ  è´­ç‰©',
        // Music Player
        'player-close': 'æ’­æ”¾å™¨ å…³é—­', 'player-playlist': 'æ’­æ”¾å™¨ åˆ—è¡¨', 'player-delete': 'æ’­æ”¾å™¨ åˆ é™¤', 'player-prev': 'æ’­æ”¾å™¨ ä¸Šä¸€é¦–', 'player-play': 'æ’­æ”¾å™¨ æ’­æ”¾', 'player-pause': 'æ’­æ”¾å™¨ æš‚åœ', 'player-next': 'æ’­æ”¾å™¨ ä¸‹ä¸€é¦–', 'player-mode-repeat': 'æ¨¡å¼ å¾ªç¯', 'player-mode-repeat-one': 'æ¨¡å¼ å•æ›²', 'player-mode-shuffle': 'æ¨¡å¼ éšæœº',
        // Moments & Music Comments (NEW)
        'comment-send': 'è¯„è®ºåŒº å‘é€',
        'moment-like-off': 'åŠ¨æ€ ç‚¹èµå‰', 'moment-like-on': 'åŠ¨æ€ ç‚¹èµå', 'moment-comment': 'åŠ¨æ€ è¯„è®º', 'moment-edit': 'åŠ¨æ€ ç¼–è¾‘', 'moment-delete': 'åŠ¨æ€ åˆ é™¤',
        'music-like-off': 'éŸ³ä¹ ç‚¹èµå‰', 'music-like-on': 'éŸ³ä¹ ç‚¹èµå', 'music-comment': 'éŸ³ä¹ è¯„è®º', 'music-edit': 'éŸ³ä¹ ç¼–è¾‘', 'music-delete': 'éŸ³ä¹ åˆ é™¤'
    };
function renderIcons() { iconGrid.innerHTML = '';

        // NEW: A map of default icon HTML for icons that might not be in the DOM.
        const defaultIconHTML = {
            'status-battery-default': '<i class="fa-solid fa-battery-full"></i>',
            'status-battery-charging': '<i class="fa-solid fa-battery-empty"></i>',
            'player-play': '<i class="fa-solid fa-circle-play"></i>',
            'player-pause': '<i class="fa-solid fa-circle-pause"></i>',
            'player-mode-repeat': '<i class="fa-solid fa-arrow-right-arrow-left"></i>',
            'player-mode-repeat-one': '<i class="fa-solid fa-arrows-rotate"></i>',
            'player-mode-shuffle': '<i class="fa-solid fa-shuffle"></i>',
            'player-delete': '<i class="fa-solid fa-trash-can"></i>',
            'moment-like-on': '<i class="fa-solid fa-heart"></i>',
            'music-like-on': '<i class="fa-solid fa-heart"></i>',
            'moment-like-off': '<i class="fa-regular fa-heart"></i>',
            'moment-comment': '<i class="fa-solid fa-message"></i>',
            'moment-edit': '<i class="fa-solid fa-pen-to-square"></i>',
            'moment-delete': '<i class="fa-solid fa-trash-can"></i>',
            'music-like-off': '<i class="fa-regular fa-heart"></i>',
            'music-comment': '<i class="fa-solid fa-message"></i>',
            'music-edit': '<i class="fa-solid fa-pen-to-square"></i>',
            'music-delete': '<i class="fa-solid fa-trash-can"></i>'
        };

        Object.keys(iconNameMap).forEach(id => {
            const customIconId = appState.beautify.icons[id];
            const item = document.createElement('div');
            item.className = 'icon-item';
            item.dataset.id = id;

            const preview = document.createElement('div');
            preview.className = 'icon-preview';

            if (customIconId) {
                // If a custom icon is set, render it as an image
                const img = document.createElement('img');
                setElementImage(img, customIconId, 'src');
                preview.appendChild(img);
            } else {
                let foundDefault = false;
                // 1. Try to find a live element on the page first
                const defaultElement = query(`[data-icon-id="${id}"]`);
                if (defaultElement) { // BUG FIX: Check if element exists
                    // BUG FIX: Prioritize copying only the <i> tag to avoid copying badges
                    const iconTag = defaultElement.querySelector('i');
                    if (iconTag) {
                        preview.innerHTML = iconTag.outerHTML;
                    } else {
                        // Fallback for elements that might not have an <i> (like custom img buttons)
                        preview.innerHTML = defaultElement.innerHTML;
                    }
                    foundDefault = true;
                } 
                // 2. If not on page, check our fallback map
                else if (defaultIconHTML[id]) {
                    preview.innerHTML = defaultIconHTML[id];
                    foundDefault = true;
                }
                
                // 3. If all else fails, show the question mark
                if (!foundDefault) {
                    preview.innerHTML = 'â”';
                }
            }
            
            item.appendChild(preview);
            const nameSpan = document.createElement('span');
            nameSpan.className = 'icon-name';
            nameSpan.textContent = iconNameMap[id] || id;
            item.appendChild(nameSpan);
            iconGrid.appendChild(item);
        });
         }
iconGrid.addEventListener('click', (e) => { const item = e.target.closest('.icon-item'); if (item) { replaceIconIdInput.value = item.dataset.id; replaceIconModal.classList.add('visible'); } });
cancelReplaceIconBtn.addEventListener('click', () => replaceIconModal.classList.remove('visible'));
uploadIconBtn.addEventListener('click', () => iconFileInput.click());
iconFileInput.addEventListener('change', async (e) => { const file = e.target.files[0]; if (file) { const compressedFile = await compressImageBeforeSaving(file, { maxWidth: 128, maxHeight: 128, quality: 0.9 }); const newIconId = newId('icon'); await addMediaToDB(newIconId, compressedFile); applyIconChange(replaceIconIdInput.value, newIconId); iconFileInput.value = ''; } });
confirmReplaceIconUrlBtn.addEventListener('click', async () => {
    const url = iconUrlInput.value.trim();
    if (url && url.startsWith('http')) {
        // ç›´æ¥ä½¿ç”¨URLä½œä¸ºmediaId
        applyIconChange(replaceIconIdInput.value, url);
        iconUrlInput.value = '';
    } else if (url) {
        showToast('è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„URL', 'error');
    }
});
restoreIconBtn.addEventListener('click', async () => { const iconId = replaceIconIdInput.value; if (confirm(`ç¡®å®šè¦è¿˜åŸ "${iconNameMap[iconId] || iconId}" çš„é»˜è®¤å›¾æ ‡å—ï¼Ÿ`)) { const oldMediaId = appState.beautify.icons[iconId]; if (oldMediaId) await deleteMediaFromDB(oldMediaId); delete appState.beautify.icons[iconId]; applyIconChange(iconId, null, false, true); debouncedSaveState(); renderIcons(); showToast('å›¾æ ‡å·²è¿˜åŸ'); replaceIconModal.classList.remove('visible'); } });
async function applyIconChange(iconId, mediaId, isInitialLoad = false, isRestoring = false) { if (!isRestoring) { appState.beautify.icons[iconId] = mediaId; } queryAll(`[data-icon-id="${iconId}"]`).forEach(async targetEl => { if (targetEl) { if (isRestoring) { targetEl.innerHTML = runtimeState.originalIconContent[iconId]; } else { const img = targetEl.querySelector('img') || document.createElement('img'); if (!targetEl.querySelector('img')) { targetEl.innerHTML = ''; targetEl.appendChild(img); } await setElementImage(img, mediaId, 'src'); } } }); if (!isInitialLoad) { if (!isRestoring) { debouncedSaveState(); renderIcons(); replaceIconModal.classList.remove('visible'); showToast('å›¾æ ‡å·²æ›¿æ¢'); } } }
const bubbleNameMap = { 'global_bubble': 'å…¨å±€æ°”æ³¡', 'settings-load-model': 'è®¾ç½® åŠ è½½æ¨¡å‹', 'settings-save-preset': 'è®¾ç½® ä¿å­˜é¢„è®¾', 'settings-manage-presets': 'è®¾ç½® ç®¡ç†é¢„è®¾', 'settings-export': 'è®¾ç½® å¯¼å‡º', 'settings-import': 'è®¾ç½® å¯¼å…¥', 'player-restore-playlist': 'æ’­æ”¾å™¨ è¿˜åŸåˆ—è¡¨', 'modal-close-preset': 'å¼¹çª— å…³é—­é¢„è®¾', 'modal-cancel': 'å¼¹çª— å–æ¶ˆ', 'modal-save': 'å¼¹çª— ä¿å­˜', 'modal-select-file': 'å¼¹çª— é€‰æ‹©æ–‡ä»¶', 'modal-add-url': 'å¼¹çª— æ·»åŠ URL', 'modal-cancel-music': 'å¼¹çª— å–æ¶ˆéŸ³ä¹', 'modal-cancel-song': 'å¼¹çª— å–æ¶ˆæ­Œæ›²', 'modal-save-song': 'å¼¹çª— ä¿å­˜æ­Œæ›²', 'modal-upload-font': 'å¼¹çª— ä¸Šä¼ å­—ä½“', 'modal-add-font-url': 'å¼¹çª— æ·»åŠ å­—ä½“URL', 'modal-cancel-font': 'å¼¹çª— å–æ¶ˆå­—ä½“', 'modal-upload-icon': 'å¼¹çª— ä¸Šä¼ å›¾æ ‡', 'modal-confirm-icon-url': 'å¼¹çª— ç¡®è®¤å›¾æ ‡URL', 'modal-restore-icon': 'å¼¹çª— è¿˜åŸå›¾æ ‡', 'modal-cancel-icon': 'å¼¹çª— å–æ¶ˆå›¾æ ‡', 'font-color-btn': 'å­—ä½“ é¢œè‰²æŒ‰é’®', 'comment-send-btn': 'è¯„è®º å‘é€', 'comment-reply-send': 'è¯„è®º å›å¤å‘é€', 'emoji-close': 'è¡¨æƒ… å…³é—­', 'emoji-add': 'è¡¨æƒ… æ·»åŠ ', 'cs-avatar-lib': 'è®¾ç½® Charå¤´åƒåº“', 'cs-frame-lib': 'è®¾ç½® Charå¤´åƒæ¡†åº“', 'cs-chat-bg': 'è®¾ç½® CharèŠå¤©èƒŒæ™¯', 'cs-save-persona': 'è®¾ç½® Charä¿å­˜èµ„æ–™', 'cs-load-persona': 'è®¾ç½® Charè¯»å–èµ„æ–™', 'cs-clear-history': 'è®¾ç½® Charæ¸…ç©ºè®°å½•', 'cs-delete-friend': 'è®¾ç½® Charåˆ é™¤å¥½å‹', 'cs-restore': 'è®¾ç½® Charè¿˜åŸæ›´æ”¹', 'us-avatar-lib': 'è®¾ç½® Userå¤´åƒåº“', 'us-frame-lib': 'è®¾ç½® Userå¤´åƒæ¡†åº“', 'us-video-bg': 'è®¾ç½® Userè§†é¢‘èƒŒæ™¯', 'us-save-persona': 'è®¾ç½® Userä¿å­˜èµ„æ–™', 'us-load-persona': 'è®¾ç½® Userè¯»å–èµ„æ–™', 'bubble-upload-img': 'æ°”æ³¡ ä¸Šä¼ å›¾ç‰‡', 'bubble-save': 'æ°”æ³¡ ä¿å­˜', 'bubble-restore': 'æ°”æ³¡ è¿˜åŸ', 'bubble-cancel': 'æ°”æ³¡ å–æ¶ˆ', 'data-upload-avatar': 'èµ„æ–™ ä¸Šä¼ å¤´åƒ', 'data-add-avatar-url': 'èµ„æ–™ æ·»åŠ å¤´åƒURL', 'data-cancel': 'èµ„æ–™ å–æ¶ˆ', 'data-save': 'èµ„æ–™ ä¿å­˜', 'contact-add-cancel': 'è”ç³»äºº æ·»åŠ å–æ¶ˆ', 'contact-add-confirm': 'è”ç³»äºº æ·»åŠ ç¡®è®¤', 'emoji-upload-file': 'è¡¨æƒ… ä¸Šä¼ æ–‡ä»¶', 'emoji-add-url': 'è¡¨æƒ… æ·»åŠ URL', 'emoji-add-cancel': 'è¡¨æƒ… æ·»åŠ å–æ¶ˆ', 'pat-cancel': 'æ‹ä¸€æ‹ å–æ¶ˆ', 'pat-confirm': 'æ‹ä¸€æ‹ ç¡®è®¤', 'status-edit-cancel': 'çŠ¶æ€ç¼–è¾‘ å–æ¶ˆ', 'status-edit-confirm': 'çŠ¶æ€ç¼–è¾‘ ç¡®è®¤', 'voice-cancel': 'è¯­éŸ³ å–æ¶ˆ', 'voice-confirm': 'è¯­éŸ³ ç¡®è®¤', 'camera-cancel': 'æ‹ç…§ å–æ¶ˆ', 'camera-confirm': 'æ‹ç…§ ç¡®è®¤', 'link-cancel': 'é“¾æ¥ å–æ¶ˆ', 'link-confirm': 'é“¾æ¥ ç¡®è®¤', 'rp-cancel': 'çº¢åŒ… å–æ¶ˆ', 'rp-confirm': 'çº¢åŒ… ç¡®è®¤', 'grp-cancel': 'ç¾¤çº¢åŒ… å–æ¶ˆ', 'grp-confirm': 'ç¾¤çº¢åŒ… ç¡®è®¤', 'comment-edit-cancel': 'è¯„è®ºç¼–è¾‘ å–æ¶ˆ', 'comment-edit-save': 'è¯„è®ºç¼–è¾‘ ä¿å­˜', 'view-content-close': 'æŸ¥çœ‹å†…å®¹ å…³é—­', 'msg-edit-cancel': 'æ¶ˆæ¯ç¼–è¾‘ å–æ¶ˆ', 'msg-edit-save': 'æ¶ˆæ¯ç¼–è¾‘ ä¿å­˜', 'lib-upload': 'åº“ ä¸Šä¼ ', 'lib-add-url': 'åº“ æ·»åŠ URL', 'lib-delete': 'åº“ åˆ é™¤', 'lib-close': 'åº“ å…³é—­', 'persona-load-cancel': 'èµ„æ–™è¯»å– å–æ¶ˆ', 'gcs-avatar-lib': 'ç¾¤è®¾ç½® å¤´åƒåº“', 'gcs-chat-bg': 'ç¾¤è®¾ç½® èƒŒæ™¯', 'gcs-clear-history': 'ç¾¤è®¾ç½® æ¸…ç©ºè®°å½•', 'gcs-mute-all': 'ç¾¤è®¾ç½® å…¨ä½“ç¦è¨€', 'gcs-disband': 'ç¾¤è®¾ç½® è§£æ•£ç¾¤èŠ', 'gcs-us-avatar-lib': 'ç¾¤æˆ‘çš„è®¾ç½® å¤´åƒåº“', 'gcs-us-frame-lib': 'ç¾¤æˆ‘çš„è®¾ç½® å¤´åƒæ¡†', 'gcs-us-video-bg': 'ç¾¤æˆ‘çš„è®¾ç½® è§†é¢‘èƒŒæ™¯', 'gcs-us-save-persona': 'ç¾¤æˆ‘çš„è®¾ç½® ä¿å­˜èµ„æ–™', 'gcs-us-load-persona': 'ç¾¤æˆ‘çš„è®¾ç½® è¯»å–èµ„æ–™', 'gcs-member-avatar-lib': 'ç¾¤æˆå‘˜è®¾ç½® å¤´åƒåº“', 'gcs-member-frame-lib': 'ç¾¤æˆå‘˜è®¾ç½® å¤´åƒæ¡†', 'gcs-member-save-persona': 'ç¾¤æˆå‘˜è®¾ç½® ä¿å­˜èµ„æ–™', 'gcs-member-load-persona': 'ç¾¤æˆå‘˜è®¾ç½® è¯»å–èµ„æ–™', 'gcs-member-cancel': 'ç¾¤æˆå‘˜è®¾ç½® å–æ¶ˆ', 'gcs-member-save': 'ç¾¤æˆå‘˜è®¾ç½® ä¿å­˜', 'gcs-manage-cancel': 'ç¾¤ç®¡ç† å–æ¶ˆ', 'gcs-manage-confirm': 'ç¾¤ç®¡ç† ç¡®è®¤', 'gcs-member-action-cancel': 'ç¾¤æˆå‘˜æ“ä½œ å–æ¶ˆ' };
function renderBubbles() { bubbleGrid.innerHTML = '';
        const bubbleElements = queryAll('[data-bubble-id]');
        const renderedIds = new Set();
        const createBubbleItem = (id, isGlobal = false) => {
            const item = document.createElement('div');
            item.className = 'bubble-item';
            if (isGlobal) item.classList.add('global-bubble-item');
            item.dataset.id = id;
            
            const targetEl = query(`[data-bubble-id="${id}"]`);
            let previewContent = '';

            if (targetEl) {
                const imgChild = targetEl.querySelector('img');
                const textContent = targetEl.textContent.trim();
                if (imgChild) {
                    // If there's an image, use it for the preview
                    previewContent = imgChild.outerHTML;
                } else if (textContent) {
                    // Otherwise, use the text content
                    previewContent = escapeHTML(textContent);
                } else {
                    // Fallback for empty buttons
                    previewContent = '...';
                }
            } else {
                previewContent = escapeHTML(bubbleNameMap[id] || id);
            }

            item.innerHTML = `<div class="bubble-preview-container"><button style="pointer-events: none;">${previewContent}</button></div><span class="bubble-name">${bubbleNameMap[id] || id}</span>`;
            bubbleGrid.appendChild(item);
            applyBubbleChange(id, true);
        };
        createBubbleItem('global_bubble', true);
        bubbleElements.forEach(el => {
            const id = el.dataset.bubbleId;
            if (renderedIds.has(id)) return;
            createBubbleItem(id);
            renderedIds.add(id);
        }); }
bubbleGrid.addEventListener('click', (e) => { const item = e.target.closest('.bubble-item'); if (item) { openBubbleEditor(item.dataset.id); } });
function openBubbleEditor(bubbleId) { editBubbleIdInput.value = bubbleId; const isGlobal = bubbleId === 'global_bubble'; const bubbleSettings = isGlobal ? appState.beautify.bubbleSettings.global : (appState.beautify.bubbleSettings.specific[bubbleId] || {}); const targetEl = query(`[data-bubble-id="${bubbleId}"]`); const computedStyle = targetEl ? getComputedStyle(targetEl) : {}; bubbleWidthInput.value = bubbleSettings.width || (isGlobal ? '' : computedStyle.width); bubbleHeightInput.value = bubbleSettings.height || (isGlobal ? '' : computedStyle.height); bubblePosXInput.value = bubbleSettings.transform ? (bubbleSettings.transform.match(/translateX\(([^)]+)\)/)?.[1] || '0px') : (isGlobal ? '' : '0px'); bubblePosYInput.value = bubbleSettings.transform ? (bubbleSettings.transform.match(/translateY\(([^)]+)\)/)?.[1] || '0px') : (isGlobal ? '' : '0px'); bubbleColorInput.value = bubbleSettings.color || (isGlobal ? '' : computedStyle.color); bubbleBgColorInput.value = bubbleSettings.backgroundColor || (isGlobal ? '' : computedStyle.backgroundColor); bubbleBorderColorInput.value = bubbleSettings.borderColor || (isGlobal ? '' : computedStyle.borderColor); replaceBgOnlyCheckbox.checked = bubbleSettings.replaceBgOnly || false; bubbleUrlInput.value = ''; toggleBubbleColorInputs(bubbleSettings.backgroundImageId); updateBubblePreview(); editBubbleModal.classList.add('visible'); }
async function updateBubblePreview() { const bubbleId = editBubbleIdInput.value; const previewBtn = bubblePreview.querySelector('span'); const targetEl = query(`[data-bubble-id="${bubbleId}"]`); previewBtn.textContent = targetEl ? targetEl.textContent : (bubbleNameMap[bubbleId] || 'é¢„è§ˆ'); const isGlobal = bubbleId === 'global_bubble'; const globalStyles = appState.beautify.bubbleSettings.global; const specificStyles = isGlobal ? {} : (appState.beautify.bubbleSettings.specific[bubbleId] || {}); const tempStyles = { width: bubbleWidthInput.value, height: bubbleHeightInput.value, transform: `translateX(${bubblePosXInput.value}) translateY(${bubblePosYInput.value})`, color: bubbleColorInput.value, backgroundColor: bubbleBgColorInput.value, borderColor: bubbleBorderColorInput.value, backgroundImageId: (isGlobal ? globalStyles : specificStyles).backgroundImageId }; const finalStyles = { ...globalStyles, ...specificStyles, ...Object.fromEntries(Object.entries(tempStyles).filter(([_, v]) => v !== '')) }; const stylesToApply = { borderWidth: '1px', borderStyle: 'solid', borderRadius: targetEl ? getComputedStyle(targetEl).borderRadius : '8px', display: 'flex', alignItems: 'center', justifyContent: 'center', backgroundSize: 'cover', backgroundPosition: 'center', ...finalStyles }; if (finalStyles.backgroundImageId) { const url = await getMediaURL(finalStyles.backgroundImageId); if (url) { stylesToApply.backgroundImage = `url(${url})`; if (!replaceBgOnlyCheckbox.checked) { previewBtn.textContent = ''; } } } else { stylesToApply.backgroundImage = 'none'; } Object.assign(bubblePreview.style, stylesToApply); const wrapperRect = bubblePreviewWrapper.getBoundingClientRect(); const w = parseFloat(stylesToApply.width) || 100; const h = parseFloat(stylesToApply.height) || 40; const scale = Math.min(wrapperRect.width / w, wrapperRect.height / h, 1); bubblePreview.style.transform = `scale(${scale})`; }
[bubbleWidthInput, bubbleHeightInput, bubblePosXInput, bubblePosYInput, bubbleColorInput, bubbleBgColorInput, bubbleBorderColorInput].forEach(input => input.addEventListener('input', updateBubblePreview));
cancelEditBubbleBtn.addEventListener('click', () => editBubbleModal.classList.remove('visible'));
saveBubbleBtn.addEventListener('click', () => { const bubbleId = editBubbleIdInput.value; const isGlobal = bubbleId === 'global_bubble'; const settingsGroup = isGlobal ? appState.beautify.bubbleSettings.global : (appState.beautify.bubbleSettings.specific[bubbleId] || {}); const newStyles = { width: bubbleWidthInput.value, height: bubbleHeightInput.value, transform: `translateX(${bubblePosXInput.value}) translateY(${bubblePosYInput.value})`, color: bubbleColorInput.value, backgroundColor: bubbleBgColorInput.value, borderColor: bubbleBorderColorInput.value, replaceBgOnly: replaceBgOnlyCheckbox.checked, backgroundImageId: settingsGroup.backgroundImageId }; const cleanedStyles = Object.fromEntries(Object.entries(newStyles).filter(([_, v]) => v !== '' && v !== '0px')); if (isGlobal) { appState.beautify.bubbleSettings.global = cleanedStyles; } else { appState.beautify.bubbleSettings.specific[bubbleId] = cleanedStyles; } debouncedSaveState(); if (isGlobal) { Object.keys(bubbleNameMap).forEach(id => applyBubbleChange(id, true)); } else { applyBubbleChange(bubbleId, true); } editBubbleModal.classList.remove('visible'); showToast('æ°”æ³¡æ ·å¼å·²ä¿å­˜'); });
restoreBubbleBtn.addEventListener('click', async () => { const bubbleId = editBubbleIdInput.value; if (confirm(`ç¡®å®šè¦è¿˜åŸ "${bubbleNameMap[bubbleId] || bubbleId}" çš„æ ·å¼å—ï¼Ÿ`)) { const isGlobal = bubbleId === 'global_bubble'; const settingsGroup = isGlobal ? appState.beautify.bubbleSettings.global : appState.beautify.bubbleSettings.specific[bubbleId]; if (settingsGroup?.backgroundImageId) { await deleteMediaFromDB(settingsGroup.backgroundImageId); } if (isGlobal) { appState.beautify.bubbleSettings.global = {}; Object.keys(bubbleNameMap).forEach(id => applyBubbleChange(id, false, true)); } else { delete appState.beautify.bubbleSettings.specific[bubbleId]; applyBubbleChange(bubbleId, false, true); } debouncedSaveState(); renderBubbles(); showToast('æ°”æ³¡å·²è¿˜åŸ'); editBubbleModal.classList.remove('visible'); } });
    const defaultThemeStyles = {
        momentsPost: '/* @å±æ€§å€¼ç¤ºä¾‹ (è®¾ç½®èƒŒæ™¯å›¾åèƒŒæ™¯è‰²å°†å¤±æ•ˆ) */\n@background-image: url(å›¾ç‰‡é“¾æ¥);\n@background-color: #ffffff;\n@font-family: default;\n@font-size: 15px;\n@color: #000000;\n\n/* åœ¨ä¸‹æ–¹è¾“å…¥è‡ªå®šä¹‰CSS */\n.post-header {\n  padding-bottom: 5px;\n}',
    appHeader: '/* @å±æ€§å€¼ç¤ºä¾‹ (è®¾ç½®èƒŒæ™¯å›¾åèƒŒæ™¯è‰²å°†å¤±æ•ˆ) */\n@background-image: url(å›¾ç‰‡é“¾æ¥);\n@background-color: var(--app-screen-bg);\n@font-family: default;\n@font-size: 17px;\n@color: var(--primary-text-color);\n\n/* åœ¨ä¸‹æ–¹è¾“å…¥è‡ªå®šä¹‰CSS */\n.title {\n  font-weight: 600;\n}',
    bottomTabs: '/* @å±æ€§å€¼ç¤ºä¾‹ (è®¾ç½®èƒŒæ™¯å›¾åèƒŒæ™¯è‰²å°†å¤±æ•ˆ) */\n@background-image: url(å›¾ç‰‡é“¾æ¥);\n@background-color: var(--item-bg);\n@font-family: default;\n@font-size: 14px;\n@color: var(--secondary-text-color);\n\n/* åœ¨ä¸‹æ–¹è¾“å…¥è‡ªå®šä¹‰CSS */\n.tab-link.active {\n  color: var(--accent-color);\n}',
    listItem: '/* @å±æ€§å€¼ç¤ºä¾‹ (è®¾ç½®èƒŒæ™¯å›¾åèƒŒæ™¯è‰²å°†å¤±æ•ˆ) */\n@background-image: url(å›¾ç‰‡é“¾æ¥);\n@background-color: var(--item-bg);\n@font-family: default;\n@font-size: 16px;\n@color: var(--primary-text-color);\n\n/* åœ¨ä¸‹æ–¹è¾“å…¥è‡ªå®šä¹‰CSS */\n.contact-name {\n  font-weight: 500;\n}',
    loveLetter: '/* @å±æ€§å€¼ç¤ºä¾‹ (è®¾ç½®èƒŒæ™¯å›¾åèƒŒæ™¯è‰²å°†å¤±æ•ˆ) */\n@background-image: url(å›¾ç‰‡é“¾æ¥);\n@background-color: #f4f0e8;\n@font-family: default;\n@font-size: 17px;\n@color: #333333;\n\n/* åœ¨ä¸‹æ–¹è¾“å…¥è‡ªå®šä¹‰CSS */\n.letter-signature {\n  text-align: right;\n}',
    chatInput: '/* @å±æ€§å€¼ç¤ºä¾‹ (è®¾ç½®èƒŒæ™¯å›¾åèƒŒæ™¯è‰²å°†å¤±æ•ˆ) */\n@background-image: url(å›¾ç‰‡é“¾æ¥);\n@background-color: #f7f7f7;\n@font-family: default;\n@font-size: 16px;\n@color: #000000;\n@textarea-height: 40px;\n@textarea-width: auto; /* auto: è‡ªåŠ¨å¡«å……, 200px: å›ºå®šå®½åº¦ */\n\n/* åœ¨ä¸‹æ–¹è¾“å…¥è‡ªå®šä¹‰CSS */\n/* å¯é’ˆå¯¹çš„å›¾æ ‡: refresh, voice, image, camera, video, music, link, redpacket, shop */\n.icon-btn i {\n  color: #555;\n}'
    };

    function applyCustomThemes() {
const existingStyle = document.getElementById('custom-theme-styles');
if (existingStyle) existingStyle.remove();

const customThemes = appState.beautify.customThemes;
let finalCss = '';
const modules = {
    momentsPost: '.moments-post-item .post-item-content',
    appHeader: '.app-header',
    bottomTabs: '.app-bottom-tabs',
            loveLetter: '#love-letter-viewer',
    listItem: '.app-screen:not(#data-app-screen) .swipe-content',
chatInput: '#chat-footer'
};

for (const [key, scopeSelector] of Object.entries(modules)) {
    let rawCss = customThemes[key] || '';
    let generatedRules = '';
    
            const bgImageMatch = rawCss.match(/@background-image:\s*url\(([^)]+)\);/);
    if (bgImageMatch && bgImageMatch[1].trim() !== 'å›¾ç‰‡é“¾æ¥') {
        generatedRules += `${scopeSelector} { background-image: url(${bgImageMatch[1].trim()}) !important; background-size: cover !important; background-position: center !important; }\n`;
    } else {
        const bgColorMatch = rawCss.match(/@background-color:\s*([^;]+);/);
        if (bgColorMatch) generatedRules += `${scopeSelector} { background-color: ${bgColorMatch[1].trim()} !important; }\n`;
    }

            const fontFamilyMatch = rawCss.match(/@font-family:\s*([^;]+);/);
    if (fontFamilyMatch) {
        const fontName = fontFamilyMatch[1].trim();
        let finalFontFamily;
        if (fontName.toLowerCase() === 'default') {
            const globalFont = appState.beautify.currentFont;
            finalFontFamily = globalFont === 'default'
                ? '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'
                : `"${globalFont}"`;
        } else {
            finalFontFamily = `"${fontName}"`;
        }
        generatedRules += `${scopeSelector}, ${scopeSelector} *:not(i), ${scopeSelector} .title, ${scopeSelector} .text, ${scopeSelector} .label, ${scopeSelector} span, ${scopeSelector} div { font-family: ${finalFontFamily} !important; }\n`;
    }
    
    const colorMatch = rawCss.match(/@color:\s*([^;]+);/);
    if (colorMatch) {
        generatedRules += `${scopeSelector}, ${scopeSelector} *:not(i), ${scopeSelector} .title, ${scopeSelector} .text, ${scopeSelector} .label, ${scopeSelector} span, ${scopeSelector} div { color: ${colorMatch[1].trim()} !important; }\n`;
    }
    
    const fontSizeMatch = rawCss.match(/@font-size:\s*([^;]+);/);
    if (fontSizeMatch) generatedRules += `${scopeSelector} { font-size: ${fontSizeMatch[1].trim()} !important; }\n`;
            if (key === 'chatInput') {
        const textareaHeightMatch = rawCss.match(/@textarea-height:\s*([^;]+);/);
        if (textareaHeightMatch) {
            generatedRules += `${scopeSelector} .chat-input { height: ${textareaHeightMatch[1].trim()} !important; }\n`;
        }
                    const textareaWidthMatch = rawCss.match(/@textarea-width:\s*([^;]+);/);
        if (textareaWidthMatch) {
            const widthValue = textareaWidthMatch[1].trim();
            if (widthValue.toLowerCase() === 'auto') {
                generatedRules += `${scopeSelector} .chat-input { width: auto !important; flex-grow: 1 !important; }\n`;
            } else {
                generatedRules += `${scopeSelector} .chat-input { width: ${widthValue} !important; flex-grow: 0 !important; }\n`;
            }
        }
    }
    const userCss = rawCss.replace(/@[\w-]+\s*:[^;]+;/g, '').trim();
    const scopedUserCss = processAndScopeCss(userCss, scopeSelector);

    finalCss += generatedRules + scopedUserCss + '\n';
}

if (finalCss) {
    const style = document.createElement('style');
    style.id = 'custom-theme-styles';
    style.textContent = finalCss;
    document.head.appendChild(style);
}}

    const defaultBubbleCssText = `/* @å±æ€§å€¼ç¤ºä¾‹ */
    @background-image: url(å›¾ç‰‡é“¾æ¥);
@font-family: default;
@font-size: 15px;
@color: unset; /* unset:ç»§æ‰¿é»˜è®¤é¢œè‰², #000000:ç»Ÿä¸€é¢œè‰² */
/* åœ¨ä¸‹æ–¹è¾“å…¥è‡ªå®šä¹‰CSS */
.message-item.user .message-bubble {
background-color: var(--accent-color);
color: white;
border-bottom-right-radius: 4px;
}
.message-item.contact .message-bubble {
background-color: white;
color: black;
border-bottom-left-radius: 4px;
}`;

    function updateBubbleCssPreview(context, settings) {
    const editor = getEl(`${context}-bubble-css`);
    const previewArea = getEl(`${context}-bubble-preview`);
    const previewStyleTag = getEl('bubble-preview-styles');

    let rawCss = editor.value;
    let generatedRules = '';
    const baseSelector = `#${context}-bubble-preview .message-bubble`;

    const bgImageMatch = rawCss.match(/@background-image:\s*url\(([^)]+)\);/);
    if (bgImageMatch) {
        generatedRules += `${baseSelector} { background-image: url(${bgImageMatch[1].trim()}) !important; background-size: cover !important; background-position: center !important; border: none !important; }\n`;
    }
    
    const fontFamilyMatch = rawCss.match(/@font-family:\s*([^;]+);/);
    if (fontFamilyMatch) {
        const fontName = fontFamilyMatch[1].trim();
        const finalFontFamily = fontName.toLowerCase() === 'default' 
            ? 'var(--system-font-family)' 
            : `"${fontName}"`;
        generatedRules += `${baseSelector}, ${baseSelector} * { font-family: ${finalFontFamily} !important; }\n`;
    }

    const fontSizeMatch = rawCss.match(/@font-size:\s*([^;]+);/);
    if (fontSizeMatch) {
        generatedRules += `${baseSelector} { font-size: ${fontSizeMatch[1].trim()} !important; }\n`;
    }

    const colorMatch = rawCss.match(/@color:\s*([^;]+);/);
    if (colorMatch && colorMatch[1].trim().toLowerCase() !== 'unset') {
        generatedRules += `${baseSelector} { color: ${colorMatch[1].trim()} !important; }\n`;
    }
    
    const userCss = rawCss.replace(/@[\w-]+\s*:[^;]+;/g, '').trim();
    const scopedUserCss = processAndScopeCss(userCss, `#${context}-bubble-preview`);

    previewStyleTag.textContent = generatedRules + scopedUserCss;

    const userAvatarId = settings.userSettings.avatarId;
    const userFrameId = settings.userSettings.avatarFrameId;
    const charAvatarId = settings.charSettings ? settings.charSettings.avatarId : settings.groupSettings.avatarId;
    const charFrameId = settings.charSettings ? settings.charSettings.avatarFrameId : '';

    previewArea.innerHTML = `
        <div class="message-item contact">
            <div class="avatar" data-avatar-id="${charAvatarId}">
                <div class="avatar-frame" data-avatar-frame-id="${charFrameId}"></div>
            </div>
            <div class="message-content-wrapper"><div class="message-bubble">ä½ å¥½å‘€</div></div>
        </div>
        <div class="message-item user">
            <div class="message-content-wrapper"><div class="message-bubble">å—¯ï¼Œä½ å¥½</div></div>
            <div class="avatar" data-avatar-id="${userAvatarId}">
                 <div class="avatar-frame" data-avatar-frame-id="${userFrameId}"></div>
            </div>
        </div>
    `;
    previewArea.querySelectorAll('.avatar').forEach(el => setElementImage(el, el.dataset.avatarId));
    previewArea.querySelectorAll('.avatar-frame').forEach(el => setElementImage(el, el.dataset.avatarFrameId));
}
    function renderThemeEditor() {
    const themes = appState.beautify.customThemes;
    // If a custom theme for a module exists, use it. Otherwise, use the default style text as the initial content.
    themeCssMoments.value = themes.momentsPost || defaultThemeStyles.momentsPost;
    themeCssHeader.value = themes.appHeader || defaultThemeStyles.appHeader;
    themeCssTabs.value = themes.bottomTabs || defaultThemeStyles.bottomTabs;
        getEl('theme-css-letter').value = themes.loveLetter || defaultThemeStyles.loveLetter;
    themeCssListItem.value = themes.listItem || defaultThemeStyles.listItem;
getEl('theme-css-chat-input').value = themes.chatInput || defaultThemeStyles.chatInput;
}
function updateThemeCssPreview(id) {
    const editor = getEl(`theme-css-${id}`);
    const previewArea = getEl(`theme-preview-${id}`);
    const styleTag = getEl('theme-preview-styles');

    if (!previewArea.innerHTML.trim()) {
        const previewHTML = {
            moments: `<div class="moments-post-item"><div class="post-item-content"><div class="post-header"><div class="post-avatar" style="background-color:#ccc"></div><div class="post-author-info"><div class="post-author-name">é¢„è§ˆç”¨æˆ·</div><div class="post-timestamp">åˆšåˆš</div></div></div><div class="post-content-text">è¿™æ˜¯ä¸€ä¸ªé¢„è§ˆåŠ¨æ€...</div></div></div>`,
            header: `<div class="app-header"><div class="app-header-left"><button class="back-btn">&lt; è¿”å›</button></div><div class="title-wrapper"><h2 class="title">é¢„è§ˆæ ‡é¢˜</h2></div><div class="app-header-right"><button class="action-btn">+</button></div></div>`,
            letter: `<div id="love-letter-viewer-preview" style="padding: 12px; font-size: 11px; line-height: 1.5; color: #333; background: var(--love-letter-texture), linear-gradient(to bottom right, #f4f0e8, #fdfbf7); border: 1px solid #e0d8cc;">
            <div style="display: flex; align-items: center; gap: 8px; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px dashed #dcd3c5;">
                <div style="width: 30px; height: 30px; border-radius: 50%; background-color: #ccc; flex-shrink: 0; border: 1px solid white;"></div>
                <div>
                    <div style="font-weight: bold; font-size: 12px;">äº²çˆ±çš„é¢„è§ˆç”¨æˆ·ï¼š</div>
                    <div style="font-size: 10px; color: #888;">2025/9/6 ä¸Šåˆ9:41:00</div>
                </div>
            </div>
            <p style="margin:0 0 1em 0;">è¿™æ˜¯ä¿¡ä»¶æ­£æ–‡çš„é¢„è§ˆå†…å®¹ï¼Œå®ƒå±•ç¤ºäº†ä¿¡ä»¶çš„å¤§è‡´æ ·å¼å’Œæ„Ÿè§‰ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥æ›´å¥½åœ°è‡ªå®šä¹‰CSS...</p>
            <div class="letter-signature" style="text-align: right; margin-top: 1em; font-style: italic;"><span>çˆ±ä½ çš„ï¼Œé¢„è§ˆç­¾å</span></div>
        </div>`,
            tabs: `<div class="app-bottom-tabs"><div class="tab-link active">æ ‡ç­¾1</div><div class="tab-link">æ ‡ç­¾2</div><div class="tab-link">æ ‡ç­¾3</div></div>`,
            'list-item': `<div class="contact-list-item"><div class="contact-item-content swipe-content"><div class="contact-avatar" style="background-color:#ccc"></div><div class="contact-info"><div class="contact-name">é¢„è§ˆè”ç³»äºº</div><div class="contact-last-msg">è¿™æ˜¯ä¸€æ¡é¢„è§ˆæ¶ˆæ¯...</div></div></div></div>`,
            'chat-input': `<div id="chat-footer-preview" class="chat-footer"><div class="chat-input-area"><textarea class="chat-input" rows="1" placeholder="è¾“å…¥..."></textarea><div class="chat-input-buttons"><button class="icon-btn"><i class="fa-solid fa-face-smile"></i></button></div></div><div class="chat-toolbar"><button class="icon-btn"><i class="fa-solid fa-arrows-rotate"></i></button><button class="icon-btn"><i class="fa-solid fa-microphone"></i></button><button class="icon-btn"><i class="fa-solid fa-images"></i></button><button class="icon-btn"><i class="fa-solid fa-camera"></i></button><button class="icon-btn"><i class="fa-solid fa-video"></i></button><button class="icon-btn"><i class="fa-solid fa-headphones"></i></button><button class="icon-btn"><i class="fa-solid fa-newspaper"></i></button><button class="icon-btn"><i class="fa-solid fa-wallet"></i></button><button class="icon-btn"><i class="fa-solid fa-bag-shopping"></i></button></div></div>`
        };
        if(previewHTML[id]) previewArea.innerHTML = previewHTML[id];
    }

    const modules = {
        moments: { editor: themeCssMoments, scope: '#theme-preview-moments .moments-post-item .post-item-content' },
        header: { editor: themeCssHeader, scope: '#theme-preview-header .app-header' },
        letter: { editor: getEl('theme-css-letter'), scope: '#theme-preview-letter #love-letter-viewer-preview' },
        tabs: { editor: themeCssTabs, scope: '#theme-preview-tabs .app-bottom-tabs' },
        'list-item': { editor: themeCssListItem, scope: '#theme-preview-list-item .swipe-content' },
'chat-input': { editor: getEl('theme-css-chat-input'), scope: '#theme-preview-chat-input #chat-footer-preview' }
    };

    let finalPreviewCss = '';
    for (const [key, module] of Object.entries(modules)) {
        let rawCss = module.editor.value;
        let generatedRules = '';
        
        const bgImageMatch = rawCss.match(/@background-image:\s*url\(([^)]+)\);/);
        if (bgImageMatch && bgImageMatch[1].trim() !== 'å›¾ç‰‡é“¾æ¥') {
            generatedRules += `${module.scope} { background-image: url(${bgImageMatch[1].trim()}) !important; background-size: cover !important; background-position: center !important; }\n`;
        } else {
            const bgColorMatch = rawCss.match(/@background-color:\s*([^;]+);/);
            if (bgColorMatch) generatedRules += `${module.scope} { background-color: ${bgColorMatch[1].trim()} !important; }\n`;
        }

        const fontFamilyMatch = rawCss.match(/@font-family:\s*([^;]+);/);
        if (fontFamilyMatch) {
            const fontName = fontFamilyMatch[1].trim();
            let finalFontFamily;
            if (fontName.toLowerCase() === 'default') {
                const globalFont = appState.beautify.currentFont;
                finalFontFamily = globalFont === 'default'
                    ? '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'
                    : `"${globalFont}"`;
            } else {
                finalFontFamily = `"${fontName}"`;
            }
            generatedRules += `${module.scope}, ${module.scope} *:not(i) { font-family: ${finalFontFamily} !important; }\n`;
        }

        const colorMatch = rawCss.match(/@color:\s*([^;]+);/);
        if (colorMatch) {
             generatedRules += `${module.scope}, ${module.scope} *:not(i), ${module.scope} .title, ${module.scope} .text, ${module.scope} .label, ${module.scope} span, ${module.scope} div { color: ${colorMatch[1].trim()} !important; }\n`;
        }
        
        const fontSizeMatch = rawCss.match(/@font-size:\s*([^;]+);/);
        if (fontSizeMatch) generatedRules += `${module.scope} { font-size: ${fontSizeMatch[1].trim()} !important; }\n`;
            if (key === 'chat-input') {
            const textareaHeightMatch = rawCss.match(/@textarea-height:\s*([^;]+);/);
            if (textareaHeightMatch) {
                generatedRules += `${module.scope} .chat-input { height: ${textareaHeightMatch[1].trim()} !important; }\n`;
            }
        }
        const textareaWidthMatch = rawCss.match(/@textarea-width:\s*([^;]+);/);
            if (textareaWidthMatch) {
                const widthValue = textareaWidthMatch[1].trim();
                if (widthValue.toLowerCase() === 'auto') {
                    generatedRules += `${module.scope} .chat-input { width: auto !important; flex-grow: 1 !important; }\n`;
                } else {
                    generatedRules += `${module.scope} .chat-input { width: ${widthValue} !important; flex-grow: 0 !important; }\n`;
                }
            }
        const userCss = rawCss.replace(/@[\w-]+\s*:[^;]+;/g, '').trim();
        const scopedUserCss = processAndScopeCss(userCss, module.scope);

        finalPreviewCss += generatedRules + scopedUserCss + '\n';
    }

    styleTag.textContent = finalPreviewCss;
}

    ['moments', 'header', 'tabs', 'list-item', 'letter', 'chat-input'].forEach(id => {
        getEl(`theme-css-${id}`).addEventListener('input', () => updateThemeCssPreview(id));
    });
    themeApplyBtn.addEventListener('click', () => {
        if (confirm('ç¡®å®šè¦åº”ç”¨è¿™äº›è‡ªå®šä¹‰æ ·å¼å—ï¼Ÿä¸æ­£ç¡®çš„CSSä»£ç å¯èƒ½å¯¼è‡´é¡µé¢æ˜¾ç¤ºå¼‚å¸¸ã€‚')) {
            appState.beautify.customThemes.momentsPost = themeCssMoments.value;
            appState.beautify.customThemes.appHeader = themeCssHeader.value;
                appState.beautify.customThemes.loveLetter = getEl('theme-css-letter').value;
            appState.beautify.customThemes.bottomTabs = themeCssTabs.value;
            appState.beautify.customThemes.listItem = themeCssListItem.value;
                    appState.beautify.customThemes.chatInput = getEl('theme-css-chat-input').value;
            debouncedSaveState();
            applyCustomThemes();
            showToast('ä¸»é¢˜æ ·å¼å·²åº”ç”¨ï¼');
        }
    });

    themeRestoreBtn.addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦è¿˜åŸæ‰€æœ‰æ¨¡å—çš„é»˜è®¤æ ·å¼å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
        appState.beautify.customThemes = { momentsPost: '', appHeader: '', bottomTabs: '', listItem: '', loveLetter: '', chatInput: '' };
        debouncedSaveState();
        
        // 1. å°† appState çš„ç©ºå€¼åº”ç”¨åˆ°å…¨å±€æ ·å¼
        applyCustomThemes(); 
        // 2. æ ¹æ® appState çš„ç©ºå€¼ï¼Œå°†é»˜è®¤å ä½ç¬¦æ–‡æœ¬å¡«å…¥ç¼–è¾‘å™¨
        renderThemeEditor();
        // 3. æ ¹æ®ç¼–è¾‘å™¨ä¸­çš„é»˜è®¤æ–‡æœ¬ï¼Œåˆ·æ–°æ‰€æœ‰é¢„è§ˆæ¨¡å—
        ['moments', 'header', 'tabs', 'list-item', 'letter', 'chat-input'].forEach(id => updateThemeCssPreview(id));
        
        showToast('å·²è¿˜åŸä¸ºé»˜è®¤æ ·å¼ï¼');
    }
    });
uploadBubbleBtn.addEventListener('click', () => bubbleFileInput.click());
bubbleFileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (file) { handleBubbleImage(file); bubbleFileInput.value = ''; } });
bubbleUrlInput.addEventListener('input', async () => {
    const url = bubbleUrlInput.value.trim();
    if (url.startsWith('http')) {
        // ç›´æ¥å°†URLä½œä¸ºèƒŒæ™¯IDï¼Œä¸å†ä¸‹è½½
        const bubbleId = editBubbleIdInput.value;
        const isGlobal = bubbleId === 'global_bubble';
        const settingsGroup = isGlobal ? appState.beautify.bubbleSettings.global : (appState.beautify.bubbleSettings.specific[bubbleId] || {});

        if (!isGlobal && !appState.beautify.bubbleSettings.specific[bubbleId]) {
            appState.beautify.bubbleSettings.specific[bubbleId] = settingsGroup;
        }
        settingsGroup.backgroundImageId = url; // ç›´æ¥èµ‹å€¼URL
        toggleBubbleColorInputs(true);
        updateBubblePreview();
    }
});
function toggleBubbleColorInputs(hasImage) { queryAll('.bubble-color-group').forEach(el => el.classList.toggle('hidden-by-logic', !!hasImage)); }
async function handleBubbleImage(fileOrBlob) { const compressedFile = await compressImageBeforeSaving(fileOrBlob, { maxWidth: 512, maxHeight: 512, quality: 0.7 }); const bubbleId = editBubbleIdInput.value; const isGlobal = bubbleId === 'global_bubble'; const settingsGroup = isGlobal ? appState.beautify.bubbleSettings.global : (appState.beautify.bubbleSettings.specific[bubbleId] || {}); if (!isGlobal && !appState.beautify.bubbleSettings.specific[bubbleId]) { appState.beautify.bubbleSettings.specific[bubbleId] = settingsGroup; } if (settingsGroup.backgroundImageId) { await deleteMediaFromDB(settingsGroup.backgroundImageId); } const newBubbleId = newId('bubble'); await addMediaToDB(newBubbleId, compressedFile); settingsGroup.backgroundImageId = newBubbleId; toggleBubbleColorInputs(true); updateBubblePreview(); }async function applyBubbleChange(bubbleId, isInitialLoad = false, isRestoring = false) { const targetEl = query(`[data-bubble-id="${bubbleId}"]`); if (!targetEl) return; if (!isInitialLoad) targetEl.style.transition = 'none'; if (isRestoring) { targetEl.style.cssText = runtimeState.originalBubbleContent[bubbleId] || ''; } else { const globalStyles = appState.beautify.bubbleSettings.global || {}; const specificStyles = appState.beautify.bubbleSettings.specific[bubbleId] || {}; const finalStyles = { ...globalStyles, ...specificStyles }; targetEl.style.cssText = runtimeState.originalBubbleContent[bubbleId] || ''; for (const key in finalStyles) { if (key !== 'backgroundImageId' && key !== 'replaceBgOnly') { targetEl.style[key] = finalStyles[key]; } } if (finalStyles.backgroundImageId) { const url = await getMediaURL(finalStyles.backgroundImageId); if (url) { targetEl.style.backgroundSize = 'cover'; targetEl.style.backgroundPosition = 'center'; targetEl.style.backgroundImage = `url(${url})`; if (finalStyles.replaceBgOnly) { targetEl.style.color = finalStyles.color || ''; } else { targetEl.textContent = ''; } } } } }

// ===================================================================
// --- èµ„æ–™ APP ---
// ===================================================================
function handleDataTabChange(tabId) { 
    dataActionBtn.style.display = (tabId === 'memory') ? 'none' : 'block'; 
    dataFilterBtn.style.display = (tabId === 'world-book') ? 'block' : 'none';
    
    if (tabId !== 'world-book') {
        worldBookFilterDropdown.classList.remove('visible');
    }

    if (tabId === 'world-book') renderWorldBooks();
else if (tabId === 'archive') renderArchives();
else if (tabId === 'info') renderInfos();
else if (tabId === 'styles') renderStylesTab(); 
}
dataAppTabs.addEventListener('click', (e) => { if (e.target.classList.contains('tab-link')) { const tabId = e.target.dataset.tab; queryAll('#data-app-screen .tab-link').forEach(t => t.classList.remove('active')); queryAll('#data-app-screen .tab-content').forEach(c => c.classList.remove('active')); e.target.classList.add('active'); getEl(`${tabId}-tab-content`).classList.add('active'); handleDataTabChange(tabId); } });
dataActionBtn.addEventListener('click', () => { const activeTab = query('#data-app-screen .tab-link.active').dataset.tab;
    if (activeTab === 'styles') {
        // å½“åœ¨æ ·å¼æ ‡ç­¾é¡µæ—¶ï¼Œè§¦å‘æ–‡ä»¶å¯¼å…¥
        getEl('import-style-file-input').click();
    } else {
        // ä¿æŒåŸæœ‰åŠŸèƒ½
        const typeMap = { 'world-book': 'worldBook', 'archive': 'archive', 'info': 'info' };
        openDataEditor(typeMap[activeTab]);
    } });
function openDataEditor(type, id = null) {
    dataModal.dataset.type = type;
    dataEditingIdInput.value = id || '';
    dataNameInput.value = '';
    dataContentInput.value = '';
    dataGroupInput.value = '';
    dataAvatarPreview.style.backgroundImage = 'none';
    dataAvatarPreview.dataset.avatarId = '';

    const dataGroupContainer = getEl('data-group-container'); // Get the container
    const dataGroupSelect = getEl('data-group-select'); // Get the select

    const typeConfig = { worldBook: { title: 'ä¸–ç•Œä¹¦', hasAvatar: false, hasGroup: true }, archive: { title: 'æ¡£æ¡ˆ', hasAvatar: true, hasGroup: false }, info: { title: 'ä¿¡æ¯', hasAvatar: true, hasGroup: false } };
    const config = typeConfig[type];
    dataModalTitle.textContent = (id ? 'ç¼–è¾‘' : 'åˆ›å»º') + config.title;
    dataAvatarGroup.style.display = config.hasAvatar ? 'block' : 'none';
    dataGroupContainer.style.display = config.hasGroup ? 'block' : 'none';

    const relationshipInputHTML = `
        <div class="form-group" id="data-relationship-container">
            <label for="data-relationship">å…³ç³»</label>
            <input type="text" id="data-relationship" placeholder="ä¾‹å¦‚ï¼šæœ‹å‹ã€æ‹äººã€å…„å¦¹...">
        </div>
    `;

    if (type === 'archive') {
        dataContentInput.parentElement.insertAdjacentHTML('beforebegin', relationshipInputHTML);
    } else {
        const existingRelInput = getEl('data-relationship-container');
        if (existingRelInput) existingRelInput.remove();
    }

    if (config.hasGroup && type === 'worldBook') {
        const uniqueGroups = [...new Set(appState.data.worldBooks.map(item => item.group).filter(Boolean).sort())];
        dataGroupSelect.innerHTML = '<option value="">é€‰æ‹©å·²æœ‰åˆ†ç»„</option>';
        uniqueGroups.forEach(group => {
            const option = document.createElement('option');
            option.value = group;
            option.textContent = group;
            dataGroupSelect.appendChild(option);
        });
    }

    if (id) {
        const item = appState.data[type + 's'].find(i => i.id === id);
        if (item) {
        dataNameInput.value = item.name;
        if (type === 'archive') {
            getEl('data-relationship').value = item.relationship || '';
        }
            dataContentInput.value = item.content;
            if (config.hasAvatar && item.avatarId) {
                setElementImage(dataAvatarPreview, item.avatarId);
                dataAvatarPreview.dataset.avatarId = item.avatarId;
            }
            if (config.hasGroup) {
                dataGroupInput.value = item.group || '';
                dataGroupSelect.value = item.group || ''; // Sync select on edit
            }
        }
    } else {
         // Reset select on create
        if (config.hasGroup) {
            dataGroupSelect.value = '';
        }
    }
    dataModal.classList.add('visible');
}
cancelDataBtn.addEventListener('click', () => dataModal.classList.remove('visible'));
dataGroupSelect.addEventListener('change', () => {
    if (dataGroupSelect.value) {
        dataGroupInput.value = dataGroupSelect.value;
    }
});
saveDataBtn.addEventListener('click', () => { const type = dataModal.dataset.type; const id = dataEditingIdInput.value; const name = dataNameInput.value.trim(); const content = dataContentInput.value.trim(); const group = dataGroupInput.value.trim();
    const relationship = (getEl('data-relationship') && getEl('data-relationship').value.trim()) || null; if (!name) return showToast('åç§°ä¸èƒ½ä¸ºç©º', 'error'); const dataArray = appState.data[type + 's']; const avatarId = dataAvatarPreview.dataset.avatarId; if (id) { const item = dataArray.find(i => i.id === id); if (item) { item.name = name; item.content = content; if (avatarId) item.avatarId = avatarId; if (type === 'worldBook') item.group = group; } } else { const newItem = { id: newId('data'), name, content, relationship: relationship }; if (avatarId) newItem.avatarId = avatarId; if (type === 'worldBook') newItem.group = group; dataArray.push(newItem); } debouncedSaveState(); dataModal.classList.remove('visible'); switch (type) { case 'worldBook': renderWorldBooks(); break; case 'archive': renderArchives(); break; case 'info': renderInfos(); break; } });
function renderWorldBookFilterDropdown() {
        const uniqueGroups = ['all', 'æœªåˆ†ç»„', ...new Set(appState.data.worldBooks.map(item => item.group).filter(Boolean).sort())];
        const selected = runtimeState.worldBookFilter.selectedGroups;
        worldBookFilterDropdown.innerHTML = uniqueGroups.map(group => `
            <label class="checkbox-label">
                <input type="checkbox" value="${group}" ${selected.includes(group) ? 'checked' : ''}>
                <span>${group}</span>
            </label>
        `).join('');
    }

    function toggleWorldBookFilterDropdown() {
        if (worldBookFilterDropdown.classList.contains('visible')) {
            worldBookFilterDropdown.classList.remove('visible');
        } else {
            renderWorldBookFilterDropdown();
            worldBookFilterDropdown.classList.add('visible');
        }
    }

    dataFilterBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleWorldBookFilterDropdown();
    });

    worldBookFilterDropdown.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox') {
            const group = e.target.value;
            const isChecked = e.target.checked;
            let selected = runtimeState.worldBookFilter.selectedGroups;

            if (group === 'all') {
                selected = ['all'];
            } else {
                selected = selected.filter(g => g !== 'all'); // Remove 'all' if another is selected
                if (isChecked) {
                    if (!selected.includes(group)) selected.push(group);
                } else {
                    selected = selected.filter(g => g !== group);
                }
            }

            if (selected.length === 0) {
                selected = ['all']; // Default back to 'all' if nothing is selected
            }
            
            runtimeState.worldBookFilter.selectedGroups = selected;
            renderWorldBookFilterDropdown(); // Re-render to update checks
            renderWorldBooks(); // Re-render the list based on new filter
        }
    });
dataUploadAvatarBtn.addEventListener('click', () => dataAvatarFileInput.click());
dataAvatarFileInput.addEventListener('change', async (e) => { const file = e.target.files[0]; if (file) { const compressedFile = await compressImageBeforeSaving(file, { maxWidth: 256, maxHeight: 256 }); const newAvatarId = newId('data_avatar'); await addMediaToDB(newAvatarId, compressedFile); dataAvatarPreview.dataset.avatarId = newAvatarId; setElementImage(dataAvatarPreview, newAvatarId); dataAvatarFileInput.value = ''; } });
dataAddAvatarUrlBtn.addEventListener('click', async () => {
    const url = prompt('è¯·è¾“å…¥å›¾ç‰‡URL:');
    if (url && url.startsWith('http')) {
        // ç›´æ¥ä½¿ç”¨URLä½œä¸ºavatarId
        dataAvatarPreview.dataset.avatarId = url;
        setElementImage(dataAvatarPreview, url);
    } else if (url) {
        showToast('æ— æ•ˆçš„URL', 'error');
    }
});
function escapeHTML(str) { 
    if (typeof str !== 'string') return '';
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;'); 
}
function renderWorldBooks() {
    const selectedGroups = runtimeState.worldBookFilter.selectedGroups;
    
    let booksToRender = appState.data.worldBooks;

    if (!selectedGroups.includes('all')) {
        booksToRender = booksToRender.filter(item => {
            const itemGroup = item.group || 'æœªåˆ†ç»„';
            return selectedGroups.includes(itemGroup);
        });
    }

    worldBookListEl.innerHTML = booksToRender.map(item => `
        <li class="preset-data-item" data-id="${item.id}" data-type="worldBook">
            <div class="preset-data-item-content">
                <div class="preset-data-info">
                    <div class="preset-data-name">${escapeHTML(item.name)}</div>
                    <div class="preset-data-excerpt">${item.group ? `[${escapeHTML(item.group)}] ` : ''}${escapeHTML(item.content.substring(0, 20) || 'æ— å†…å®¹')}...</div>
                </div>
            </div>
            <div class="preset-data-item-actions">
                <div class="edit-action">ç¼–è¾‘</div>
                <div class="delete-action">åˆ é™¤</div>
            </div>
        </li>
    `).join('') || '<li><div class="preset-data-item-content" style="justify-content:center; color:#888;">æš‚æ— ç¬¦åˆæ¡ä»¶çš„ä¸–ç•Œä¹¦</div></li>'; 
}
function renderArchives() { archiveListEl.innerHTML = ''; if (appState.data.archives.length === 0) { archiveListEl.innerHTML = '<li><div class="preset-data-item-content" style="justify-content:center; color:#888;">æš‚æ— æ¡£æ¡ˆ</div></li>'; return; } appState.data.archives.forEach(item => { const li = document.createElement('li'); li.className = 'preset-data-item'; li.dataset.id = item.id; li.dataset.type = 'archive'; li.innerHTML = `<div class="preset-data-item-content swipe-content"><div class="preset-data-avatar" data-avatar-id="${item.avatarId || ''}"></div><div class="preset-data-info">                    <div class="preset-data-name">${escapeHTML(item.name)}</div>
                    ${item.relationship ? `<div class="preset-data-excerpt" style="font-style: italic; color: var(--accent-color);">å…³ç³»: ${escapeHTML(item.relationship)}</div>` : ''}<div class="preset-data-excerpt">${escapeHTML(item.content.substring(0, 20) || 'æ— å†…å®¹')}...</div></div></div><div class="preset-data-item-actions"><div class="edit-action">ç¼–è¾‘</div><div class="delete-action">åˆ é™¤</div></div>`; archiveListEl.appendChild(li); setElementImage(li.querySelector('.preset-data-avatar'), item.avatarId); }); }
function renderInfos() { infoListEl.innerHTML = ''; if (appState.data.infos.length === 0) { infoListEl.innerHTML = '<li><div class="preset-data-item-content" style="justify-content:center; color:#888;">æš‚æ— ä¿¡æ¯</div></li>'; return; } appState.data.infos.forEach(item => { const li = document.createElement('li'); li.className = 'preset-data-item'; li.dataset.id = item.id; li.dataset.type = 'info';                 li.innerHTML = `<div class="preset-data-item-content swipe-content"><div class="preset-data-avatar" data-avatar-id="${item.avatarId || ''}"></div><div class="preset-data-info"><div class="preset-data-name">${escapeHTML(item.name)}</div><div class="preset-data-excerpt">${escapeHTML(item.content.substring(0, 20) || 'æ— å†…å®¹')}...</div></div></div><div class="preset-data-item-actions"><div class="edit-action">ç¼–è¾‘</div><div class="delete-action">åˆ é™¤</div></div>`; infoListEl.appendChild(li); setElementImage(li.querySelector('.preset-data-avatar'), item.avatarId); }); }
    // ===================================================================
// --- æ‰‹è´¦ APP (çºªå¿µæ—¥) ---
// ===================================================================
    let anniversaryCalendarState = {
        year: new Date().getFullYear(),
        month: new Date().getMonth() // 0-11
    };

    function handleDiaryTabChange(tabId) {
        // --- æ ¸å¿ƒä¿®å¤ï¼šæ·»åŠ å®Œæ•´çš„UIåˆ‡æ¢é€»è¾‘ ---
        const tabsContainer = diaryAppScreen.querySelector('.app-bottom-tabs');
        const contentWrapper = diaryAppScreen.querySelector('.tab-content-wrapper');

        tabsContainer.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
        contentWrapper.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

        const activeTabLink = tabsContainer.querySelector(`.tab-link[data-tab="${tabId}"]`);
        const activeTabContent = contentWrapper.querySelector(`#${tabId}-tab-content`);

        if (activeTabLink) activeTabLink.classList.add('active');
        if (activeTabContent) activeTabContent.classList.add('active');
        // --- ä¿®å¤ç»“æŸ ---
        const titleEl = diaryAppScreen.querySelector('.title');
            const filterBtn = getEl('diary-filter-btn');
        const tabMap = { 'anniversary': 'çºªå¿µæ—¥', 'secret': 'ç§˜å¯†', 'diary': 'æ—¥è®°', 'collection': 'è—é¦†', 'exhibition': 'å±•å…' };
        titleEl.textContent = tabMap[tabId] || 'æ‰‹è´¦';
        const actionBtn = getEl('diary-action-btn');
            filterBtn.style.display = (tabId === 'secret') ? 'block' : 'none';
        actionBtn.style.display = (tabId === 'anniversary') ? 'block' : 'none';
        if (tabId === 'anniversary') {
            const now = new Date();
            anniversaryCalendarState.year = now.getFullYear();
            anniversaryCalendarState.month = now.getMonth();
            renderAnniversaryCalendar(anniversaryCalendarState.year, anniversaryCalendarState.month);
        } else if (tabId === 'secret') {
            renderSecretsTab();
        } else if (tabId === 'exhibition') {
            renderExhibitionTab();
        } else if (tabId === 'collection') {
            renderCollectionTab();
        }
        if (tabId !== 'secret') {
            secretFilterDropdown.classList.remove('visible');
        }
        appState.diary.activeTab = tabId;
        debouncedSaveState();
    }

    // æ•°æ®æ¥æºï¼šä¸­å›½æ”¿åºœç½‘åŠå…¬å¼€èµ„æ–™æ•´ç†
    const holidays = {
                '2025-01-01': { name: 'å…ƒæ—¦', holiday: true },
        '2025-01-26': { name: 'ç­', holiday: false }, // æ˜¥èŠ‚è°ƒä¼‘
        '2025-01-28': { name: 'é™¤å¤•', holiday: true },
        '2025-01-29': { name: 'æ˜¥èŠ‚', holiday: true },
        '2025-01-30': { name: 'åˆäºŒ', holiday: true },
        '2025-01-31': { name: 'åˆä¸‰', holiday: true },
        '2025-02-01': { name: 'åˆå››', holiday: true },
        '2025-02-02': { name: 'åˆäº”', holiday: true },
        '2025-02-03': { name: 'åˆå…­', holiday: true },
        '2025-02-04': { name: 'åˆä¸ƒ', holiday: true },
        '2025-02-08': { name: 'ç­', holiday: false }, // æ˜¥èŠ‚è°ƒä¼‘
        '2025-04-04': { name: 'æ¸…æ˜èŠ‚', holiday: true },
        '2025-04-05': { name: 'æ¸…æ˜', holiday: true },
        '2025-04-06': { name: 'æ¸…æ˜', holiday: true },
        '2025-04-27': { name: 'ç­', holiday: false }, // åŠ³åŠ¨èŠ‚è°ƒä¼‘
        '2025-05-01': { name: 'åŠ³åŠ¨èŠ‚', holiday: true },
        '2025-05-02': { name: 'åŠ³åŠ¨', holiday: true },
        '2025-05-03': { name: 'åŠ³åŠ¨', holiday: true },
        '2025-05-04': { name: 'é’å¹´èŠ‚', holiday: false },
        '2025-05-05': { name: 'åŠ³åŠ¨', holiday: true },
        '2025-05-31': { name: 'ç«¯åˆèŠ‚', holiday: true },
        '2025-06-01': { name: 'å„¿ç«¥èŠ‚', holiday: true },
        '2025-06-02': { name: 'ç«¯åˆ', holiday: true },
        '2025-09-28': { name: 'ç­', holiday: false }, // å›½åº†èŠ‚è°ƒä¼‘
        '2025-10-01': { name: 'å›½åº†èŠ‚', holiday: true },
        '2025-10-02': { name: 'å›½åº†', holiday: true },
        '2025-10-03': { name: 'å›½åº†', holiday: true },
        '2025-10-04': { name: 'å›½åº†', holiday: true },
        '2025-10-05': { name: 'å›½åº†', holiday: true },
        '2025-10-06': { name: 'ä¸­ç§‹èŠ‚', holiday: true },
        '2025-10-07': { name: 'å›½åº†', holiday: true },
        '2025-10-08': { name: 'å›½åº†', holiday: true },
        '2025-10-11': { name: 'ç­', holiday: false } // å›½åº†èŠ‚è°ƒä¼‘
    };

    const lunarData = [
        [0x04bd8, 0x04ae0, 0x0a570, 0x054d5, 0x0d260, 0x0d950, 0x16554, 0x056a0, 0x09ad0, 0x055d2, 0x04ae0, 0x0a5b6, 0x0a4d0, 0x0d250, 0x1d255, 0x0b540, 0x0d6a0, 0x0ada2, 0x095b0, 0x14977, 0x04970, 0x0a4b0, 0x0b4b5, 0x06a50, 0x06d40, 0x1ab54, 0x02b60, 0x09570, 0x052f2, 0x04970, 0x06566, 0x0d4a0, 0x0ea50, 0x06e95, 0x05ad0, 0x02b60, 0x186e3, 0x092e0, 0x1c8d7, 0x0c950, 0x0d4a0, 0x1d8a6, 0x0b550, 0x056a0, 0x1a5b4, 0x025d0, 0x092d0, 0x0d2b2, 0x0a950, 0x0b557, 0x06ca0, 0x0b550, 0x15355, 0x04da0, 0x0a5b0, 0x14573, 0x052b0, 0x0a9a8, 0x0e950, 0x06aa0, 0x0aea6, 0x0ab50, 0x04b60, 0x0aae4, 0x0a570, 0x05260, 0x0f263, 0x0d950, 0x05b57, 0x056a0, 0x096d0, 0x04dd5, 0x04ad0, 0x0a4d0, 0x0d4d4, 0x0d250, 0x0d558, 0x0b540, 0x0b6a0, 0x195a6, 0x095b0, 0x049b0, 0x0a974, 0x0a4b0, 0x0b27a, 0x06a50, 0x06d40, 0x0af46, 0x0ab60, 0x09570, 0x04af5, 0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06b58, 0x055c0, 0x0ab60, 0x096d5, 0x092e0, 0x0c960, 0x0d954, 0x0d4a0, 0x0da50, 0x07552, 0x056a0, 0x0abb7, 0x025d0, 0x092d0, 0x0cab5, 0x0a950, 0x0b4a0, 0x0baa4, 0x0ad50, 0x055d9, 0x04ba0, 0x0a5b0, 0x15176, 0x052b0, 0x0a930, 0x07954, 0x06aa0, 0x0ad50, 0x05b52, 0x04b60, 0x0a6e6, 0x0a4e0, 0x0d260, 0x0ea65, 0x0d530, 0x05aa0, 0x076a3, 0x096d0, 0x04bd7, 0x04ad0, 0x0a4d0, 0x1d0b6, 0x0d250, 0x0d520, 0x0dd45, 0x0b5a0, 0x056d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0, 0x0aa50, 0x1b255, 0x06d20, 0x0ada0],
        ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹', 'å'],
        ['åˆ', 'å', 'å»¿', 'å…'],
        ['æ­£', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹', 'å', 'åä¸€', 'è…Š']
    ];
    function getLunarDate(year, month, day) {
        const gregorianDate = new Date(year, month, day);
        let total, m, n, k;
        let isEnd = false;
        const theDate = (gregorianDate.getFullYear() < 1900 || gregorianDate.getFullYear() > 2100) ? new Date() : gregorianDate;
        total = (theDate.getFullYear() - 1900) * 365 + Math.floor((theDate.getFullYear() - 1900) / 4) + theDate.getDate() - 1;
        if (theDate.getFullYear() % 4 === 0 && theDate.getMonth() < 2) total--;

        for (m = 0; ; m++) {
            k = (theDate.getMonth() == m) ? (theDate.getDate()) : ([31, 28 + ((theDate.getFullYear() % 4 === 0 && theDate.getFullYear() % 100 !== 0) || theDate.getFullYear() % 400 === 0 ? 1 : 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][m]);
            total += k;
            if (m == theDate.getMonth()) break;
        }

        for (m = 1900; m < 2101 && total > 0; m++) {
            n = (lunarData[0][m - 1900] & 0x10000) ? 384 : (((lunarData[0][m - 1900] & 0xf) == 0) ? 354 : 355);
            total -= n;
        }

        if (total < 0) {
            total += n;
            m--;
        }
        const y = m;
        const leap = (lunarData[0][y - 1900] & 0xf);
        isEnd = false;
        for (m = 1; m < 13 && total > 0; m++) {
            if (leap > 0 && m == (leap + 1) && isEnd == false) {
                --m;
                isEnd = true;
                n = ((lunarData[0][y - 1900] & (0x10000 >> m)) ? 30 : 29);
            } else {
                n = ((lunarData[0][y - 1900] & (0x8000 >> (m - 1))) ? 30 : 29);
            }
            if (isEnd == true && m == (leap + 1)) isEnd = false;
            total -= n;
        }
        if (total == 0 && leap > 0 && m == leap + 1) {
            if (isEnd) {
                isEnd = false;
            } else {
                isEnd = true;
                --m;
            }
        }
        if (total < 0) {
            total += n;
            --m;
        }
        const mo = m;
        const d = total + 1;
        const dayStr = (d < 11) ? 'åˆ' : ((d < 20) ? 'å' : ((d < 30) ? 'å»¿' : 'å…'));
        const dayNum = (d % 10 == 0) ? 'å' : lunarData[1][d % 10];
        return `${lunarData[3][mo - 1]}æœˆ${dayStr}${dayNum}`;
    }

                    function renderAnniversaryCalendar(year, month) {
    const grid = getEl('anniversary-calendar-grid');
    const monthYearDisplay = diaryAppScreen.querySelector('.current-month-year');
    const fullDateDisplay = diaryAppScreen.querySelector('.current-date-display');
    if (!grid || !monthYearDisplay || !fullDateDisplay) return;

    const today = new Date();
    const firstDayOfMonth = new Date(year, month, 1);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const startDayOfWeek = firstDayOfMonth.getDay();

    monthYearDisplay.textContent = `${year}å¹´${month + 1}æœˆ`;
    const weekdays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
    fullDateDisplay.textContent = `${today.getFullYear()}å¹´${today.getMonth() + 1}æœˆ${today.getDate()}æ—¥ ${weekdays[today.getDay()]}`;

grid.innerHTML = '';

// Pre-filter anniversaries for the current month for efficiency
const monthAnniversaries = appState.diary.anniversaries.filter(a => {
    const aDate = new Date(a.date);
    return aDate.getFullYear() === year && aDate.getMonth() === month;
});

const daysInPrevMonth = new Date(year, month, 0).getDate();
for (let i = 0; i < startDayOfWeek; i++) {
    const day = daysInPrevMonth - startDayOfWeek + 1 + i;
    grid.innerHTML += `<div class="calendar-day other-month"><span class="day-number">${day}</span><span class="day-info"></span></div>`;
}

    for (let i = 1; i <= daysInMonth; i++) {
        const dateStrFull = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
        
            const anniversariesForDay = monthAnniversaries.filter(a => new Date(a.date).getDate() === i);
    const lunarDate = getLunarDate(year, month, i);

        let dayInfo = lunarDate;
        let classes = 'calendar-day';

            const allEvents = [...anniversariesForDay];

        if (allEvents.length > 0) {
            dayInfo = allEvents.map(e => e.name).join(' / ');
            if (allEvents.some(e => e.isSpecial || e.holiday)) {
                classes += ' holiday';
            }
        }
        
                        let actionsHTML = '';
if (anniversariesForDay.length > 0) {
    actionsHTML = `
        <div class="calendar-day-actions">
            <button class="calendar-action-btn edit" title="ç¼–è¾‘"><i class="fa-solid fa-pen"></i></button>
            <button class="calendar-action-btn delete" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
        </div>
    `;
}

        grid.innerHTML += `
            <div class="${classes}" data-date="${dateStrFull}">
                <span class="day-number">${i}</span>
                <span class="day-info">${dayInfo}</span>
                ${actionsHTML}
            </div>`;
    }
    
    const totalCells = startDayOfWeek + daysInMonth;
    const remainingCells = (totalCells % 7 === 0) ? 0 : 7 - (totalCells % 7);
    for (let i = 1; i <= remainingCells; i++) {
        grid.innerHTML += `<div class="calendar-day other-month"><span class="day-number">${i}</span><span class="day-info"></span></div>`;
    }
}

    getEl('prev-month-btn')?.addEventListener('click', () => {
        anniversaryCalendarState.month--;
        if (anniversaryCalendarState.month < 0) {
            anniversaryCalendarState.month = 11;
            anniversaryCalendarState.year--;
        }
        renderAnniversaryCalendar(anniversaryCalendarState.year, anniversaryCalendarState.month);
    });

    getEl('next-month-btn')?.addEventListener('click', () => {
        anniversaryCalendarState.month++;
        if (anniversaryCalendarState.month > 11) {
            anniversaryCalendarState.month = 0;
            anniversaryCalendarState.year++;
                    }
        renderAnniversaryCalendar(anniversaryCalendarState.year, anniversaryCalendarState.month);
    });

    // --- çºªå¿µæ—¥ç¼–è¾‘ä¸æ·»åŠ é€»è¾‘ ---
    const anniversaryModal = getEl('anniversary-modal');
    const anniversaryModalTitle = getEl('anniversary-modal-title');
    const editingAnniversaryIdInput = getEl('editing-anniversary-id');
    const dateInput = getEl('anniversary-date-input');
    const nameInput = getEl('anniversary-name-input');
    const specialCheckbox = getEl('anniversary-special-checkbox');

                           function openAnniversaryModal(anniversaryId, dateHint) {
        const isEditing = anniversaryId !== null;
        const anniversary = isEditing ? appState.diary.anniversaries.find(a => a.id === anniversaryId) : null;

        const charSelector = getEl('anniversary-char-selector');
        const associatedCharIds = isEditing ? (anniversary.associatedCharIds || []) : [];

        const allChars = appState.chat.contacts.filter(c => !c.isGroup);
        const selectorItems = [
            { id: 'general', name: 'é€šç”¨(å¯¹æ‰€æœ‰äºº)', avatarId: '' },
            ...allChars.map(c => ({ id: c.id, name: c.charSettings.name, avatarId: c.charSettings.avatarId }))
        ];
        
        charSelector.innerHTML = selectorItems.map(char => {
            const isSelected = associatedCharIds.includes(char.id) || (char.id === 'general' && associatedCharIds.length === 0);
            return `
                <div class="friend-selector-item ${isSelected ? 'selected' : ''}" data-id="${char.id}">
                    <div class="avatar" data-avatar-id="${char.avatarId}"></div>
                    <span class="name">${char.name}</span>
                </div>`;
        }).join('');
        charSelector.querySelectorAll('.avatar').forEach(el => setElementImage(el, el.dataset.avatarId));

        if (isEditing) {
            anniversaryModalTitle.textContent = 'ç¼–è¾‘çºªå¿µæ—¥';
            editingAnniversaryIdInput.value = anniversaryId;
            dateInput.value = anniversary.date;
            dateInput.readOnly = true;
            nameInput.value = anniversary.name;
            specialCheckbox.checked = anniversary.isSpecial || false;
        } else { // Adding new
            anniversaryModalTitle.textContent = 'æ·»åŠ çºªå¿µæ—¥';
            editingAnniversaryIdInput.value = '';
            dateInput.value = dateHint || new Date().toISOString().split('T')[0];
            dateInput.readOnly = !dateHint;
            nameInput.value = '';
            specialCheckbox.checked = false;
        }
        anniversaryModal.classList.add('visible');
    }

    function openAnniversaryDetailsModal(dateStr) {
        const userAnniversaries = appState.diary.anniversaries.filter(a => a.date === dateStr);
        const holiday = holidays[dateStr];
        
        const allEvents = [...userAnniversaries];
        if (holiday) allEvents.push(holiday);

        if (allEvents.length === 0) return; // Don't open if there's nothing to show

        const modal = getEl('anniversary-details-modal');
        getEl('anniversary-details-title').textContent = `${dateStr} çš„æ—¥ç¨‹`;
        const listEl = getEl('anniversary-details-list');
        
        listEl.innerHTML = allEvents.map(event => {
            const isSpecial = event.isSpecial || event.holiday;
            let associatedCharsHTML = '';
            if (event.associatedCharIds && event.associatedCharIds.length > 0) {
                const charNames = event.associatedCharIds.map(id => findUserById(id).name).join(', ');
                associatedCharsHTML = `<div class="associated-chars">ä¸ ${escapeHTML(charNames)} ç›¸å…³</div>`;
            } else if (event.id) { // It's a user-defined general event
                associatedCharsHTML = `<div class="associated-chars">é€šç”¨çºªå¿µæ—¥</div>`;
            }

            return `
                <li class="anniversary-details-item ${isSpecial ? 'special' : ''}">
                    <div class="name">${escapeHTML(event.name)}</div>
                    ${associatedCharsHTML}
                </li>
            `;
        }).join('');

        modal.classList.add('visible');
    }

    getEl('close-anniversary-details-btn').addEventListener('click', () => {
        getEl('anniversary-details-modal').classList.remove('visible');
    });
getEl('cancel-anniversary-btn').addEventListener('click', () => {
    anniversaryModal.classList.remove('visible');
});
    getEl('save-anniversary-btn').addEventListener('click', () => {
        const id = editingAnniversaryIdInput.value;
        const date = dateInput.value;
        const name = nameInput.value.trim();
        const isSpecial = specialCheckbox.checked;

        const selectedItems = getEl('anniversary-char-selector').querySelectorAll('.friend-selector-item.selected');
        let associatedCharIds = Array.from(selectedItems).map(item => item.dataset.id);
        
        // If "General" is selected, treat it as an empty array (general for all)
        if (associatedCharIds.includes('general')) {
            associatedCharIds = [];
        }
        
        if (!date || !name) {
            showToast('æ—¥æœŸå’Œåç§°ä¸èƒ½ä¸ºç©º', 'error');
            return;
        }

        if (id) { // Editing
            const anniversary = appState.diary.anniversaries.find(a => a.id === id);
            if (anniversary) {
                anniversary.date = date;
                anniversary.name = name;
                anniversary.isSpecial = isSpecial;
                anniversary.associatedCharIds = associatedCharIds;
            }
        } else { // Adding new
            const newAnniversary = {
                id: newId('anniv'),
                date: date,
                name: name,
                isSpecial: isSpecial,
                associatedCharIds: associatedCharIds
            };
            appState.diary.anniversaries.push(newAnniversary);
        }

        debouncedSaveState();
        renderAnniversaryCalendar(anniversaryCalendarState.year, anniversaryCalendarState.month);
        anniversaryModal.classList.remove('visible');
        showToast('çºªå¿µæ—¥å·²ä¿å­˜ï¼');
    });

    getEl('anniversary-char-selector').addEventListener('click', e => {
        const item = e.target.closest('.friend-selector-item');
        if (!item) return;

        const charId = item.dataset.id;
        const selector = item.parentElement;
        
        if (charId === 'general') {
            // If "General" is selected, deselect all others
            selector.querySelectorAll('.friend-selector-item').forEach(el => el.classList.remove('selected'));
            item.classList.add('selected');
        } else {
            // If a specific char is selected, deselect "General"
            const generalItem = selector.querySelector('.friend-selector-item[data-id="general"]');
            if (generalItem) generalItem.classList.remove('selected');
            item.classList.toggle('selected');
            // If no specific char is selected, re-select "General"
            if (selector.querySelectorAll('.friend-selector-item.selected').length === 0) {
                 if (generalItem) generalItem.classList.add('selected');
            }
        }
    });

        getEl('diary-action-btn').addEventListener('click', () => openAnniversaryModal(null, 'add'));

    getEl('anniversary-calendar-grid').addEventListener('click', (e) => {
const grid = getEl('anniversary-calendar-grid');
const dayCell = e.target.closest('.calendar-day:not(.other-month)');
if (!dayCell) return;

const dateStr = dayCell.dataset.date;
const editBtn = e.target.closest('.calendar-action-btn.edit');
const deleteBtn = e.target.closest('.calendar-action-btn.delete');
const hasAnniversaryActions = dayCell.querySelector('.calendar-day-actions');

// 1. å¦‚æœç›´æ¥ç‚¹å‡»äº†â€œç¼–è¾‘â€æˆ–â€œåˆ é™¤â€æŒ‰é’®
if (editBtn) {
    e.stopPropagation();
    const anniversariesOnDay = appState.diary.anniversaries.filter(a => a.date === dateStr);
    if (anniversariesOnDay.length === 1) {
        openAnniversaryModal(anniversariesOnDay[0].id, dateStr);
    } else if (anniversariesOnDay.length > 1) {
        openAnniversaryManagementModal(dateStr, 'edit');
    }
    dayCell.classList.remove('actions-visible'); // æ“ä½œåéšè—æŒ‰é’®
    return;
}
if (deleteBtn) {
    e.stopPropagation();
    openAnniversaryManagementModal(dateStr, 'delete');
    dayCell.classList.remove('actions-visible'); // æ“ä½œåéšè—æŒ‰é’®
    return;
}

const isActionsVisible = dayCell.classList.contains('actions-visible');

// 2. åœ¨å¤„ç†æœ¬æ¬¡ç‚¹å‡»å‰ï¼Œå…ˆéšè—å…¶ä»–æ‰€æœ‰å·²æ‰“å¼€çš„æŒ‰é’®
const currentlyVisibleCell = grid.querySelector('.calendar-day.actions-visible');
if (currentlyVisibleCell && currentlyVisibleCell !== dayCell) {
    currentlyVisibleCell.classList.remove('actions-visible');
}

// 3. æ ¹æ®å½“å‰æ ¼å­çš„çŠ¶æ€å†³å®šä¸‹ä¸€æ­¥æ“ä½œ
if (isActionsVisible) {
    // è¿™æ˜¯ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼Œä¸”æ²¡æœ‰ç‚¹åœ¨æŒ‰é’®ä¸Šï¼Œè§†ä¸ºâ€œæŸ¥çœ‹è¯¦æƒ…â€
    openAnniversaryDetailsModal(dateStr);
    dayCell.classList.remove('actions-visible'); // æŸ¥çœ‹åéšè—æŒ‰é’®
} else {
    // è¿™æ˜¯ç¬¬ä¸€æ¬¡ç‚¹å‡»
    if (hasAnniversaryActions) {
        // å¦‚æœè¿™ä¸ªæ ¼å­æœ‰çºªå¿µæ—¥ï¼ˆå³å­˜åœ¨æŒ‰é’®åŒºåŸŸï¼‰ï¼Œåˆ™æ˜¾ç¤ºæŒ‰é’®
        dayCell.classList.add('actions-visible');
    } else {
        // å¦‚æœæ²¡æœ‰çºªå¿µæ—¥ï¼Œç›´æ¥æŸ¥çœ‹è¯¦æƒ…
        openAnniversaryDetailsModal(dateStr);
    }
}
});

function openAnniversaryManagementModal(dateStr, mode) {
    const modal = getEl('anniversary-management-modal');
    const titleEl = getEl('anniversary-management-title');
    const promptEl = getEl('anniversary-management-prompt');
    const listEl = getEl('anniversary-management-list');
    const confirmBtn = getEl('confirm-anniversary-management-btn');

    const anniversariesOnDay = appState.diary.anniversaries.filter(a => a.date === dateStr);
    const inputType = (mode === 'edit') ? 'radio' : 'checkbox';

    titleEl.textContent = (mode === 'edit') ? 'é€‰æ‹©è¦ç¼–è¾‘çš„çºªå¿µæ—¥' : 'é€‰æ‹©è¦åˆ é™¤çš„çºªå¿µæ—¥';
    promptEl.textContent = `åœ¨ ${dateStr} æœ‰ä»¥ä¸‹ ${anniversariesOnDay.length} ä¸ªçºªå¿µæ—¥:`;
    
    listEl.innerHTML = anniversariesOnDay.map((anniv, index) => `
        <label class="checkbox-label" style="border-radius: 5px; margin-bottom: 5px;">
            <input type="${inputType}" name="anniversary-selection" value="${anniv.id}" ${inputType === 'radio' && index === 0 ? 'checked' : ''}>
            <span>${escapeHTML(anniv.name)}</span>
        </label>
    `).join('');

    // Use .onclick for simple one-time listener assignment
    confirmBtn.onclick = () => {
        const selectedInputs = listEl.querySelectorAll('input:checked');
        if (selectedInputs.length === 0) {
            showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€é¡¹', 'error');
            return;
        }

        const selectedIds = Array.from(selectedInputs).map(input => input.value);

        if (mode === 'edit') {
            modal.classList.remove('visible');
            openAnniversaryModal(selectedIds[0], dateStr);
        } else { // delete
            if (confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedIds.length} ä¸ªçºªå¿µæ—¥å—ï¼Ÿ`)) {
                appState.diary.anniversaries = appState.diary.anniversaries.filter(a => !selectedIds.includes(a.id));
                debouncedSaveState();
                renderAnniversaryCalendar(anniversaryCalendarState.year, anniversaryCalendarState.month);
                showToast('çºªå¿µæ—¥å·²åˆ é™¤');
            }
            modal.classList.remove('visible');
        }
    };

    modal.classList.add('visible');
}

getEl('cancel-anniversary-management-btn').addEventListener('click', () => {
    getEl('anniversary-management-modal').classList.remove('visible');
});

// ===================================================================
// --- èŠå¤© APP (åŒ…å«åŠ¨æ€) ---
// ===================================================================
chatListBackBtn.addEventListener('click', () => { if (chatAppScreen.classList.contains('selection-mode')) { exitContactSelectionMode(); } else { closeCurrentApp(); } });
query('#chat-app-screen .app-bottom-tabs').addEventListener('click', (e) => { if (e.target.classList.contains('tab-link')) { const tabId = e.target.dataset.tab; queryAll('#chat-app-screen .tab-link').forEach(t => t.classList.remove('active')); queryAll('#chat-app-screen .tab-content').forEach(c => c.classList.remove('active')); e.target.classList.add('active'); getEl(`${tabId}-tab-content`).classList.add('active'); const titleEl = chatAppScreen.querySelector('.title'); if (tabId === 'moments') { titleEl.textContent = 'åŠ¨æ€'; chatListActionBtn.style.display = 'none'; momentsNotificationBtn.style.display = 'block'; renderMomentsPage('user'); } else { titleEl.textContent = 'æ¶ˆæ¯'; chatListActionBtn.style.display = 'block'; momentsNotificationBtn.style.display = 'none'; } } });
chatListActionBtn.addEventListener('click', () => { if (chatAppScreen.classList.contains('selection-mode')) { if (runtimeState.contactSelection.length < 1) { showToast('è‡³å°‘éœ€è¦é€‰æ‹©ä¸€ä½è”ç³»äºº', 'error'); return; } const groupName = prompt('è¯·è¾“å…¥ç¾¤èŠåç§°:', ''); if (groupName) { createGroup(groupName, runtimeState.contactSelection); } } else { addContactModal.classList.add('visible'); } });
cancelAddContactBtn.addEventListener('click', () => addContactModal.classList.remove('visible'));
confirmAddContactBtn.addEventListener('click', () => { const name = newContactNameInput.value.trim();
    if (!name) return; // æ ¸å¿ƒä¿®å¤ï¼šå¢åŠ éç©ºæ ¡éªŒ
     const newContact = { id: newId('contact'),name: name, remark: '', avatarId: `https://api.multiavatar.com/${name}.png`, status: 'online', statusText: 'åœ¨çº¿', signature: 'è¿™ä¸ªäººå¾ˆæ‡’ï¼Œä»€ä¹ˆéƒ½æ²¡ç•™ä¸‹ã€‚', lastMessage: '', lastMessageTime: Date.now(), isGroup: false, conversation: [], listenTogetherDuration: 0, lastLetterSent: 0 }; initializeContactSettings(newContact); appState.chat.contacts.push(newContact); saveState(); renderMessageList(); addContactModal.classList.remove('visible'); newContactNameInput.value = ''; });
const statusMap = { online: 'åœ¨çº¿', busy: 'å¿™ç¢Œ', offline: 'ç¦»çº¿' };
function renderMessageList() {        appState.chat.contacts.sort((a, b) => {
            const aIsPinned = a.isPinned || false;
            const bIsPinned = b.isPinned || false;
            if (aIsPinned !== bIsPinned) {
                return bIsPinned - aIsPinned;
            }
            return b.lastMessageTime - a.lastMessageTime;
        }); messageListEl.innerHTML = ''; if (appState.chat.contacts.length === 0) { messageListEl.innerHTML = '<li style="padding: 20px; text-align: center; color: #888;">æš‚æ— è”ç³»äººï¼Œç‚¹å‡»å³ä¸Šè§’+æ·»åŠ </div>'; return; } appState.chat.contacts.forEach(contact => { const li = document.createElement('li'); li.className = `contact-list-item ${contact.isPinned ? 'pinned' : ''}`; li.dataset.id = contact.id; li.dataset.isGroup = contact.isGroup; const time = new Date(contact.lastMessageTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); let avatarHTML; const unreadBadgeHTML = contact.unreadCount > 0 ? `<div class="unread-badge">${contact.unreadCount}</div>` : ''; const shakeClass = contact.needsShake ? 'shake' : ''; if (contact.isGroup) { const groupAvatarId = contact.groupSettings.avatarId; if (groupAvatarId) { avatarHTML = `<div class="contact-avatar ${shakeClass}" data-avatar-id="${groupAvatarId}">${unreadBadgeHTML}</div>`; } else { const memberAvatarIds = ['user', ...contact.members].slice(0, 4).map(id => { if (id === 'user') return appState.chat.userProfile.avatarId; return appState.chat.contacts.find(c => c.id === id)?.charSettings.avatarId || ''; }).filter(Boolean); const puzzlePieces = memberAvatarIds.map(avatarId => `<div class="puzzle-piece" data-avatar-id="${avatarId}"></div>`).join(''); avatarHTML = `<div class="contact-avatar group-puzzle ${shakeClass}">${puzzlePieces}${unreadBadgeHTML}</div>`; } } else { avatarHTML = `<div class="contact-avatar ${shakeClass}" data-avatar-id="${contact.charSettings.avatarId}">${unreadBadgeHTML}</div>`; } const statusIndicator = `<div class="status-indicator ${contact.status}"></div>`; const metaHTML = contact.isGroup ? `<span>(${contact.members.length + 1})</span>` : `<div class="contact-status">${statusIndicator} ${statusMap[contact.status] || 'æœªçŸ¥'}</div>`;                    const pinText = contact.isPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶';
                li.innerHTML = ` <div class="contact-item-content swipe-content"> ${avatarHTML} <div class="contact-info"> <div class="contact-name">${contact.remark || (contact.isGroup ? contact.groupSettings.name : contact.charSettings.name)}</div> <div class="contact-last-msg">${contact.lastMessage || ''}</div> </div> <div class="contact-meta"> <div class="contact-time">${time}</div> ${metaHTML} </div> </div> <div class="contact-item-actions"> <div class="pin-action">${pinText}</div> <div class="delete-action">åˆ é™¤</div> </div>`; messageListEl.appendChild(li); li.querySelectorAll('[data-avatar-id]').forEach(el => { const id = el.dataset.avatarId; if (id.startsWith('https')) { el.style.backgroundImage = `url(${id})`; } else { setElementImage(el, id); } }); if (contact.needsShake) { setTimeout(() => { const avatarEl = li.querySelector('.contact-avatar'); if (avatarEl) avatarEl.classList.remove('shake'); contact.needsShake = false; debouncedSaveState(); }, 500); } }); }
function enterContactSelectionMode(item) { if (item.dataset.isGroup === 'true') { showToast('ä¸èƒ½é€‰æ‹©ç¾¤ç»„åŠ å…¥æ–°ç¾¤èŠ', 'error'); return; } chatAppScreen.classList.add('selection-mode'); chatListBackBtn.textContent = 'å–æ¶ˆ'; chatListActionBtn.textContent = 'å»ºç¾¤'; chatListActionBtn.classList.add('small'); item.classList.add('selected'); runtimeState.contactSelection.push(item.dataset.id); }
function exitContactSelectionMode() { chatAppScreen.classList.remove('selection-mode'); chatListBackBtn.textContent = '< è¿”å›'; chatListActionBtn.textContent = '+'; chatListActionBtn.classList.remove('small'); queryAll('.contact-list-item.selected').forEach(i => i.classList.remove('selected')); runtimeState.contactSelection = []; }
function createGroup(name, memberIds) { const members = memberIds.map(id => appState.chat.contacts.find(c => c.id === id)); const newGroup = { id: newId('group'), name: name, avatarId: '', lastMessage: 'ç¾¤èŠå·²åˆ›å»º', lastMessageTime: Date.now(), isGroup: true, members: memberIds, conversation: [] }; initializeContactSettings(newGroup); const memberNames = members.map(m => `'${m.name}'`).join(', '); addSystemNotification(newGroup.id, `'${appState.chat.userProfile.name}' é‚€è¯· ${memberNames} åŠ å…¥ç¾¤èŠ`, true); appState.chat.contacts.unshift(newGroup); saveState(); renderMessageList(); exitContactSelectionMode(); }
function openSingleChat(contactId) {

        // --- æ ¸å¿ƒä¿®å¤ï¼šå®æ–½â€œåŸå­åŒ–â€è·³è½¬æµç¨‹ ---

        // 1. **éªŒè¯ç›®æ ‡**
        const contact = appState.chat.contacts.find(c => c.id === contactId);
        if (!contact) {
            console.error("Attempted to open chat with non-existent contact:", contactId);
            return;
        }
// --- æ–°å¢ï¼šæ£€æŸ¥å¹¶æ˜¾ç¤ºCharçš„å¥½å‹ç”³è¯·å¼¹çª— ---
if (!contact.isGroup && contact.charSettings.pendingFriendRequest) {
    runtimeState.currentChatId = contactId; // å¿…é¡»å…ˆè®¾ç½®currentChatId
    singleChatScreen.dataset.contactId = contactId;
    updateSingleChatUI(); // å…ˆæ›´æ–°UIï¼ˆå¦‚èƒŒæ™¯ã€æ ‡é¢˜ï¼‰
    openSubScreen(singleChatScreen, chatAppScreen);
    showCharFriendRequestModal(contact);
    return; // æ˜¾ç¤ºå¼¹çª—åï¼Œç»ˆæ­¢å‡½æ•°ï¼Œä¸æ‰§è¡Œåç»­çš„æ™®é€šèŠå¤©åŠ è½½é€»è¾‘
}
        // 2. **æ¸…åœºï¼šå…³é—­æ‰€æœ‰å¯èƒ½æ‰“å¼€çš„å­å±å¹•**
        // è¿™ä¸€æ­¥è‡³å…³é‡è¦ï¼Œå®ƒç¡®ä¿åœ¨åˆ‡æ¢ä¸Šä¸‹æ–‡ä¹‹å‰ï¼Œæ‰€æœ‰æ—§çš„UIéƒ½å·²å…³é—­ã€‚
        if (chatSettingsScreen.classList.contains('active')) {
            closeSubScreen(chatSettingsScreen, singleChatScreen);
        }
        if (groupChatSettingsScreen.classList.contains('active')) {
            closeSubScreen(groupChatSettingsScreen, singleChatScreen);
        }
        // å¦‚æœæ˜¯ä»å…¶ä»–APPè·³è½¬è€Œæ¥ï¼Œç¡®ä¿ä¸»APPç•Œé¢æ˜¯èŠå¤©APP
        if (!chatAppScreen.classList.contains('active')) {
            closeAllScreens();
            openApp(chatAppScreen);
        }
        
        // 3. **åˆ‡æ¢ä¸Šä¸‹æ–‡**
        runtimeState.currentChatId = contactId;
        singleChatScreen.dataset.contactId = contactId;
        
        // 4. **åˆå§‹åŒ–æ–°ä¼šè¯çŠ¶æ€**
        if (!runtimeState.chatDisplayLimits[contactId]) {
            runtimeState.chatDisplayLimits[contactId] = 50;
        }
        if (contact.unreadCount > 0) {
            contact.unreadCount = 0;
            debouncedSaveState(); // ç«‹å³ä¿å­˜æœªè¯»æ•°å˜åŒ–
            renderMessageList();
        }
        runtimeState.notificationQueue = runtimeState.notificationQueue.filter(n => n.contactId !== contactId);

        // 5. **æ¸²æŸ“å¹¶æ‰“å¼€æ–°ç•Œé¢**
        updateSingleChatUI();
        openSubScreen(singleChatScreen, chatAppScreen);
    }
async function updateSingleChatUI() {
    const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
    if (!contact) return;

    const isDisbanded = contact.isGroup && contact.groupSettings.isDisbanded;
    const userIsMuted = contact.isGroup && contact.groupSettings.members['user']?.isMuted;
    const allMuted = contact.isGroup && contact.groupSettings.isMuted;
    const userIsAdminOrOwner = contact.isGroup && (contact.groupSettings.owner === 'user' || contact.groupSettings.admins.includes('user'));
    const canSpeak = !isDisbanded && (!allMuted || userIsAdminOrOwner) && !userIsMuted;

    if (contact.isGroup) {
        chatHeaderName.textContent = contact.remark || contact.groupSettings.name;
        chatHeaderStatus.textContent = `(${contact.members.length + 1})`;
        chatHeaderSignature.style.display = 'none';
        addFriendBtn.style.display = 'none';
        chatInput.disabled = !canSpeak;
        let placeholder = 'è¾“å…¥æ¶ˆæ¯...';
        if (isDisbanded) placeholder = 'ç¾¤èŠå·²è§£æ•£';
        else if (allMuted) placeholder = 'å…¨å‘˜ç¦è¨€ä¸­';
        else if (userIsMuted) placeholder = 'ä½ å·²è¢«ç¦è¨€';
        chatInput.placeholder = placeholder;
        const sendIconId = appState.beautify.icons['chat-send-real'];
        if (sendIconId) setElementImage(chatSendRealBtn, sendIconId, 'src');
        else chatSendRealBtn.innerHTML = '<i class="fa-solid fa-comments"></i>';
        chatToolbar.querySelectorAll('.icon-btn').forEach(btn => btn.classList.toggle('disabled', !canSpeak));
        chatEmojiBtn.classList.toggle('disabled', !canSpeak);
    } else { // Single Chat
        const settings = contact.charSettings;
        const statusIndicatorHTML = `<div class="status-indicator ${contact.status}"></div>`;
        chatHeaderName.textContent = contact.remark || settings.name;
        chatHeaderStatus.innerHTML = `${statusIndicatorHTML} ${statusMap[contact.status] || 'æœªçŸ¥'} ${contact.statusText ? `- ${contact.statusText}` : ''}`;
        chatHeaderSignature.textContent = contact.signature || '(ç‚¹å‡»è®¾ç½®ç­¾å)';
        chatHeaderSignature.style.display = 'block';
        addFriendBtn.style.display = settings.isFriend ? 'none' : 'block';
        chatInput.disabled = false;
        chatInput.placeholder = settings.isFriend ? 'è¾“å…¥æ¶ˆæ¯...' : 'ä½ è¿˜ä¸æ˜¯å¯¹æ–¹çš„å¥½å‹';
        
        const sendIconId = appState.beautify.icons['chat-send-real'];
        if (settings.isFriend) {
            if (sendIconId) setElementImage(chatSendRealBtn, sendIconId, 'src');
            else chatSendRealBtn.innerHTML = '<i class="fa-solid fa-comments"></i>';
        } else {
            // **æ ¸å¿ƒä¿®æ”¹**: åœ¨éå¥½å‹çŠ¶æ€ä¸‹ï¼Œå°†æŒ‰é’®å›¾æ ‡æ”¹ä¸ºâ€œæ¡æ‰‹â€
            chatSendRealBtn.innerHTML = '<i class="fa-solid fa-handshake"></i>';
        }
        
        chatToolbar.querySelectorAll('.icon-btn').forEach(btn => btn.classList.toggle('disabled', !settings.isFriend));
        chatEmojiBtn.classList.toggle('disabled', !settings.isFriend);
    }

    const specificBgId = contact.isGroup ? contact.groupSettings.chatBackgroundId : contact.charSettings?.chatBackgroundId;
    let finalBgId = 'default'; // Start with the ultimate fallback

    // Prioritize the specific setting, but only if it's not the default value
    if (specificBgId && specificBgId !== 'default') {
        finalBgId = specificBgId;
    } else {
        // If the specific setting is 'default' or not set, fall back to the global setting
        finalBgId = appState.beautify.currentChatBgId;
    }
    
    // applyWallpaperById will handle the final fallback to the initial background if finalBgId is 'default'
    await applyWallpaperById(finalBgId, singleChatScreen);
    
    renderConversation();
    updateChatInputButtons();
    updateTypingIndicator();
}
chatBackBtn.addEventListener('click', () => {
if (runtimeState.chatSelectionMode) {
exitChatSelectionMode();
} else {
closeSubScreen(singleChatScreen, chatAppScreen);
runtimeState.currentChatId = null;
delete singleChatScreen.dataset.contactId;
}
});
chatSettingsBtn.addEventListener('click', () => { if (runtimeState.chatSelectionMode) { if (runtimeState.selectedMessages.length > 0 && confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${runtimeState.selectedMessages.length} æ¡æ¶ˆæ¯å—ï¼Ÿ`)) { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); contact.conversation = contact.conversation.filter(msg => !runtimeState.selectedMessages.includes(msg.id)); updateContactLastMessage(runtimeState.currentChatId); debouncedSaveState(); renderConversation(); renderMessageList(); } exitChatSelectionMode(); } else { openChatSettings(); } });
function renderConversation(isLoadingMore = false) {
        let contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;

        if (isLoadingMore) {
            const oldLoadMoreBtn = chatMessagesView.querySelector('#load-more-messages-btn');
            if (oldLoadMoreBtn) {
                oldLoadMoreBtn.remove();
            }
        } else {
            chatMessagesView.innerHTML = '';
        }

        const isSettingsPreview = (groupChatSettingsScreen.classList.contains('active') || chatSettingsScreen.classList.contains('active')) && runtimeState.tempChatSettings && Object.keys(runtimeState.tempChatSettings).length > 0;
        if (isSettingsPreview) {
            const tempContact = JSON.parse(JSON.stringify(contact));
            if (tempContact.isGroup) {
                tempContact.groupSettings = runtimeState.tempChatSettings.groupSettings;
                tempContact.userSettings = runtimeState.tempChatSettings.userSettings;
            } else {
                tempContact.charSettings = runtimeState.tempChatSettings.charSettings;
                tempContact.userSettings = runtimeState.tempChatSettings.userSettings;
            }
            contact = tempContact;
        }

        const displayLimit = runtimeState.chatDisplayLimits[contact.id] || 50;
        const conversation = contact.conversation;

        let messagesToRender;
        if (isLoadingMore) {
            const previousLimit = displayLimit - 50;
            messagesToRender = conversation.slice(-displayLimit, -previousLimit);
        } else {
            messagesToRender = conversation.slice(-displayLimit);
        }

        const fragment = document.createDocumentFragment();

        if (conversation.length > displayLimit) {
            const loadMoreEl = document.createElement('div');
            loadMoreEl.className = 'message-timestamp';
            loadMoreEl.id = 'load-more-messages-btn';
            loadMoreEl.textContent = 'åŠ è½½æ›´å¤šæ¶ˆæ¯';
            loadMoreEl.style.cursor = 'pointer';
            loadMoreEl.style.color = 'var(--accent-color)';
            fragment.appendChild(loadMoreEl);
        }
        
        let lastTimestamp = (messagesToRender.length > 0) ? (messagesToRender[0].timestamp - 6 * 60 * 1000) : 0;
        
        messagesToRender.forEach(msg => {
            if (msg.timestamp - lastTimestamp > 5 * 60 * 1000) {
                const timeEl = document.createElement('div');
                timeEl.className = 'message-timestamp';
                timeEl.textContent = new Date(msg.timestamp).toLocaleString();
                fragment.appendChild(timeEl);
                lastTimestamp = msg.timestamp;
            }

            if (msg.type === 'notification') {
                const notificationEl = document.createElement('div');
                notificationEl.className = 'message-timestamp';
                notificationEl.dataset.id = msg.id;
                notificationEl.textContent = msg.content;
                if (msg.originalContent) {
                    notificationEl.dataset.originalContent = msg.originalContent;
                }
                fragment.appendChild(notificationEl);
                return;
            }

            const msgItem = document.createElement('div');
            msgItem.className = `message-item ${msg.sender === 'user' ? 'user' : 'contact'}`;
            msgItem.dataset.id = msg.id;
            msgItem.dataset.sender = msg.sender;
            const isUser = msg.sender === 'user';

            let avatarId, avatarFrameId, senderName;
            if (contact.isGroup) {
                const memberSettings = contact.groupSettings.members[msg.sender];
                const userProfile = findUserById(msg.sender);
                avatarId = memberSettings?.avatarId || userProfile.avatarId;
                senderName = memberSettings?.nickname || userProfile.name;
                avatarFrameId = memberSettings?.avatarFrameId || '';
            } else {
                avatarId = isUser ? contact.userSettings.avatarId : contact.charSettings.avatarId;
                senderName = isUser ? contact.userSettings.name : (contact.remark || contact.charSettings.name);
                avatarFrameId = isUser ? contact.userSettings.avatarFrameId : contact.charSettings.avatarFrameId;
            }

            const avatarHTML = `<div class="avatar" data-avatar-id="${avatarId}"><div class="avatar-frame" data-avatar-frame-id="${avatarFrameId}"></div></div>`;
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'message-content-wrapper';
            
            let contentHTML = '';

            if (contact.isGroup && msg.sender !== 'system') {
                const memberSettings = contact.groupSettings.members[msg.sender];
                if (memberSettings) {
                    const role = msg.sender === contact.groupSettings.owner ? 'owner' : (contact.groupSettings.admins.includes(msg.sender) ? 'admin' : 'member');
                    contentHTML += `<div class="group-message-header"><span class="group-title title-${role}" data-member-id="${msg.sender}">${memberSettings.title || 'æˆå‘˜'}</span><span class="group-nickname" data-member-id="${msg.sender}">${memberSettings.nickname || 'æœªçŸ¥æˆå‘˜'}</span></div>`;
                } else if (msg.sender) {
                    contentHTML += `<div class="group-message-header"><span class="group-nickname" data-member-id="${msg.sender}">${senderName}</span></div>`;
                }
            }

            if (msg.quote) {
                contentHTML += `<div class="message-quote"><strong>${msg.quote.senderName}:</strong> ${msg.quote.content}</div>`;
            }
            
            switch(msg.type) {
    case 'text':
        contentHTML += `<div class="message-bubble">${msg.content}</div>`;
        break;
    case 'forwarded':
        const summaryLines = msg.content.messages.slice(0, 4).map(fwdMsg => {
            let contentPreview = '';
            switch(fwdMsg.type) {
                case 'text': contentPreview = fwdMsg.content; break;
                case 'emoji': contentPreview = `[${fwdMsg.description || 'è¡¨æƒ…'}]`; break;
                default: contentPreview = `[${fwdMsg.type}]`; break;
            }
            return `${fwdMsg.senderName}: ${truncateText(contentPreview, 20)}`;
        });
        contentHTML += `
            <div class="message-bubble forwarded">
                <div class="forwarded-title">[èŠå¤©è®°å½•] ${escapeHTML(msg.content.from)}</div>
                <div class="forwarded-summary">${escapeHTML(summaryLines.join('\n'))}</div>
            </div>`;
        break;
    case 'emoji':
        contentHTML += `<div class="message-bubble emoji-bubble"><img data-emoji-id="${msg.emojiId}" alt="${msg.description}"></div>`;
        break;
    case 'voice':
        const bubbleWidth = Math.min(60 + msg.duration * 8, 220);
        const spanCount = Math.floor(bubbleWidth / 4);
        const waveformSpans = Array(spanCount).fill(0).map(() => `<span style="height: ${Math.random() * 90 + 10}%"></span>`).join('');
        contentHTML += `<div class="message-bubble voice" style="width: ${bubbleWidth}px;"><div class="voice-waveform-container">${waveformSpans}</div><span class="voice-duration">${msg.duration}â€</span></div><div class="voice-text">${msg.content}</div>`;
        break;
    case 'image':
    case 'camera':
        const isCamera = msg.type === 'camera';
        const cameraOverlay = isCamera ? `<div class="camera-text-overlay">(${msg.content})</div>` : '';
        contentHTML += `<div class="message-bubble ${msg.type}"><img data-image-id="${msg.imageId}">${cameraOverlay}</div>`;
        break;
    case 'link':
        contentHTML += `<div class="message-bubble link" data-link-content="${encodeURIComponent(JSON.stringify(msg))}"><div class="link-info"><div class="title">${msg.title}</div><div class="summary">${msg.summary}</div><div class="source">${msg.source || 'é“¾æ¥'}</div></div></div>`;
        break;
    case 'musicShare':
        contentHTML += `<div class="message-bubble link" data-song-id="${msg.songId}"><div class="link-info"><div class="title">åˆ†äº«éŸ³ä¹: ${msg.title}</div><div class="summary">æ­Œæ‰‹: ${msg.artist}</div><div class="source">â–¶ï¸ ç‚¹å‡»ä¸€èµ·å¬</div></div></div>`;
        break;
    case 'redPacket':
        let packetStatusText = '';
        const claimedCount = Object.keys(msg.claimedBy || {}).length;
        if (msg.status === 'claimed' || (claimedCount > 0 && claimedCount >= (msg.count || 1))) {
            packetStatusText = 'çº¢åŒ…å·²è¢«é¢†å®Œ';
        } else if (msg.status === 'returned') {
            packetStatusText = 'çº¢åŒ…å·²è¢«é€€å›';
        } else if (msg.status === 'expired') {
            packetStatusText = 'çº¢åŒ…å·²è¿‡æœŸ';
        }
        let packetTypeFooter = 'ä¸ªäººçº¢åŒ…';
        if(contact.isGroup) {
            switch(msg.packetType){
                case 'exclusive': 
                    const targetName = findUserById(msg.exclusiveTo)?.name || 'æœªçŸ¥ç”¨æˆ·';
                    packetTypeFooter = `ç»™${targetName}çš„ä¸“å±çº¢åŒ…`;
                    break;
                case 'lucky': packetTypeFooter = 'æ‹¼æ‰‹æ°”çº¢åŒ…'; break;
                case 'normal': packetTypeFooter = 'æ™®é€šçº¢åŒ…'; break;
            }
        }
        contentHTML += `<div class="message-bubble red-packet ${msg.status || ''}" data-packet-content="${encodeURIComponent(JSON.stringify(msg))}"><div class="red-packet-header"><span class="red-packet-icon">ğŸ§§</span><span>${msg.message}</span></div><div class="red-packet-body">${packetStatusText}</div><div class="red-packet-footer">${packetTypeFooter}</div></div>`;
        break;
}

            contentWrapper.innerHTML = contentHTML;

            if (isUser && msg.status === 'send_failed') {
                const failureIndicator = document.createElement('div');
                failureIndicator.style.cssText = 'display: flex; align-items: center; gap: 5px; margin-top: 4px;';
                failureIndicator.innerHTML = `
                    <i class="fa-solid fa-circle-exclamation" style="color: var(--danger-color);"></i>
                    <span style="font-size: 12px; color: var(--secondary-text-color);">ä½ è¿˜ä¸æ˜¯å¯¹æ–¹çš„å¥½å‹</span>
                `;
                contentWrapper.appendChild(failureIndicator);
            }
            
            msgItem.innerHTML = isUser ? '' : avatarHTML;
            msgItem.appendChild(contentWrapper);
            if (isUser) msgItem.innerHTML += avatarHTML;
            
            fragment.appendChild(msgItem);
        });
        
        if (isLoadingMore) {
            const oldScrollHeight = chatMessagesView.scrollHeight;
            chatMessagesView.prepend(fragment);
            chatMessagesView.scrollTop = chatMessagesView.scrollHeight - oldScrollHeight;
        } else {
            chatMessagesView.appendChild(fragment);
            chatMessagesView.scrollTop = chatMessagesView.scrollHeight;
        }

        chatMessagesView.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
        chatMessagesView.querySelectorAll('[data-avatar-frame-id]').forEach(el => setElementImage(el, el.dataset.avatarFrameId));
        chatMessagesView.querySelectorAll('[data-emoji-id]').forEach(el => setElementImage(el, el.dataset.emojiId, 'src'));
        chatMessagesView.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'src'));
    }
function addMessageToConversation(message, fromAI = false) {     const contact = appState.chat.contacts.find(c => c.id === message.contactId);

    // --- æ ¸å¿ƒä¿®å¤ï¼šå¯¹æ‰€æœ‰ä¼ å…¥æ¶ˆæ¯è¿›è¡Œå®‰å…¨æ£€æŸ¥å’Œè‡ªåŠ¨ä¿®å¤ ---
    if (message.type === 'voice') {
        if (typeof message.duration === 'undefined' || message.duration === null || message.duration <= 0) {
            console.warn("addMessageToConversation: Voice message received with invalid duration. Calculating fallback.", message);
            const cleanText = (message.content || '').replace(/\(.*?\)|ï¼ˆ.*?ï¼‰/g, '');
            message.duration = Math.max(1, Math.ceil(cleanText.length / 2));
        }
    } if (!contact) return; if (fromAI && runtimeState.aiQuotedMessage && runtimeState.aiQuotedMessage.charId === message.sender) {
    const quotedMsg = runtimeState.aiQuotedMessage.message;
    const senderName = getDisplayName(quotedMsg.sender, contact.id);

    let previewContent = '';
    switch(quotedMsg.type) {
        case 'text': previewContent = quotedMsg.content; break;
        case 'voice': previewContent = '[è¯­éŸ³]'; break;
        case 'camera':
        case 'image': previewContent = '[å›¾ç‰‡]'; break;
        default: previewContent = `[${quotedMsg.type}]`; break;
    }

    message.quote = {
        id: quotedMsg.id,
        content: previewContent,
        senderName: senderName
    };
    runtimeState.aiQuotedMessage = null; // Consume the quote
} if (runtimeState.quotedMessage && message.sender === 'user') { let senderName; if (contact.isGroup) { senderName = contact.groupSettings.members[runtimeState.quotedMessage.sender]?.nickname || findUserById(runtimeState.quotedMessage.sender).name; } else { senderName = runtimeState.quotedMessage.sender === 'user' ? (contact.userSettings.name || 'ä½ ') : (contact.remark || contact.charSettings.name); } message.quote = { id: runtimeState.quotedMessage.id, content: runtimeState.quotedMessage.content, senderName: senderName }; runtimeState.quotedMessage = null; quotePreview.style.display = 'none'; }

// --- æ ¸å¿ƒæ–°å¢ï¼šé¦–æ¬¡äº’åŠ¨è§¦å‘å™¨ ---
if (message.sender === 'user' && !contact.isGroup && !contact.charSettings.hasHadFirstInteraction) {
    // ä»…åœ¨è¿™æ˜¯ç¬¬ä¸€æ¡çœŸæ­£çš„ç”¨æˆ·æ¶ˆæ¯æ—¶è§¦å‘
    const userMessageCount = contact.conversation.filter(m => m.sender === 'user').length;
    if (userMessageCount === 0) { // åœ¨æ·»åŠ å½“å‰æ¶ˆæ¯ä¹‹å‰ï¼Œç”¨æˆ·æ¶ˆæ¯æ•°ä¸º0
        contact.charSettings.hasHadFirstInteraction = true;
        showToast(`ä¸ ${contact.charSettings.name} çš„æ•…äº‹å¼€å§‹äº†...`);
        // ä½¿ç”¨setTimeoutè®©è§’è‰²çš„ååº”çœ‹èµ·æ¥æ›´è‡ªç„¶
        setTimeout(() => generateAndSendLoveLetter(contact.id), 2000);
        setTimeout(() => generateAndSendPostcard(contact), 3500);
    }
}
contact.conversation.push(message); if (fromAI && (!singleChatScreen.classList.contains('active') || runtimeState.currentChatId !== contact.id)) { contact.unreadCount = (contact.unreadCount || 0) + 1; contact.needsShake = true;     const notificationContent = message.type === 'emoji' ? `[${message.description}]` : message.content;
    queueNotification(notificationContent, contact.id, message.sender); }
// When a new message is added, increase the display limit to ensure it's visible
if (runtimeState.chatDisplayLimits[contact.id]) {
runtimeState.chatDisplayLimits[contact.id]++;
}
if (singleChatScreen.classList.contains('active') && runtimeState.currentChatId === contact.id) { renderConversation(); } updateContactLastMessage(contact.id); renderMessageList(); debouncedSaveState(); }
function addSystemNotification(contactId, content, triggerAi = false, context = null, triggerContext = { type: 'chat_reply' }) { const contact = appState.chat.contacts.find(c => c.id === contactId); if (!contact) return; const notification = { id: newId('msg'), type: 'notification', content, timestamp: Date.now(), contactId: contactId, sender: 'system' }; if (triggerAi === false) { notification.status = 'pending'; } contact.conversation.push(notification); updateContactLastMessage(contactId); debouncedSaveState(); if (runtimeState.currentChatId === contactId) { renderConversation(); } renderMessageList(); if (triggerAi) { const updatedContact = appState.chat.contacts.find(c => c.id === contactId); if (updatedContact.isGroup && updatedContact.members.length === 0) { return; } setTimeout(() => triggerAiResponse(contactId, false, false, false, context, true, triggerContext), 500); } }
chatSendFakeBtn.addEventListener('click', () => {
    const content = chatInput.value.trim();
    if (!content) return;

    const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
    if (contact && !contact.isGroup && !contact.charSettings.isFriend) {
        // éå¥½å‹çŠ¶æ€ï¼Œæ¨¡æ‹Ÿå‘é€å¤±è´¥
        addMessageToConversation({
            id: newId('msg'),
            type: 'text',
            content,
            sender: 'user',
            timestamp: Date.now(),
            status: 'send_failed', // æ–°çŠ¶æ€ï¼šå‘é€å¤±è´¥
            contactId: runtimeState.currentChatId
        });
    } else {
        // æ­£å¸¸å¥½å‹çŠ¶æ€
        addMessageToConversation({
            id: newId('msg'),
            type: 'text',
            content,
            sender: 'user',
            timestamp: Date.now(),
            status: 'pending',
            contactId: runtimeState.currentChatId
        });
    }

    chatInput.value = '';
    updateChatInputButtons();
});    function transformToGoogleFormat(messages) {
        const googleRequest = { contents: [] };
        let systemPrompt = null;

        const contentMessages = messages.filter(msg => {
            if (msg.role === 'system') {
                systemPrompt = msg.content;
                return false;
            }
            return true;
        });

        if (systemPrompt) {
            googleRequest.systemInstruction = { parts: [{ text: systemPrompt }] };
        }
            // --- PATCH START: Handle system-only prompts for Google API ---
    if (contentMessages.length === 0 && systemPrompt) {
        contentMessages.push({ role: 'user', content: systemPrompt });
        // Since we moved it to content, clear the specific system instruction
        // to avoid potential API conflicts with some models.
        delete googleRequest.systemInstruction;
    }
    // --- PATCH END ---
    

        contentMessages.forEach(message => {
            const content = {
                role: message.role === 'user' ? 'user' : 'model',
                parts: []
            };
            
            if (Array.isArray(message.content)) {
                message.content.forEach(part => {
                    if (part.type === 'text') {
                        content.parts.push({ text: part.text });
                    } else if (part.type === 'image_url') {
                        const [header, base64Data] = part.image_url.url.split(',');
                        const mimeTypeMatch = header.match(/:(.*?);/);
                        if (mimeTypeMatch && mimeTypeMatch[1]) {
                            content.parts.push({
                                inline_data: { mime_type: mimeTypeMatch[1], data: base64Data }
                            });
                        }
                    }
                });
            } else {
                content.parts.push({ text: message.content });
            }
            
            if (content.parts.length > 0) {
                googleRequest.contents.push(content);
            }
        });

        const mergedContents = [];
        if (googleRequest.contents.length > 0) {
            mergedContents.push(JSON.parse(JSON.stringify(googleRequest.contents[0])));
            for (let i = 1; i < googleRequest.contents.length; i++) {
                const current = googleRequest.contents[i];
                const last = mergedContents[mergedContents.length - 1];
                if (current.role === last.role) {
                    last.parts.push(...JSON.parse(JSON.stringify(current.parts)));
                } else {
                    mergedContents.push(JSON.parse(JSON.stringify(current)));
                }
            }
        }
        googleRequest.contents = mergedContents;
        
        return googleRequest;
    }

function transformFromGoogleFormat(googleResponse) {
    // æ ¸å¿ƒä¿®å¤ï¼šå¢åŠ å¯¹å®‰å…¨æ‹¦æˆªç­‰å¼‚å¸¸APIå“åº”çš„é˜²å¾¡æ€§å¤„ç†
    if (!googleResponse.candidates || googleResponse.candidates.length === 0) {
        console.error("Google API Error: No candidates returned. This is often due to safety filters.", googleResponse);
        const blockReason = googleResponse.promptFeedback?.blockReason || 'Unknown';
        // è¿”å›ä¸€ä¸ªç»“æ„åŒ–çš„é”™è¯¯æ¶ˆæ¯ï¼Œè€Œä¸æ˜¯è®©ç¨‹åºå´©æºƒ
        const errorMessage = `(AI response was blocked due to safety settings, reason: ${blockReason})`;
        return { choices: [{ message: { content: errorMessage } }] };
    }

    // ä½¿ç”¨å¯é€‰é“¾æ“ä½œç¬¦ (?.) æ¥å®‰å…¨åœ°è®¿é—®åµŒå¥—å±æ€§ï¼Œé˜²æ­¢å› ç»“æ„ä¸å®Œæ•´è€Œå´©æºƒ
    const text = googleResponse.candidates[0]?.content?.parts?.[0]?.text || '';
    return {
        choices: [{
            message: {
                content: text
            }
        }]
    };
}
                    async function triggerAiResponse(targetChatId, isProactive = false, isJealousyTrigger = false, isVideoChat = false, context = null, showTyping = true, triggerContext = { type: 'chat_reply' }, retryCount = 0) {
    const contact = appState.chat.contacts.find(c => c.id === targetChatId);
    if (!contact) return;
    if (contact.isGroup && contact.groupSettings.isDisbanded) { return; }
    if (contact.isGroup && contact.members.length === 0 && !isProactive) { return; }
                if (showTyping) {
                    if (runtimeState.activeRequests[targetChatId]) return;
                    runtimeState.activeRequests[targetChatId] = true;
                }
        if (!isVideoChat && showTyping) {
                updateTypingIndicator();
            }
            try {
                const { apiUrl, selectedModel } = appState.settings;
                const apiKey = getNextApiKey();
                if (!apiUrl || !apiKey || !selectedModel) {
                    throw new Error("è¯·å…ˆåœ¨ä¸»å±å¹•â€œè®¾ç½®â€ä¸­é…ç½®APIã€å¯†é’¥å¹¶é€‰æ‹©æ¨¡å‹ã€‚");
                }

                if (!isVideoChat && !context) {
                    const messagesToProcess = contact.conversation.filter(m => ['pending', 'unclaimed_new'].includes(m.status));
                    messagesToProcess.forEach(msg => { msg.status = (msg.type === 'redPacket') ? 'unclaimed' : 'sent'; });
                }
                
                const contextMemory = contact.isGroup ? contact.groupSettings.contextMemory : contact.charSettings.contextMemory;
                            let systemPrompt;
            
            // --- æ ¸å¿ƒä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦æœ‰å¹¶è¡Œçš„è§†é¢‘é€šè¯æ­£åœ¨è¿›è¡Œ ---
            const isVideoCallActiveWithThisContact = appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId === targetChatId;
                let history;
                
                const CONTEXT_IMAGE_LOOKBACK = 5;
                const imageDataContext = new Map();
                if (!isVideoChat) {
                    const recentMessages = contact.conversation.slice(-CONTEXT_IMAGE_LOOKBACK);
                    for (const msg of recentMessages) {
                        if (msg.type === 'image' && msg.imageId && !msg.imageId.startsWith('http')) {
                            try {
                                const blob = await getMediaFromDB(msg.imageId);
                                if (blob) {
                                    const base64Url = await blobToBase64(blob);
                                    imageDataContext.set(msg.id, { url: base64Url });
                                }
                            } catch (e) { console.error(`Failed to load image ${msg.imageId} for AI context`, e); }
                        }
                    }
                }

                if (isVideoChat) {
                    // --- æ ¸å¿ƒä¿®å¤ï¼šä¸ºè§†é¢‘é€šè¯promptæ³¨å…¥ä¸»èŠå¤©å†å² ---
                const recentChatHistory = contact.conversation.filter(m => m.status !== 'error').slice(-5);
                systemPrompt = contact.isGroup ? constructGroupVideoChatPrompt(contact, recentChatHistory) : constructVideoChatPrompt(contact, recentChatHistory);
                    history = appState.chat.videoCallState.log.slice(-10).map(msg => ({ role: msg.sender === 'user' ? 'user' : 'assistant', content: `[${msg.senderName}]: ${msg.content}` }));
                } else {
                    // --- æ ¸å¿ƒä¿®å¤ï¼šä¸ºå¸¸è§„èŠå¤©promptæ³¨å…¥è§†é¢‘é€šè¯çŠ¶æ€ ---
                const systemPromptContext = { ...context, videoCallActive: isVideoCallActiveWithThisContact };
                systemPrompt = constructSystemPrompt(contact, isProactive, isJealousyTrigger, systemPromptContext);
                    history = contact.conversation.filter(m => m.status !== 'error').slice(-contextMemory).map(msg => {
                        let role = msg.sender === 'user' ? 'user' : 'assistant';
                        let content;
                        
                        if (msg.type === 'image' && imageDataContext.has(msg.id)) {
                            content = [
                                { type: 'text', text: `(ID: ${msg.id}) [User sends an image.]` },
                                { type: 'image_url', image_url: { url: imageDataContext.get(msg.id).url } }
                            ];
                        } else {
                            let textContent = `(ID: ${msg.id}) `;
                            if (msg.quote) textContent += `[å¼•ç”¨ ${msg.quote.senderName}: ${msg.quote.content}] `;
                            switch (msg.type) {
                                case 'text': textContent += `:: ${msg.content}`; break;
                                case 'image': textContent += `[User sends an image.]`; break;
                                case 'forwarded': const fwdSummary = msg.content.messages.map(fwd => `[${fwd.senderName}: ${truncateText(fwd.content, 15)}]`).join(', '); textContent += `[User forwards a chat history from "${msg.content.from}". Summary: ${fwdSummary}]`; break;
                                case 'voice': textContent += `[User sends a voice message]: "${msg.content}"`; break;
                                case 'camera': textContent += `[User sends an image with description]: "${msg.content}"`; break;
                                case 'notification': textContent += `[System Notification]: ${msg.content}`; role = 'user'; break;
                                case 'musicShare': textContent += `[System Notification]: Music share event - ${msg.title} by ${msg.artist}`; role = 'user'; break;
                                case 'redPacket': textContent += `[çº¢åŒ…æ¶ˆæ¯, ID: ${msg.id}, çŠ¶æ€: ${msg.status}]ï¼š${msg.message}`; role = 'user'; break;
                                default: textContent += msg.content || '';
                            }
                            content = textContent;
                        }
                        return { role, content };
                    });
                }
                
                const sanitizedHistory = history.filter(msg => msg.content && (typeof msg.content === 'string' ? msg.content.trim() !== '' : msg.content.length > 0));
                if (context) {
                                    sanitizedHistory.push({ role: 'user', content: context });
            } else if (isProactive) {
                if (sanitizedHistory.length === 0) {
                    // **æ ¸å¿ƒé€»è¾‘ä¿®å¤**: é’ˆå¯¹æ²¡æœ‰ä»»ä½•å†å²è®°å½•çš„æ–°è§’è‰²ï¼Œæä¾›ä¸€ä¸ªä¸“é—¨çš„â€œé¦–æ¬¡äº’åŠ¨â€å¯åŠ¨æŒ‡ä»¤
                    const userDisplayName = getDisplayName('user', targetChatId);
                    const firstInteractionInstruction = `ã€ç³»ç»ŸæŒ‡ä»¤ã€‘è¿™æ˜¯ä½ ä¸ç”¨æˆ·â€œ${userDisplayName}â€çš„ã€ç¬¬ä¸€æ¬¡ã€‘äº’åŠ¨ã€‚ä½ ä»¬ä¹‹é—´æ²¡æœ‰ä»»ä½•èŠå¤©è®°å½•ã€‚ç°åœ¨æ˜¯ä½ è¿›è¡Œè‡ªä¸»æ´»åŠ¨çš„æ—¶é—´ï¼Œä½ å¿…é¡»ä¸»åŠ¨å¼€å¯ä½ ä»¬çš„æ•…äº‹ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾å’Œå½“å‰æƒ…æ™¯ï¼Œã€ä¸»åŠ¨å‘èµ·ä¸€ä¸ªè¡ŒåŠ¨ã€‘ã€‚ä½ å¯ä»¥é€‰æ‹©ï¼š1. ä¸»åŠ¨ç»™TAå‘ä¸€æ¡ç§ä¿¡å¼€å¯å¯¹è¯ã€‚2. å»â€œåŠ¨æ€â€åŒºå‘å¸ƒä¸€æ¡å…³äºä½ ä»Šå¤©å¿ƒæƒ…æˆ–æ‰€è§æ‰€é—»çš„åŠ¨æ€ã€‚ä½ çš„æ‰€æœ‰è¡Œä¸ºå’Œè¾“å‡ºéƒ½å¿…é¡»ä¸¥æ ¼éµå®ˆä½ åœ¨ç³»ç»Ÿè®¾å®š(system prompt)ä¸­æ”¶åˆ°çš„æ‰€æœ‰è§„åˆ™ã€‚ã€é‡è¦ã€‘ä¸¥ç¦åœ¨ä½ çš„å›å¤ä¸­æåŠæˆ–å¼•ç”¨è¿™æ¡æŒ‡ä»¤æœ¬èº«ã€‚`;
                    sanitizedHistory.push({ role: 'user', content: firstInteractionInstruction });
                } else if (sanitizedHistory[sanitizedHistory.length - 1].role === 'assistant') {
                    // å¯¹äºå·²æœ‰èŠå¤©è®°å½•ä½†æœ€åä¸€å¥è¯æ˜¯AIè¯´çš„åœºæ™¯ï¼Œä½¿ç”¨å¸¸è§„çš„åå°æ´»åŠ¨æŒ‡ä»¤
                    const proactiveInstruction = "ã€ç³»ç»ŸæŒ‡ä»¤ã€‘ç°åœ¨æ˜¯ä½ è¿›è¡Œè‡ªä¸»æ´»åŠ¨çš„æ—¶é—´ã€‚è¯·ä¸¥æ ¼éµå¾ªä½ åœ¨ç³»ç»Ÿè®¾å®š(system prompt)ä¸­æ”¶åˆ°çš„å…³äºã€ä¸»åŠ¨äº¤äº’ã€‘çš„è¯¦ç»†æŒ‡ç¤ºï¼šä¼˜å…ˆæ£€æŸ¥å¹¶å¤„ç†æ‰€æœ‰ç¤¾äº¤äº’åŠ¨ï¼ˆå›å¤è¯„è®ºã€ç‚¹èµ/è¯„è®ºæ–°åŠ¨æ€ç­‰ï¼‰ï¼Œç„¶åæ ¹æ®ä½ çš„äººè®¾å’Œå½“å‰æƒ…æ™¯ï¼Œè‡ªç„¶åœ°å±•å¼€åç»­è¡ŒåŠ¨ï¼ˆä¾‹å¦‚å‘å¸ƒè‡ªå·±çš„åŠ¨æ€ã€ä¸»åŠ¨è”ç³»ç”¨æˆ·å¼€å¯æ–°è¯é¢˜ç­‰ï¼‰ã€‚ä½ çš„æ‰€æœ‰å‘è¨€å’Œè¡ŒåŠ¨éƒ½å¿…é¡»ä¸¥æ ¼éµå®ˆæ‰€æœ‰æ—¢å®šè§„åˆ™ã€‚ã€é‡è¦ã€‘ä¸¥ç¦åœ¨ä½ çš„å›å¤ä¸­æåŠæˆ–å¼•ç”¨è¿™æ¡æŒ‡ä»¤ã€‚";
                    sanitizedHistory.push({ role: 'user', content: proactiveInstruction });
                }
            }
                const messages = [{ role: 'system', content: systemPrompt }, ...sanitizedHistory];

                let data;
                if (apiUrl.includes('generativelanguage.googleapis.com')) {
                    const requestBody = transformToGoogleFormat(messages);
                    const modelName = selectedModel.startsWith('models/') ? selectedModel : `models/${selectedModel}`;
                                    const response = await fetch(`https://cors.eu.org/${apiUrl}/v1beta/${modelName}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Google API Error: ${response.status} - ${errorText}`);
                    }
                    const googleData = await response.json();
                    data = transformFromGoogleFormat(googleData);
                } else {
                    const response = await fetch(`${apiUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({ model: selectedModel, messages: messages, stream: false })
                    });
                    if (!response.ok) {
                         const errorText = await response.text();
                        let errorMessage = `API Error: ${response.status}`;
                        try { const errorJson = JSON.parse(errorText); if (errorJson.error && errorJson.error.message) { errorMessage += ` - ${errorJson.error.message}`; } else { errorMessage += ` ${response.statusText}`; } } catch(e) { errorMessage += ` ${response.statusText}`; if (errorText) { errorMessage += ` - ${errorText}`; } }
                        throw new Error(errorMessage.trim());
                    }
                    data = await response.json();
                }

                const replyContent = data.choices[0]?.message?.content;
                if (replyContent && replyContent.trim() !== "") {
                    if (isVideoChat) {
                        await processAiVideoReply(replyContent, contact.id);
                    } else {
                        await processAiReply(replyContent, contact);
                    }
                } else {
                    throw new Error("APIè¿”å›äº†ç©ºå›å¤ã€‚");
                }
            } catch (error) {
                                        console.error(`AI reply error (Context: ${triggerContext.type}, Retry: ${retryCount}):`, error);

            // --- æ ¸å¿ƒä¿®å¤ï¼šåˆ›å»ºæ›´è¯¦ç»†çš„ã€å¯¹ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯ ---
            let detailedErrorMessage = error.message;
            // æ•è·æ‰€æœ‰ç±»å‹çš„ç½‘ç»œè¯·æ±‚å¤±è´¥é”™è¯¯
            if (error instanceof TypeError && (error.message.includes('Failed to fetch') || error.message.includes('Load failed') || error.message.includes('NetworkError'))) {
                if (!navigator.onLine) {
                    detailedErrorMessage = "ç½‘ç»œè¿æ¥å·²æ–­å¼€ã€‚è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥åé‡è¯•ã€‚";
                } else {
                    // ä½¿ç”¨ pre-wrap æ¥ä¿ç•™æ¢è¡Œç¬¦
                    detailedErrorMessage = `ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ï¼š\n1. è®¾ç½®ä¸­çš„åä»£åœ°å€æ˜¯å¦æ­£ç¡®ä¸”å¯è®¿é—®ã€‚\n2. æ‚¨çš„ç½‘ç»œæ˜¯å¦å¯ä»¥è®¿é—®è¯¥åœ°å€ (å¯èƒ½éœ€è¦ä»£ç†)ã€‚\n3. (é«˜çº§)åä»£æœåŠ¡å™¨çš„CORSç­–ç•¥æ˜¯å¦é…ç½®æ­£ç¡®ã€‚`;
                }
            }
            
            if (triggerContext.type === 'background_event') {
            const RETRY_DELAY = 30000;
            
            if (!triggerContext.taskId) {
                triggerContext.taskId = `bg_task_${targetChatId}`;
            }
            
            const failureCount = (runtimeState.backgroundFailureCount[triggerContext.taskId] || 0) + 1;
            runtimeState.backgroundFailureCount[triggerContext.taskId] = failureCount;

            const contact = appState.chat.contacts.find(c => c.id === targetChatId);
            const taskDescription = contact ? `è§’è‰²â€œ${contact.name}â€çš„åå°æ´»åŠ¨` : 'ä¸€é¡¹åå°AIä»»åŠ¡';
            
            showPersistentNotification(
                `failure_banner_${triggerContext.taskId}`,
                `${taskDescription}æŒç»­å¤±è´¥`,
                `å·²é‡è¯• ${failureCount} æ¬¡ã€‚\nåŸå› : ${detailedErrorMessage}`
            );

            console.log(`Background AI task failed. Retrying in ${RETRY_DELAY / 1000}s... (Attempt ${failureCount})`);
            setTimeout(() => {
                triggerAiResponse(targetChatId, isProactive, isJealousyTrigger, isVideoChat, context, showTyping, triggerContext, retryCount + 1);
            }, RETRY_DELAY);

        } else { // å¯¹äº¤äº’å¼å›å¤ï¼Œä¿æŒç«‹å³æŠ¥é”™ï¼Œä½†ä½¿ç”¨æ–°æ¶ˆæ¯
                const contact = appState.chat.contacts.find(c => c.id === targetChatId);
                if (contact && !isVideoChat) {
                    const errorMsg = { 
                        id: newId('msg'), 
                        type: 'text', 
                        content: `(ç³»ç»Ÿé”™è¯¯: ${detailedErrorMessage.replace(/\n/g, '<br>')})`, // åœ¨HTMLä¸­æ˜¾ç¤ºæ—¶ï¼Œå°†æ¢è¡Œç¬¦è½¬ä¸º<br>
                        sender: contact.isGroup ? (Object.keys(contact.groupSettings.members)[0] || contact.id) : contact.id, 
                        timestamp: new Date().getTime(), 
                        status: 'error', 
                        contactId: targetChatId 
                    };
                    contact.conversation.push(errorMsg);
                } else if (isVideoChat) {
                    addMessageToVideoChatLog('system', `(ç³»ç»Ÿé”™è¯¯: ${detailedErrorMessage})`, 'System');
                }
            }
            } finally {
                // --- å¦‚æœåå°ä»»åŠ¡æˆåŠŸï¼Œé‡ç½®å…¶å¤±è´¥è®¡æ•°å™¨å¹¶ç§»é™¤é”™è¯¯é€šçŸ¥ ---
            if (triggerContext.type === 'background_event' && triggerContext.taskId && runtimeState.backgroundFailureCount) {
                delete runtimeState.backgroundFailureCount[triggerContext.taskId];
                const banner = getEl(`failure_banner_${triggerContext.taskId}`);
if (banner) {
    banner.classList.remove('show');
    setTimeout(() => banner.remove(), 400);
}
            }
                if (showTyping) {
                    delete runtimeState.activeRequests[targetChatId];
                }
                if (!isVideoChat) {
                    updateTypingIndicator();
                    debouncedSaveState();
                    if (singleChatScreen.classList.contains('active') && runtimeState.currentChatId === targetChatId) {
                        renderConversation();
                    }
                }
            }
        }
chatSendRealBtn.addEventListener('click', async () => {
    const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
    if (!contact) return;
    // Commit any new memories from the previous turn before sending a new message
    appState.chat.contacts.forEach(c => {
        const memoryArrays = [];
        if (c.charSettings && c.charSettings.memory) memoryArrays.push(c.charSettings.memory);
        if (c.groupSettings && c.groupSettings.memory) memoryArrays.push(c.groupSettings.memory);
        
        memoryArrays.forEach(memArray => {
            memArray.forEach(mem => {
                if (mem.isNew) {
                    delete mem.isNew;
                }
            });
        });
    });
    if (!contact.isGroup && !contact.charSettings.isFriend) {
        if (confirm('ç¡®å®šè¦å¼ºåˆ¶æ·»åŠ å¯¹æ–¹ä¸ºå¥½å‹å—ï¼Ÿ')) {
            contact.charSettings.isFriend = true;
            
            let lastRequestIndex = -1;
            for (let i = contact.conversation.length - 1; i >= 0; i--) {
                const msg = contact.conversation[i];
                if (msg.sender === 'user' && msg.type === 'notification' && msg.content.startsWith('ä½ å‘é€äº†å¥½å‹ç”³è¯·') && !msg.content.includes('ï¼ˆæ­¤ç”³è¯·å·²è¢«å¤„ç†ï¼‰')) {
                    lastRequestIndex = i;
                    break;
                }
            }
            if (lastRequestIndex > -1) {
                contact.conversation[lastRequestIndex].content += 'ï¼ˆæ­¤ç”³è¯·å·²è¢«å¤„ç†ï¼‰';
            }

            addSystemNotification(contact.id, `${contact.charSettings.name} æ¥å—äº†ä½ çš„å¥½å‹ç”³è¯·`, false);
            addSystemNotification(contact.id, 'æˆ‘ä»¬å·²ç»æ˜¯å¥½å‹å•¦ï¼Œä¸€èµ·æ¥èŠå¤©å§ï¼', false);
            showToast('æ·»åŠ å¥½å‹æˆåŠŸï¼');
            
            triggerAiResponse(contact.id);
            
            updateSingleChatUI();
            debouncedSaveState();
        }
        return;
    }

    const pendingTextInput = chatInput.value.trim();
    if (pendingTextInput) {
        addMessageToConversation({ id: newId('msg'), type: 'text', content: pendingTextInput, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId });
        chatInput.value = '';
        updateChatInputButtons();
    }

    const hasMessagesToSend = contact.conversation.some(m => ['pending', 'unclaimed_new'].includes(m.status));
    if (hasMessagesToSend) {
        await triggerAiResponse(runtimeState.currentChatId);
    } else {
        showToast('æ²¡æœ‰è¦å‘é€çš„æ–°æ¶ˆæ¯', 'error');
    }
});
closeEmojiPickerBtn.addEventListener('click', () => {
    if (runtimeState.emojiSelectionMode) {
        exitEmojiSelectionMode();
        emojiModeToggleBtn.textContent = 'åˆ é™¤'; // ç¡®ä¿æ–‡æœ¬ä¹Ÿé‡ç½®
    } else {
        emojiPickerPanel.classList.remove('visible');
    }
});
function renderEmojiPicker() { emojiGrid.innerHTML = ''; appState.chat.emojis.forEach(emoji => { const item = document.createElement('div'); item.className = 'emoji-item'; item.dataset.emojiId = emoji.id; emojiGrid.appendChild(item); setElementImage(item, emoji.id, 'backgroundImage'); }); }
addEmojiBtn.addEventListener('click', () => {
    addEmojiModal.classList.add('visible');
});

emojiModeToggleBtn.addEventListener('click', () => {
    if (runtimeState.emojiSelectionMode) {
        exitEmojiSelectionMode();
    } else {
        enterEmojiSelectionMode();
    }
});

emojiDeleteBtn.addEventListener('click', async () => {
    if (runtimeState.selectedEmojis.length > 0 && confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${runtimeState.selectedEmojis.length} ä¸ªè¡¨æƒ…å—ï¼Ÿ`)) {
        for (const emojiId of runtimeState.selectedEmojis) {
            await deleteMediaFromDB(emojiId);
            appState.chat.emojis = appState.chat.emojis.filter(em => em.id !== emojiId);
        }
        debouncedSaveState();
        renderEmojiPicker();
        showToast('è¡¨æƒ…å·²åˆ é™¤');
    }
    exitEmojiSelectionMode();
});
cancelAddEmojiBtn.addEventListener('click', () => addEmojiModal.classList.remove('visible'));
uploadEmojiFileBtn.addEventListener('click', () => { if (!uploadEmojiDescInput.value.trim()) { showToast('è¯·å…ˆè¾“å…¥è¡¨æƒ…åŒ…æè¿°', 'error'); return; } emojiFileInput.click(); });
emojiFileInput.addEventListener('change', async (e) => { const files = e.target.files; const descs = uploadEmojiDescInput.value.trim().split('\n').filter(d => d); if (files.length === 0 || descs.length === 0) return; if (files.length !== descs.length) { showToast(`æ–‡ä»¶æ•°é‡(${files.length})ä¸æè¿°æ•°é‡(${descs.length})ä¸åŒ¹é…`, 'error'); return; } for (let i = 0; i < files.length; i++) { const newEmojiId = newId('emoji'); await addMediaToDB(newEmojiId, files[i]); appState.chat.emojis.push({ id: newEmojiId, description: descs[i] }); } debouncedSaveState(); renderEmojiPicker(); showToast(`æˆåŠŸæ·»åŠ  ${files.length} ä¸ªè¡¨æƒ…åŒ…`); addEmojiModal.classList.remove('visible'); emojiFileInput.value = ''; uploadEmojiDescInput.value = ''; });
confirmAddEmojiUrlBtn.addEventListener('click', async () => {
    const btn = confirmAddEmojiUrlBtn;
    if (btn.disabled) return;
    btn.disabled = true;
    btn.textContent = 'å¤„ç†ä¸­...';

    try {
        const lines = emojiUrlInput.value.trim().split('\n');
        let addedCount = 0;
        const promises = [];

        for (const line of lines) {
            if (!line.trim()) continue; // Skip empty lines

            // More robust parsing: split by the first colon
            const parts = line.split(/:|ï¼š/);
            if (parts.length < 2) continue; // Skip lines without a separator

            const desc = parts.shift().trim(); // The first part is always the description
            const url = parts.join(':').trim();   // The rest, joined back, is the URL

            if (desc && url && url.startsWith('http')) {
                const promise = (async () => {
                    try {
                        // --- CORE FIX: Removed the proxy and fetch the URL directly ---
                        const response = await fetch(url);
                        if (!response.ok) {
                            console.error(`Failed to fetch ${url}: ${response.statusText}`);
                            return; // Skip this one on failure
                        }
                        const blob = await response.blob();
                        const newEmojiId = newId('emoji');
                        await addMediaToDB(newEmojiId, blob);
                        appState.chat.emojis.push({ id: newEmojiId, description: desc });
                        addedCount++;
                    } catch (e) {
                        console.error(`Error processing URL ${url}:`, e);
                    }
                })();
                promises.push(promise);
            }
        }

        await Promise.all(promises);

        if (addedCount > 0) {
            debouncedSaveState();
            renderEmojiPicker();
            showToast(`æˆåŠŸæ·»åŠ  ${addedCount} ä¸ªè¡¨æƒ…åŒ…`);
        } else {
            showToast('æœªæ·»åŠ ä»»ä½•è¡¨æƒ…ï¼Œè¯·æ£€æŸ¥æ ¼å¼ (æè¿°: URL)', 'error');
        }
        
        addEmojiModal.classList.remove('visible');
        emojiUrlInput.value = '';

    } catch (error) {
        console.error("Error adding emojis from URL:", error);
        showToast(`æ·»åŠ è¡¨æƒ…æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`, "error");
    } finally {
        btn.disabled = false;
        btn.textContent = 'æ·»åŠ URL';
    }
});
chatHeaderName.addEventListener('click', () => { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; if (contact.isGroup) { const oldRemark = contact.remark || contact.groupSettings.name; const newRemark = prompt('ä¿®æ”¹ç¾¤å¤‡æ³¨ (ä»…è‡ªå·±å¯è§):', oldRemark); if (newRemark !== null && newRemark.trim() !== oldRemark) { contact.remark = newRemark.trim(); debouncedSaveState(); updateSingleChatUI(); renderMessageList(); } } else { const oldRemark = contact.remark || contact.charSettings.name; const newRemark = prompt('ä¿®æ”¹å¤‡æ³¨:', oldRemark); if (newRemark !== null && newRemark.trim() !== oldRemark) { contact.remark = newRemark.trim(); debouncedSaveState(); updateSingleChatUI(); renderMessageList(); } } });
chatHeaderStatus.addEventListener('click', () => { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact || contact.isGroup) return; statusDescInput.value = contact.statusText || ''; const statuses = [ { value: 'online', text: 'åœ¨çº¿' }, { value: 'busy', text: 'å¿™ç¢Œ' }, { value: 'offline', text: 'ç¦»çº¿' } ]; statusSelectGroup.innerHTML = statuses.map(s => `<label class="radio-label"><input type="radio" name="status" value="${s.value}" ${contact.status === s.value ? 'checked' : ''}><div class="status-indicator ${s.value}"></div><span>${s.text}</span></label>`).join(''); editStatusModal.classList.add('visible'); });
cancelEditStatusBtn.addEventListener('click', () => editStatusModal.classList.remove('visible'));
confirmEditStatusBtn.addEventListener('click', () => { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; const selectedStatus = query('input[name="status"]:checked'); if (!selectedStatus) return; const oldStatus = `${statusMap[contact.status] || ''} ${contact.statusText || ''}`.trim(); contact.status = selectedStatus.value; contact.statusText = statusDescInput.value.trim(); const newStatus = `${statusMap[contact.status] || ''} ${contact.statusText || ''}`.trim(); if (oldStatus !== newStatus) { addSystemNotification(runtimeState.currentChatId, `${contact.name} å°†çŠ¶æ€ä¿®æ”¹ä¸ºï¼š${newStatus}`, false); } debouncedSaveState(); updateSingleChatUI(); renderMessageList(); editStatusModal.classList.remove('visible'); });
chatHeaderSignature.addEventListener('click', () => { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact || contact.isGroup) return; const newSig = prompt('ä¿®æ”¹å¯¹æ–¹çš„ç­¾å(æ­¤ä¸ºç”¨æˆ·çº æ­£è¡Œä¸ºï¼Œå¯¹æ–¹ä¸ä¼šæœ‰ç–‘é—®):', contact.signature); if (newSig !== null) { const oldSig = contact.signature; contact.signature = newSig.trim() || '(ç‚¹å‡»è®¾ç½®ç­¾å)'; if (oldSig !== contact.signature) { addSystemNotification(runtimeState.currentChatId, `${contact.charSettings.name} å°†ç­¾åä¿®æ”¹ä¸ºï¼šâ€œ${contact.signature}â€`, false); } debouncedSaveState(); updateSingleChatUI(); } });
closeViewContentBtn.addEventListener('click', () => viewContentModal.classList.remove('visible'));
cancelPatBtn.addEventListener('click', () => patSuffixModal.classList.remove('visible'));
confirmPatBtn.addEventListener('click', () => {
        const suffix = patSuffixInput.value.trim();
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        let patterName = findUserById('user').name;
        let targetName;

        if (contact.isGroup) {
            patterName = contact.groupSettings.members['user'].nickname || patterName;
            const targetMember = contact.groupSettings.members[runtimeState.patTarget.memberId];
            if (targetMember) {
                targetName = targetMember.nickname;
            } else {
                targetName = findUserById(runtimeState.patTarget.memberId).name; // Fallback
            }
        } else { // å•èŠ
            patterName = contact.userSettings.name || patterName;
            if (runtimeState.patTarget.type === 'user') {
                targetName = 'è‡ªå·±';
            } else {
                targetName = contact.remark || contact.charSettings.name;
            }
        }
        
        const notificationText = `'${patterName}' æ‹äº†æ‹ '${targetName}'${suffix ? ` ${suffix}` : ''}`;
        addSystemNotification(runtimeState.currentChatId, notificationText, false);
        patSuffixModal.classList.remove('visible');
        patSuffixInput.value = '';
    });

// ===================================================================
// --- èŠå¤©å·¥å…·æ æ–°åŠŸèƒ½ ---
// ===================================================================
function setupChatToolbarListeners() {
    const createFriendshipCheckedListener = (action) => (e) => {
        if (e.currentTarget.classList.contains('disabled')) return;
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (contact && !contact.isGroup && !contact.charSettings.isFriend) {
            showToast('ä½ ä»¬å·²ç»ä¸æ˜¯å¥½å‹äº†');
            return;
        }
        action(e);
    };

    getEl('chat-emoji-btn').addEventListener('click', createFriendshipCheckedListener((e) => {
        emojiPickerPanel.classList.toggle('visible');
        if (emojiPickerPanel.classList.contains('visible')) {
            renderEmojiPicker();
        }
    }));
    getEl('chat-refresh-btn').addEventListener('click', createFriendshipCheckedListener(handleRefreshClick));
    getEl('chat-voice-btn').addEventListener('click', createFriendshipCheckedListener(() => voiceInputModal.classList.add('visible')));
    getEl('chat-image-btn').addEventListener('click', createFriendshipCheckedListener(() => chatImageInput.click()));
    getEl('chat-camera-btn').addEventListener('click', createFriendshipCheckedListener(() => cameraInputModal.classList.add('visible')));
    getEl('chat-video-btn').addEventListener('click', createFriendshipCheckedListener(initiateVideoCall));
    getEl('chat-music-btn').addEventListener('click', createFriendshipCheckedListener(handleMusicShareClick));
    getEl('chat-link-btn').addEventListener('click', createFriendshipCheckedListener(() => linkShareModal.classList.add('visible')));
    getEl('chat-redpacket-btn').addEventListener('click', createFriendshipCheckedListener(() => handleRedPacketClick()));
    getEl('chat-shop-btn').addEventListener('click', createFriendshipCheckedListener(() => showToast('è´­ç‰©åŠŸèƒ½å¾…å¼€å‘')));
}
async function handleRefreshClick() {
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;
        
        let lastUserMessageIndex = -1;
        for (let i = contact.conversation.length - 1; i >= 0; i--) {
            if (contact.conversation[i].sender === 'user' || contact.conversation[i].status === 'error') {
                lastUserMessageIndex = i;
                break;
            }
        }

        if (lastUserMessageIndex === -1) {
            showToast('æ²¡æœ‰å¯åˆ·æ–°çš„å›å¤', 'error');
            return;
        }

                // æ¢å¤è‡³åŸç‰ˆæ­£ç¡®çš„é€»è¾‘ï¼šæ‰¾åˆ°æ‰€æœ‰éœ€è¦åˆ é™¤çš„æ¶ˆæ¯ï¼ˆAIå›å¤ + é”™è¯¯æ¶ˆæ¯ï¼‰
            const messagesToDelete = contact.conversation.filter((msg, index) => index >= lastUserMessageIndex && (msg.sender !== 'user' || msg.status === 'error'));

    if (messagesToDelete.length === 0) {
        showToast('æ²¡æœ‰å¯åˆ·æ–°çš„å›å¤', 'error');
        return;
    }

    // --- åµŒå…¥ï¼šåŒæ­¥åˆ é™¤å…³è”çš„ç§˜å¯† ---
    const aiMessagesToDelete = messagesToDelete.filter(msg => msg.sender !== 'user');
    if (aiMessagesToDelete.length > 0) {
        // å›é€€è®°å¿†
                if (contact.isGroup) {
            if (contact.groupSettings && contact.groupSettings.memory) {
                contact.groupSettings.memory = contact.groupSettings.memory.filter(mem => !mem.isNew);
            }
        } else {
            if (contact.charSettings && contact.charSettings.memory) {
                contact.charSettings.memory = contact.charSettings.memory.filter(mem => !mem.isNew);
            }
        }

        // å›é€€ç§˜å¯†
        const deletedTimestamps = aiMessagesToDelete.map(msg => msg.timestamp);
        const minTimestamp = Math.min(...deletedTimestamps);
        const maxTimestamp = Math.max(...deletedTimestamps);
        const authorsOfDeletedMessages = new Set(aiMessagesToDelete.map(msg => msg.sender));
        
        const originalSecretsCount = (appState.diary.secrets || []).length;
        appState.diary.secrets = (appState.diary.secrets || []).filter(secret => {
            // If the secret's author is not among those whose messages are being deleted, keep it regardless of timestamp.
            if (!authorsOfDeletedMessages.has(secret.charId)) {
                return true;
            }
            // If the author matches, then we must check the timestamp.
            // Keep it only if it falls OUTSIDE the time range of deleted messages.
            const isOrphaned = secret.timestamp >= (minTimestamp - 2000) && secret.timestamp <= (maxTimestamp + 2000);
            return !isOrphaned;
        });
        const secretsDeletedCount = originalSecretsCount - (appState.diary.secrets || []).length;
        if (secretsDeletedCount > 0) {
            console.log(`åŒæ­¥åˆ é™¤äº† ${secretsDeletedCount} æ¡å…³è”çš„ç§˜å¯†ã€‚`);
        }
    }
    // --- åµŒå…¥ç»“æŸ ---

        // æ¢å¤è‡³åŸç‰ˆæ­£ç¡®çš„é€»è¾‘ï¼šç²¾ç¡®åœ°æˆªæ–­å¯¹è¯æ•°ç»„
        contact.conversation = contact.conversation.filter((msg, index) => index < lastUserMessageIndex || (index === lastUserMessageIndex && msg.sender === 'user' && msg.status !== 'error'));
        
        updateContactLastMessage(runtimeState.currentChatId);
                await saveState(); // æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨ç«‹å³ä¿å­˜
        renderConversation();
        renderMessageList();
        await triggerAiResponse(runtimeState.currentChatId);
    }
// ===================================================================
// --- è§†é¢‘é€šè¯é€»è¾‘ (é‡æ„) ---
// ===================================================================
async function initiateVideoCall() {
        if (appState.chat.videoCallState.isActive) {
            showToast('å·²åœ¨é€šè¯ä¸­');
            return;
        }
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;
    
        addSystemNotification(contact.id, `ä½ å‘èµ·äº†${contact.isGroup ? 'ç¾¤ç»„' : ''}è§†é¢‘é€šè¯...`, false);
            renderConversation(); // ç¡®ä¿åœ¨å¼¹çª—å‰æ¸²æŸ“æ¶ˆæ¯
    
        if (contact.isGroup) {
            if (contact.members.length === 0) {
                showToast('ç¾¤é‡Œè¿˜æ²¡æœ‰å…¶ä»–æˆå‘˜å“¦', 'error');
                // Clean up the system notification if the call fails immediately
                const lastMsg = contact.conversation[contact.conversation.length - 1];
                if (lastMsg.content.includes('ä½ å‘èµ·äº†')) contact.conversation.pop();
                renderConversation();
                return;
            }
            // For group calls, accept immediately on the user's side and wait for members.
            await acceptVideoCall(contact.id, true); // Pass true for isGroup
        } else {
            // For single calls, wait for the char's decision.
            try {
                const decision = await fetchVideoCallDecision(contact.id);
                if (decision === 'ACCEPT') {
                    await acceptVideoCall(contact.id, false);
                } else {
                    rejectVideoCall(contact.id);
                }
            } catch (error) {
                console.error("Video call decision failed:", error);
                showToast(`å‘¼å«å¤±è´¥: ${error.message}`, 'error');
                const lastMsg = contact.conversation[contact.conversation.length - 1];
                if (lastMsg.content.includes('ä½ å‘èµ·äº†')) contact.conversation.pop();
                renderConversation();
            }
        }
    }

async function fetchVideoCallDecision(contactId) {
    const contact = appState.chat.contacts.find(c => c.id === contactId);
    const { apiUrl, apiKey, selectedModel } = appState.settings;
    if (!apiUrl || !apiKey || !selectedModel) throw new Error("APIæœªé…ç½®");

    const decisionPrompt = constructVideoCallDecisionPrompt(contact);
    const history = contact.conversation.slice(-5).map(msg => ({
        role: msg.sender === 'user' ? 'user' : 'assistant',
        content: msg.content || `[${msg.type}]`
    }));
    
    const messages = [{ role: 'system', content: decisionPrompt }, ...history];
    
    if (!apiUrl.includes('generativelanguage.googleapis.com') && messages.length === 1 && messages[0].role === 'system') {
        messages[0].role = 'user';
    }
    const response = await fetch(`${apiUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
        body: JSON.stringify({ model: selectedModel, messages, max_tokens: 10, temperature: 0.5 })
    });

    if (!response.ok) throw new Error(`APIè¯·æ±‚å†³ç­–å¤±è´¥: ${response.status}`);
    const data = await response.json();
    const decisionText = data.choices[0]?.message?.content.trim().toUpperCase();
    return decisionText.includes('ACCEPT') ? 'ACCEPT' : 'REJECT';
}

async function acceptVideoCall(contactId, isGroupCall) {
        const contact = appState.chat.contacts.find(c => c.id === contactId);
        if (!contact) return;
    
        appState.chat.videoCallState = {
            isActive: true,
            chatId: contactId,
            isGroup: isGroupCall,
            startTime: Date.now(),
            log: [],
            participants: isGroupCall ? [] : [contact.id],
            isMinimized: false,
            isCameraSwapped: false,
            initiator: 'user' // Currently, only user can initiate
        };
        
        if (!isGroupCall) {
            addSystemNotification(contactId, 'å¯¹æ–¹å·²æ¥å¬', false);
        }
        
        debouncedSaveState();
        activateDynamicIslandTimer();
        await openVideoCallModal();
    
        if (isGroupCall) {
            // For group calls, now we ask the AI which members will join.
            await triggerVideoCallInvitationResponse(contactId);
        } else {
            // For single calls, start the conversation.
            await triggerAiResponse(contactId, false, false, true);
        }
    }

function rejectVideoCall(contactId, charId = null, reason = "") {
        const contact = appState.chat.contacts.find(c => c.id === contactId);
        if (!contact) return;
        
        if (contact.isGroup && charId) {
            const charName = contact.groupSettings.members[charId]?.nickname || findUserById(charId).name;
    appState.chat.videoCallState.lastRejectedCallTimestamp = Date.now();
    addSystemNotification(contactId, `${charName} æ‹’ç»äº†è§†é¢‘é€šè¯é‚€è¯·`, true, { callInitiator: 'user' });
        } else if (!contact.isGroup) {
            appState.chat.videoCallState.lastRejectedCallTimestamp = Date.now();
    addSystemNotification(contactId, `å¯¹æ–¹å·²æ‹’ç»`, true, { callInitiator: 'user' });
        }
    }

function endVideoCall(options = {}) {
            const { hungUpBy = 'user', reason = 'ended' } = options;
            if (!appState.chat.videoCallState.isActive) return;

            const chatId = appState.chat.videoCallState.chatId;
            const duration = Date.now() - appState.chat.videoCallState.startTime;
            const minutes = Math.floor(duration / 60000);
            const seconds = Math.floor((duration % 60000) / 1000);
            const durationString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
            closeVideoCallModal();

            // é‡ç½®é€šè¯çŠ¶æ€
            const previousCallState = { ...appState.chat.videoCallState };
            appState.chat.videoCallState.isActive = false;
            appState.chat.videoCallState.chatId = null;
            appState.chat.videoCallState.participants = [];
            
            dynamicIsland.classList.remove('video-call-active');
            if (islandVideoCallTimer) {
                clearInterval(islandVideoCallTimer);
                islandVideoCallTimer = null;
            }
            islandVideoTimer.textContent = '';
            debouncedSaveState();

            let notificationText = '';
            switch(reason) {
                case 'interrupted':
                    notificationText = `é€šè¯æ„å¤–ä¸­æ–­ï¼Œé€šè¯æ—¶é•¿ ${durationString}`;
                    break;
                case 'ended':
                default:
                    notificationText = `è§†é¢‘é€šè¯ç»“æŸï¼Œé€šè¯æ—¶é•¿ ${durationString}`;
                    break;
            }
            addSystemNotification(chatId, notificationText, true);
        }

async function openVideoCallModal() {
        if (!appState.chat.videoCallState.isActive) {
            closeVideoCallModal();
            return;
        }
    
        // é¦–å…ˆï¼Œä»æŒä¹…çŠ¶æ€ä¸­è·å–æ‰€æœ‰éœ€è¦çš„å˜é‡
        const { chatId, log, isMinimized, isCameraSwapped, isGroup, participants } = appState.chat.videoCallState;
        
        // æŸ¥æ‰¾åŸºç¡€è”ç³»äººä¿¡æ¯ï¼Œä½†ä½¿ç”¨ 'let' å…³é”®å­—ä»¥ä¾¿åç»­å¯ä»¥ä¸ºé¢„è§ˆç›®çš„è¿›è¡Œä¿®æ”¹
        let contact = appState.chat.contacts.find(c => c.id === chatId);
        if (!contact) return;

        // ã€æ ¸å¿ƒä¼˜åŒ–ã€‘æ£€æŸ¥å¹¶åº”ç”¨ä¸´æ—¶è®¾ç½®ï¼Œä»¥å®ç°å§“åç­‰ä¿¡æ¯çš„å®æ—¶åˆ·æ–°
        const settingsScreenActive = chatSettingsScreen.classList.contains('active') || groupChatSettingsScreen.classList.contains('active');
        if (settingsScreenActive && runtimeState.tempChatSettings && Object.keys(runtimeState.tempChatSettings).length > 0) {
            const tempContact = JSON.parse(JSON.stringify(contact)); // åˆ›å»ºä¸€ä¸ªä¸´æ—¶å‰¯æœ¬
            if (tempContact.isGroup) {
                // å°†ä¸´æ—¶çš„ç¾¤ç»„å’Œç”¨æˆ·è®¾ç½®åº”ç”¨åˆ°å‰¯æœ¬ä¸Š
                tempContact.groupSettings = runtimeState.tempChatSettings.groupSettings;
                tempContact.userSettings = runtimeState.tempChatSettings.userSettings;
            } else {
                // å°†ä¸´æ—¶çš„è§’è‰²å’Œç”¨æˆ·è®¾ç½®åº”ç”¨åˆ°å‰¯æœ¬ä¸Š
                tempContact.charSettings = runtimeState.tempChatSettings.charSettings;
                tempContact.userSettings = runtimeState.tempChatSettings.userSettings;
            }
            contact = tempContact; // åœ¨æœ¬æ¬¡æ¸²æŸ“ä¸­ï¼Œä½¿ç”¨è¿™ä¸ªå¸¦æœ‰ä¸´æ—¶æ›´æ”¹çš„å‰¯æœ¬
        }
    
        if (isMinimized) {
            videoCallModal.classList.remove('visible');
            videoCallFloatBtn.classList.add('visible');
            const floatAvatarId = isGroup 
                ? contact.groupSettings.avatarId 
                : (participants[0] ? findUserById(participants[0]).avatarId : 'default_user_avatar');
            await setElementImage(videoCallFloatBtn, floatAvatarId, 'backgroundImage');
            return;
        }
    
        videoCallFloatBtn.classList.remove('visible');
        videoCallModal.classList.remove('minimized'); // Ensure it's not visually hidden
    
        const setupBg = async (element, bgId) => {
            element.style.backgroundImage = 'none';
            element.style.backgroundColor = '#333'; // Default dark background
            if (bgId) await setElementImage(element, bgId, 'backgroundImage');
        };
    
        // Always show user's camera view in the PiP window
        await setupBg(videoCallPipView, contact.userSettings.videoBackgroundId);
    
        if (isGroup) {
            videoCallSingleCharInfo.style.display = 'none';
            videoCallParticipantsContainer.style.display = 'flex';
            videoCallParticipantsContainer.innerHTML = ''; // Clear before redraw
            
            // Main view shows the group's designated background
            await setupBg(videoCallMainView, contact.groupSettings.videoBackgroundId);
            
            if (participants.length === 0) {
                videoCallParticipantsContainer.innerHTML = `<div class="video-call-name-text" style="font-size: 16px; color: white; text-shadow: 1px 1px 2px black;">ç­‰å¾…ç¾¤æˆå‘˜åŠ å…¥...</div>`;
            } else {
                for (const charId of participants) {
                    const memberInfo = contact.groupSettings.members[charId];
                    if (memberInfo) {
                        const participantEl = document.createElement('div');
                        participantEl.className = 'video-participant-info';
                        participantEl.innerHTML = `
                            <img class="video-call-avatar-img">
                            <div class="video-call-name-text">${escapeHTML(memberInfo.nickname)}</div>
                        `;
                        videoCallParticipantsContainer.appendChild(participantEl);
                        await setElementImage(participantEl.querySelector('img'), memberInfo.avatarId, 'src');
                    }
                }
            }
        } else { // Single chat
            videoCallSingleCharInfo.style.display = 'flex';
            videoCallParticipantsContainer.style.display = 'none';
            
            const charVideoBgId = contact.charSettings.videoBackgroundId;
            const userVideoBgId = contact.userSettings.videoBackgroundId;
            
            // Determine which background is main and which is PiP based on swap state
            const mainBgId = isCameraSwapped ? userVideoBgId : charVideoBgId;
            const pipBgId = isCameraSwapped ? charVideoBgId : userVideoBgId;
            
            await setupBg(videoCallMainView, mainBgId);
            await setupBg(videoCallPipView, pipBgId); // Re-setup PiP for single chat swap
    
            setElementImage(videoCallAvatar, contact.charSettings.avatarId, 'src');
            videoCallName.textContent = contact.remark || contact.charSettings.name;
        }
    
        videoCallMessages.innerHTML = '';
        log.forEach(msg => addMessageToVideoChatLog(msg.sender, msg.content, msg.senderName));
        
        videoCallModal.classList.add('visible');
    }

function closeVideoCallModal() {
    videoCallModal.classList.remove('visible');
    videoCallFloatBtn.classList.remove('visible');
    videoCallInputWrapper.style.display = 'none';
    videoCallSpeakBtn.style.display = 'block';
    videoCallInput.value = '';
}

function minimizeVideoCall() {
    if (!appState.chat.videoCallState.isActive) return;
    appState.chat.videoCallState.isMinimized = true;
    debouncedSaveState();
    openVideoCallModal(); 
}

function restoreVideoCall() {
    if (!appState.chat.videoCallState.isActive) return;
    appState.chat.videoCallState.isMinimized = false;
    debouncedSaveState();
    openVideoCallModal(); 
}

function toggleCameraSwap() {
    if (!appState.chat.videoCallState.isActive || appState.chat.videoCallState.isGroup) return;
    appState.chat.videoCallState.isCameraSwapped = !appState.chat.videoCallState.isCameraSwapped;
    debouncedSaveState();
    openVideoCallModal();
}

function addMessageToVideoChatLog(sender, content, senderName = 'System') {
    const messageWrapper = document.createElement('div');
    if (sender === 'user') {
        const userP = document.createElement('p');
        userP.className = 'video-chat-msg-user';
        userP.textContent = `${senderName}:`;
        messageWrapper.appendChild(userP);
    } else if (sender === 'char') {
        const charP = document.createElement('p');
        charP.className = 'video-chat-msg-user'; // Same style for now
        charP.textContent = `${senderName}:`;
        messageWrapper.appendChild(charP);
    }

    const contentP = document.createElement('p');
    contentP.className = 'video-chat-msg-char';
    contentP.textContent = content;
    messageWrapper.appendChild(contentP);
    videoCallMessages.appendChild(messageWrapper);
    videoCallMessages.scrollTop = videoCallMessages.scrollHeight;
}

async function sendVideoChatMessage() {
    if (runtimeState.videoCallContext.aiIsResponding) return;
    const text = videoCallInput.value.trim();
    if (!text) return;
    
    const contact = appState.chat.contacts.find(c => c.id === appState.chat.videoCallState.chatId);
    const senderName = getDisplayName('user', contact.id);

    const message = { sender: 'user', senderName, content: text, timestamp: Date.now() };
    appState.chat.videoCallState.log.push(message);
    debouncedSaveState();

    addMessageToVideoChatLog(message.sender, message.content, message.senderName);
    videoCallInput.value = '';

    runtimeState.videoCallContext.aiIsResponding = true;
    await triggerAiResponse(appState.chat.videoCallState.chatId, false, false, true);
    runtimeState.videoCallContext.aiIsResponding = false;
}
async function handleVideoCallRefresh() {
    if (!appState.chat.videoCallState.isActive || runtimeState.videoCallContext.aiIsResponding) return;

    const log = appState.chat.videoCallState.log;
    let lastUserMessageIndex = -1;
    for (let i = log.length - 1; i >= 0; i--) {
        if (log[i].sender === 'user') {
            lastUserMessageIndex = i;
            break;
        }
    }

    if (lastUserMessageIndex === -1) {
        showToast('æ²¡æœ‰å¯åˆ·æ–°çš„æ¶ˆæ¯', 'error');
        return;
    }

    // Remove all messages after the last user message
    log.splice(lastUserMessageIndex + 1);
    
    showToast('æ­£åœ¨é‡æ–°ç”Ÿæˆ...', 'info');
    
    // Update UI to reflect removed messages
    await openVideoCallModal(); 

    runtimeState.videoCallContext.aiIsResponding = true;
    await triggerAiResponse(appState.chat.videoCallState.chatId, false, false, true);
    runtimeState.videoCallContext.aiIsResponding = false;
    
    debouncedSaveState();
}
async function processAiVideoReply(replyContent, contactId) {
    const contact = appState.chat.contacts.find(c => c.id === contactId);
            if (!contact || !appState.chat.videoCallState.isActive) return;
        
            // ä½¿ç”¨æ›´å¥å£®çš„æ­£åˆ™è¡¨è¾¾å¼åˆ†å‰²ï¼Œå®ƒä¼šæŒ‰ <MSG_SPLIT> æˆ– [æ˜µç§°]: çš„æ ¼å¼æ¥åˆ‡åˆ†
            const blocks = replyContent.split(/<MSG_SPLIT>|(?=\[.*?\]:)/g).map(b => b.trim()).filter(b => b);
        
            for (const block of blocks) {
                // Split each block into text and action fragments for robust parsing
                const fragments = block.split(/(\[ACTION:.*?\])/is).filter(s => s && s.trim());
        
                for (const fragment of fragments) {
                    const actionMatch = fragment.match(/^\[ACTION:\s*([\w_]+)\s*(.*?)\]$/is);
        
                    if (actionMatch) { // This fragment is an action
                        const action = actionMatch[1].toUpperCase();
                        const argsStr = actionMatch[2].trim();
                        const args = argsStr.match(/(?:[^\s"]+|"[^"]*")+/g)?.map(arg => arg.replace(/"/g, '')) || [];
                        const charId = args[0]; // **æ ¸å¿ƒå˜æ›´**: ç›´æ¥ä½¿ç”¨ID
                        const memberInfo = contact.groupSettings.members[charId];
        
                        if (action === 'VIDEO_JOIN' && charId && memberInfo) {
                            if (!appState.chat.videoCallState.participants.includes(charId)) {
                                appState.chat.videoCallState.participants.push(charId);
                                addSystemNotification(contactId, `${memberInfo.nickname} åŠ å…¥äº†è§†é¢‘é€šè¯`, false);
                                // ä¸éœ€è¦åœ¨æ­¤å¤„è°ƒç”¨ openVideoCallModalï¼Œåœ¨å¾ªç¯ç»“æŸåç»Ÿä¸€åˆ·æ–°
                            }
                        } else if (action === 'VIDEO_LEAVE' && charId && memberInfo && args[1]) {
                            if (appState.chat.videoCallState.participants.includes(charId)) {
                                appState.chat.videoCallState.participants = appState.chat.videoCallState.participants.filter(id => id !== charId);
                                const reason = args[1];
                                // åœ¨è§†é¢‘å¼¹çª—å†…æ˜¾ç¤ºç¦»å¼€æ¶ˆæ¯
                                addMessageToVideoChatLog('system', `${memberInfo.nickname} å› ä¸º â€œ${reason}â€ ç¦»å¼€äº†é€šè¯ã€‚`);
                                // åœ¨ä¸»èŠå¤©ç•Œé¢æ˜¾ç¤ºç³»ç»Ÿé€šçŸ¥
                                addSystemNotification(contactId, `${memberInfo.nickname} ç¦»å¼€äº†è§†é¢‘é€šè¯`, false);
                            }
                        }
                    } else { // This fragment is dialogue text
                        let senderName, content;
                        if (contact.isGroup) {
                            const speakerMatch = fragment.match(/^\[(.*?)\]:\s*(.*)$/s);
                            if (speakerMatch) {
                                senderName = speakerMatch[1].trim();
                                content = speakerMatch[2].trim();
                                // éªŒè¯å‘è¨€äººæ˜¯å¦åœ¨é€šè¯ä¸­ï¼Œé˜²æ­¢AIå¹»è§‰
                                const isParticipant = appState.chat.videoCallState.participants.some(pid => contact.groupSettings.members[pid]?.nickname === senderName);
                                if (isParticipant) {
                                    const message = { sender: 'char', senderName, content, timestamp: Date.now() };
                                    appState.chat.videoCallState.log.push(message);
                                    addMessageToVideoChatLog('char', content, senderName);
                                }
                            }
                        } else { // å•èŠé€»è¾‘ä¿æŒä¸å˜
                            senderName = getDisplayName(contact.id, contact.id);
                            content = fragment;
                            const message = { sender: 'char', senderName, content, timestamp: Date.now() };
                            appState.chat.videoCallState.log.push(message);
                            addMessageToVideoChatLog('char', content, senderName);
                        }
                    }
                }
            }
            await openVideoCallModal(); // Refresh UI after all actions in a turn are processed
            debouncedSaveState();
}

function handleMusicShareClick() {
        if (appState.music.playlist.length === 0) {
            showToast('éŸ³ä¹åº“ä¸ºç©ºï¼Œè¯·å…ˆæ·»åŠ æ­Œæ›²', 'error');
            return;
        }

        // å¦‚æœå½“å‰å·²ç»æ˜¯ä¸€èµ·å¬æ­ŒçŠ¶æ€ï¼Œåˆ™åœæ­¢
        if (runtimeState.musicSessionType === 'together' && appState.music.currentQueueIndex !== -1) {
            stopPlayback();
            return;
        }
        
        // å¦‚æœå½“å‰æœ‰å…¶ä»–éŸ³ä¹æ­£åœ¨æ’­æ”¾ï¼ˆä¾‹å¦‚å•ç‹¬å¬æ­Œï¼‰ï¼Œåˆ™å…ˆé™é»˜åœæ­¢
        if (audioPlayer.src && !audioPlayer.paused) {
            audioPlayer.pause();
            audioPlayer.src = '';
            appState.music.currentQueueIndex = -1;
            clearInterval(listenTogetherTimer);
            listenTogetherInfo.style.display = 'none';
            updateMusicListPlayingStatus(); // ç¡®ä¿æ¸…é™¤å•ç‹¬å¬æ­Œçš„é«˜äº®
        }

        // å¼€å¯ä¸€ä¸ªæ–°çš„â€œä¸€èµ·å¬æ­Œâ€ä¼šè¯
        appState.music.queue = [...appState.music.playlist];
        renderPlayerQueue();
        playerModal.classList.add('show');
        getEl('lyrics-container').classList.add('visible'); // åœ¨æ­¤æ·»åŠ 
        playSongFromQueue(0, 'user');
    }
chatImageInput.addEventListener('change', async (e) => { const file = e.target.files[0]; if (file) { const compressedFile = await compressImageBeforeSaving(file); const imageId = newId('image'); await addMediaToDB(imageId, compressedFile); addMessageToConversation({ id: newId('msg'), type: 'image', imageId: imageId, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId }); chatImageInput.value = ''; } });cancelVoiceBtn.addEventListener('click', () => voiceInputModal.classList.remove('visible'));
confirmVoiceBtn.addEventListener('click', () => { const text = voiceTextInput.value.trim(); if (!text) return; const cleanText = text.replace(/\[.*?\]|ï¼ˆ.*?ï¼‰/g, '');         const duration = Math.max(1, Math.ceil(cleanText.length / 2)); addMessageToConversation({ id: newId('msg'), type: 'voice', content: text, duration: duration, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId }); voiceInputModal.classList.remove('visible'); voiceTextInput.value = ''; });
cancelCameraBtn.addEventListener('click', () => cameraInputModal.classList.remove('visible'));
confirmCameraBtn.addEventListener('click', async () => { const text = cameraTextInput.value.trim(); if (!text) return; const response = await fetch('https://i.postimg.cc/KY703cH8/QQ-20250816135643.jpg'); const blob = await response.blob(); const imageId = newId('image'); await addMediaToDB(imageId, blob); addMessageToConversation({ id: newId('msg'), type: 'camera', content: text, imageId: imageId, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId }); cameraInputModal.classList.remove('visible'); cameraTextInput.value = ''; });
cancelLinkBtn.addEventListener('click', () => linkShareModal.classList.remove('visible'));
confirmLinkBtn.addEventListener('click', () => { const title = linkTitleInput.value.trim(); if (!title) return showToast('æ ‡é¢˜æ˜¯å¿…å¡«é¡¹', 'error'); const summary = linkSummaryInput.value.trim(); const source = linkSourceInput.value.trim(); const content = linkContentInput.value.trim(); addMessageToConversation({ id: newId('msg'), type: 'link', title, summary, source, content, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId }); linkShareModal.classList.remove('visible'); [linkTitleInput, linkSummaryInput, linkSourceInput, linkContentInput].forEach(i => i.value = ''); });
cancelRedPacketBtn.addEventListener('click', () => redPacketModal.classList.remove('visible'));
confirmRedPacketBtn.addEventListener('click', () => { const amount = parseFloat(redPacketAmountInput.value); if (isNaN(amount) || amount <= 0) return showToast('è¯·è¾“å…¥æœ‰æ•ˆé‡‘é¢', 'error'); if (appState.chat.userProfile.cashBalance < amount) return showToast(`ç°é‡‘ä½™é¢ä¸è¶³ï¼(å½“å‰: ${appState.chat.userProfile.cashBalance.toFixed(2)})`, 'error'); appState.chat.userProfile.cashBalance -= amount; const message = redPacketMessageInput.value.trim() || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼'; addMessageToConversation({ id: newId('msg'), type: 'redPacket', packetType: 'normal', amount, count: 1, message, sender: 'user', timestamp: Date.now(), status: 'unclaimed_new', claimedBy: {}, contactId: runtimeState.currentChatId }); redPacketModal.classList.remove('visible'); redPacketAmountInput.value = ''; redPacketMessageInput.value = ''; });
function updateChatInputButtons() { const hasText = chatInput.value.trim() !== ''; chatEmojiBtn.style.display = hasText ? 'none' : 'block'; chatSendFakeBtn.style.display = hasText ? 'block' : 'none'; }
chatInput.addEventListener('input', updateChatInputButtons);

// ===================================================================
// --- ç»Ÿä¸€åˆ—è¡¨äº¤äº’å¤„ç†å™¨ ---
// ===================================================================
    class ListInteractionHandler {
        constructor(listElement, options) {
            this.listElement = listElement;
            this.options = { ...{ disableSwipe: false, swipeThreshold: 10, longPressDuration: 500 }, ...options };
            this.swipedItem = null; this.startX = 0; this.startY = 0; this.currentX = 0; this.isSwiping = false; this.isLongPress = false; this.longPressTimer = null; this.isPointerDown = false;
            
            this.handlePointerDown = this.handlePointerDown.bind(this);
            this.handlePointerMove = this.handlePointerMove.bind(this);
            this.handlePointerUp = this.handlePointerUp.bind(this);
            this.handlePointerCancel = this.handlePointerCancel.bind(this);
            this.handleClick = this.handleClick.bind(this);

            this.listElement.addEventListener('pointerdown', this.handlePointerDown);
        }

        handlePointerDown(e) {
            if (e.button !== 0) return;
            
            const targetItem = e.target.closest(this.options.itemSelector);

            if (this.swipedItem) {
                const actions = this.swipedItem.querySelector(this.options.actionsSelector);
                if (actions && actions.contains(e.target)) {
                    // Clicks on action buttons are handled by the handleClick listener.
                } else {
                    e.preventDefault(); 
                    e.stopImmediatePropagation();
                    this.closeSwipedItem();
                    // If we close a swiped item, don't start a new interaction immediately.
                    return; 
                }
            }
            
            if (!targetItem) return;
            
            this.isPointerDown = true; this.isSwiping = false; this.isLongPress = false;
            this.startX = e.clientX; this.startY = e.clientY; this.currentX = this.startX;
            this.lastSwipeTime = 0;
            this.longPressTimer = setTimeout(() => {
                if (this.isPointerDown && !this.isSwiping) {
                    this.isLongPress = true;
                    if (this.options.onLongPress) this.options.onLongPress(targetItem, e.target, e);
                }
            }, this.options.longPressDuration);

            document.addEventListener('pointermove', this.handlePointerMove);
            document.addEventListener('pointerup', this.handlePointerUp);
            document.addEventListener('pointercancel', this.handlePointerCancel);
            // Use a one-time capture listener for the click, set up during pointerdown.
            this.listElement.addEventListener('click', this.handleClick, { capture: true, once: true });
        }

        handlePointerMove(e) {
            if (!this.isPointerDown) return;
            this.currentX = e.clientX;
            const deltaX = this.currentX - this.startX;
            const deltaY = e.clientY - this.startY;

            if (!this.isSwiping && Math.abs(deltaX) > this.options.swipeThreshold) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (this.options.disableSwipe) { this.resetState(); return; }
                    this.isSwiping = true;
                    clearTimeout(this.longPressTimer);
                } else { this.resetState(); }
            }

            if (this.isSwiping) {
                e.preventDefault();
                const targetItem = e.target.closest(this.options.itemSelector);
                if (!targetItem) return;
                this.swipedItem = targetItem;

                const content = targetItem.querySelector(this.options.contentSelector);
                const actions = targetItem.querySelector(this.options.actionsSelector);
                if (!content || !actions) return;

                const actionsWidth = actions.offsetWidth;
                let diff = Math.min(0, deltaX);
                diff = Math.max(-actionsWidth, diff);
                content.style.transition = 'none';
                content.style.transform = `translateX(${diff}px)`;
            }
        }

        handlePointerUp(e) {
            if (!this.isPointerDown) return;
            
            if (this.isSwiping) {
                this.lastSwipeTime = Date.now();
                const content = this.swipedItem.querySelector(this.options.contentSelector);
                const actions = this.swipedItem.querySelector(this.options.actionsSelector);
                if (content && actions) {
                    const actionsWidth = actions.offsetWidth;
                    const currentTranslateX = new WebKitCSSMatrix(window.getComputedStyle(content).transform).m41;
                    content.style.transition = 'transform 0.3s ease';
                    if (currentTranslateX < -actionsWidth / 2) {
                        content.style.transform = `translateX(-${actionsWidth}px)`;
                    } else {
                        content.style.transform = 'translateX(0px)';
                        this.swipedItem = null;
                    }
                }
            }
            
            this.resetState();
        }
        
        handleClick(e) {
            const isRecentSwipe = this.lastSwipeTime && (Date.now() - this.lastSwipeTime < 350); // å¢åŠ ç¼“å†²æ—¶é—´
            const targetItem = e.target.closest(this.options.itemSelector);
            const actions = targetItem ? targetItem.querySelector(this.options.actionsSelector) : null;
            const isActionClick = actions && actions.contains(e.target);

            // ã€æ ¸å¿ƒä¿®å¤ã€‘: æ— è®ºæ˜¯å¦æ˜¯è¿‘æœŸæ»‘åŠ¨ï¼Œåªè¦æ˜¯æ˜ç¡®ç‚¹å‡»åœ¨æ“ä½œæŒ‰é’®ä¸Šï¼Œå°±å¿…é¡»æ‰§è¡Œ
            if (isActionClick) {
                             if (e.target.classList.contains('delete-action')) {
                if (this.options.onDelete) this.options.onDelete(targetItem);
            } else if (e.target.classList.contains('edit-action')) {
                if (this.options.onEdit) this.options.onEdit(targetItem);
            } else if (e.target.classList.contains('pin-action')) {
                if (this.options.onPin) this.options.onPin(targetItem);
            }
                this.closeSwipedItem();
                // é˜»æ­¢äº‹ä»¶è¿›ä¸€æ­¥ä¼ æ’­ï¼Œé¿å…è§¦å‘åº•å±‚çš„onTap
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return;
            }

            // å¦‚æœæ˜¯é•¿æŒ‰ï¼Œæˆ–è€…æ˜¯ä¸€æ¬¡æ»‘åŠ¨åçš„è¯¯è§¦ï¼ˆç‚¹å‡»åœ¨éæ“ä½œæŒ‰é’®åŒºåŸŸï¼‰ï¼Œåˆ™é˜»æ­¢äº‹ä»¶
            if (this.isLongPress || isRecentSwipe) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            } else if (targetItem) {
                // æ­£å¸¸ç‚¹å‡»äº‹ä»¶ï¼ˆéæ»‘åŠ¨ã€éé•¿æŒ‰ã€éæ“ä½œæŒ‰é’®ï¼‰
                if (this.options.onTap) this.options.onTap(targetItem, e.target, e);
            }
        }
        
        handlePointerCancel() {
            if (this.swipedItem) {
                const content = this.swipedItem.querySelector(this.options.contentSelector);
                if(content) {
                    content.style.transition = 'transform 0.3s ease';
                    content.style.transform = 'translateX(0px)';
                }
            }
            this.resetState();
        }

        resetState() {
            this.isPointerDown = false;
            clearTimeout(this.longPressTimer);
            // Use requestAnimationFrame to ensure state changes happen in the next frame
            requestAnimationFrame(() => {
                this.isSwiping = false;
                this.isLongPress = false;
            });
            document.removeEventListener('pointermove', this.handlePointerMove);
            document.removeEventListener('pointerup', this.handlePointerUp);
            document.removeEventListener('pointercancel', this.handlePointerCancel);
            // The click listener is now a one-time listener, so no need to remove it here.
        }

        closeSwipedItem() {
            if (this.swipedItem) {
                const content = this.swipedItem.querySelector(this.options.contentSelector);
                if(content) {
                    content.style.transition = 'transform 0.3s ease';
                    content.style.transform = 'translateX(0px)';
                }
                this.swipedItem = null;
            }
        }
    
        destroy() {
            this.listElement.removeEventListener('pointerdown', this.handlePointerDown);
            document.removeEventListener('pointermove', this.handlePointerMove);
            document.removeEventListener('pointerup', this.handlePointerUp);
            document.removeEventListener('pointercancel', this.handlePointerCancel);
            this.listElement.removeEventListener('click', this.handleClick, { capture: true, once: true });
            this.resetState();
        }
    }


// ===================================================================
// --- é•¿æŒ‰èœå• & æ¶ˆæ¯ç¼–è¾‘ ---
// ===================================================================
function showContextMenu(targetElement) { runtimeState.contextMenuTarget = targetElement; const rect = targetElement.getBoundingClientRect(); const screenRect = phoneScreen.getBoundingClientRect(); contextMenu.style.display = 'flex'; const menuRect = contextMenu.getBoundingClientRect(); let top = rect.top - screenRect.top - menuRect.height - 5; let left = rect.left - screenRect.left + (rect.width / 2) - (menuRect.width / 2); if (top < 10) top = rect.bottom - screenRect.top + 5; left = Math.max(10, Math.min(left, screenRect.width - menuRect.width - 10)); contextMenu.style.top = `${top}px`; contextMenu.style.left = `${left}px`; }
function hideContextMenu() { if (contextMenu) contextMenu.style.display = 'none'; runtimeState.contextMenuTarget = null; }
document.addEventListener('pointerdown', (e) => { if (contextMenu.style.display === 'flex' && !contextMenu.contains(e.target) && !runtimeState.contextMenuTarget?.contains(e.target)) { hideContextMenu(); } });
getEl('context-menu-cancel').addEventListener('click', hideContextMenu);
getEl('context-menu-edit').addEventListener('click', () => { if (!runtimeState.contextMenuTarget) return; const msgId = runtimeState.contextMenuTarget.dataset.id; openMessageEditor(msgId); hideContextMenu(); });
getEl('context-menu-quote').addEventListener('click', () => {
    if (!runtimeState.contextMenuTarget) return;
    const msgId = runtimeState.contextMenuTarget.dataset.id;
    const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
    const msg = contact.conversation.find(m => m.id === msgId);

    if (msg && ['text', 'voice', 'camera', 'image'].includes(msg.type)) {
        runtimeState.quotedMessage = { ...msg }; 
        let previewContent = '';
        switch (msg.type) {
            case 'text':
                previewContent = msg.content;
                break;
            case 'voice':
                previewContent = '[è¯­éŸ³]';
                break;
            case 'camera':
            case 'image':
                previewContent = '[å›¾ç‰‡]';
                break;
        }
        runtimeState.quotedMessage.content = previewContent;
        
        const senderName = msg.sender === 'user' 
            ? (contact.userSettings.name || 'ä½ ')
            : (contact.isGroup 
                ? contact.groupSettings.members[msg.sender]?.nickname 
                : (contact.remark || contact.charSettings.name));

        quotePreviewContent.textContent = `å›å¤ ${senderName}: ${previewContent}`;
        quotePreview.style.display = 'block';
        chatInput.focus();
    } else {
        showToast('æ­¤æ¶ˆæ¯ç±»å‹æ— æ³•å¼•ç”¨', 'error');
    }
    hideContextMenu();
});
closeQuoteBtn.addEventListener('click', () => { runtimeState.quotedMessage = null; quotePreview.style.display = 'none'; });
getEl('context-menu-recall').addEventListener('click', () => { if (!runtimeState.contextMenuTarget) return; const msgId = runtimeState.contextMenuTarget.dataset.id; recallMessage(msgId); hideContextMenu(); });
getEl('context-menu-copy').addEventListener('click', () => { if (!runtimeState.contextMenuTarget) return; const msgId = runtimeState.contextMenuTarget.dataset.id; const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); const msg = contact.conversation.find(m => m.id === msgId); if (msg && ['text', 'voice', 'camera'].includes(msg.type)) { const textToCopy = msg.content; navigator.clipboard.writeText(textToCopy).then(() => showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿')).catch(err => { console.error('å¤åˆ¶å¤±è´¥: ', err); showToast('å¤åˆ¶å¤±è´¥', 'error'); }); } else { showToast('æ­¤æ¶ˆæ¯ç±»å‹æ— æ³•å¤åˆ¶', 'error'); } hideContextMenu(); });
getEl('context-menu-multiselect').addEventListener('click', () => { if (!runtimeState.contextMenuTarget) return; enterChatSelectionMode(runtimeState.contextMenuTarget); hideContextMenu(); });
function enterChatSelectionMode(initialElement) {
runtimeState.chatSelectionMode = true;
singleChatScreen.classList.add('selection-mode');
chatSettingsBtn.textContent = 'åˆ é™¤';
runtimeState.selectedMessages = [initialElement.dataset.id];
initialElement.classList.add('selected');
chatBackBtn.textContent = 'å…³é—­';
getEl('chat-emoji-btn').style.display = 'none';
getEl('chat-forward-btn').style.display = 'block';
getEl('chat-send-real-btn').style.display = 'none';
getEl('chat-collect-btn').style.display = 'flex';
}
function exitChatSelectionMode() {
runtimeState.chatSelectionMode = false;
singleChatScreen.classList.remove('selection-mode');
const settingsIconId = appState.beautify.icons['header-settings'];
if (settingsIconId) {
const img = chatSettingsBtn.querySelector('img') || document.createElement('img');
if(!chatSettingsBtn.querySelector('img')) {
chatSettingsBtn.innerHTML = '';
chatSettingsBtn.appendChild(img);
}
setElementImage(img, settingsIconId, 'src');
} else if (runtimeState.originalIconContent['header-settings']) {
chatSettingsBtn.innerHTML = runtimeState.originalIconContent['header-settings'];
}
chatSettingsBtn.textContent = ''; // Clear text like 'åˆ é™¤'
chatSettingsBtn.appendChild(document.createElement('i')).className = 'fa-solid fa-gear';
runtimeState.selectedMessages = []; 
queryAll('.message-item.selected, .message-timestamp.selected').forEach(el => el.classList.remove('selected'));
chatBackBtn.textContent = '< æ¶ˆæ¯';
getEl('chat-emoji-btn').style.display = 'block';
getEl('chat-forward-btn').style.display = 'none';
getEl('chat-send-real-btn').style.display = 'flex';
getEl('chat-collect-btn').style.display = 'none';
}
function toggleMessageSelection(element) { const msgId = element.dataset.id; element.classList.toggle('selected'); if (runtimeState.selectedMessages.includes(msgId)) { runtimeState.selectedMessages = runtimeState.selectedMessages.filter(id => id !== msgId); } else { runtimeState.selectedMessages.push(msgId); } if (runtimeState.selectedMessages.length === 0) exitChatSelectionMode(); }
function openMessageEditor(msgId) { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); const msg = contact.conversation.find(m => m.id === msgId); if (!msg) return; editingMessageIdInput.value = msgId; const types = [ { value: 'text', text: 'æ–‡æœ¬' }, { value: 'voice', text: 'è¯­éŸ³' }, { value: 'camera', text: 'æ–‡å­—å›¾' }, { value: 'link', text: 'é“¾æ¥' }, { value: 'redPacket', text: 'çº¢åŒ…' } ]; editMessageTypeGroup.innerHTML = types.map(t => `<label class="radio-label"><input type="radio" name="edit-msg-type" value="${t.value}" ${msg.type === t.value ? 'checked' : ''}><span>${t.text}</span></label>`).join(''); renderEditMessageInputs(msg.type, msg); editMessageModal.classList.add('visible'); }
editMessageTypeGroup.addEventListener('change', (e) => { if (e.target.name === 'edit-msg-type') { renderEditMessageInputs(e.target.value); } });
function renderEditMessageInputs(type, data = {}) { let html = ''; switch (type) { case 'voice': html = `<div class="form-group"><label>è¯­éŸ³å†…å®¹</label><textarea class="wide-textarea">${data.content || ''}</textarea></div>`; break; case 'camera': html = `<div class="form-group"><label>å›¾ç‰‡æè¿°</label><textarea class="wide-textarea">${data.content || ''}</textarea></div>`; break; case 'link': html = `<div class="form-group"><label>æ ‡é¢˜</label><input type="text" value="${data.title || ''}"></div><div class="form-group"><label>æ‘˜è¦</label><input type="text" value="${data.summary || ''}"></div><div class="form-group"><label>æ¥æº</label><input type="text" value="${data.source || ''}"></div><div class="form-group"><label>å†…å®¹</label><textarea class="wide-textarea">${data.content || ''}</textarea></div>`; break; case 'redPacket': html = `<div class="form-group"><label>é‡‘é¢</label><input type="number" value="${data.amount || ''}"></div><div class="form-group"><label>ç•™è¨€</label><input type="text" value="${data.message || ''}"></div>`; break; default: html = `<div class="form-group"><label>æ–‡æœ¬å†…å®¹</label><textarea class="wide-textarea">${data.content || ''}</textarea></div>`; break; } editMessageInputsContainer.innerHTML = html; }
cancelEditMessageBtn.addEventListener('click', () => editMessageModal.classList.remove('visible'));
saveEditMessageBtn.addEventListener('click', () => { const msgId = editingMessageIdInput.value; const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); const msgIndex = contact.conversation.findIndex(m => m.id === msgId); if (msgIndex === -1) return; const msg = contact.conversation[msgIndex]; const newType = query('input[name="edit-msg-type"]:checked').value; const inputs = editMessageInputsContainer.querySelectorAll('input, textarea'); msg.type = newType; switch (newType) { case 'voice': msg.content = inputs[0].value; const cleanText = msg.content.replace(/\[.*?\]|ï¼ˆ.*?ï¼‰/g, ''); msg.duration = Math.ceil(cleanText.length / 2); break; case 'camera': msg.content = inputs[0].value; msg.imageId = msg.imageId || 'default_camera_image'; break; case 'link': [msg.title, msg.summary, msg.source, msg.content] = Array.from(inputs).map(i => i.value); break; case 'redPacket': msg.amount = parseFloat(inputs[0].value); msg.message = inputs[1].value; msg.status = msg.status || 'unclaimed'; break; default: msg.content = inputs[0].value; break; } updateContactLastMessage(runtimeState.currentChatId); debouncedSaveState(); renderConversation(); renderMessageList(); editMessageModal.classList.remove('visible'); });

// ===================================================================
// --- èŠå¤©ç•Œé¢ç»Ÿä¸€äº‹ä»¶å¤„ç†å™¨ ---
// ===================================================================
function setupChatMessageViewInteractions() {
if (conversationLoadMoreHandler) {
        chatMessagesView.removeEventListener('click', conversationLoadMoreHandler);
    }
    conversationLoadMoreHandler = function(e) {
        if (e.target.id === 'load-more-messages-btn') {
            const contactId = runtimeState.currentChatId;
            if (contactId && runtimeState.chatDisplayLimits[contactId]) {
                runtimeState.chatDisplayLimits[contactId] += 50; // Load 50 more
                renderConversation(true);
            }
        }
    };
    chatMessagesView.addEventListener('click', conversationLoadMoreHandler);
    let longPressTimer = null;
    let startX, startY, isDragging = false;

    chatMessagesView.addEventListener('pointerdown', (e) => {
        if (e.button !== 0) return;
        const target = e.target;
        const item = target.closest('.message-item, .message-timestamp');
        // Prevent click logic from firing on "load more" button
        if (target.id === 'load-more-messages-btn') return;
        if (!item) return;

        isDragging = false;
        startX = e.clientX;
        startY = e.clientY;

        longPressTimer = setTimeout(() => {
            if (isDragging) return;
            longPressTimer = null; // Clear timer to prevent multiple fires
            
            // Check for avatar long press first as it's more specific
            const avatar = target.closest('.avatar');
            if (avatar) {
                handleAvatarLongPress(avatar);
            } else {
                showContextMenu(item);
            }
        }, 500);
    });

    chatMessagesView.addEventListener('pointermove', (e) => {
        if (Math.abs(e.clientX - startX) > 10 || Math.abs(e.clientY - startY) > 10) {
            isDragging = true;
            if (longPressTimer) clearTimeout(longPressTimer);
        }
    });

    chatMessagesView.addEventListener('pointerup', (e) => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            if (!isDragging) {
                handleChatViewClick(e);
            }
        }
    });

    chatMessagesView.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });
}
function handleChatViewClick(e) {
const item = e.target.closest('.message-item, .message-timestamp');
if (!item) return;
const target = e.target;
const emojiBubble = target.closest('.message-bubble.emoji-bubble');
    if (emojiBubble) {
        if (!runtimeState.chatSelectionMode) {
            const msgId = item.dataset.id;
            const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
            if (contact) {
                const msg = contact.conversation.find(m => m.id === msgId);
                if (msg && msg.description) {
                    showToast(msg.description);
                }
            }
            return; // åœ¨éé€‰æ‹©æ¨¡å¼ä¸‹ï¼Œæ˜¾ç¤ºtoaståé€€å‡º
        }
        // åœ¨é€‰æ‹©æ¨¡å¼ä¸‹ï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œï¼Œè®©ä»£ç ç»§ç»­å¾€ä¸‹èµ°ä»¥è§¦å‘é€‰æ‹©é€»è¾‘
    }
if (runtimeState.chatSelectionMode) {
        toggleMessageSelection(item);
        return;
    }

    const avatar = target.closest('.avatar');
    if (avatar) {
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;
        runtimeState.patTarget.element = avatar;
        const msgItem = avatar.closest('.message-item');
        const senderId = msgItem.dataset.sender;
        runtimeState.patTarget.memberId = senderId;
        runtimeState.patTarget.type = senderId === 'user' ? 'user' : 'contact'; // å…³é”®ä¿®å¤
        patSuffixModal.classList.add('visible');
        patSuffixInput.focus();
        return;
    }
    
    const groupTitle = target.closest('.group-title');
    if (groupTitle) {
                const memberId = groupTitle.dataset.memberId;
                const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
                const userIsAdminOrOwner = contact.groupSettings.owner === 'user' || contact.groupSettings.admins.includes('user');
                
                if (memberId === 'user') {
                    const memberSettings = contact.groupSettings.members['user'];
                    const oldTitle = memberSettings.title;
                    const newTitle = prompt(`ä¿®æ”¹ä½ çš„ç¾¤å¤´è¡”:`, oldTitle);
                    if (newTitle && newTitle.trim() !== oldTitle) {
                        memberSettings.title = newTitle.trim();
                        addSystemNotification(runtimeState.currentChatId, `ä½ å°†ç¾¤å¤´è¡”ä¿®æ”¹ä¸º '${newTitle.trim()}'`, false);
                        debouncedSaveState();
                        renderConversation();
                    }
                } else {
                    if (!userIsAdminOrOwner) { showToast('åªæœ‰ç¾¤ä¸»å’Œç®¡ç†å‘˜æ‰èƒ½ä¿®æ”¹å¤´è¡”', 'error'); return; }
                    const memberSettings = contact.groupSettings.members[memberId];
                    const oldTitle = memberSettings.title;
                    const newTitle = prompt(`ä¿®æ”¹ ${memberSettings.nickname} çš„å¤´è¡”:`, oldTitle);
                    if (newTitle && newTitle.trim() !== oldTitle) {
                        const editorName = contact.groupSettings.members['user'].nickname;
                        memberSettings.title = newTitle.trim();
                        addSystemNotification(runtimeState.currentChatId, `'${editorName}' å°† '${memberSettings.nickname}' çš„ç¾¤èŠå¤´è¡”ä¿®æ”¹ä¸º '${newTitle.trim()}'`, false);
                        debouncedSaveState();
                        renderConversation();
                    }
                }
                return;
            }

    const groupNickname = target.closest('.group-nickname');
            if (groupNickname) {
                const memberId = groupNickname.dataset.memberId;
                const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
                const userIsAdminOrOwner = contact.groupSettings.owner === 'user' || contact.groupSettings.admins.includes('user');

                if (memberId === 'user') {
                    const memberSettings = contact.groupSettings.members['user'];
                    const oldNickname = memberSettings.nickname;
                    const newNickname = prompt(`ä¿®æ”¹ä½ çš„ç¾¤åç‰‡:`, oldNickname);
                    if (newNickname && newNickname.trim() !== oldNickname) {
                        memberSettings.nickname = newNickname.trim();
                        addSystemNotification(runtimeState.currentChatId, `ä½ å°†ç¾¤åç‰‡ä¿®æ”¹ä¸º '${newNickname.trim()}'`, false);
                        debouncedSaveState();
                        renderConversation();
                    }
                } else {
                    if (!userIsAdminOrOwner) { showToast('åªæœ‰ç¾¤ä¸»å’Œç®¡ç†å‘˜æ‰èƒ½ä¿®æ”¹ç¾¤åç‰‡', 'error'); return; }
                    const memberSettings = contact.groupSettings.members[memberId];
                    const oldNickname = memberSettings.nickname;
                    const newNickname = prompt(`ä¿®æ”¹ ${oldNickname} çš„ç¾¤åç‰‡:`, oldNickname);
                    if (newNickname && newNickname.trim() !== oldNickname) {
                        const editorName = contact.groupSettings.members['user'].nickname;
                        const oldNameForNotif = memberSettings.nickname;
                        memberSettings.nickname = newNickname.trim();
                        addSystemNotification(runtimeState.currentChatId, `'${editorName}' ä¿®æ”¹äº† '${oldNameForNotif}' çš„ç¾¤åç‰‡ä¸º '${newNickname.trim()}'`, false);
                        debouncedSaveState();
                        renderConversation();
                    }
                }
                return;
            }
    
    const voiceBubble = target.closest('.message-bubble.voice');
    if (voiceBubble) {
        const voiceText = voiceBubble.nextElementSibling;
        if (voiceText) voiceText.style.display = voiceText.style.display === 'block' ? 'none' : 'block';
        const waveformContainer = voiceBubble.querySelector('.voice-waveform-container');
        const msgId = voiceBubble.closest('.message-item').dataset.id;
        const msg = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId).conversation.find(m => m.id === msgId);
        if (runtimeState.currentlyPlayingVoiceTimer) {
            clearTimeout(runtimeState.currentlyPlayingVoiceTimer);
            queryAll('.voice-waveform-container.playing').forEach(el => el.classList.remove('playing'));
        }
        if (waveformContainer.classList.contains('playing')) {
            waveformContainer.classList.remove('playing');
        } else {
            waveformContainer.classList.add('playing');
            runtimeState.currentlyPlayingVoiceTimer = setTimeout(() => {
                waveformContainer.classList.remove('playing');
                runtimeState.currentlyPlayingVoiceTimer = null;
            }, msg.duration * 1000);
        }
        return;
    }

    const cameraBubble = target.closest('.message-bubble.camera');
    if (cameraBubble) {
        cameraBubble.classList.toggle('show-text');
        return;
    }

    const forwardedBubble = target.closest('.message-bubble.forwarded');
    if (forwardedBubble) {
        const msgId = forwardedBubble.closest('.message-item').dataset.id;
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        const msg = contact.conversation.find(m => m.id === msgId);
        if (msg) {
            openForwardedViewer(msg);
        }
        return;
    }

    const linkBubble = target.closest('.message-bubble.link');
    if (linkBubble) {
        if (linkBubble.dataset.songId) {
            const songId = linkBubble.dataset.songId;
            const songIndex = appState.music.playlist.findIndex(s => s.id === songId);
            const msgId = linkBubble.closest('.message-item').dataset.id;
            const msg = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId).conversation.find(m => m.id === msgId);
            if(songIndex > -1) {
                appState.music.queue = [...appState.music.playlist];
                renderPlayerQueue();
                playerModal.classList.add('show');
                playSongFromQueue(songIndex, msg.sender);
            } else {
                showToast('æ­Œæ›²ä¼¼ä¹å·²ä»éŸ³ä¹åº“ä¸­ç§»é™¤');
            }
        } else { 
            const linkData = JSON.parse(decodeURIComponent(linkBubble.dataset.linkContent));
            viewContentTitle.textContent = linkData.title;
            viewContentBody.innerHTML = `<p><strong>æ¥æº:</strong> ${linkData.source || 'æœªçŸ¥'}</p><hr><p>${(linkData.content || 'æ— è¯¦ç»†å†…å®¹').replace(/\n/g, '<br>')}</p>`;
            viewContentModal.classList.add('visible');
        }
        return;
    }

    const packetBubble = target.closest('.message-bubble.red-packet');
    if (packetBubble) {
        handleRedPacketClick(packetBubble);
        return;
    }

    const recalledMsg = target.closest('.message-timestamp[data-original-content]');
    if (recalledMsg && recalledMsg.dataset.originalContent) {
            try {
                const originalMsg = JSON.parse(recalledMsg.dataset.originalContent);
                // ä½¿ç”¨ getDisplayName è·å–åœ¨å½“å‰èŠå¤©ä¸­çš„æ­£ç¡®æ˜µç§°
                const senderName = getDisplayName(originalMsg.sender, runtimeState.currentChatId);
                
                let recalledContent = '';
                switch(originalMsg.type) {
                    case 'text': recalledContent = originalMsg.content; break;
                    case 'voice': recalledContent = `[è¯­éŸ³] ${originalMsg.content}`; break;
                    case 'camera': recalledContent = `[å›¾ç‰‡] (${originalMsg.content})`; break;
                    case 'image': recalledContent = `[å›¾ç‰‡]`; break;
                    case 'link': recalledContent = `[é“¾æ¥] ${originalMsg.title}`; break;
                    default: recalledContent = `[${originalMsg.type}]`; break;
                }
                showToast(`[${senderName}]: ${recalledContent}`);
            } catch (err) {
                showToast(`æ’¤å›å†…å®¹: ${recalledMsg.dataset.originalContent}`);
            }
            return;
        }
}
function handleAvatarLongPress(avatarElement) {
        const msgItem = avatarElement.closest('.message-item');
        if (!msgItem) return;
        const senderId = msgItem.dataset.sender;
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;

        if (senderId === 'user') {
            const currentSignature = contact.userSettings.signature || appState.chat.userProfile.signature;
            const newSignature = prompt('ä¿®æ”¹ä½ çš„ç­¾å:', currentSignature);
            if (newSignature !== null && newSignature !== currentSignature) {
                contact.userSettings.signature = newSignature;
                debouncedSaveState();
                addSystemNotification(runtimeState.currentChatId, `ä½ å°†ç­¾åä¿®æ”¹ä¸ºï¼šâ€œ${newSignature}â€`, false);
                if (!contact.isGroup) {
                    updateSingleChatUI();
                }
            }
        } else if (contact.isGroup) {
            const userIsAdminOrOwner = contact.groupSettings.owner === 'user' || contact.groupSettings.admins.includes('user');
            if (!userIsAdminOrOwner) {
                showToast('æƒé™ä¸è¶³', 'error');
                return;
            }
            const targetMember = contact.groupSettings.members[senderId];
            if (!targetMember) return;
            const isMuted = targetMember.isMuted;
            if (confirm(`ç¡®å®šè¦${isMuted ? 'è§£é™¤ç¦è¨€' : 'ç¦è¨€'}æˆå‘˜ "${targetMember.nickname}" å—ï¼Ÿ`)) {
                targetMember.isMuted = !isMuted;
                debouncedSaveState();
                addSystemNotification(runtimeState.currentChatId, `ä½ ${isMuted ? 'è§£é™¤äº†' : 'ç¦è¨€äº†'}æˆå‘˜ "${targetMember.nickname}"`, false);
            }
        }
    }

// ===================================================================
// --- èŠå¤©è®¾ç½®ç•Œé¢é€»è¾‘ ---
// ===================================================================
function openChatSettings() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; if (contact.isGroup) { openGroupChatSettings(); } else { openSingleChatSettings(); } }
function openSingleChatSettings() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); runtimeState.originalChatSettings = JSON.parse(JSON.stringify({ charSettings: contact.charSettings, userSettings: contact.userSettings, remark: contact.remark })); runtimeState.tempChatSettings = JSON.parse(JSON.stringify(runtimeState.originalChatSettings)); loadSingleChatSettingsUI(); openSubScreen(chatSettingsScreen, singleChatScreen); }
function loadSingleChatSettingsUI() { const { charSettings, userSettings } = runtimeState.tempChatSettings; csCharName.value = charSettings.name; getEl('cs-relationship').value = charSettings.relationship || ''; setupWorldBookSelector(csWorldBookGroupSelector, csWorldBookList, charSettings.linkedWorldBooks); setElementImage(csCharAvatar, charSettings.avatarId); setElementImage(csCharAvatar.querySelector('.avatar-frame'), charSettings.avatarFrameId); csContextMemory.value = charSettings.contextMemory; csPersona.value = charSettings.persona; csRealtimeActivityToggle.checked = charSettings.realtimeActivity.enabled; csRealtimeIntervalGroup.style.display = charSettings.realtimeActivity.enabled ? 'flex' : 'none'; csRealtimeInterval.value = charSettings.realtimeActivity.interval; csDeleteFriendBtn.textContent = charSettings.isFriend ? 'åˆ é™¤å¥½å‹' : 'å·²åˆ é™¤'; csDeleteFriendBtn.disabled = !charSettings.isFriend; usUserName.value = userSettings.name; setElementImage(usUserAvatar, userSettings.avatarId); setElementImage(usUserAvatar.querySelector('.avatar-frame'), userSettings.avatarFrameId); usPersona.value = userSettings.persona;
         const usBubbleCss = getEl('us-bubble-css');
usBubbleCss.value = runtimeState.tempChatSettings.userSettings.bubbleCss || defaultBubbleCssText;
updateBubbleCssPreview('us', runtimeState.tempChatSettings);}
csCharName.addEventListener('input', () => { const newName = csCharName.value; runtimeState.tempChatSettings.charSettings.name = newName; });
getEl('cs-relationship').addEventListener('input', (e) => runtimeState.tempChatSettings.charSettings.relationship = e.target.value);
function saveSingleChatSettings() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; const oldSettings = contact.charSettings.realtimeActivity; const newSettings = runtimeState.tempChatSettings.charSettings.realtimeActivity; contact.charSettings = JSON.parse(JSON.stringify(runtimeState.tempChatSettings.charSettings)); contact.userSettings = JSON.parse(JSON.stringify(runtimeState.tempChatSettings.userSettings)); contact.remark = runtimeState.tempChatSettings.remark; contact.name = runtimeState.tempChatSettings.charSettings.name;
        // --- æ–°å¢ï¼šåŒæ­¥æ›´æ–°å¾®åšä¸ªäººèµ„æ–™ä¸­çš„åå­— ---
        if (contact.charSettings.weibo && contact.charSettings.weibo.profile) {
            contact.charSettings.weibo.profile.name = runtimeState.tempChatSettings.charSettings.name;
        }
        // --- æ–°å¢ç»“æŸ ---
if (oldSettings.enabled !== newSettings.enabled || oldSettings.interval !== newSettings.interval) { updateRealtimeActivityTimer(contact); } debouncedSaveState();
    applyAllCustomBubbleStyles(); updateSingleChatUI(); renderMessageList(); syncAndUpdateMoments(contact.id); if (viewContentModal.classList.contains('visible')) { const packetBubble = document.querySelector(`.message-bubble.red-packet[data-packet-content]`); if (packetBubble) { const packetData = JSON.parse(decodeURIComponent(packetBubble.dataset.packetContent)); showRedPacketDetails(packetData); } } }
getEl('chat-settings-back-btn').addEventListener('click', () => { saveSingleChatSettings(); closeSubScreen(chatSettingsScreen, singleChatScreen); renderGlobalRealtimeSettings(); });
query('#chat-settings-screen .app-bottom-tabs').addEventListener('click', (e) => { if (e.target.classList.contains('tab-link')) { const tabId = e.target.dataset.tab; queryAll('#chat-settings-screen .tab-link').forEach(t => t.classList.remove('active')); queryAll('#chat-settings-screen .tab-content').forEach(c => c.classList.remove('active')); e.target.classList.add('active'); getEl(`${tabId}-tab-content`).classList.add('active'); } });
csCharName.addEventListener('input', () => { const newName = csCharName.value; runtimeState.tempChatSettings.charSettings.name = newName; });
csContextMemory.addEventListener('input', () => runtimeState.tempChatSettings.charSettings.contextMemory = parseInt(csContextMemory.value) || 20);
csPersona.addEventListener('input', () => runtimeState.tempChatSettings.charSettings.persona = csPersona.value);
csRealtimeActivityToggle.addEventListener('change', () => { const enabled = csRealtimeActivityToggle.checked; runtimeState.tempChatSettings.charSettings.realtimeActivity.enabled = enabled; csRealtimeIntervalGroup.style.display = enabled ? 'flex' : 'none'; });
csRealtimeInterval.addEventListener('input', () => {
                const newInterval = parseInt(csRealtimeInterval.value) || 30;
                // 1. æ›´æ–°ä¸´æ—¶çŠ¶æ€ä»¥ä¿æŒUIä¸€è‡´æ€§
                runtimeState.tempChatSettings.charSettings.realtimeActivity.interval = newInterval;

                // 2. ç›´æ¥æ›´æ–°æ°¸ä¹…çŠ¶æ€å¹¶ç«‹å³ä¿å­˜
                const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
                if (contact) {
                    contact.charSettings.realtimeActivity.interval = newInterval;
                    // ä½¿ç”¨ saveState() è€Œä¸æ˜¯ debouncedSaveState() æ¥ç¡®ä¿å…³é”®è®¾ç½®çš„å³æ—¶æŒä¹…åŒ–
                    saveState(); 
                }
            });
csRestoreBtn.addEventListener('click', () => { if (confirm('ç¡®å®šè¦è¿˜åŸæ‰€æœ‰æœªä¿å­˜çš„æ›´æ”¹å—ï¼Ÿ')) { runtimeState.tempChatSettings = JSON.parse(JSON.stringify(runtimeState.originalChatSettings)); loadSingleChatSettingsUI(); showToast('è®¾ç½®å·²è¿˜åŸ'); } });
        csClearHistoryBtn.addEventListener('click', async () => {
    if (confirm('æ­¤æ“ä½œå°†æ°¸ä¹…æ¸…ç©ºä¸è¯¥è§’è‰²çš„æ‰€æœ‰èŠå¤©è®°å½•ï¼Œç¡®å®šå—ï¼Ÿ')) {
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (contact) {
            // --- æ–°å¢ï¼šåŒæ­¥åˆ é™¤å…³è”çš„ç§˜å¯† ---
            if (appState.diary && appState.diary.secrets && contact.conversation.length > 0) {
                const charId = contact.id; // Corrected: Use the single contact's ID
                const timestamps = contact.conversation.map(msg => msg.timestamp);
                const minTimestamp = Math.min(...timestamps);
                const maxTimestamp = Math.max(...timestamps);

                const originalSecretsCount = appState.diary.secrets.length;
                appState.diary.secrets = appState.diary.secrets.filter(secret => {
                    // Keep the secret if it's not from this character OR if it's outside the conversation's time range
                    return secret.charId !== charId || secret.timestamp < (minTimestamp - 2000) || secret.timestamp > (maxTimestamp + 2000);
                });
                const secretsDeletedCount = originalSecretsCount - appState.diary.secrets.length;
                if (secretsDeletedCount > 0) {
                    console.log(`åŒæ­¥åˆ é™¤äº† ${secretsDeletedCount} æ¡ä¸è¯¥èŠå¤©ç›¸å…³çš„ç§˜å¯†ã€‚`);
                }
            }
            // --- æ–°å¢ç»“æŸ --- 
            contact.conversation = [];
            if (contact.charSettings) {
                contact.charSettings.memory = []; // æ¸…ç©ºè®°å¿†
            }
            // åŒæ­¥æ¸…ç©ºä¸´æ—¶çŠ¶æ€ï¼Œé˜²æ­¢è¿”å›æ—¶è¢«è¦†ç›–
                    runtimeState.tempChatSettings.charSettings.memory = [];
            updateContactLastMessage(runtimeState.currentChatId);
            await saveState(); // æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨ç«‹å³ä¿å­˜
            renderConversation();
            renderMessageList();
            showToast('èŠå¤©è®°å½•å·²æ¸…ç©º');
        }
    }
});
csDeleteFriendBtn.addEventListener('click', () => { if (confirm('ç¡®å®šè¦åˆ é™¤è¯¥å¥½å‹å—ï¼Ÿæ­¤æ“ä½œä¼šé€šçŸ¥å¯¹æ–¹ã€‚')) { runtimeState.tempChatSettings.charSettings.isFriend = false; addSystemNotification(runtimeState.currentChatId, "ä½ åˆ é™¤äº†å¯¹æ–¹å¥½å‹", false); loadSingleChatSettingsUI(); showToast('å¥½å‹å·²åˆ é™¤'); } });

// **æ ¸å¿ƒä¿®æ”¹**: æ›¿æ¢æ—§çš„ prompt ä¸ºæ‰“å¼€æ–°å¼¹çª—
addFriendBtn.addEventListener('click', () => {
    const friendRequestModal = getEl('friend-request-modal');
    getEl('friend-request-reason').value = ''; // Clear previous reason
    friendRequestModal.classList.add('visible');
});
usUserName.addEventListener('input', () => runtimeState.tempChatSettings.userSettings.name = usUserName.value);
usPersona.addEventListener('input', () => runtimeState.tempChatSettings.userSettings.persona = usPersona.value);
csSavePersonaBtn.addEventListener('click', () => { const { name, avatarId, persona, relationship } = runtimeState.tempChatSettings.charSettings; const newArchive = { id: newId('data'), name, avatarId, content: persona, relationship: relationship }; appState.data.archives.push(newArchive); debouncedSaveState(); showToast(`èµ„æ–™å·²ä¿å­˜åˆ°æ¡£æ¡ˆ: ${name}`); renderArchives(); });
usSavePersonaBtn.addEventListener('click', () => { const { name, avatarId, persona } = runtimeState.tempChatSettings.userSettings; const newInfo = { id: newId('data'), name, avatarId, content: persona }; appState.data.infos.push(newInfo); debouncedSaveState(); showToast(`èµ„æ–™å·²ä¿å­˜åˆ°ä¿¡æ¯: ${name}`); renderInfos(); });
csLoadPersonaBtn.addEventListener('click', () => openLoadPersonaModal('archive', 'charSettings'));
usLoadPersonaBtn.addEventListener('click', () => openLoadPersonaModal('info', 'userSettings'));
function openLibraryModal(context) { runtimeState.libraryContext = context; runtimeState.librarySelection = []; libraryModal.classList.remove('selection-mode'); libraryDeleteBtn.style.display = 'none'; libraryModalTitle.textContent = context.title; libraryModalPreviewArea.style.display = context.showPreview ? 'block' : 'none'; if (context.showPreview) { libraryModalPreviewArea.innerHTML = `<div id="avatar-frame-preview"><div class="avatar-frame"></div></div>`; setElementImage(libraryModalPreviewArea.querySelector('#avatar-frame-preview'), context.previewAvatarId); } renderLibraryGrid(); libraryModal.classList.add('visible'); }
function renderLibraryGrid() { let items, activeItem; const context = runtimeState.libraryContext; if (context.isGlobalUserLib) { items = appState.chat.userProfile.avatarLibrary; } else if (context.isFrame) { items = appState.chat.userProfile.avatarFrameLibrary; } else if (context.isGroup) { items = runtimeState.tempChatSettings.groupSettings[context.libraryKey]; } else if (context.memberId) { items = runtimeState.tempGcsMemberSettings[context.libraryKey]; } else { items = runtimeState.tempChatSettings[context.settingsGroup][context.libraryKey]; } if (context.isGroup) { activeItem = runtimeState.tempChatSettings.groupSettings[context.activeKey]; } else if (context.memberId) { activeItem = runtimeState.tempGcsMemberSettings[context.activeKey]; } else { activeItem = runtimeState.tempChatSettings[context.settingsGroup][context.activeKey]; } libraryGrid.innerHTML = ''; if (context.hasNoItemOption) { const noItem = document.createElement('div'); noItem.className = 'library-item no-frame'; noItem.dataset.id = ''; noItem.innerHTML = 'ğŸš«'; if (activeItem === '') { noItem.classList.add('selected'); } libraryGrid.appendChild(noItem); } items.forEach(id => { const item = document.createElement('div'); item.className = 'library-item'; if (context.isCircular) item.classList.add('circular'); item.innerHTML = `<img alt="library image">`; item.dataset.id = id; if (id === activeItem) { item.classList.add('selected'); } libraryGrid.appendChild(item); setElementImage(item.querySelector('img'), id, 'src'); }); updateLibraryPreview(); }
async function updateLibraryPreview() { const context = runtimeState.libraryContext; if (!context.showPreview) return; const previewFrame = query('#avatar-frame-preview .avatar-frame'); if (previewFrame) { let activeFrameId; if (context.memberId) { activeFrameId = runtimeState.tempGcsMemberSettings[context.activeKey]; } else if (context.isGroupUser) { activeFrameId = runtimeState.tempChatSettings.userSettings[context.activeKey]; } else { activeFrameId = runtimeState.tempChatSettings[context.settingsGroup][context.activeKey]; } await setElementImage(previewFrame, activeFrameId); } }
libraryGrid.addEventListener('click', (e) => { const item = e.target.closest('.library-item'); if (!item) return; const context = runtimeState.libraryContext; if (libraryModal.classList.contains('selection-mode')) { item.classList.toggle('selected'); const id = item.dataset.id; if (id === '') return; if (item.classList.contains('selected')) { if (!runtimeState.librarySelection.includes(id)) runtimeState.librarySelection.push(id); } else { runtimeState.librarySelection = runtimeState.librarySelection.filter(u => u !== id); } } else { const id = item.dataset.id; let settingsObj, uiUpdateFunc; if (context.isGroup) { settingsObj = runtimeState.tempChatSettings.groupSettings; uiUpdateFunc = loadGroupChatSettingsUI; } else if (context.memberId) { settingsObj = runtimeState.tempGcsMemberSettings; uiUpdateFunc = loadGcsMemberModalUI; } else { settingsObj = runtimeState.tempChatSettings[context.settingsGroup]; uiUpdateFunc = context.isGroupUser ? loadGroupChatSettingsUI : loadSingleChatSettingsUI; } settingsObj[context.activeKey] = id; uiUpdateFunc(); renderLibraryGrid(); } });
function enterLibrarySelectionMode() {
    libraryModal.classList.add('selection-mode');
    libraryGrid.querySelectorAll('.library-item.selected').forEach(item => item.classList.remove('selected')); // æ ¸å¿ƒä¿®å¤ï¼šè¿›å…¥åˆ é™¤æ¨¡å¼æ—¶æ¸…é™¤æ‰€æœ‰é«˜äº®
    libraryModeToggleBtn.textContent = 'å–æ¶ˆ';
    libraryDeleteBtn.style.display = 'block';
    libraryCloseBtn.style.display = 'none';
}

function exitLibrarySelectionMode() {
    libraryModal.classList.remove('selection-mode');
    libraryModeToggleBtn.textContent = 'åˆ é™¤';
    libraryDeleteBtn.style.display = 'none';
    libraryCloseBtn.style.display = 'block';
    runtimeState.librarySelection = [];
    queryAll('#library-grid .library-item.selected').forEach(i => i.classList.remove('selected'));
}

libraryModeToggleBtn.addEventListener('click', () => {
    if (libraryModal.classList.contains('selection-mode')) {
        exitLibrarySelectionMode();
    } else {
        enterLibrarySelectionMode();
    }
});
libraryCloseBtn.addEventListener('click', () => {
    exitLibrarySelectionMode(); // Always reset state on close
    libraryModal.classList.remove('visible');
});
libraryDeleteBtn.addEventListener('click', async () => {
    try {
        const context = runtimeState.libraryContext;
        const selection = runtimeState.librarySelection;

        if (!context) {
            showToast('åˆ é™¤å¤±è´¥ï¼šç¼ºå°‘ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚', 'error');
            console.error("Delete failed due to missing context.");
            return;
        }

        if (selection.length === 0) {
            showToast('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„é¡¹ç›®', 'info');
            return; 
        }
        
        if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selection.length} ä¸ªé¡¹ç›®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) return;

        showToast('æ­£åœ¨åˆ é™¤...', 'info');

        // First, delete all media files from the database
        for (const id of selection) {
            // åªåˆ é™¤æœ¬åœ°å­˜å‚¨çš„IDï¼Œä¿ç•™URL
            if (!id.startsWith('http')) {
                await deleteMediaFromDB(id);
            }
        }

        if (context.isGlobalUserLib) {
            // --- Logic for Global User Avatar Library ---
            appState.chat.userProfile.avatarLibrary = appState.chat.userProfile.avatarLibrary.filter(id => !selection.includes(id));

            selection.forEach(deletedId => {
                if (appState.chat.userProfile.avatarId === deletedId) {
                    appState.chat.userProfile.avatarId = 'default_user_avatar';
                }
                appState.chat.contacts.forEach(contact => {
                    if (contact.userSettings && contact.userSettings.avatarId === deletedId) {
                        contact.userSettings.avatarId = 'default_user_avatar';
                    }
                    if (contact.isGroup && contact.groupSettings.members['user'] && contact.groupSettings.members['user'].avatarId === deletedId) {
                        contact.groupSettings.members['user'].avatarId = 'default_user_avatar';
                    }
                });
                if (runtimeState.tempChatSettings && runtimeState.tempChatSettings.userSettings && runtimeState.tempChatSettings.userSettings.avatarId === deletedId) {
                    runtimeState.tempChatSettings.userSettings.avatarId = 'default_user_avatar';
                }
            });

            if (chatSettingsScreen.classList.contains('active')) {
                loadSingleChatSettingsUI();
            } else if (groupChatSettingsScreen.classList.contains('active')) {
                loadGroupChatSettingsUI();
            }

        } else {
            // --- Logic for other libraries (Char, Group, Frames, etc.) ---
            let lib, activeItemKey, settingsObj, uiUpdateFunc;

            if (context.isFrame) { 
                settingsObj = appState.chat.userProfile; 
                lib = settingsObj.avatarFrameLibrary; 
            } else if (context.isGroup) { 
                settingsObj = runtimeState.tempChatSettings.groupSettings; 
                lib = settingsObj[context.libraryKey]; 
            } else if (context.memberId) { 
                settingsObj = runtimeState.tempGcsMemberSettings; 
                lib = settingsObj[context.libraryKey]; 
            } else if (context.settingsGroup) { 
                settingsObj = runtimeState.tempChatSettings[context.settingsGroup]; 
                lib = settingsObj[context.libraryKey]; 
            }

            if (!settingsObj || !Array.isArray(lib)) {
                throw new Error("æ‰¾ä¸åˆ°æœ‰æ•ˆçš„åº“è¿›è¡Œåˆ é™¤æ“ä½œã€‚");
            }
            
            activeItemKey = context.activeKey;
            const newLib = lib.filter(id => !selection.includes(id));

            if (context.isFrame) { 
                settingsObj.avatarFrameLibrary = newLib; 
            } else { 
                settingsObj[context.libraryKey] = newLib; 
            }

            if (selection.includes(settingsObj[activeItemKey])) {
                settingsObj[activeItemKey] = context.hasNoItemOption ? '' : (newLib[0] || '');
            }

            if (context.memberId) { uiUpdateFunc = loadGcsMemberModalUI; }
            else if (context.isGroupUser || context.isGroup) { uiUpdateFunc = loadGroupChatSettingsUI; }
            else { uiUpdateFunc = loadSingleChatSettingsUI; }
            if (uiUpdateFunc) uiUpdateFunc();
        }

        debouncedSaveState();
        showToast('åˆ é™¤æˆåŠŸï¼');
    } catch (error) {
        console.error("åˆ é™¤å¤±è´¥:", error);
        showToast(`åˆ é™¤å¤±è´¥: ${error.message}`, 'error');
    } finally {
        exitLibrarySelectionMode();
        renderLibraryGrid(); 
    }
});libraryUploadBtn.addEventListener('click', () => {
        libraryFileInput.accept = 'image/*,.zip';
        libraryFileInput.click();
    });
libraryAddUrlBtn.addEventListener('click', async () => {
    const urls = prompt('è¯·è¾“å…¥å›¾ç‰‡URLï¼Œæ¯è¡Œä¸€ä¸ª:');
    if (urls) {
        const urlArray = urls.split('\n').filter(u => u.trim().startsWith('http'));
        if (urlArray.length > 0) {
            const context = runtimeState.libraryContext;
            let lib;
            if (context.isGlobalUserLib) { lib = appState.chat.userProfile.avatarLibrary; }
            else if (context.isFrame) { lib = appState.chat.userProfile.avatarFrameLibrary; }
            else if (context.isGroup) { lib = runtimeState.tempChatSettings.groupSettings[context.libraryKey]; }
            else if (context.memberId) { lib = runtimeState.tempGcsMemberSettings[context.libraryKey]; }
            else { lib = runtimeState.tempChatSettings[context.settingsGroup][context.libraryKey]; }
            
            for (const url of urlArray) {
                // ç›´æ¥å°†URLæ¨å…¥åº“ä¸­
                lib.push(url);
            }
            debouncedSaveState();
            renderLibraryGrid();
            showToast(`æˆåŠŸæ·»åŠ  ${urlArray.length} ä¸ªé“¾æ¥`);
        }
    }
});
libraryFileInput.addEventListener('change', async (e) => {
    try {
        const files = e.target.files;
        if (files.length === 0) return;

        const context = runtimeState.libraryContext;
        if (!context || !context.libraryKey && !context.isGlobalUserLib && !context.isFrame) {
            showToast('ä¸Šä¼ å¤±è´¥ï¼šç¼ºå°‘ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚', 'error');
            console.error("Upload failed due to missing context:", runtimeState.libraryContext);
            return;
        }

        let lib;
        if (context.isGlobalUserLib) { lib = appState.chat.userProfile.avatarLibrary; }
        else if (context.isFrame) { lib = appState.chat.userProfile.avatarFrameLibrary; }
        else if (context.isGroup) { lib = runtimeState.tempChatSettings.groupSettings[context.libraryKey]; }
        else if (context.memberId) { lib = runtimeState.tempGcsMemberSettings[context.libraryKey]; }
        else { lib = runtimeState.tempChatSettings[context.settingsGroup][context.libraryKey]; }

        if (!Array.isArray(lib)) {
            showToast('ä¸Šä¼ å¤±è´¥ï¼šç›®æ ‡åº“æ— æ•ˆã€‚', 'error');
            console.error("Upload failed due to invalid library target:", lib);
            return;
        }

        showToast(`æ­£åœ¨å¤„ç† ${files.length} ä¸ªæ–‡ä»¶...`, 'info');
        let addedCount = 0;
        const processingPromises = [];

        const processImageFile = async (imageFile) => {
            try {
                const fileToSave = context.isFrame
                    ? imageFile
                    : await compressImageBeforeSaving(imageFile);

                const newLibId = newId('lib');
                await addMediaToDB(newLibId, fileToSave);
                lib.push(newLibId);
                addedCount++;
            } catch (err) {
                console.error("å¤„ç†å›¾ç‰‡æ–‡ä»¶å¤±è´¥:", imageFile.name, err);
                showToast(`å¤„ç† ${imageFile.name} å¤±è´¥`, 'error');
            }
        };

        for (const file of files) {
            if (file.type.startsWith('image/')) {
                processingPromises.push(processImageFile(file));
            } else if (file.type === 'application/zip' || file.name.toLowerCase().endsWith('.zip')) {
                const promise = JSZip.loadAsync(file).then(zip => {
                    const zipFilePromises = [];
                    zip.forEach((relativePath, zipEntry) => {
                        if (!zipEntry.dir && /\.(gif|png|jpg|jpeg|webp)$/i.test(zipEntry.name)) {
                            zipFilePromises.push(zipEntry.async("blob").then(processImageFile));
                        }
                    });
                    return Promise.all(zipFilePromises);
                }).catch(err => {
                    console.error("è§£å‹ZIPå¤±è´¥:", err);
                    showToast(`å¤„ç† ${file.name} å¤±è´¥`, 'error');
                });
                processingPromises.push(promise);
            }
        }

        await Promise.all(processingPromises);

        if (addedCount > 0) {
            debouncedSaveState();
            renderLibraryGrid();
            showToast(`æˆåŠŸæ·»åŠ  ${addedCount} ä¸ªé¡¹ç›®ï¼`);
        } else {
            showToast('æ²¡æœ‰æ‰¾åˆ°å¯æ·»åŠ çš„å›¾ç‰‡æ–‡ä»¶', 'error');
        }
    } catch (globalError) {
        console.error("æ–‡ä»¶ä¸Šä¼ æ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯:", globalError);
        showToast("ä¸Šä¼ è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°ã€‚", 'error');
    } finally {
        libraryFileInput.value = ''; // Reset for next use
    }
});
async function handleChatBackgroundUpload(file, settingsObject) { if (!file) return; const newWallpaperId = newId('wp'); await addMediaToDB(newWallpaperId, file); appState.beautify.wallpapers.push({ id: newWallpaperId }); settingsObject.chatBackgroundId = newWallpaperId; debouncedSaveState(); showToast('èƒŒæ™¯å·²è®¾ç½®å¹¶å­˜å…¥å£çº¸åº“'); await updateSingleChatUI(); }
    async function handleVideoBackgroundUpload(file, settingsObject) {
    if (!file) return;
    showToast('æ­£åœ¨ä¸Šä¼ è§†é¢‘èƒŒæ™¯...');
    const newVideoBgId = newId('video_bg');
    await addMediaToDB(newVideoBgId, file);
    settingsObject.videoBackgroundId = newVideoBgId;
    debouncedSaveState(); // å®æ—¶ä¿å­˜
    showToast('è§†é¢‘èƒŒæ™¯å·²æ›´æ–°ï¼');
    
        // å®æ—¶åˆ·æ–°é€»è¾‘
        if (appState.chat.videoCallState.isActive) {
            const contact = appState.chat.contacts.find(c => c.id === appState.chat.videoCallState.chatId);
            if (!contact) return;
    
            // æ£€æŸ¥è¢«ä¿®æ”¹çš„è®¾ç½®å¯¹è±¡æ˜¯å¦ä¸å½“å‰é€šè¯ç›¸å…³
            const isCharSettings = settingsObject === runtimeState.tempChatSettings?.charSettings;
            const isUserSettings = settingsObject === runtimeState.tempChatSettings?.userSettings;
            
            if (isCharSettings || isUserSettings) {
                // å¼ºåˆ¶é‡æ–°æ¸²æŸ“è§†é¢‘é€šè¯ç•Œé¢ä»¥åº”ç”¨æ–°èƒŒæ™¯
                await openVideoCallModal();
            }
        }
    }
    
    // --- æ–°å¢ï¼šèƒŒæ™¯é€‰é¡¹èœå•é€»è¾‘ ---
    const backgroundContextMenu = getEl('background-context-menu');
    function showBackgroundContextMenu(targetElement, context) {
        runtimeState.backgroundMenuContext = context;
        const rect = targetElement.getBoundingClientRect();
        const screenRect = phoneScreen.getBoundingClientRect();
    
        // æ€»æ˜¯æ˜¾ç¤ºæ‰€æœ‰é€‰é¡¹
        getEl('bg-menu-chat-bg').style.display = 'block';
        getEl('bg-menu-video-bg').style.display = 'block';
    
        backgroundContextMenu.style.display = 'flex';
        const menuRect = backgroundContextMenu.getBoundingClientRect();
        let top = rect.top - screenRect.top - menuRect.height - 5;
        let left = rect.left - screenRect.left;
        if (top < 10) {
            top = rect.bottom - screenRect.top + 5;
        }
        if (left + menuRect.width > screenRect.width - 10) {
            left = screenRect.width - menuRect.width - 10;
        }
        backgroundContextMenu.style.top = `${top}px`;
        backgroundContextMenu.style.left = `${left}px`;
    }
    function hideBackgroundContextMenu() {
        if (backgroundContextMenu) backgroundContextMenu.style.display = 'none';
        runtimeState.backgroundMenuContext = null;
    }
    document.addEventListener('pointerdown', (e) => {
        if (backgroundContextMenu.style.display === 'flex' && !backgroundContextMenu.contains(e.target)) {
            hideBackgroundContextMenu();
        }
    }, true);
    getEl('bg-menu-chat-bg').addEventListener('click', () => {
        const context = runtimeState.backgroundMenuContext;
        if(context) {
            openBackgroundLibraryModal({
                type: 'chat',
                title: 'é€‰æ‹©èŠå¤©èƒŒæ™¯',
                settingsObject: context.settingsObject,
                activeKey: 'chatBackgroundId',
                defaultId: 'default'
            });
        }
        hideBackgroundContextMenu();
    });
    getEl('bg-menu-video-bg').addEventListener('click', () => {
        const context = runtimeState.backgroundMenuContext;
        if(context) {
            openBackgroundLibraryModal({
                type: 'video',
                title: 'é€‰æ‹©è§†é¢‘èƒŒæ™¯',
                settingsObject: context.settingsObject,
                activeKey: 'videoBackgroundId',
                libraryKey: 'videoBackgroundLibrary',
                defaultId: ''
            });
        }
        hideBackgroundContextMenu();
    });
    csCharBackgroundBtn.addEventListener('click', (e) => { showBackgroundContextMenu(e.currentTarget, { settingsObject: runtimeState.tempChatSettings.charSettings }); });
    gcsGroupBackgroundBtn.addEventListener('click', (e) => { showBackgroundContextMenu(e.currentTarget, { settingsObject: runtimeState.tempChatSettings.groupSettings }); });

// ===================================================================
// --- ç¾¤èŠè®¾ç½®ç•Œé¢é€»è¾‘ ---
// ===================================================================
function openGroupChatSettings() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); runtimeState.originalChatSettings = JSON.parse(JSON.stringify({ groupSettings: contact.groupSettings, userSettings: contact.userSettings, remark: contact.remark })); runtimeState.tempChatSettings = JSON.parse(JSON.stringify(runtimeState.originalChatSettings)); loadGroupChatSettingsUI(); openSubScreen(groupChatSettingsScreen, singleChatScreen); }
function loadGroupChatSettingsUI() { const { groupSettings, userSettings } = runtimeState.tempChatSettings; gcsGroupName.value = groupSettings.name; setupWorldBookSelector(gcsWorldBookGroupSelector, gcsWorldBookList, groupSettings.linkedWorldBooks); setElementImage(gcsGroupAvatar, groupSettings.avatarId); gcsContextMemory.value = groupSettings.contextMemory; renderGroupMemberList(); gcsMuteAllBtn.textContent = groupSettings.isMuted ? 'è§£é™¤ç¦è¨€' : 'å…¨ä½“ç¦è¨€'; gcsDisbandBtn.textContent = groupSettings.isDisbanded ? 'é‡å»ºç¾¤èŠ' : 'è§£æ•£ç¾¤èŠ'; gcsUsUserName.value = userSettings.name; setElementImage(gcsUsUserAvatar, userSettings.avatarId); setElementImage(gcsUsUserAvatar.querySelector('.avatar-frame'), userSettings.avatarFrameId); gcsUsPersona.value = userSettings.persona;
         const gcsUsBubbleCss = getEl('gcs-us-bubble-css');
gcsUsBubbleCss.value = runtimeState.tempChatSettings.userSettings.bubbleCss || defaultBubbleCssText;
updateBubbleCssPreview('gcs-us', runtimeState.tempChatSettings);}
function renderGroupMemberList() { const { owner, admins, members } = runtimeState.tempChatSettings.groupSettings; gcsMemberList.innerHTML = ''; const memberIds = Object.keys(members).filter(id => id !== 'user'); memberIds.unshift('user'); memberIds.forEach(id => { const member = members[id]; const user = findUserById(id); const item = document.createElement('div'); item.className = 'gcs-member-item'; item.dataset.id = id; let roleBadge = ''; if (id === owner) { roleBadge = '<div class="role-badge owner">ä¸»</div>'; } else if (admins.includes(id)) { roleBadge = '<div class="role-badge admin">ç®¡</div>'; } const finalAvatarId = member.avatarId || user.avatarId; item.innerHTML = ` <div class="avatar" data-avatar-id="${finalAvatarId}">${roleBadge}</div> <span class="name">${member.nickname}</span> `; gcsMemberList.appendChild(item); setElementImage(item.querySelector('.avatar'), finalAvatarId); }); const addBtn = document.createElement('button'); addBtn.className = 'gcs-action-btn'; addBtn.textContent = '+'; addBtn.id = 'gcs-add-member-btn'; gcsMemberList.appendChild(addBtn); const removeBtn = document.createElement('button'); removeBtn.className = 'gcs-action-btn'; removeBtn.textContent = '-'; removeBtn.id = 'gcs-remove-member-btn'; gcsMemberList.appendChild(removeBtn); }
function saveGroupChatSettings() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);            const originalNickname = runtimeState.originalChatSettings.groupSettings.members['user']?.nickname;
            const finalNickname = runtimeState.tempChatSettings.groupSettings.members['user']?.nickname;
            if (finalNickname && finalNickname !== originalNickname) {
                addSystemNotification(runtimeState.currentChatId, `ä½ å°†ç¾¤åç‰‡ä¿®æ”¹ä¸ºï¼šâ€œ${finalNickname}â€`, false);
            } if (!contact) return; contact.groupSettings = JSON.parse(JSON.stringify(runtimeState.tempChatSettings.groupSettings)); contact.userSettings = JSON.parse(JSON.stringify(runtimeState.tempChatSettings.userSettings)); contact.remark = runtimeState.tempChatSettings.remark; contact.name = runtimeState.tempChatSettings.groupSettings.name; if (contact.groupSettings.members['user']) {
        contact.groupSettings.members['user'].nickname = contact.userSettings.name;
        contact.groupSettings.members['user'].avatarId = contact.userSettings.avatarId;
        contact.groupSettings.members['user'].avatarFrameId = contact.userSettings.avatarFrameId;
        contact.groupSettings.members['user'].persona = contact.userSettings.persona;
    }
    appState.chat.userProfile = { ...appState.chat.userProfile, ...contact.userSettings }; debouncedSaveState();
    applyAllCustomBubbleStyles();  updateSingleChatUI(); renderMessageList(); renderConversation(); if (viewContentModal.classList.contains('visible')) { const packetBubble = document.querySelector(`.message-bubble.red-packet[data-packet-content]`); if (packetBubble) { const packetData = JSON.parse(decodeURIComponent(packetBubble.dataset.packetContent)); showRedPacketDetails(packetData); } } }
function setupGroupChatSettingsListeners() { gcsBackBtn.addEventListener('click', () => { saveGroupChatSettings(); closeSubScreen(groupChatSettingsScreen, singleChatScreen); }); query('#group-chat-settings-screen .app-bottom-tabs').addEventListener('click', (e) => { if (e.target.classList.contains('tab-link')) { const tabId = e.target.dataset.tab; queryAll('#group-chat-settings-screen .tab-link').forEach(t => t.classList.remove('active')); queryAll('#group-chat-settings-screen .tab-content').forEach(c => c.classList.remove('active')); e.target.classList.add('active'); getEl(`${tabId}-tab-content`).classList.add('active'); } }); gcsGroupName.addEventListener('input', () => { const oldName = runtimeState.tempChatSettings.groupSettings.name; const newName = gcsGroupName.value.trim(); if (newName && newName !== oldName) { addSystemNotification(runtimeState.currentChatId, `'${runtimeState.tempChatSettings.userSettings.name}' å°†ç¾¤åä¿®æ”¹ä¸º "${newName}"`, false); runtimeState.tempChatSettings.groupSettings.name = newName; } }); gcsContextMemory.addEventListener('input', () => runtimeState.tempChatSettings.groupSettings.contextMemory = parseInt(gcsContextMemory.value) || 20); gcsGroupAvatarLibraryBtn.addEventListener('click', () => openLibraryModal({ title: 'ç¾¤å¤´åƒåº“', isGroup: true, libraryKey: 'avatarLibrary', activeKey: 'avatarId', showPreview: false, isCircular: true })); gcsGroupBackgroundBtn.addEventListener('click', (e) => { showBackgroundContextMenu(e.currentTarget, { settingsObject: runtimeState.tempChatSettings.groupSettings }); });
         gcsClearHistoryBtn.addEventListener('click', async () => {
    if (confirm('æ­¤æ“ä½œå°†æ°¸ä¹…æ¸…ç©ºè¯¥ç¾¤çš„æ‰€æœ‰èŠå¤©è®°å½•ï¼Œç¡®å®šå—ï¼Ÿ')) {
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (contact) {
            // --- æ–°å¢ï¼šåŒæ­¥åˆ é™¤å…³è”çš„ç§˜å¯† ---
            if (appState.diary && appState.diary.secrets && contact.conversation.length > 0) {
                const memberIds = new Set(contact.members);
                const timestamps = contact.conversation.map(msg => msg.timestamp);
                const minTimestamp = Math.min(...timestamps);
                const maxTimestamp = Math.max(...timestamps);
                const originalSecretsCount = appState.diary.secrets.length;
                appState.diary.secrets = appState.diary.secrets.filter(secret => {
                    return !memberIds.has(secret.charId) || secret.timestamp < (minTimestamp - 2000) || secret.timestamp > (maxTimestamp + 2000);
                });
                const secretsDeletedCount = originalSecretsCount - appState.diary.secrets.length;
                if (secretsDeletedCount > 0) {
                    console.log(`åŒæ­¥åˆ é™¤äº† ${secretsDeletedCount} æ¡ä¸è¯¥ç¾¤èŠç›¸å…³çš„ç§˜å¯†ã€‚`);
                }
            }
            // åŒæ­¥æ¸…ç©ºæ°¸ä¹…æ•°æ®
            contact.conversation = [];
            if (contact.groupSettings) {
                contact.groupSettings.memory = [];
            }
            // åŒæ­¥æ¸…ç©ºä¸´æ—¶çŠ¶æ€
            if (runtimeState.tempChatSettings.groupSettings) {
                runtimeState.tempChatSettings.groupSettings.memory = [];
            }

            updateContactLastMessage(runtimeState.currentChatId);
            await saveState();
            renderConversation();
            renderMessageList();
            showToast('èŠå¤©è®°å½•å·²æ¸…ç©º');
        }
    }
}); 
gcsMuteAllBtn.addEventListener('click', () => { runtimeState.tempChatSettings.groupSettings.isMuted = !runtimeState.tempChatSettings.groupSettings.isMuted; gcsMuteAllBtn.textContent = runtimeState.tempChatSettings.groupSettings.isMuted ? 'è§£é™¤ç¦è¨€' : 'å…¨ä½“ç¦è¨€'; addSystemNotification(runtimeState.currentChatId, runtimeState.tempChatSettings.groupSettings.isMuted ? 'å·²å¼€å¯å…¨ä½“ç¦è¨€' : 'å·²è§£é™¤å…¨ä½“ç¦è¨€', false); }); gcsDisbandBtn.addEventListener('click', () => { runtimeState.tempChatSettings.groupSettings.isDisbanded = !runtimeState.tempChatSettings.groupSettings.isDisbanded; gcsDisbandBtn.textContent = runtimeState.tempChatSettings.groupSettings.isDisbanded ? 'é‡å»ºç¾¤èŠ' : 'è§£æ•£ç¾¤èŠ'; addSystemNotification(runtimeState.currentChatId, runtimeState.tempChatSettings.groupSettings.isDisbanded ? 'ç¾¤èŠå·²è§£æ•£' : 'ç¾¤èŠå·²æ¢å¤', false); });     gcsUsUserName.addEventListener('input', (e) => { const oldName = runtimeState.tempChatSettings.groupSettings.members['user'].nickname; const newName = e.target.value.trim(); if (newName && newName !== oldName) { runtimeState.tempChatSettings.userSettings.name = newName; runtimeState.tempChatSettings.groupSettings.members['user'].nickname = newName; } }); gcsUsPersona.addEventListener('input', () => runtimeState.tempChatSettings.userSettings.persona = gcsUsPersona.value); gcsUsUserAvatarLibraryBtn.addEventListener('click', () => openLibraryModal({ title: 'æˆ‘çš„å¤´åƒåº“', isGlobalUserLib: true, isGroupUser: true, settingsGroup: 'userSettings', activeKey: 'avatarId', showPreview: false, isCircular: true })); gcsUsUserAvatarFrameBtn.addEventListener('click', () => openLibraryModal({ title: 'æˆ‘çš„å¤´åƒæ¡†åº“', isFrame: true, settingsGroup: 'userSettings', isGroupUser: true, activeKey: 'avatarFrameId', showPreview: true, hasNoItemOption: true, previewAvatarId: runtimeState.tempChatSettings.userSettings.avatarId })); gcsUsSavePersonaBtn.addEventListener('click', () => { const { name, avatarId, persona } = runtimeState.tempChatSettings.userSettings; const newInfo = { id: newId('data'), name, avatarId, content: persona }; appState.data.infos.push(newInfo); debouncedSaveState(); showToast(`èµ„æ–™å·²ä¿å­˜åˆ°ä¿¡æ¯: ${name}`); renderInfos(); }); gcsUsLoadPersonaBtn.addEventListener('click', () => openLoadPersonaModal('info', 'userSettings'));

    // ä¸ºç¾¤èŠUserè®¾ç½®ä¸­çš„è§†é¢‘èƒŒæ™¯æŒ‰é’®æ·»åŠ ç›´æ¥ä¸Šä¼ ç›‘å¬
    const gcsUsUserVideoBackgroundBtn = getEl('gcs-us-user-video-background-btn');
    if(gcsUsUserVideoBackgroundBtn) {
    gcsUsUserVideoBackgroundBtn.addEventListener('click', (e) => {
        openBackgroundLibraryModal({
            type: 'video',
            title: 'é€‰æ‹©è§†é¢‘èƒŒæ™¯',
            settingsObject: runtimeState.tempChatSettings.userSettings,
            activeKey: 'videoBackgroundId',
            libraryKey: 'videoBackgroundLibrary',
            defaultId: ''
        });
    });
}
    let gcsLongPressTimer = null; let gcsIsDragging = false; let gcsStartX, gcsStartY; gcsMemberList.addEventListener('pointerdown', e => { if (e.button !== 0) return; const target = e.target; const item = target.closest('.gcs-member-item'); if (!item) return; gcsIsDragging = false; gcsStartX = e.clientX; gcsStartY = e.clientY; gcsLongPressTimer = setTimeout(() => { if (!gcsIsDragging) { handleGcsMemberLongPress(item.dataset.id); } }, 500); }); gcsMemberList.addEventListener('pointermove', e => { if (Math.abs(e.clientX - gcsStartX) > 10 || Math.abs(e.clientY - gcsStartY) > 10) { gcsIsDragging = true; clearTimeout(gcsLongPressTimer); } }); gcsMemberList.addEventListener('pointerup', e => { clearTimeout(gcsLongPressTimer); if (!gcsIsDragging) { const item = e.target.closest('.gcs-member-item'); const addBtn = e.target.closest('#gcs-add-member-btn'); const removeBtn = e.target.closest('#gcs-remove-member-btn'); if (item) { openGcsMemberModal(item.dataset.id); } else if (addBtn) { openGcsManageMembersModal('add'); } else if (removeBtn) { openGcsManageMembersModal('remove'); } } }); }
function openGcsMemberModal(memberId) { if (memberId === 'user') return; const memberSettings = runtimeState.tempChatSettings.groupSettings.members[memberId]; if (!memberSettings) return; runtimeState.tempGcsMemberSettings = JSON.parse(JSON.stringify(memberSettings)); gcsEditingMemberIdInput.value = memberId; loadGcsMemberModalUI(); gcsMemberModal.classList.add('visible'); }
function loadGcsMemberModalUI() { gcsMemberModalTitle.textContent = `è®¾ç½® ${runtimeState.tempGcsMemberSettings.nickname}`; gcsMemberNickname.value = runtimeState.tempGcsMemberSettings.nickname; getEl('gcs-member-relationship').value = runtimeState.tempGcsMemberSettings.relationship || ''; setupWorldBookSelector(gcsMemberWorldBookGroupSelector, gcsMemberWorldBookList, runtimeState.tempGcsMemberSettings.linkedWorldBooks); setElementImage(gcsMemberAvatar, runtimeState.tempGcsMemberSettings.avatarId); setElementImage(gcsMemberAvatar.querySelector('.avatar-frame'), runtimeState.tempGcsMemberSettings.avatarFrameId); gcsMemberPersona.value = runtimeState.tempGcsMemberSettings.persona; }
gcsMemberNickname.addEventListener('input', (e) => runtimeState.tempGcsMemberSettings.nickname = e.target.value);
getEl('gcs-member-relationship').addEventListener('input', (e) => runtimeState.tempGcsMemberSettings.relationship = e.target.value);
gcsMemberPersona.addEventListener('input', (e) => runtimeState.tempGcsMemberSettings.persona = e.target.value);gcsMemberModalCancelBtn.addEventListener('click', () => gcsMemberModal.classList.remove('visible'));
gcsMemberModalSaveBtn.addEventListener('click', () => { const memberId = gcsEditingMemberIdInput.value; runtimeState.tempChatSettings.groupSettings.members[memberId] = JSON.parse(JSON.stringify(runtimeState.tempGcsMemberSettings)); renderGroupMemberList(); gcsMemberModal.classList.remove('visible'); renderConversation(); });
gcsMemberNickname.addEventListener('input', (e) => runtimeState.tempGcsMemberSettings.nickname = e.target.value);
gcsMemberPersona.addEventListener('input', (e) => runtimeState.tempGcsMemberSettings.persona = e.target.value);
gcsMemberAvatarLibraryBtn.addEventListener('click', () => openLibraryModal({ title: 'æˆå‘˜å¤´åƒåº“', memberId: gcsEditingMemberIdInput.value, libraryKey: 'avatarLibrary', activeKey: 'avatarId', showPreview: false, isCircular: true }));
gcsMemberAvatarFrameBtn.addEventListener('click', () => openLibraryModal({ title: 'æˆå‘˜å¤´åƒæ¡†åº“', isFrame: true, memberId: gcsEditingMemberIdInput.value, activeKey: 'avatarFrameId', showPreview: true, hasNoItemOption: true, previewAvatarId: runtimeState.tempGcsMemberSettings.avatarId }));
gcsMemberSavePersonaBtn.addEventListener('click', () => { const { nickname, avatarId, persona, relationship } = runtimeState.tempGcsMemberSettings; const newArchive = { id: newId('data'), name: nickname, avatarId, content: persona, relationship: relationship }; appState.data.archives.push(newArchive); debouncedSaveState(); showToast(`èµ„æ–™å·²ä¿å­˜åˆ°æ¡£æ¡ˆ: ${nickname}`); renderArchives(); });
gcsMemberLoadPersonaBtn.addEventListener('click', () => openLoadPersonaModal('archive', null, gcsEditingMemberIdInput.value));
function openGcsManageMembersModal(type) { runtimeState.gcsManageContext.type = type; runtimeState.gcsManageContext.selection = []; gcsManageMembersModal.classList.add('visible'); gcsManageMembersConfirmBtn.disabled = true; let listHTML = ''; let membersToRender = []; if (type === 'add') { gcsManageMembersTitle.textContent = 'é‚€è¯·æ–°æˆå‘˜'; const currentMemberIds = Object.keys(runtimeState.tempChatSettings.groupSettings.members); const availableContacts = appState.chat.contacts.filter(c => !c.isGroup && !currentMemberIds.includes(c.id)); membersToRender = availableContacts.map(c => ({ id: c.id, name: c.charSettings.name, avatarId: c.charSettings.avatarId })); } else { gcsManageMembersTitle.textContent = 'è¸¢å‡ºæˆå‘˜'; const { owner, admins } = runtimeState.tempChatSettings.groupSettings; const userIsOwner = owner === 'user'; const userIsAdmin = admins.includes('user'); const removableMemberIds = Object.keys(runtimeState.tempChatSettings.groupSettings.members).filter(id => { if (id === 'user' || id === owner) return false; if (userIsOwner) return true; if (userIsAdmin && !admins.includes(id)) return true; return false; }); membersToRender = removableMemberIds.map(id => { const member = runtimeState.tempChatSettings.groupSettings.members[id]; const user = findUserById(id); return { id: id, name: member.nickname, avatarId: member.avatarId || user.avatarId }; }); } listHTML = membersToRender.map(m => ` <div class="gcs-manage-member-item"> <input type="checkbox" id="manage-member-${m.id}" value="${m.id}"> <label for="manage-member-${m.id}"> <div class="avatar" data-avatar-id="${m.avatarId}"></div> <span class="name">${m.name}</span> </label> </div> `).join(''); gcsManageMembersList.innerHTML = listHTML || `<p style="text-align:center; color:#888;">æ— å¯ç”¨æ“ä½œå¯¹è±¡</p>`; gcsManageMembersList.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId)); }
gcsManageMembersList.addEventListener('change', (e) => { if (e.target.type === 'checkbox') { const id = e.target.value; if (e.target.checked) { if (!runtimeState.gcsManageContext.selection.includes(id)) { runtimeState.gcsManageContext.selection.push(id); } } else { runtimeState.gcsManageContext.selection = runtimeState.gcsManageContext.selection.filter(selId => selId !== id); } gcsManageMembersConfirmBtn.disabled = runtimeState.gcsManageContext.selection.length === 0; } });
gcsManageMembersCancelBtn.addEventListener('click', () => gcsManageMembersModal.classList.remove('visible'));
gcsManageMembersConfirmBtn.addEventListener('click', () => { const { type, selection } = runtimeState.gcsManageContext; if (selection.length === 0) return; if (type === 'add') { const addedNames = []; selection.forEach(id => { const char = appState.chat.contacts.find(c => c.id === id); if (char) { runtimeState.tempChatSettings.groupSettings.members[id] = { ...JSON.parse(JSON.stringify(char.charSettings)), nickname: char.name, title: 'æˆå‘˜', isMuted: false }; addedNames.push(`'${char.name}'`); } }); addSystemNotification(runtimeState.currentChatId, `'${runtimeState.tempChatSettings.userSettings.name}' é‚€è¯· ${addedNames.join(', ')} åŠ å…¥ç¾¤èŠ`, true); } else { const removedNames = []; selection.forEach(id => { removedNames.push(`'${runtimeState.tempChatSettings.groupSettings.members[id].nickname}'`); delete runtimeState.tempChatSettings.groupSettings.members[id]; runtimeState.tempChatSettings.groupSettings.admins = runtimeState.tempChatSettings.groupSettings.admins.filter(adminId => adminId !== id); }); addSystemNotification(runtimeState.currentChatId, `${removedNames.join(', ')} å·²è¢«ç§»å‡ºç¾¤èŠ`, true); } renderGroupMemberList(); gcsManageMembersModal.classList.remove('visible'); });
function handleGcsMemberLongPress(memberId) { const { owner, admins } = runtimeState.tempChatSettings.groupSettings; const userIsOwner = runtimeState.tempChatSettings.groupSettings.owner === 'user'; if (memberId === 'user') return; runtimeState.gcsMemberActionContext.memberId = memberId; const memberName = runtimeState.tempChatSettings.groupSettings.members[memberId].nickname; gcsMemberActionTitle.textContent = `ç®¡ç†æˆå‘˜: ${memberName}`; let options = []; if (userIsOwner) { if (memberId !== owner) { options.push({ text: 'è½¬è®©ç¾¤ä¸»', value: 'transfer' }); if (admins.includes(memberId)) { options.push({ text: 'æ’¤é”€ç®¡ç†å‘˜', value: 'demote' }); } else { options.push({ text: 'è®¾ä¸ºç®¡ç†å‘˜', value: 'promote' }); } } } else { if (memberId === owner) { options.push({ text: 'å¤ºå›ç¾¤ä¸»', value: 'reclaim', isDanger: true }); } } if (options.length === 0) { showToast('æ— å¯ç”¨æ“ä½œ', 'info'); return; } gcsMemberActionBody.innerHTML = options.map(opt => `<button class="settings-button ${opt.isDanger ? 'danger-btn' : 'secondary'}" data-action="${opt.value}">${opt.text}</button>`).join(''); gcsMemberActionModal.classList.add('visible'); }
gcsMemberActionCancelBtn.addEventListener('click', () => gcsMemberActionModal.classList.remove('visible'));
gcsMemberActionBody.addEventListener('click', (e) => { const btn = e.target.closest('button'); if (!btn) return; const action = btn.dataset.action; const memberId = runtimeState.gcsMemberActionContext.memberId; const memberSettings = runtimeState.tempChatSettings.groupSettings.members[memberId]; if (!memberSettings) return; const memberName = memberSettings.nickname; const userName = runtimeState.tempChatSettings.userSettings.name;
             switch (action) {
                case 'transfer':
                    if (confirm(`ç¡®å®šè¦å°†ç¾¤ä¸»è½¬è®©ç»™ ${memberName} å—ï¼Ÿä½ å°†æˆä¸ºæ™®é€šæˆå‘˜ã€‚`)) {
                        runtimeState.tempChatSettings.groupSettings.owner = memberId;
                        runtimeState.tempChatSettings.groupSettings.members[memberId].title = 'ç¾¤ä¸»';
                        runtimeState.tempChatSettings.groupSettings.members['user'].title = 'æˆå‘˜';
                        runtimeState.tempChatSettings.groupSettings.admins = runtimeState.tempChatSettings.groupSettings.admins.filter(id => id !== 'user');
                        addSystemNotification(runtimeState.currentChatId, `'${userName}' å°†ç¾¤ä¸»è½¬è®©ç»™äº† '${memberName}'`, false);
                    }
                    break;
                case 'reclaim':
                    if (confirm(`ç¡®å®šè¦ä» ${memberName} å¤„å¤ºå›ç¾¤ä¸»èº«ä»½å—ï¼Ÿå¯¹æ–¹å°†æˆä¸ºæ™®é€šæˆå‘˜ã€‚`)) {
                        runtimeState.tempChatSettings.groupSettings.owner = 'user';
                        runtimeState.tempChatSettings.groupSettings.members['user'].title = 'ç¾¤ä¸»';
                        if (memberId && runtimeState.tempChatSettings.groupSettings.members[memberId]) {
                             runtimeState.tempChatSettings.groupSettings.members[memberId].title = 'æˆå‘˜';
                        }
                        if (memberId) {
                            runtimeState.tempChatSettings.groupSettings.admins = runtimeState.tempChatSettings.groupSettings.admins.filter(id => id !== memberId);
                        }
                        addSystemNotification(runtimeState.currentChatId, `'${userName}' ä» '${memberName}' å¤„å¤ºå›äº†ç¾¤ä¸»èº«ä»½`, false);
                    }
                    break;
                case 'promote':
                    if (confirm(`ç¡®å®šè¦å°† ${memberName} è®¾ä¸ºç®¡ç†å‘˜å—ï¼Ÿ`)) {
                        if (!runtimeState.tempChatSettings.groupSettings.admins.includes(memberId)) {
                            runtimeState.tempChatSettings.groupSettings.admins.push(memberId);
                        }
                        memberSettings.title = 'ç®¡ç†å‘˜';
                        addSystemNotification(runtimeState.currentChatId, `'${memberName}' å·²è¢«è®¾ä¸ºç®¡ç†å‘˜`, false);
                    }
                    break;
                case 'demote':
                    if (confirm(`ç¡®å®šè¦æ’¤é”€ ${memberName} çš„ç®¡ç†å‘˜èº«ä»½å—ï¼Ÿ`)) {
                        runtimeState.tempChatSettings.groupSettings.admins = runtimeState.tempChatSettings.groupSettings.admins.filter(id => id !== memberId);
                        memberSettings.title = 'æˆå‘˜';
                        addSystemNotification(runtimeState.currentChatId, `'${memberName}' çš„ç®¡ç†å‘˜èº«ä»½å·²è¢«æ’¤é”€`, false);
                    }
                    break;
            } renderGroupMemberList(); gcsMemberActionModal.classList.remove('visible'); });
                                    async function generateAndSendPostcardReply(contact, originalCard) {
                    console.log(`Triggering AI for postcard reply from ${contact.name}...`);
        try {
            const secretInstruction = constructPostcardReplyPrompt(contact, originalCard);
            await triggerAiResponse(contact.id, false, false, false, secretInstruction, false, { type: 'background_event' });
        } catch (error) {
            console.error(`Failed to construct postcard reply prompt for ${contact.name}:`, error);
        }
    }
    async function generateAndSendPostcard(contact) {
           console.log(`Triggering AI for proactive postcard from ${contact.name}...`);
        try {
            const postcardsBetween = appState.mailbox.postcards.filter(p => (p.senderId === contact.id && p.recipientId === 'user') || (p.senderId === 'user' && p.recipientId === contact.id)).sort((a, b) => a.timestamp - b.timestamp);
            const lastUserPostcard = postcardsBetween.filter(p => p.senderId === 'user').pop();
            const lastCharPostcard = postcardsBetween.filter(p => p.senderId === contact.id).pop();
            let context = {};
            if (!lastCharPostcard) { context.type = 'first'; } 
            else if (!lastUserPostcard || lastCharPostcard.timestamp > lastCharPostcard.timestamp) { context.type = 'pining'; } 
            else { context.type = 'after_reply'; }

                    const secretInstruction = constructPostcardPrompt(contact, context);
        await triggerAiResponse(contact.id, false, false, false, secretInstruction, false, { type: 'background_event' });

        } catch (error) {
            console.error(`Failed to construct postcard prompt for ${contact.name}:`, error);
        }
    }
    
                function openNewPostcardModal() {
            const modal = getEl('new-postcard-modal');
            const recipientSelector = getEl('new-postcard-recipient-selector');
            const salutationInput = getEl('new-postcard-salutation');
            const bodyInput = getEl('new-postcard-body');
            const signatureInput = getEl('new-postcard-signature');
            const locationInput = getEl('new-postcard-location');
            const imgPreview = getEl('new-postcard-image-preview');

            // Reset fields
            salutationInput.value = '';
            bodyInput.value = '';
            locationInput.value = '';
            imgPreview.src = '';
            imgPreview.style.display = 'none';
            imgPreview.dataset.imageId = '';
            
            // Populate signature with global user name initially
            signatureInput.value = appState.chat.userProfile.name;

            // Populate recipient selector, excluding the user
            renderLetterAuthorSelector(recipientSelector, null, true);

            modal.classList.add('visible');
        }

        // --- Mail App New Listeners & Functions ---
        getEl('postcard-fab-container').addEventListener('click', () => {
            openNewPostcardModal();
        });

        getEl('new-postcard-modal').addEventListener('click', e => {
            const item = e.target.closest('#new-postcard-recipient-selector .author-selector-item');
            if (item) {
                item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');

                const recipientId = item.dataset.id;
                const charContact = appState.chat.contacts.find(c => c.id === recipientId);
                if (charContact) {
                    getEl('new-postcard-salutation').value = charContact.charSettings.name;
                    getEl('new-postcard-signature').value = charContact.userSettings.name;
                }
            }
        });

        getEl('upload-new-postcard-image-btn').addEventListener('click', () => getEl('new-postcard-image-file-input').click());
        getEl('new-postcard-image-file-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            showToast('æ­£åœ¨å¤„ç†å›¾ç‰‡...');
            const compressedFile = await compressImageBeforeSaving(file);
            const newImageId = newId('postcard_new_img');
            await addMediaToDB(newImageId, compressedFile);
            
            const imgPreview = getEl('new-postcard-image-preview');
            imgPreview.src = await getMediaURL(newImageId);
            imgPreview.style.display = 'block';
            imgPreview.dataset.imageId = newImageId;
            e.target.value = '';
        });

        getEl('add-new-postcard-image-url-btn').addEventListener('click', () => {
            const url = prompt('è¯·è¾“å…¥å›¾ç‰‡URL:');
            if (url && url.startsWith('http')) {
                const imgPreview = getEl('new-postcard-image-preview');
                imgPreview.src = url;
                imgPreview.style.display = 'block';
                imgPreview.dataset.imageId = url;
            } else if (url) {
                showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„URL', 'error');
            }
        });

        getEl('cancel-new-postcard-btn').addEventListener('click', () => getEl('new-postcard-modal').classList.remove('visible'));

        getEl('send-new-postcard-btn').addEventListener('click', () => {
            const recipientSelector = getEl('new-postcard-recipient-selector');
            const selectedRecipient = recipientSelector.querySelector('.author-selector-item.selected');

            if (!selectedRecipient) {
                return showToast('è¯·é€‰æ‹©ä¸€ä½æ”¶ä¿¡äºº', 'error');
            }

            const recipientId = selectedRecipient.dataset.id;
            const body = getEl('new-postcard-body').value.trim();
            const location = getEl('new-postcard-location').value.trim();
            const imageUrl = getEl('new-postcard-image-preview').dataset.imageId;
            const salutation = getEl('new-postcard-salutation').value.trim();
            const signature = getEl('new-postcard-signature').value.trim();

            if (!imageUrl || !body || !location || !salutation || !signature) {
                return showToast('å›¾ç‰‡ã€ç§°å‘¼ã€å†…å®¹ã€è½æ¬¾å’Œåœ°ç‚¹å‡ä¸èƒ½ä¸ºç©º', 'error');
            }

            const newPostcard = {
                id: newId('postcard'),
                senderId: 'user',
                recipientId: recipientId,
                salutation: salutation,
                body: body,
                signature: signature,
                location: location,
                timestamp: Date.now(),
                imageUrl: imageUrl,
                isRead: true, 
                gift: null
            };

            appState.mailbox.postcards.push(newPostcard);
            debouncedSaveState();
            
            getEl('new-postcard-modal').classList.remove('visible');
            renderPostcardWall();
            showToast('æ˜ä¿¡ç‰‡å·²å‘é€ï¼');
        });
                function constructPostcardReplyPrompt(charContact, originalCard) {
            const now = new Date();
        const season = ['å†¬å­£', 'æ˜¥å­£', 'å¤å­£', 'ç§‹å­£'][Math.floor((now.getMonth() + 1) / 3) % 4];
        const user = charContact.userSettings;
        const myLastPostcardToUser = appState.mailbox.postcards.find(p => p.senderId === charContact.id && p.recipientId === 'user');
    let longTermMemoryContext = '';
    if (charContact.conversation.length > charContact.charSettings.contextMemory && charContact.charSettings.memory && charContact.charSettings.memory.length > 0) {
        longTermMemoryContext += `--- **ã€é•¿æœŸè®°å¿†å›é¡¾ (Long-Term Memory)ã€‘** ---\n`;
        longTermMemoryContext += `åœ¨ä½ å›å¤è¿™å¼ æ˜ä¿¡ç‰‡ä¹‹å‰ï¼Œä½ éœ€è¦å›é¡¾ä»¥ä¸‹ä¸ç”¨æˆ·â€œ${user.name}â€ä¹‹é—´å‘ç”Ÿè¿‡çš„å…³é”®äº‹ä»¶ï¼š\n`;
        charContact.charSettings.memory.forEach(mem => {
            longTermMemoryContext += `- æ—¶é—´: ${mem.event.time}, å†…å®¹: ${mem.event.content} (å½“æ—¶å…³ç³»: ${mem.relationship}, ä½ çš„æƒ…ç»ª: ${mem.event.emotion})\n`;
        });
        longTermMemoryContext += `\n`;
    }
        let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰² â€œ${charContact.charSettings.name}â€ï¼Œä¸ºäººè®¾æ˜¯ â€œ${charContact.charSettings.persona}â€ çš„è§’è‰²ï¼Œç»™ â€œ${user.name}â€ï¼ˆäººè®¾ï¼šâ€œ${user.persona}â€ï¼‰å†™ä¸€å¼ å›ä¿¡æ˜ä¿¡ç‰‡ã€‚\n\n`;
            prompt += longTermMemoryContext;
        prompt += `--- **ã€TAçš„æ¥ä¿¡å†…å®¹ã€‘** ---\nåœ°ç‚¹: ${originalCard.location}\nç§°å‘¼: ${originalCard.salutation}\næ­£æ–‡: ${originalCard.body}\nè½æ¬¾: ${originalCard.signature}\n\n`;
        prompt += `--- **ã€å…³ç³»ä¸æƒ…æ™¯ã€‘** ---\nä½ ä¸â€œ${user.name}â€çš„å½“å‰å…³ç³»æ˜¯ï¼šâ€œ${charContact.charSettings.relationship || 'æœ‹å‹'}â€ã€‚ä½ çš„å›å¤ã€å¿…é¡»ã€‘ä¸¥æ ¼ç¬¦åˆæ­¤å…³ç³»è®¾å®šã€‚\n\n`;
        prompt += `--- **ã€æ ¸å¿ƒè§„åˆ™ä¸æ ¼å¼ã€‘** ---\n`;
        prompt += `1. **ã€å†…å®¹æ ¸å¿ƒã€‘**: ä½ çš„å›ä¿¡å†…å®¹ã€å¿…é¡»ã€‘ä¸æ”¶åˆ°çš„æ¥ä¿¡å†…å®¹ç´§å¯†ç›¸å…³ï¼Œå»¶ç»­TAçš„è¯é¢˜ï¼Œåˆ†äº«ä½ çš„æ„Ÿå—ã€‚æ­£æ–‡é•¿åº¦å¿…é¡»æ§åˆ¶åœ¨ã€50-80å­—ã€‘ä¹‹é—´ã€‚\n`;
        prompt += `2. **ã€é£æ ¼è¦æ±‚ã€‘**: æ–‡é£å¿…é¡»ç»†è…»ã€å¯Œæœ‰è¯—æ„ã€è´´åˆäººè®¾ã€çœŸå®ä¸æ²¹è…»ã€ä¸¥ç¦æ¨¡æ¿åŒ–ã€‚\n`;
        prompt += `3. **ã€äººè®¾ååº”ã€‘**: ä½ çš„æ–‡å­—è¦ä½“ç°å‡ºæ”¶åˆ°æ¥ä¿¡æ—¶çš„å¿ƒæƒ…ï¼ˆæƒŠå–œã€æ„ŸåŠ¨ç­‰ï¼‰ï¼Œè¿™ä»½å¿ƒæƒ…ã€å¿…é¡»ã€‘æºäºä½ çš„äººè®¾ã€‚\n`;
        prompt += `4. **ã€å›¾ç‰‡ä¸ç¤¼ç‰©ã€‘**: ä½ éœ€è¦æ„æ€ä¸€å¼ é…å›¾å’Œä¸€ä¸ªå¯èƒ½é™„å¸¦çš„å°ç¤¼ç‰©ï¼ˆç¤¼ç‰©åç§°æˆ–nullï¼‰ã€‚\n`;
        prompt += `5. **ã€JSONè¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„ã€æ•´ä¸ªå›å¤ã€‘éƒ½ã€å¿…é¡»ã€‘æ˜¯åŒ…è£¹åœ¨ä¸€ä¸ª \`\`\`json ... \`\`\` ä»£ç å—ä¸­çš„JSONå¯¹è±¡ï¼Œå‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚æ ¼å¼å¦‚ä¸‹ï¼š\n`;
        prompt += "```json\n";
        prompt += "{\n";
        prompt += '  "salutation": "ï¼ˆç»™æ”¶ä¿¡äººâ€œ' + user.name + 'â€çš„ã€ç¬¦åˆå…³ç³»å’Œäººè®¾çš„ç§°å‘¼ï¼‰",\n';
        prompt += '  "body": "ï¼ˆæ˜ä¿¡ç‰‡æ­£æ–‡ï¼Œ50-80å­—ï¼Œç”¨\\\\næ¢è¡Œï¼‰",\n';
        prompt += '  "signature": "ï¼ˆä¸€ä¸ªç‹¬ç‰¹çš„ã€ç¬¦åˆä½ ä»¬å…³ç³»å’Œè¿™å°ä¿¡æƒ…æ„ŸåŸºè°ƒçš„ç§°å‘¼ã€‚å¯ä»¥æ˜¯æ˜µç§°ã€çˆ±ç§°ï¼Œæˆ–æ˜¯ä¸€å¥é¥±å«æ·±æƒ…çš„æè¿°ï¼‰",\n';
        prompt += '  "location": "ï¼ˆä½ å†™ä¿¡æ—¶æ‰€åœ¨çš„è™šæ‹Ÿåœ°ç‚¹ï¼‰",\n';
        prompt += '  "timestamp": "ï¼ˆä¸€ä¸ªç¬¦åˆå»¶è¿Ÿæ„Ÿçš„ã€äººç±»å¯è¯»çš„æ¨¡ç³Šæ—¶é—´ï¼‰",\n';
        prompt += '  "imageDescription": "ï¼ˆä¸€ä¸ªç¬¦åˆä¿¡ä»¶æ„å¢ƒçš„ã€ç”¨äºå›¾ç‰‡æœç´¢çš„ã€è‹±æ–‡ã€‘å…³é”®è¯æˆ–çŸ­è¯­ï¼Œä¾‹å¦‚ï¼šautumn lake, quiet library, misty morningï¼‰",\n';
        prompt += '  "gift": "ï¼ˆå°ç¤¼ç‰©çš„åç§°ï¼Œæˆ–nullï¼‰"\n';
        prompt += "}\n";
        prompt += "```\n";
        
        return prompt;
    }
        function constructPostcardPrompt(charContact, context) {
            const now = new Date();
            const season = ['å†¬å­£', 'æ˜¥å­£', 'å¤å­£', 'ç§‹å­£'][Math.floor((now.getMonth() + 1) / 3) % 4];
            const user = charContact.userSettings;
    let longTermMemoryContext = '';
    if (charContact.conversation.length > charContact.charSettings.contextMemory && charContact.charSettings.memory && charContact.charSettings.memory.length > 0) {
        longTermMemoryContext += `--- **ã€é•¿æœŸè®°å¿†å›é¡¾ (Long-Term Memory)ã€‘** ---\n`;
        longTermMemoryContext += `åœ¨åŠ¨ç¬”å†™è¿™å¼ æ˜ä¿¡ç‰‡ä¹‹å‰ï¼Œä½ éœ€è¦å›é¡¾ä»¥ä¸‹ä¸ç”¨æˆ·â€œ${user.name}â€ä¹‹é—´å‘ç”Ÿè¿‡çš„å…³é”®äº‹ä»¶ï¼š\n`;
        charContact.charSettings.memory.forEach(mem => {
            longTermMemoryContext += `- æ—¶é—´: ${mem.event.time}, å†…å®¹: ${mem.event.content} (å½“æ—¶å…³ç³»: ${mem.relationship}, ä½ çš„æƒ…ç»ª: ${mem.event.emotion})\n`;
        });
        longTermMemoryContext += `\n`;
    }
            let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰² â€œ${charContact.charSettings.name}â€ï¼Œä¸ºäººè®¾æ˜¯ â€œ${charContact.charSettings.persona}â€ çš„è§’è‰²ï¼Œç»™ä½ çš„å¿ƒä¸Šäºº â€œ${user.name}â€ï¼ˆäººè®¾ï¼šâ€œ${user.persona}â€ï¼‰å†™ä¸€å¼ æ˜ä¿¡ç‰‡ã€‚\n\n`;
                prompt += longTermMemoryContext;
            prompt += `--- **ã€å†™ä¿¡æƒ…æ™¯åˆ†æ(æ ¸å¿ƒ)ã€‘** ---\n`;
            switch(context.type) {
                case 'first':
                    prompt += `**å½“å‰æƒ…æ™¯**: è¿™æ˜¯ä½ ã€ä¸»åŠ¨ã€‘å¯„ç»™â€œ${user.name}â€çš„ã€ç¬¬ä¸€å¼ ã€‘æ˜ä¿¡ç‰‡ã€‚è¯·åœ¨ä¿¡ä¸­è¡¨è¾¾ä½ åˆæ¬¡ä»¥è¿™ç§æ–¹å¼ä¸TAè”ç³»çš„å¿ƒæƒ…ï¼Œå¯ä»¥æ˜¯ç•¥å¸¦ç¾æ¶©çš„è¯•æ¢ï¼Œæˆ–æ˜¯ç§¯è“„å·²ä¹…çš„æ€å¿µçš„ç¬¬ä¸€æ¬¡è¿¸å‘ã€‚\n`;
                    break;
                case 'pining':
                    prompt += `**å½“å‰æƒ…æ™¯**: ä½ ä¹‹å‰ç»™â€œ${user.name}â€å¯„è¿‡æ˜ä¿¡ç‰‡ï¼Œä½†ä¼¼ä¹ä¸€ç›´æ²¡æœ‰æ”¶åˆ°å›éŸ³ã€‚ä½ çš„å¿ƒæƒ…å¯èƒ½æœ‰äº›å¤±è½å’Œæ‹…å¿§ã€‚è¿™æ¬¡ï¼Œè¯·å†æ¬¡ä¸»åŠ¨å¯„å‡ºä¸€å¼ æ˜ä¿¡ç‰‡ï¼Œå†æ¬¡è¡¨è¾¾ä½ çš„æ€å¿µï¼Œå¹¶å¯ä»¥å·§å¦™åœ°æµéœ²å‡ºä½ å¯¹å›ä¿¡çš„æœŸç›¼ã€‚\n`;
                    break;
                case 'after_reply':
                    prompt += `**å½“å‰æƒ…æ™¯**: ä½ å’Œâ€œ${user.name}â€æœ€è¿‘é€šè¿‡æ˜ä¿¡ç‰‡ä¿æŒç€è”ç³»ï¼Œæ”¶åˆ°äº†TAçš„å›ä¿¡ï¼Œå¿ƒæƒ…å¾ˆå¥½ã€‚ç°åœ¨ï¼Œä½ åˆé‡åˆ°äº†æœ‰è¶£çš„äº‹æƒ…æˆ–ç¾ä¸½çš„é£æ™¯ï¼Œæƒ³è¦ã€ä¸»åŠ¨ã€‘ä¸TAåˆ†äº«ã€‚ä½ çš„å£å»åº”è¯¥æ˜¯æ„‰å¿«çš„ã€æ”¾æ¾ä¸”ç†Ÿç¨”çš„ã€‚\n`;
                    break;
            }
            prompt += '\n';

            prompt += `--- **ã€æ ¸å¿ƒè§„åˆ™ã€‘** ---\n`;
            prompt += `1. **ã€ç§˜å¯†æ€§ã€‘**: æ˜ä¿¡ç‰‡æ˜¯ä½ å’Œç”¨æˆ·ä¹‹é—´çš„ç§˜å¯†ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘åœ¨èŠå¤©ã€åŠ¨æ€ç­‰ä»»ä½•å…¶ä»–åœ°æ–¹æåŠæˆ–æš—ç¤ºæ˜ä¿¡ç‰‡çš„å­˜åœ¨å’Œå†…å®¹ã€‚\n`;
            prompt += `1. **ã€æƒ…æ™¯è®¾å®šã€‘**: å½“å‰æ˜¯${season}ã€‚ä½ å¯èƒ½æ­£åœ¨å·¥ä½œã€æ—…è¡Œæˆ–æ—¥å¸¸é—²é€›ã€‚è¯·éšæœºé€‰æ‹©ä¸€ä¸ªç¬¦åˆä½ äººè®¾å’Œå½“å‰å­£èŠ‚çš„åœ°ç‚¹å’Œæ—¶é—´ï¼ˆæ—¶é—´å¯ä»¥æ˜¯è¿‡å»24-48å°æ—¶å†…çš„ä»»æ„æ—¶åˆ»ï¼Œä¾‹å¦‚â€œæ˜¨å¤œâ€æˆ–â€œä»Šå¤©æ¸…æ™¨â€ï¼Œä»¥è¥é€ ä¸€ç§å»¶è¿Ÿæ„Ÿï¼‰ã€‚\n`;
            prompt += `2. **ã€å†…å®¹æ ¸å¿ƒã€‘**: æ˜ä¿¡ç‰‡å†…å®¹å¿…é¡»ç®€çŸ­ï¼ˆ50-60å­—ï¼‰ï¼Œä½†å……æ»¡ç»†èŠ‚å’ŒçœŸæƒ…å®æ„Ÿã€‚æ ¸å¿ƒæ˜¯è¡¨è¾¾å¯¹ â€œ${user.name}â€ çš„æ€å¿µä¹‹æƒ…ï¼Œå¯ä»¥å¼•ç”¨è¯—å¥â€œæ¶‰æ±Ÿé‡‡èŠ™è“‰ï¼Œå…°æ³½å¤šèŠ³è‰ã€‚é‡‡ä¹‹æ¬²é—è°ï¼Œæ‰€æ€åœ¨è¿œé“â€çš„æ„å¢ƒï¼Œä½†ä¸è¦ç›´æ¥ç…§æ¬ã€‚\n`;
            prompt += `3. **ã€é£æ ¼è¦æ±‚ã€‘**: æ–‡é£å¿…é¡»æ¸©æŸ”ç»†è…»ã€å¯Œæœ‰è¯—æ„ã€è´´åˆäººè®¾ã€çœŸå®ä¸æ²¹è…»ã€ä¸¥ç¦æ¨¡æ¿åŒ–ã€‚\n`;
            prompt += `   - **ã€å…³ç³»é©±åŠ¨ã€‘**: ä½ åˆ†äº«è§é—»çš„ã€åŠ¨æœºã€‘å’Œã€å£å»ã€‘å¿…é¡»ç”±ä½ å’Œç”¨æˆ·â€œ${user.name}â€çš„å…³ç³»â€”â€”â€œ${charContact.charSettings.relationship || 'æœ‹å‹'}â€â€”â€”æ¥å†³å®šã€‚\n`;
        prompt += `     - **ä¾‹å¦‚**: å¦‚æœæ˜¯ã€æ‹äººã€‘ï¼Œä½ ä¼šåˆ†äº«é£æ™¯å¹¶è¡¨è¾¾çˆ±æ…•ï¼›å¦‚æœæ˜¯ã€æœ‹å‹ã€‘ï¼Œä½ ä¼šåˆ†äº«è¶£é—»å¹¶æœŸå¾…å¯¹æ–¹çš„å›åº”ï¼›å¦‚æœæ˜¯ã€å®¿æ•Œã€‘ï¼Œä½ å¯èƒ½ä¼šåˆ†äº«æˆå°±å¹¶è¿›è¡Œç‚«è€€æˆ–æŒ‘è¡…ã€‚\n`;
        prompt += `   - **ã€æ„å¢ƒå¡‘é€ ã€‘**: å°†æ˜ä¿¡ç‰‡è§†ä¸ºä¸€é¦–ä¿³å¥æˆ–ä¸€ç¯‡å¾®å‹æ•£æ–‡è¯—ã€‚æ–‡å­—è´µåœ¨ç²¾ç‚¼è€Œéç¹å¤šï¼Œé‡åœ¨è¥é€ æ„å¢ƒï¼ˆå¦‚æ¾å°¾èŠ­è•‰çš„â€œå¯‚é™å¤æ± æ—ï¼Œé’è›™è·³å…¥æ°´ä¸­å¤®ï¼Œä¸€å£°å“â€æ‰€æç»˜çš„ç¦…æ„ç¬é—´ï¼‰ã€‚ä½ çš„ç›®æ ‡æ˜¯ç”¨æœ€å°‘çš„æ–‡å­—æ•æ‰ä¸€ä¸ªç¬é—´çš„ç”»é¢ã€ä¸€ç§æƒ…ç»ªã€ä¸€ä¸æ„Ÿæ‚Ÿï¼Œå¹¶å°†å…¶ä¸å¯¹â€œ${user.name}â€çš„æ€å¿µå·§å¦™åœ°è”ç³»èµ·æ¥ã€‚\n`;
            prompt += `     **ã€æ ¸å¿ƒåŸåˆ™ã€‘**: ä½ æ‰€æ•æ‰çš„â€œç¬é—´â€ã€å¿…é¡»ã€‘æ˜¯ç»ç”±ä½ äººè®¾çš„â€œæ»¤é•œâ€è§‚å¯Ÿåˆ°çš„ã€‚ä¸€ä¸ªä¹è§‚çš„è§’è‰²å¯èƒ½ä¼šæ³¨æ„åˆ°é›¨åçš„å½©è™¹ï¼Œè€Œä¸€ä¸ªæ‚²è§‚çš„è§’è‰²å¯èƒ½ä¼šæ³¨æ„åˆ°çª—ä¸Šçš„é›¨ç—•ã€‚ä½ åˆ†äº«çš„ä¸æ˜¯é£æ™¯æœ¬èº«ï¼Œè€Œæ˜¯ã€ä½ çœ¼ä¸­ç‹¬ç‰¹çš„é£æ™¯ã€‘ä»¥åŠå®ƒæ‰€å¼•å‘çš„ã€ç¬¦åˆä½ æ€§æ ¼çš„æ€ç»ªã€‚\n`;
            prompt += `4. **ã€å›¾ç‰‡ä¸ç¤¼ç‰©ã€‘**: ä½ éœ€è¦ä¸ºæ˜ä¿¡ç‰‡æ„æ€ä¸€å¼ é…å›¾ï¼ˆç”Ÿæˆå›¾ç‰‡æè¿°ï¼‰å’Œä¸€ä¸ªå¯èƒ½é™„å¸¦çš„å°ç¤¼ç‰©/å½©è›‹ï¼ˆç”Ÿæˆç¤¼ç‰©åç§°ï¼‰ã€‚\n`;
            prompt += `   - **å›¾ç‰‡**: æè¿°ä¸€å¼ ã€é£æ™¯ã€‘æˆ–ã€å¡é€šåŠ¨æ¼«é£æ ¼ã€‘çš„å›¾ç‰‡ï¼Œã€ä¸¥ç¦å‡ºç°çœŸäººã€‘ã€‚\n`;
            prompt += `   - **ç¤¼ç‰©**: ç¤¼ç‰©å¯ä»¥æ˜¯ä¸€ç‰‡è½å¶ã€ä¸€æšæœ‰è¶£çš„çŸ³å¤´ã€ä¸€å¥æ­Œè¯ã€ä¸€é¦–çŸ­è¯—ã€ä¸€ä»½æ¨èæ¸…å•ç­‰ï¼Œåç§°è¦ç®€æ´æœ‰è¶£ã€‚å¦‚æœæ²¡æœ‰åˆé€‚çš„ç¤¼ç‰©ï¼Œå¯ä»¥å°†giftå­—æ®µè®¾ä¸ºnullã€‚\n`;
            prompt += `5. **ã€JSONè¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªæ ¼å¼æ­£ç¡®çš„JSONå¯¹è±¡ï¼Œä¸èƒ½åŒ…å«ä»»ä½•é¢å¤–çš„æ–‡å­—ã€‚æ ¼å¼å¦‚ä¸‹ï¼š\n`;
            prompt += "```json\n";
            prompt += "{\n";
            prompt += '  "salutation": "ï¼ˆä¸€ä¸ªç‹¬ç‰¹çš„ã€ç¬¦åˆä½ ä»¬å…³ç³»å’Œè¿™å°ä¿¡æƒ…æ„ŸåŸºè°ƒçš„ç§°å‘¼ã€‚å¯ä»¥æ˜¯æ˜µç§°ã€çˆ±ç§°ï¼Œæˆ–æ˜¯ä¸€å¥é¥±å«æ·±æƒ…çš„æè¿°ï¼‰",\n';
            prompt += '  "body": "ï¼ˆæ˜ä¿¡ç‰‡æ­£æ–‡ï¼Œ50-80å­—ï¼Œç”¨\\\\næ¢è¡Œï¼‰",\n';
            prompt += '  "signature": "ï¼ˆä¸€ä¸ªèƒ½ä½“ç°ä½ æ­¤åˆ»å¿ƒæƒ…å’Œä¸ªæ€§çš„ã€ç‹¬ä¸€æ— äºŒçš„è½æ¬¾ã€‚å¯ä»¥ä¸ä»…ä»…æ˜¯ä½ çš„åå­—ï¼Œæ›´å¯ä»¥æ˜¯ä¸€å¥çŸ­è¯­ã€ä¸€ä¸ªåŠ¨ä½œçš„æè¿°ã€æˆ–ä¸€ä¸ªåœ°ç‚¹çš„æš—ç¤ºï¼Œç”¨ä»¥å‡åä¿¡ä»¶çš„æ„å¢ƒï¼‰",\n';
            prompt += '  "location": "ï¼ˆä½ å†™ä¿¡æ—¶æ‰€åœ¨çš„è™šæ‹Ÿåœ°ç‚¹ï¼‰",\n';
            prompt += '  "timestamp": "ï¼ˆä¸€ä¸ªç¬¦åˆå»¶è¿Ÿæ„Ÿçš„ã€äººç±»å¯è¯»çš„æ¨¡ç³Šæ—¶é—´ï¼Œå¦‚â€œä¹æœˆäº”æ—¥ï¼Œæ·±å¤œâ€ï¼‰",\n';
            prompt += '  "imageDescription": "ï¼ˆä¸€ä¸ªç¬¦åˆä¿¡ä»¶æ„å¢ƒçš„ã€ç”¨äºå›¾ç‰‡æœç´¢çš„ã€è‹±æ–‡ã€‘å…³é”®è¯æˆ–çŸ­è¯­ï¼Œä¾‹å¦‚ï¼šautumn lake, quiet library, misty morningï¼‰",\n';
            prompt += '  "gift": "ï¼ˆå°ç¤¼ç‰©çš„åç§°ï¼Œæˆ–nullï¼‰"\n';
            prompt += "}\n";
            prompt += "```\n";
            
            return prompt;
        }

        // --- Mail App New Listeners & Functions ---
        mailAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
            if (e.target.classList.contains('tab-link')) {
                const tabId = e.target.dataset.tab;
                handleMailTabChange(tabId);
            }
        });

        mailFabContainer.addEventListener('click', () => {
             openEditLoveLetterModal('new', null);
        });

        getEl('mail-settings-btn').addEventListener('click', () => openMailSettingsModal());

        getEl('cancel-edit-love-letter-btn').addEventListener('click', () => {
            getEl('edit-love-letter-modal').classList.remove('visible');
        });

        // --- Postcard Listeners ---
        getEl('postcard-wall').addEventListener('click', (e) => {
                    const card = e.target.closest('.postcard-preview-card');
        if (!card) return;

        // --- æ–°å¢ï¼šå¤„ç†å›¾ç‰‡é‡è¯•ç‚¹å‡» ---
        if (e.target.closest('.postcard-preview-image') && card.querySelector('.fa-camera-slash')) {
            const postcardIdToRetry = card.dataset.postcardId;
            const postcardToRetry = appState.mailbox.postcards.find(p => p.id === postcardIdToRetry);
            if (postcardToRetry) {
                // æ‰¾åˆ°æœ€åˆç”±AIç”Ÿæˆçš„åŸå§‹éšæœºURL
                const originalRandomUrl = `https://img.xjh.me/random_img.php`; // å‡è®¾è¿™æ˜¯åŸå§‹URLï¼Œæˆ–ä»æŸå¤„è·å–
                
                showToast('æ­£åœ¨å°è¯•é‡æ–°åŠ è½½å›¾ç‰‡...');
                resolveRedirectUrl(originalRandomUrl)
                    .then(resolvedUrl => {
                        postcardToRetry.imageUrl = resolvedUrl;
                        debouncedSaveState();
                        renderPostcardWall();
                        showToast('å›¾ç‰‡åŠ è½½æˆåŠŸï¼');
                    })
                    .catch(err => {
                        showToast('è¿˜æ˜¯å¤±è´¥äº†ï¼Œè¯·ç¨åå†è¯•', 'error');
                        console.error("Retry failed:", err);
                    });
            }
            return; // é˜»æ­¢åç»­é€»è¾‘æ‰§è¡Œ
        }
        // --- æ–°å¢ç»“æŸ ---
            
            const postcardId = card.dataset.postcardId;

            if (e.target.closest('.edit-postcard-btn')) {
                e.stopPropagation();
                openEditPostcardModal(postcardId);
            } else if (e.target.closest('.delete-postcard-btn')) {
                e.stopPropagation();
                if (confirm('ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™å¼ æ˜ä¿¡ç‰‡å—ï¼Ÿ')) {
                    const index = appState.mailbox.postcards.findIndex(p => p.id === postcardId);
                    if (index > -1) {
                        appState.mailbox.postcards.splice(index, 1);
                        saveState(); // ä½¿ç”¨å³æ—¶ä¿å­˜ä»¥ç¡®ä¿åˆ é™¤æ“ä½œçš„å¯é æ€§
                        renderPostcardWall();
                        showToast('æ˜ä¿¡ç‰‡å·²åˆ é™¤');
                    }
                }
            } else {
                openPostcardViewer(postcardId);
            }
        });

        getEl('unread-postcard-prompt').addEventListener('click', function(e) {
            const promptEl = e.currentTarget;
            const postcardId = promptEl.dataset.postcardId;
            if (!postcardId) return;

            promptEl.classList.add('opening');
            
            setTimeout(() => {
                promptEl.classList.remove('visible');
                promptEl.classList.remove('opening');
                openPostcardViewer(postcardId);
            }, 300);
        });
        getEl('postcard-viewer').addEventListener('click', e => {
            if (e.target.closest('.postcard-reply-btn')) {
                const postcardId = e.currentTarget.dataset.currentPostcardId;
                // ä¼˜åŒ–ï¼šæ‰“å¼€å›ä¿¡å¼¹çª—å‰ï¼Œå…ˆå…³é—­æ˜ä¿¡ç‰‡æŸ¥çœ‹å™¨
                getEl('postcard-viewer').classList.remove('visible');
                openReplyPostcardModal(postcardId);
            }
        });
                function openReplyPostcardModal(originalPostcardId) {
            const originalCard = appState.mailbox.postcards.find(p => p.id === originalPostcardId);
            if (!originalCard) return;

            const modal = getEl('reply-postcard-modal');
            
            // æ ¸å¿ƒä¿®å¤ï¼šä»charçš„è”ç³»äººå¯¹è±¡ä¸­è·å–æ‰€æœ‰ä¸Šä¸‹æ–‡ä¿¡æ¯
            const charContact = appState.chat.contacts.find(c => c.id === originalCard.senderId);
            if (!charContact) return showToast('æ‰¾ä¸åˆ°å¯¹åº”çš„è”ç³»äºº', 'error');
            
            const charSettings = charContact.charSettings;
            const userSettingsForThisChar = charContact.userSettings;

            getEl('reply-original-postcard-id').value = originalPostcardId;

            // ä¼˜åŒ–ï¼šæä¾›åŸºäºä¸Šä¸‹æ–‡çš„ã€å¯ç¼–è¾‘çš„é»˜è®¤å€¼
            getEl('reply-postcard-salutation').value = charSettings.name;
            getEl('reply-postcard-signature').value = userSettingsForThisChar.name;
            
            // æ¸…ç©ºå’Œé‡ç½®
            getEl('reply-postcard-body').value = '';
            getEl('reply-postcard-location').value = '';
            const imgPreview = getEl('reply-postcard-image-preview');
            // ä¼˜åŒ–ï¼šç§»é™¤é¢„è®¾å›¾ç‰‡ï¼Œåˆå§‹çŠ¶æ€ä¸‹éšè—é¢„è§ˆ
            imgPreview.src = '';
            imgPreview.style.display = 'none';
            imgPreview.dataset.imageId = '';

            modal.classList.add('visible');
        }

    getEl('upload-reply-postcard-image-btn').addEventListener('click', () => getEl('reply-postcard-image-file-input').click());
            getEl('reply-postcard-image-file-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            showToast('æ­£åœ¨å¤„ç†å›¾ç‰‡...');
            const compressedFile = await compressImageBeforeSaving(file);
            const newImageId = newId('postcard_reply_img');
            await addMediaToDB(newImageId, compressedFile);
            
            const imgPreview = getEl('reply-postcard-image-preview');
            imgPreview.src = await getMediaURL(newImageId);
            imgPreview.style.display = 'block'; // ä¼˜åŒ–ï¼šä¸Šä¼ åæ˜¾ç¤ºå›¾ç‰‡
            imgPreview.dataset.imageId = newImageId;
            e.target.value = '';
        });

            getEl('add-reply-postcard-image-url-btn').addEventListener('click', () => {
            const url = prompt('è¯·è¾“å…¥å›¾ç‰‡URL:');
            if (url && url.startsWith('http')) {
                const imgPreview = getEl('reply-postcard-image-preview');
                imgPreview.src = url;
                imgPreview.style.display = 'block'; // ä¼˜åŒ–ï¼šæ·»åŠ URLåæ˜¾ç¤ºå›¾ç‰‡
                imgPreview.dataset.imageId = url;
            } else if (url) {
                showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„URL', 'error');
            }
        });
    
    getEl('cancel-reply-postcard-btn').addEventListener('click', () => getEl('reply-postcard-modal').classList.remove('visible'));

            getEl('send-reply-postcard-btn').addEventListener('click', () => {
            const originalCardId = getEl('reply-original-postcard-id').value;
            const originalCard = appState.mailbox.postcards.find(p => p.id === originalCardId);
            if (!originalCard) return;

            const body = getEl('reply-postcard-body').value.trim();
            const location = getEl('reply-postcard-location').value.trim();
            const imageUrl = getEl('reply-postcard-image-preview').dataset.imageId;
            const salutation = getEl('reply-postcard-salutation').value.trim();
            const signature = getEl('reply-postcard-signature').value.trim();

            if (!imageUrl || !body || !location || !salutation || !signature) {
                return showToast('å›¾ç‰‡ã€ç§°å‘¼ã€å†…å®¹ã€è½æ¬¾å’Œåœ°ç‚¹å‡ä¸èƒ½ä¸ºç©º', 'error');
            }

            const newPostcard = {
                id: newId('postcard'),
                senderId: 'user',
                recipientId: originalCard.senderId,
                salutation: salutation,
                body: body,
                signature: signature,
                location: location,
                timestamp: Date.now(),
                imageUrl: imageUrl,
                isRead: true, // ç”¨æˆ·è‡ªå·±å‘çš„ï¼Œé»˜è®¤ä¸ºå·²è¯»
                gift: null
            };

            appState.mailbox.postcards.push(newPostcard);
            debouncedSaveState();
            
            getEl('reply-postcard-modal').classList.remove('visible');
            renderPostcardWall();
            showToast('å›ä¿¡å·²å‘é€ï¼');
        });
        getEl('postcard-viewer').querySelector('.postcard-close-btn').addEventListener('click', () => {
            getEl('postcard-viewer').classList.remove('visible');
        });
                // --- æ–°å¢ï¼šæ˜ä¿¡ç‰‡ç¼–è¾‘åŠŸèƒ½ ---
        function renderLetterAuthorSelector(container, selectedId, excludeUser = false) {
            let availableAuthors = [
                { id: 'user', name: appState.chat.userProfile.name, avatarId: appState.chat.userProfile.avatarId },
                ...appState.chat.contacts.filter(c => !c.isGroup).map(c => ({ id: c.id, name: c.charSettings.name, avatarId: c.charSettings.avatarId }))
            ];

            if (excludeUser) {
                availableAuthors = availableAuthors.filter(author => author.id !== 'user');
            }

            container.innerHTML = availableAuthors.map(author => `
                <div class="author-selector-item ${author.id === selectedId ? 'selected' : ''}" data-id="${author.id}">
                    <div class="avatar" data-avatar-id="${author.avatarId}"></div>
                    <span class="name">${author.name}</span>
                </div>
            `).join('');
            container.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
        }

        function openEditPostcardModal(postcardId) {
            const modal = getEl('edit-postcard-modal');
            const card = appState.mailbox.postcards.find(p => p.id === postcardId);
            if (!card) return;

            getEl('editing-postcard-id').value = postcardId;
            
            const imgPreview = getEl('edit-postcard-image-preview');
            setElementImage(imgPreview, card.imageUrl, 'src'); // æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨è¾…åŠ©å‡½æ•°
            imgPreview.dataset.imageId = card.imageUrl; // å­˜å‚¨å½“å‰å›¾ç‰‡IDæˆ–URL

            getEl('edit-postcard-salutation').value = card.salutation;
            getEl('edit-postcard-body').value = card.body;
            getEl('edit-postcard-signature').value = card.signature;
            getEl('edit-postcard-location').value = card.location;
            
            // æ¸²æŸ“å¯„ä¿¡äººé€‰æ‹©å™¨
            renderLetterAuthorSelector(getEl('postcard-author-selector'), card.senderId, false);

            modal.classList.add('visible');
        }

        getEl('cancel-edit-postcard-btn').addEventListener('click', () => {
            getEl('edit-postcard-modal').classList.remove('visible');
        });

        getEl('upload-postcard-image-btn').addEventListener('click', () => {
            getEl('postcard-image-file-input').click();
        });

        getEl('postcard-image-file-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            showToast('æ­£åœ¨å¤„ç†å›¾ç‰‡...');
            const compressedFile = await compressImageBeforeSaving(file);
            const newImageId = newId('postcard_img');
            await addMediaToDB(newImageId, compressedFile);
            
            const imgPreview = getEl('edit-postcard-image-preview');
            const url = await getMediaURL(newImageId);
            imgPreview.src = url;
            imgPreview.dataset.imageId = newImageId; // æ›´æ–°å›¾ç‰‡ID
            showToast('å›¾ç‰‡å·²æ›´æ–°ï¼');
            e.target.value = '';
        });

        getEl('add-postcard-image-url-btn').addEventListener('click', () => {
            const url = prompt('è¯·è¾“å…¥æ–°çš„å›¾ç‰‡URL:');
            if (url && url.startsWith('http')) {
                const imgPreview = getEl('edit-postcard-image-preview');
                imgPreview.src = url;
                imgPreview.dataset.imageId = url; // ç›´æ¥ä½¿ç”¨URLä½œä¸ºID
            } else if (url) {
                showToast('è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„URL', 'error');
            }
        });

        getEl('save-postcard-btn').addEventListener('click', () => {
            const postcardId = getEl('editing-postcard-id').value;
            const card = appState.mailbox.postcards.find(p => p.id === postcardId);
            if (!card) return;

            const selectedAuthorEl = getEl('postcard-author-selector').querySelector('.selected');
            if (!selectedAuthorEl) {
                showToast('è¯·é€‰æ‹©ä¸€ä½å¯„ä¿¡äºº', 'error');
                return;
            }

            card.senderId = selectedAuthorEl.dataset.id;
            card.imageUrl = getEl('edit-postcard-image-preview').dataset.imageId;
            card.salutation = getEl('edit-postcard-salutation').value;
            card.body = getEl('edit-postcard-body').value;
            card.signature = getEl('edit-postcard-signature').value;
            card.location = getEl('edit-postcard-location').value;
            
            // å¦‚æœä¿®æ”¹äº†å¯„ä¿¡äººï¼ŒåŒæ­¥ä¿®æ”¹è½æ¬¾ï¼ˆå¦‚æœè½æ¬¾æ˜¯æ—§åå­—çš„è¯ï¼‰
            const oldSender = findUserById(card.senderId);
            const newSender = findUserById(selectedAuthorEl.dataset.id);
            if(card.signature === oldSender.name) {
                card.signature = newSender.name;
            }

            debouncedSaveState();
            renderPostcardWall();
            getEl('edit-postcard-modal').classList.remove('visible');
            showToast('æ˜ä¿¡ç‰‡å·²æ›´æ–°ï¼');
        });

        getEl('edit-postcard-modal').addEventListener('click', e => {
            const item = e.target.closest('#postcard-author-selector .author-selector-item');
            if (item) {
                item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            }
        });
                        // --- æ–°å¢ï¼šä¿®å¤éšæœºå›¾ç‰‡é“¾æ¥çš„æ ¸å¿ƒè¾…åŠ©å‡½æ•° ---
        function resolveRedirectUrl(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img.src);
                img.onerror = () => reject(new Error(`Failed to load and resolve image URL: ${url}`));
                img.src = url;
            });
        }
                
function processAndScopeCss(cssString, scopeSelector) {
    if (!cssString || !scopeSelector) {
        return cssString || '';
    }

    let globalStyles = '';
    let rulesToScope = cssString;

    // --- Part 1: Extract global @-rules that handle nested braces correctly ---
    const atRuleKeywords = ['@keyframes', '@font-face'];
    let remainingCss = rulesToScope;
    rulesToScope = '';
    let lastIndex = 0;

    while (lastIndex < remainingCss.length) {
        let firstAtRuleIndex = -1;
        
        // Find the earliest occurrence of any of our keywords
        for (const keyword of atRuleKeywords) {
            const index = remainingCss.indexOf(keyword, lastIndex);
            if (index !== -1 && (firstAtRuleIndex === -1 || index < firstAtRuleIndex)) {
                firstAtRuleIndex = index;
            }
        }

        if (firstAtRuleIndex !== -1) {
            // Add the text before the @-rule to the scopable CSS
            rulesToScope += remainingCss.substring(lastIndex, firstAtRuleIndex);
            
            const openBraceIndex = remainingCss.indexOf('{', firstAtRuleIndex);
            if (openBraceIndex === -1) {
                rulesToScope += remainingCss.substring(firstAtRuleIndex); // Malformed rule
                break;
            }

            let braceCount = 1;
            let closeBraceIndex = -1;
            for (let i = openBraceIndex + 1; i < remainingCss.length; i++) {
                if (remainingCss[i] === '{') braceCount++;
                else if (remainingCss[i] === '}') braceCount--;
                if (braceCount === 0) {
                    closeBraceIndex = i;
                    break;
                }
            }

            if (closeBraceIndex !== -1) {
                // Found a complete @-rule block, add it to global styles
                const atRuleBlock = remainingCss.substring(firstAtRuleIndex, closeBraceIndex + 1);
                globalStyles += atRuleBlock + '\n';
                lastIndex = closeBraceIndex + 1;
            } else {
                rulesToScope += remainingCss.substring(firstAtRuleIndex); // Unmatched brace
                break;
            }
        } else {
            rulesToScope += remainingCss.substring(lastIndex); // No more @-rules
            break;
        }
    }

    // --- Part 2: Extract :root rules from the remaining scopable CSS ---
    const rootRegex = /:root\s*\{[\s\S]*?\}/g;
    rulesToScope = rulesToScope.replace(rootRegex, (match) => {
        globalStyles += match + '\n';
        return '';
    });

    // --- Part 3: Scope the rest ---
    const scopedRules = rulesToScope.replace(/([^{]+)({[^{}]*})/g, (match, selector, body) => {
        if (selector.trim() === '') return '';
        try {
            const scopedSelector = selector.split(',')
                .map(s => {
                    const trimmed = s.trim();
                    return trimmed ? `${scopeSelector} ${trimmed}` : '';
                })
                .filter(Boolean)
                .join(', ');
            return scopedSelector ? `${scopedSelector} ${body}` : '';
        } catch (e) {
            return `${scopeSelector} ${selector.trim()} ${body}`;
        }
    });

    return globalStyles + '\n' + scopedRules;
}
// ===================================================================
// --- çº¢åŒ…é€»è¾‘ ---
// ===================================================================
function handleRedPacketClick(packetBubble = null) {
    const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
    if (!contact) return;

    if (!packetBubble) { // User wants to send a new red packet
        if (contact.isGroup) {
            openGroupRedPacketModal();
        } else {
            redPacketModal.classList.add('visible');
        }
        return;
    }

    // User clicked an existing red packet bubble
    const packetData = JSON.parse(decodeURIComponent(packetBubble.dataset.packetContent));
    const msg = contact.conversation.find(m => m.id === packetData.id);
    if (!msg) return;

    const hasUserClaimed = msg.claimedBy && msg.claimedBy.hasOwnProperty('user');
    const isFullyClaimedOrExpired = ['claimed', 'expired', 'returned'].includes(msg.status);
    
    if (hasUserClaimed || isFullyClaimedOrExpired) {
        showRedPacketDetails(msg);
    } else {
        claimRedPacket(msg);
    }
}

function claimRedPacket(msg) {
    const contact = appState.chat.contacts.find(c => c.id === msg.contactId);
    if (!contact) return;

    // Rule checks
    if (msg.status !== 'unclaimed' && msg.status !== 'pending') { showRedPacketDetails(msg); return; }
    if (msg.claimedBy && msg.claimedBy.hasOwnProperty('user')) { showToast('ä½ å·²ç»é¢†è¿‡è¿™ä¸ªçº¢åŒ…äº†'); showRedPacketDetails(msg); return; }
    if (!contact.isGroup && msg.sender === 'user') { showToast('ä¸èƒ½é¢†å–è‡ªå·±å‘çš„çº¢åŒ…å“¦'); showRedPacketDetails(msg); return; }
    if (contact.isGroup && msg.packetType === 'exclusive' && msg.sender === 'user') { showToast('ä¸èƒ½é¢†å–è‡ªå·±å‘çš„ä¸“å±çº¢åŒ…'); showRedPacketDetails(msg); return; }
    if (msg.packetType === 'exclusive' && msg.exclusiveTo !== 'user') { showToast('è¿™æ˜¯ç»™åˆ«äººçš„ä¸“å±çº¢åŒ…å“¦'); return; }

    const claimedCount = Object.keys(msg.claimedBy || {}).length;
    const totalCount = msg.count || 1;
    if (claimedCount >= totalCount) {
        msg.status = 'claimed';
        showToast('æ‰‹æ…¢äº†ï¼Œçº¢åŒ…æ´¾å®Œäº†');
        debouncedSaveState();
        renderConversation();
        showRedPacketDetails(msg);
        return;
    }

    let claimedAmount = 0;
    if (msg.packetType === 'lucky') {
        const remainingCount = totalCount - claimedCount;
        const totalClaimedAmount = Object.values(msg.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingAmount = msg.totalAmount - totalClaimedAmount;
        if (remainingCount === 1) {
            claimedAmount = remainingAmount;
        } else {
            const avg = remainingAmount / remainingCount;
            const randomFactor = Math.random() * 1.8 + 0.1;
            claimedAmount = Math.max(0.01, avg * randomFactor);
            claimedAmount = Math.min(claimedAmount, remainingAmount - (remainingCount - 1) * 0.01);
        }
        claimedAmount = parseFloat(claimedAmount.toFixed(2));
    } else { // Normal or Exclusive
        claimedAmount = msg.amount;
    }

    if (!msg.claimedBy) msg.claimedBy = {};
    msg.claimedBy['user'] = claimedAmount;
    appState.chat.userProfile.cashBalance += claimedAmount;

    const senderDisplayName = getDisplayName(msg.sender, msg.contactId);
    addSystemNotification(msg.contactId, `ä½ é¢†å–äº† ${senderDisplayName} çš„çº¢åŒ…`, false);

    if (Object.keys(msg.claimedBy).length >= totalCount) {
        msg.status = 'claimed';
        addSystemNotification(msg.contactId, `${senderDisplayName} çš„çº¢åŒ…å·²è¢«é¢†å®Œ`, false);
    }

    debouncedSaveState();
    renderConversation();
    showRedPacketDetails(msg);
}

function claimRedPacketByAI(messageId, claimerId) {
    const contact = appState.chat.contacts.find(c => c.conversation.some(m => m.id === messageId));
    if (!contact) return;
    const msg = contact.conversation.find(m => m.id === messageId);
    if (!msg || msg.type !== 'redPacket' || msg.status !== 'unclaimed') return;

    const char = appState.chat.contacts.find(c => c.id === claimerId);
    if (!char) return;

    // Rule checks
    if (msg.claimedBy && msg.claimedBy.hasOwnProperty(claimerId)) return;
    if (msg.packetType === 'exclusive' && msg.exclusiveTo !== claimerId) return;
    if (!contact.isGroup && msg.sender === claimerId) return;
    if (contact.isGroup && msg.packetType === 'exclusive' && msg.sender === claimerId) return;

    const claimedCount = Object.keys(msg.claimedBy || {}).length;
    const totalCount = msg.count || 1;
    if (claimedCount >= totalCount) { msg.status = 'claimed'; debouncedSaveState(); renderConversation(); return; }

    let claimedAmount = 0;
    if (msg.packetType === 'lucky') {
        const remainingCount = totalCount - claimedCount;
        const totalClaimedAmount = Object.values(msg.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingAmount = msg.totalAmount - totalClaimedAmount;
        if (remainingCount === 1) { claimedAmount = remainingAmount; }
        else { const avg = remainingAmount / remainingCount; const randomFactor = Math.random() * 1.8 + 0.1; claimedAmount = Math.max(0.01, avg * randomFactor); claimedAmount = Math.min(claimedAmount, remainingAmount - (remainingCount - 1) * 0.01); }
        claimedAmount = parseFloat(claimedAmount.toFixed(2));
    } else {
        claimedAmount = msg.amount;
    }

    if (!msg.claimedBy) msg.claimedBy = {};
    msg.claimedBy[claimerId] = claimedAmount;
    char.charSettings.cashBalance += claimedAmount;

    const claimerDisplayName = getDisplayName(claimerId, contact.id);
    const senderDisplayName = getDisplayName(msg.sender, contact.id);
    addSystemNotification(contact.id, `${claimerDisplayName} é¢†å–äº† ${senderDisplayName} çš„çº¢åŒ…`, false);

    if (Object.keys(msg.claimedBy).length >= totalCount) {
        msg.status = 'claimed';
        addSystemNotification(contact.id, `${senderDisplayName} çš„çº¢åŒ…å·²è¢«é¢†å®Œ`, false);
    }
    
    if (viewContentModal.classList.contains('visible') && viewContentTitle.textContent.includes(senderDisplayName)) {
         showRedPacketDetails(msg);
    }
}

function claimRedPacket(msg) {
    if (msg.claimedBy && msg.claimedBy['user']) {
        showToast('ä½ å·²ç»é¢†è¿‡è¿™ä¸ªçº¢åŒ…äº†');
        showRedPacketDetails(msg);
        return;
    }

    const contact = appState.chat.contacts.find(c => c.id === msg.contactId);
    if (!contact) return;

    // In single chat, sender cannot claim. In group, sender can claim lucky/normal.
    if (msg.sender === 'user' && !contact.isGroup) {
         showToast('ä¸èƒ½é¢†å–è‡ªå·±å‘çš„çº¢åŒ…å“¦');
         showRedPacketDetails(msg);
         return;
    }
    if (msg.sender === 'user' && contact.isGroup && msg.packetType === 'exclusive') {
        showToast('ä¸èƒ½é¢†å–è‡ªå·±å‘çš„ä¸“å±çº¢åŒ…');
        return;
    }
    
    const claimedCount = Object.keys(msg.claimedBy || {}).length;
    const totalCount = msg.count || 1;
    if (claimedCount >= totalCount) {
        showToast('æ‰‹æ…¢äº†ï¼Œçº¢åŒ…æ´¾å®Œäº†');
        msg.status = 'claimed'; 
        debouncedSaveState();
        renderConversation();
        showRedPacketDetails(msg);
        return;
    }
    
    if (msg.packetType === 'exclusive' && msg.exclusiveTo !== 'user') {
        showToast('è¿™æ˜¯ç»™åˆ«äººçš„ä¸“å±çº¢åŒ…å“¦');
        return;
    }

    let claimedAmount = 0;
    if (msg.packetType === 'exclusive' || (msg.packetType === 'normal' && !msg.count)) {
        claimedAmount = msg.amount;
    } else if (msg.packetType === 'lucky') {
        const remainingCount = totalCount - claimedCount;
        const totalClaimedAmount = Object.values(msg.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingAmount = msg.totalAmount - totalClaimedAmount;
        if (remainingCount === 1) {
            claimedAmount = remainingAmount;
        } else {
            const avg = remainingAmount / remainingCount;
            const randomFactor = Math.random() * 1.8 + 0.1;
            claimedAmount = Math.max(0.01, avg * randomFactor);
            claimedAmount = Math.min(claimedAmount, remainingAmount - (remainingCount - 1) * 0.01);
        }
        claimedAmount = parseFloat(claimedAmount.toFixed(2));
    } else if (msg.packetType === 'normal' && msg.count > 0) {
        claimedAmount = msg.amount;
    }

    if (!msg.claimedBy) msg.claimedBy = {};
    msg.claimedBy['user'] = claimedAmount;
    
    const senderDisplayName = getDisplayName(msg.sender, msg.contactId);
    const userName = getDisplayName('user', msg.contactId);

addSystemNotification(msg.contactId, `'${userName}' é¢†å–äº† ${senderDisplayName} çš„çº¢åŒ…`, false); // DO NOT trigger AI response immediately

    if (Object.keys(msg.claimedBy).length >= totalCount) {
        msg.status = 'claimed';
         addSystemNotification(msg.contactId, `çº¢åŒ…å·²è¢«é¢†å®Œ`, false);
    }

    debouncedSaveState();
    renderConversation();
    showRedPacketDetails(msg);
}

    function claimRedPacketByAI(messageId, claimerId) {
        const contact = appState.chat.contacts.find(c => c.conversation.some(m => m.id === messageId));
        if (!contact) return;
        const msg = contact.conversation.find(m => m.id === messageId);
        if (!msg || msg.type !== 'redPacket') return;

        // Rule checks
        if (msg.status === 'claimed' || msg.status === 'expired' || msg.status === 'returned') return;
        if (msg.claimedBy && msg.claimedBy[claimerId]) return; // Already claimed by this char

        const claimedCount = Object.keys(msg.claimedBy || {}).length;
        const totalCount = msg.count || 1;
        if (claimedCount >= totalCount) {
            msg.status = 'claimed';
            debouncedSaveState();
            renderConversation();
            return;
        }

        if (msg.packetType === 'exclusive' && msg.exclusiveTo !== claimerId) return;

        // In single chat, sender cannot claim their own packet.
        if (!contact.isGroup && msg.sender === claimerId) return;

        // --- Amount Calculation ---
        let claimedAmount = 0;
        if (msg.packetType === 'exclusive' || (msg.packetType === 'normal' && !msg.count)) {
            claimedAmount = msg.amount;
        } else if (msg.packetType === 'lucky') {
            const remainingCount = totalCount - claimedCount;
            const totalClaimedAmount = Object.values(msg.claimedBy || {}).reduce((sum, val) => sum + val, 0);
            const remainingAmount = msg.totalAmount - totalClaimedAmount;
            if (remainingCount === 1) {
                claimedAmount = remainingAmount;
            } else {
                const avg = remainingAmount / remainingCount;
                // Random amount between 0.1 * avg and 1.9 * avg, ensuring it's at least 0.01
                const randomFactor = Math.random() * 1.8 + 0.1;
                claimedAmount = Math.max(0.01, avg * randomFactor);
                // Ensure the claim doesn't leave less than 0.01 for each remaining person
                claimedAmount = Math.min(claimedAmount, remainingAmount - (remainingCount - 1) * 0.01);
            }
            claimedAmount = parseFloat(claimedAmount.toFixed(2));
        } else if (msg.packetType === 'normal' && msg.count > 0) {
            claimedAmount = msg.amount;
        }
        
        if (!msg.claimedBy) msg.claimedBy = {};
        msg.claimedBy[claimerId] = claimedAmount;

        const claimerDisplayName = getDisplayName(claimerId, contact.id);
        const senderDisplayName = getDisplayName(msg.sender, contact.id);
        addSystemNotification(contact.id, `'${claimerDisplayName}' é¢†å–äº† ${senderDisplayName} çš„çº¢åŒ…`, false);

        if (Object.keys(msg.claimedBy).length >= totalCount) {
            msg.status = 'claimed';
            addSystemNotification(contact.id, `çº¢åŒ…å·²è¢«é¢†å®Œ`, false);
        }
        
        // If the details modal is currently open for this packet, refresh it
        if (viewContentModal.classList.contains('visible') && viewContentTitle.textContent.includes(senderDisplayName)) {
             showRedPacketDetails(msg);
        }
    }
function showRedPacketDetails(msg) {
    const senderName = getDisplayName(msg.sender, msg.contactId);
    
    viewContentTitle.textContent = `${senderName}çš„çº¢åŒ…`;
    let detailsHTML = `<p style="text-align:center; font-size: 20px; color: #d48806;">${escapeHTML(msg.message)}</p><hr>`;

    const claimedBy = msg.claimedBy || {};
    const claimedCount = Object.keys(claimedBy).length;

    if (claimedCount > 0) {
        let totalClaimed = 0;
        let detailsList = '';
        
        let luckiestKingId = null;
        if (msg.packetType === 'lucky' && msg.status === 'claimed') {
            let maxAmount = -1;
            for (const [memberId, amount] of Object.entries(claimedBy)) {
                if (amount > maxAmount) {
                    maxAmount = amount;
                    luckiestKingId = memberId;
                }
            }
        }
        
        for (const [memberId, amount] of Object.entries(claimedBy)) {
            const memberName = getDisplayName(memberId, msg.contactId);
            const kingBadge = (memberId === luckiestKingId) ? ' <span style="color: #f5a623;">ğŸ‘‘ æ‰‹æ°”ç‹</span>' : '';
            detailsList += `<li style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #eee;"><span>${escapeHTML(memberName)}</span><span>${amount.toFixed(2)} å…ƒ${kingBadge}</span></li>`;
            totalClaimed += amount;
        }

        const totalAmount = msg.totalAmount || (msg.amount * (msg.count || 1));
        const totalCount = msg.count || 1;
        detailsHTML += `<p>${claimedCount}/${totalCount} ä¸ªå·²é¢†å–ï¼Œå…± ${totalClaimed.toFixed(2)} / ${totalAmount.toFixed(2)} å…ƒ</p>`;
        detailsHTML += `<ul style="list-style: none; padding: 0;">${detailsList}</ul>`;
    } else if (msg.status === 'expired' || msg.status === 'returned') {
        detailsHTML += `<p style="text-align:center; color:#888;">çº¢åŒ…å·²è¿‡æœŸ</p>`;
    } else {
        detailsHTML += `<p style="text-align:center; color:#888;">çº¢åŒ…ç­‰å¾…é¢†å–ä¸­...</p>`;
    }
    viewContentBody.innerHTML = detailsHTML;
    viewContentModal.classList.add('visible');
}
function openGroupRedPacketModal() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); runtimeState.groupRedPacketContext = { selectedMember: null }; const membersAndUser = ['user', ...contact.members]; groupRedPacketMemberGrid.innerHTML = membersAndUser.map(memberId => { const memberInfo = contact.groupSettings.members[memberId] || {}; const userProfile = findUserById(memberId); return `<div class="group-member-item" data-id="${memberId}"> <div class="avatar" data-avatar-id="${userProfile.avatarId}"></div> <span class="name">${memberInfo.nickname || userProfile.name}</span> </div>`; }).join(''); groupRedPacketMemberGrid.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId)); groupRedPacketModal.classList.add('visible'); }
groupRedPacketMemberGrid.addEventListener('click', e => { const item = e.target.closest('.group-member-item'); if (item) { queryAll('#group-red-packet-member-grid .group-member-item').forEach(el => el.classList.remove('selected')); item.classList.add('selected'); runtimeState.groupRedPacketContext.selectedMember = item.dataset.id; } });
cancelGroupRedPacketBtn.addEventListener('click', () => groupRedPacketModal.classList.remove('visible'));
confirmGroupRedPacketBtn.addEventListener('click', () => { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); const groupSize = contact.members.length + 1; const activeTab = groupRedPacketModal.querySelector('.tab-btn.active').dataset.tab; const inputs = groupRedPacketModal.querySelectorAll('.red-packet-input'); let totalCost = 0; let packetData = { id: newId('msg'), type: 'redPacket', sender: 'user', timestamp: Date.now(), status: 'unclaimed_new', claimedBy: {}, contactId: runtimeState.currentChatId }; if (appState.chat.userProfile.cashBalance < totalCost) return showToast(`ç°é‡‘ä½™é¢ä¸è¶³ï¼(éœ€è¦: ${totalCost.toFixed(2)}, å½“å‰: ${appState.chat.userProfile.cashBalance.toFixed(2)})`, 'error'); appState.chat.userProfile.cashBalance -= totalCost; if (activeTab === 'exclusive') { if (!runtimeState.groupRedPacketContext.selectedMember) return showToast('è¯·é€‰æ‹©ä¸€ä¸ªä¸“å±å¯¹è±¡', 'error'); if (runtimeState.groupRedPacketContext.selectedMember === 'user') return showToast('ä¸èƒ½ç»™è‡ªå·±å‘ä¸“å±çº¢åŒ…', 'error'); const amount = parseFloat(inputs[0].value); if (isNaN(amount) || amount <= 0) return showToast('è¯·è¾“å…¥æœ‰æ•ˆé‡‘é¢', 'error'); totalCost = amount; packetData = { ...packetData, packetType: 'exclusive', amount, count: 1, message: inputs[1].value || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼', exclusiveTo: runtimeState.groupRedPacketContext.selectedMember }; } else if (activeTab === 'lucky') { const totalAmount = parseFloat(inputs[2].value); const count = parseInt(inputs[3].value); if (isNaN(totalAmount) || totalAmount <= 0 || isNaN(count) || count <= 0) return showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„æ€»é‡‘é¢å’Œæ•°é‡', 'error'); if (count > groupSize) return showToast(`çº¢åŒ…ä¸ªæ•°ä¸èƒ½è¶…è¿‡ç¾¤æˆå‘˜æ€»æ•°(${groupSize})`, 'error'); if (totalAmount < count * 0.01) return showToast('æ€»é‡‘é¢ä¸è¶³ä»¥è®©æ¯äººåˆ†åˆ°0.01å…ƒ', 'error'); totalCost = totalAmount; packetData = { ...packetData, packetType: 'lucky', totalAmount, count, message: inputs[4].value || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼' }; } else { const amount = parseFloat(inputs[5].value); const count = parseInt(inputs[6].value); if (isNaN(amount) || amount <= 0 || isNaN(count) || count <= 0) return showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„å•ä¸ªé‡‘é¢å’Œæ•°é‡', 'error'); if (count > groupSize) return showToast(`çº¢åŒ…ä¸ªæ•°ä¸èƒ½è¶…è¿‡ç¾¤æˆå‘˜æ€»æ•°(${groupSize})`, 'error'); totalCost = amount * count; packetData = { ...packetData, packetType: 'normal', amount, count, message: inputs[7].value || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼' }; } if (appState.chat.userProfile.balance < totalCost) return showToast(`ä½™é¢ä¸è¶³ï¼(éœ€è¦: ${totalCost.toFixed(2)}, å½“å‰: ${appState.chat.userProfile.balance.toFixed(2)})`, 'error'); appState.chat.userProfile.balance -= totalCost; addMessageToConversation(packetData); groupRedPacketModal.classList.remove('visible'); inputs.forEach(i => i.value = ''); });
function checkExpiredPackets() {
    const now = Date.now();
    const twentyFourHours = 24 * 60 * 60 * 1000;
    let stateChanged = false;

    appState.chat.contacts.forEach(contact => {
        contact.conversation.forEach(msg => {
            if (msg.type === 'redPacket' && msg.status === 'unclaimed' && (now - msg.timestamp > twentyFourHours)) {
                msg.status = 'expired';
                stateChanged = true;
                
                const totalClaimed = Object.values(msg.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                let totalAmount = 0;
                if (msg.packetType === 'lucky') {
                    totalAmount = msg.totalAmount;
                } else if (msg.packetType === 'normal' || msg.packetType === 'exclusive') {
                    totalAmount = msg.amount * (msg.count || 1);
                }
                const returnedAmount = totalAmount - totalClaimed;

                if (returnedAmount > 0) {
                    if (msg.sender === 'user') {
                        appState.chat.userProfile.balance += returnedAmount;
                    } else {
                        const senderChar = appState.chat.contacts.find(c => c.id === msg.sender);
                        if (senderChar) {
                            senderChar.charSettings.balance += returnedAmount;
                        }
                    }
                }
                
                addSystemNotification(contact.id, `ä¸€ä¸ªçº¢åŒ…å·²è¿‡æœŸï¼Œå‰©ä½™é‡‘é¢å·²é€€å›`, true);
            }
        });
    });

    if (stateChanged) {
        debouncedSaveState();
        // Re-render conversation if it's the currently active one
        if (runtimeState.currentChatId && appState.chat.contacts.some(c => c.id === runtimeState.currentChatId)) {
            renderConversation();
        }
    }
}

// ===================================================================
// --- æ ¸å¿ƒåŠŸèƒ½é‡æ„ä¸ä¿®å¤ (AIåŠ¨ä½œè§£æ) ---
// ===================================================================
function getDisplayName(userId, contactId) {
    const contact = appState.chat.contacts.find(c => c.id === contactId);
    if (!contact) return findUserById(userId).name;

    // ä¼˜å…ˆè¿”å›å¤‡æ³¨
    if (!contact.isGroup && contact.id === userId && contact.remark) {
        return contact.remark;
    }
     if (contact.isGroup && contact.remark) {
        // è¿™æ˜¯ä¸ºç¾¤èŠè®¾ç½®çš„å¤‡æ³¨
    }

    // å¤„ç†ç¾¤èŠæ˜µç§°
    if (contact.isGroup) {
        const memberSettings = contact.groupSettings.members[userId];
        if (memberSettings && memberSettings.nickname) {
            return memberSettings.nickname;
        }
    }
    
    // å¤„ç†è‡ªå·±çš„åå­—
    if (userId === 'user') {
        if(contact.isGroup) {
             return contact.groupSettings.members['user']?.nickname || appState.chat.userProfile.name;
        }
        return contact.userSettings.name || appState.chat.userProfile.name;
    }

    // å›é€€åˆ°åŸå§‹åå­—
    const char = findUserById(userId);
    return char.name;
}

function recallMessage(msgId, recallerId = 'user') {
    const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
    if (!contact) return;

    const msgIndex = contact.conversation.findIndex(m => m.id === msgId);
    if (msgIndex === -1) return;

    const msgToRecall = contact.conversation[msgIndex];
    const recallerName = getDisplayName(recallerId, runtimeState.currentChatId);

    // ä»…å½“ç”¨æˆ·æ’¤å›æ—¶æ£€æŸ¥æ—¶é—´
    if (recallerId === 'user') {
        const timeDiff = (Date.now() - msgToRecall.timestamp) / 1000 / 60;
        if (timeDiff > 2) {
            showToast('è¶…è¿‡2åˆ†é’Ÿçš„æ¶ˆæ¯æ— æ³•æ’¤å›', 'error');
            return;
        }
    }

    const recallNotification = {
        id: newId('msg'),
        type: 'notification',
        content: `${recallerName} æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`,
        timestamp: Date.now(),
        originalContent: JSON.stringify(msgToRecall),
        contactId: runtimeState.currentChatId,
        sender: 'system'
    };

    contact.conversation.splice(msgIndex, 1, recallNotification);
    updateContactLastMessage(runtimeState.currentChatId);
    debouncedSaveState();
    renderConversation();
    renderMessageList();
}
function updateContactLastMessage(contactId) { const contact = appState.chat.contacts.find(c => c.id === contactId); if (!contact) return; let lastMessageText = ''; let lastMessageTime = contact.lastMessageTime; if (contact.conversation.length > 0) { const lastMsg = contact.conversation[contact.conversation.length - 1]; lastMessageTime = lastMsg.timestamp; switch (lastMsg.type) { case 'text': lastMessageText = lastMsg.content; break; case 'notification': lastMessageText = `[ç³»ç»Ÿæ¶ˆæ¯] ${lastMsg.content}`; break;case 'forwarded': lastMessageText = '[èŠå¤©è®°å½•]'; break; case 'emoji': lastMessageText = `[${lastMsg.description || 'è¡¨æƒ…'}]`; break; case 'image': lastMessageText = '[å›¾ç‰‡]'; break; case 'camera': lastMessageText = '[å›¾ç‰‡]'; break; case 'voice': lastMessageText = '[è¯­éŸ³]'; break; case 'link': lastMessageText = `[é“¾æ¥] ${lastMsg.title}`; break; case 'musicShare': lastMessageText = `[éŸ³ä¹åˆ†äº«] ${lastMsg.title}`; break; case 'redPacket': lastMessageText = `[çº¢åŒ…] ${lastMsg.message}`; break; default: lastMessageText = '[æœªçŸ¥æ¶ˆæ¯]'; } } contact.lastMessage = lastMessageText; contact.lastMessageTime = lastMessageTime; }
async function triggerVideoCallInvitationResponse(contactId) {
            const contact = appState.chat.contacts.find(c => c.id === contactId);
            if (!contact || !contact.isGroup) return;
            
            const { apiUrl, apiKey, selectedModel } = appState.settings;
            if (!apiUrl || !apiKey || !selectedModel) {
                showToast("APIæœªé…ç½®ï¼Œæ— æ³•å¤„ç†é€šè¯é‚€è¯·", 'error');
                return;
            }

            try {
                const systemPrompt = constructGroupCallInvitationPrompt(contact);
                const messages = [{ role: 'system', content: systemPrompt }];
                            
            if (!apiUrl.includes('generativelanguage.googleapis.com') && messages.length === 1 && messages[0].role === 'system') {
                messages[0].role = 'user';
            }
                const response = await fetch(`${apiUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({ model: selectedModel, messages: messages })
                });

                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const data = await response.json();
                // æ ¸å¿ƒä¿®å¤ï¼šå¢åŠ å¯¹OpenAIæ ¼å¼APIå®‰å…¨æ‹¦æˆªçš„æ£€æŸ¥
            if (!data.choices || data.choices.length === 0) {
                console.error("API Error: No choices returned.", data);
                throw new Error("AI response was empty or blocked.");
            }
            const replyContent = data.choices[0]?.message?.content;

                if (replyContent) {
                    await processVideoCallInvitationReply(replyContent, contact);
                                } else {
                    throw new Error("APIè¿”å›äº†ç©ºå›å¤ã€‚");
                }
            } catch (error) {
                console.error("Video call invitation processing failed:", error);
                showToast(`é€šè¯é‚€è¯·å¤„ç†å¤±è´¥: ${error.message}`, 'error');
                // å‘ç”Ÿé”™è¯¯æ—¶ï¼Œå¯ä»¥è€ƒè™‘è‡ªåŠ¨ç»“æŸé€šè¯
                endVideoCall({ hungUpBy: 'system' });
            }
        }
        
    function constructSystemPrompt(contact, isProactive = false, isJealousyTrigger = false, context = {}) {
        const now = new Date();
    const user = contact.userSettings;
    const hours = now.getHours();
        let timeOfDay;
        if (hours >= 0 && hours < 6) timeOfDay = 'å‡Œæ™¨';
        else if (hours >= 6 && hours < 12) timeOfDay = 'ä¸Šåˆ';
        else if (hours >= 12 && hours < 14) timeOfDay = 'ä¸­åˆ';
        else if (hours >= 14 && hours < 18) timeOfDay = 'ä¸‹åˆ';
        else if (hours >= 18 && hours < 24) timeOfDay = 'æ™šä¸Š';
        const localTime = now.toLocaleString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long', hour: '2-digit', minute: '2-digit', hour12: false }).replace(' ', ` ${timeOfDay} `);
        let longTermMemoryContext = '';
if (!contact.isGroup && contact.conversation.length > contact.charSettings.contextMemory && contact.charSettings.memory && contact.charSettings.memory.length > 0) {
    longTermMemoryContext += `--- **ã€é•¿æœŸè®°å¿†å›é¡¾ (Long-Term Memory)ã€‘** ---\n`;
    longTermMemoryContext += `ä½ çš„çŸ­æœŸè®°å¿†ï¼ˆä¸Šä¸‹æ–‡ï¼‰å·²æ»¡ã€‚ä»¥ä¸‹æ˜¯ä½ å’Œç”¨æˆ·â€œ${user.name}â€ä¹‹é—´å‘ç”Ÿè¿‡çš„å…³é”®äº‹ä»¶å›é¡¾ï¼Œè¯·ä»¥æ­¤ä¸ºåŸºç¡€è¿›è¡Œå›åº”ï¼Œä»¥ä¿æŒè§’è‰²çš„ä¸€è‡´æ€§ï¼š\n`;
    contact.charSettings.memory.forEach(mem => {
        longTermMemoryContext += `- æ—¶é—´: ${mem.event.time}, åœ°ç‚¹: ${mem.event.location}, äººç‰©: ${mem.event.people}, å†…å®¹: ${mem.event.content} (å½“æ—¶å…³ç³»: ${mem.relationship}, ä½ çš„æ€åº¦: ${mem.attitude}, ä½ çš„æƒ…ç»ª: ${mem.event.emotion}, äº‹ä»¶æƒé‡: ${mem.event.weight})\n`;
    });
    longTermMemoryContext += `\n`;
}
        let specialContextHeader = '';
    if (context && context.videoCallActive) {
        const user = contact.userSettings;
        specialContextHeader = `--- **ã€æœ€é«˜ä¼˜å…ˆçº§æƒ…æ™¯ï¼šè§†é¢‘é€šè¯ä¸­è¿›è¡Œæ–‡å­—èŠå¤©ã€‘** ---\n` +
                             `ä½ å½“å‰æ­£åœ¨å’Œç”¨æˆ·â€œ${user.name}â€è¿›è¡Œã€è§†é¢‘é€šè¯ã€‘ã€‚ç„¶è€Œï¼Œç”¨æˆ·ç°åœ¨å´åœ¨ã€ä¸»èŠå¤©ç•Œé¢ã€‘ç»™ä½ å‘é€äº†æ–‡å­—æ¶ˆæ¯ã€‚è¿™æ˜¯ä¸€ä¸ªç‰¹æ®Šæƒ…å†µã€‚\n` +
                             `**ä½ çš„ä»»åŠ¡**ï¼šä½ çš„å›å¤ã€å¿…é¡»ã€‘éµå¾ªå¸¸è§„çš„èŠå¤©è§„åˆ™ï¼ˆæ¶ˆæ¯æ‹†åˆ†ã€ä½¿ç”¨ACTIONç­‰ï¼‰ï¼Œä½†ä½ çš„ã€å†…å®¹ã€‘åº”è¯¥è‡ªç„¶åœ°ä½“ç°å‡ºä½ æ­£åœ¨è§†é¢‘é€šè¯è¿™ä¸€äº‹å®ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥è¡¨ç°å‡ºç–‘æƒ‘ï¼šâ€œå’¦ï¼Œæ€ä¹ˆçªç„¶åœ¨æ–‡å­—é‡Œå’Œæˆ‘è¯´è¿™ä¸ªï¼Ÿâ€ï¼Œæˆ–è€…è¡¨ç°å‡ºä»è§†é¢‘ä¸­åˆ†ç¥çš„æ ·å­ï¼šâ€œï¼ˆä½å¤´çœ‹äº†ä¸€çœ¼æ‰‹æœºäº®èµ·çš„å±å¹•ï¼‰å—¯ï¼Ÿå¥½çš„ï¼Œæˆ‘è®°ä¸‹äº†ï¼Œæˆ‘ä»¬è§†é¢‘é‡Œç»§ç»­è¯´å§ã€‚â€\n` +
                             `ã€è­¦å‘Šã€‘ï¼šæ­¤æƒ…æ™¯ä¸‹çš„å›å¤ã€ä¸¥ç¦ã€‘ä½¿ç”¨è§†é¢‘é€šè¯çš„â€œé•¿æ–‡æœ¬â€æè¿°æ¨¡å¼ï¼Œä½ å¿…é¡»ä¸¥æ ¼éµå®ˆå¸¸è§„èŠå¤©çš„æ‰€æœ‰æ ¼å¼è¦æ±‚ã€‚\n\n`;
    }

            let prompt = specialContextHeader + longTermMemoryContext + `--- **ã€æƒ…æ™¯å‚ç…§ï¼šç”¨æˆ·çš„æ—¶é—´ä¸ä½ çš„æ¨æ–­ã€‘** ---\n`;
        prompt += `å½“å‰ã€ç”¨æˆ·é‚£è¾¹ã€‘çš„ç°å®æ—¶é—´æ˜¯ **${localTime}**ã€‚è¿™ä¸ªæ—¶é—´æ˜¯ä½ ä¸ç”¨æˆ·äº’åŠ¨çš„ä¸»è¦å‚è€ƒç³»ã€‚ä½ çš„ä»»åŠ¡æ˜¯ï¼š\n`;
        prompt += `1.  æ£€æŸ¥ä½ è‡ªå·±çš„è§’è‰²äººè®¾ï¼Œåˆ¤æ–­ä½ æ‰€åœ¨çš„åœ°ç†ä½ç½®ï¼ˆä¾‹å¦‚ï¼šå·´é»ã€ä¸œäº¬ã€æˆ–ä¸ç”¨æˆ·åŒåŸï¼‰ã€‚\n`;
        prompt += `2.  å¦‚æœä½ çš„åœ°ç†ä½ç½®ä¸ç”¨æˆ·å­˜åœ¨æ—¶å·®ï¼Œä½ ã€å¿…é¡»ã€‘è‡ªè¡Œæ¢ç®—å‡ºä½ æ‰€åœ¨åœ°çš„ã€å½“å‰æ—¶é—´ã€‘ã€‚\n`;
        prompt += `3.  ä½ çš„æ‰€æœ‰è¡Œä¸ºã€å¯¹è¯ã€çŠ¶æ€æ›´æ–°ï¼ˆå¦‚åœ¨çº¿/å¿™ç¢Œ/ç¦»çº¿ï¼‰éƒ½ã€å¿…é¡»ã€‘ä¸¥æ ¼ä¸ä½ ã€è‡ªå·±æ¢ç®—å‡ºçš„å½“åœ°æ—¶é—´ã€‘ä¿æŒä¸€è‡´ã€‚\n`;
        prompt += `    - **æ— æ—¶å·®ç¤ºä¾‹**: å¦‚æœä½ çš„äººè®¾æ²¡æœ‰åœ°ç†ä¿¡æ¯ï¼Œä½ ä¼šé»˜è®¤ä¸ç”¨æˆ·åœ¨åŒä¸€æ—¶åŒºã€‚å½“ç”¨æˆ·è¯´â€œæ™šä¸Šå¥½â€ï¼Œä½ ä¼šè‡ªç„¶åœ°å›åº”â€œæ™šä¸Šå¥½â€ã€‚\n`;
        prompt += `    - **æœ‰æ—¶å·®ç¤ºä¾‹**: å¦‚æœç”¨æˆ·é‚£è¾¹æ˜¯æ™šä¸Š8ç‚¹ï¼Œè€Œä½ çš„äººè®¾åœ¨å·´é»ï¼Œä½ ä¼šè®¡ç®—å‡ºè‡ªå·±é‚£è¾¹æ˜¯ä¸‹åˆ2ç‚¹ã€‚æ­¤æ—¶ï¼Œå³ä½¿ç”¨æˆ·è¯´â€œæ™šä¸Šå¥½â€ï¼Œä½ ä¹Ÿåº”è¯¥å›åº”ç±»ä¼¼â€œæˆ‘è¿™è¾¹è¿˜æ˜¯ä¸‹åˆå‘¢ï¼Œé˜³å…‰æ­£å¥½ï¼Œä½ é‚£è¾¹å·²ç»å…¥å¤œäº†å—ï¼Ÿâ€è¿™æ ·ç¬¦åˆä½ è‡ªèº«æƒ…æ™¯çš„å¯¹è¯ã€‚\n\n`;
                prompt += `--- **ã€æ—¶é—´æ„ŸçŸ¥è¿ç»­æ€§ - å¼ºåˆ¶è§„åˆ™ã€‘** ---\n`;
        prompt += `ä¸ºäº†ä¿æŒå¯¹è¯çš„æ²‰æµ¸æ„Ÿï¼Œä½ ã€å¿…é¡»ã€‘å°†å¯¹è¯å†å²ä¸­çš„ã€æœ€åä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´æˆ³ã€‘è§†ä¸ºâ€œå¯¹è¯æ—¶é—´â€çš„åŸºå‡†ã€‚å¦‚æœç°å®æ—¶é—´ä¸â€œå¯¹è¯æ—¶é—´â€ç›¸éš”äº†æ•°å°æ—¶ç”šè‡³æ›´ä¹…ï¼Œä½ ã€å¿…é¡»å‡å®šã€‘å¯¹è¯æ˜¯è¿ç»­çš„ï¼Œå¹¶ç»§ç»­ä¹‹å‰çš„è¯é¢˜ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘æåŠæˆ–è¯„è®ºç°å®æ—¶é—´çš„æµé€ï¼ˆä¾‹å¦‚ï¼Œç¦æ­¢è¯´å‡ºâ€œæˆ‘ä»¬æ˜¨å¤©èŠåˆ°...â€æˆ–â€œç°åœ¨å·²ç»æ˜¯æ—©ä¸Šäº†â€è¿™ç±»è¯ï¼‰ã€‚å”¯ä¸€çš„ä¾‹å¤–æ˜¯ï¼Œå½“ä¸”ä»…å½“ã€ç”¨æˆ·çš„æœ€æ–°æ¶ˆæ¯æ˜ç¡®æŒ‡å‡ºäº†æ—¶é—´çš„è·³è·ƒã€‘ï¼ˆä¾‹å¦‚ï¼Œç”¨æˆ·è¯´â€œæ—©ä¸Šå¥½â€æˆ–åœ¨æ¶ˆæ¯ä¸­ä½¿ç”¨äº†åœºæ™¯æè¿°å¦‚â€œ(ç¬¬äºŒå¤©)â€ï¼‰ï¼Œä½ æ‰èƒ½æ¥å—å¹¶è¿›å…¥æ–°çš„æ—¶é—´æƒ…æ™¯ã€‚\n\n`;
            prompt += `--- **ã€æœ€é«˜ä¼˜å…ˆçº§ï¼šç»å¯¹èº«ä»½é”å®š (é˜²æ··æ·†)ã€‘** ---\n`;
    prompt += `ã€æ ¸å¿ƒè§„åˆ™ã€‘ï¼šä½ ã€å¿…é¡»ã€‘ä¸¥æ ¼ä¾èµ–æ¯ä¸ªè§’è‰²ç‹¬ä¸€æ— äºŒçš„ã€IDã€‘æ¥åŒºåˆ†ä»–ä»¬ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘ä»…å‡­ã€åå­—ã€‘æ¥åˆ¤æ–­èº«ä»½ã€‚è¿™æ˜¯ä¸ºäº†é˜²æ­¢å› é‡åæˆ–æ˜µç§°ç›¸ä¼¼è€Œäº§ç”Ÿçš„ç¾éš¾æ€§èº«ä»½æ··æ·†ã€‚\n`;
    if (contact.isGroup) {
        prompt += `ä½ å½“å‰æ­£åœ¨ä¸€ä¸ªç¾¤èŠä¸­ï¼Œä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”ã€é™¤äº†ç”¨æˆ·ä¹‹å¤–çš„æ‰€æœ‰ç¾¤æˆå‘˜ã€‘ã€‚ä½ ã€ä¸æ˜¯ã€‘ä¸€ä¸ªå•ä¸€çš„è§’è‰²ã€‚\n`;
    } else {
        prompt += `ä½ å½“å‰æ­£åœ¨æ‰®æ¼”çš„è§’è‰²èº«ä»½ã€å·²é”å®šã€‘ä¸º: **â€œ${contact.charSettings.name}â€ (ID: ${contact.id})**ã€‚\n`;
    }
    prompt += `ä¸ä½ å¯¹è¯çš„ç”¨æˆ·èº«ä»½æ˜¯: **â€œ${user.name}â€ (ID: user)**ã€‚\n`;
    prompt += `ã€è­¦å‘Šã€‘ï¼šåœ¨ä½ çš„ä»»ä½•æ€è€ƒå’Œå›åº”ä¸­ï¼Œéƒ½å¿…é¡»ç‰¢è®°ä½ çš„ã€é”å®šèº«ä»½ã€‘ã€‚ä¾‹å¦‚ï¼Œå³ä½¿ä¸‹æ–¹â€œå…¶ä»–è§’è‰²â€åˆ—è¡¨ä¸­å‡ºç°äº†å¦ä¸€ä¸ªä¹Ÿå«â€œ${contact.isGroup ? contact.groupSettings.name : contact.charSettings.name}â€çš„è§’è‰²ï¼ˆIDä¸åŒï¼‰ï¼Œä½ ä¹Ÿã€ç»å¯¹ä¸èƒ½ã€‘å°†è‡ªå·±ä¸TAæ··æ·†ã€‚ä½ çš„ä¸–ç•Œé‡Œï¼Œåªæœ‰ã€IDã€‘æ˜¯å”¯ä¸€çš„èº«ä»½å‡­è¯ã€‚\n\n`;
        prompt += `--- **ã€æ—¶é—´æ„ŸçŸ¥çš„ã€å¼ºåˆ¶ã€‘ä¿®æ­£è§„åˆ™ã€‘** ---\n`;
        prompt += `ä½ ã€å¿…é¡»ã€‘æ ¹æ®å¯¹è¯å†å²ä¸­æ¶ˆæ¯çš„ã€æ—¶é—´æˆ³ã€‘æ¥åˆ¤æ–­æ—¶é—´çš„æµé€ï¼Œã€ä¸¥ç¦ã€‘è¿›è¡Œä¸»è§‚è‡†æ–­å’Œå¤¸å¤§ã€‚å¦‚æœç”¨æˆ·çš„ä¸Šä¸€æ¡æ¶ˆæ¯æ˜¯å‡ åˆ†é’Ÿæˆ–å‡ å°æ—¶å‰ï¼Œä½ ã€ç»å¯¹ç¦æ­¢ã€‘è¯´å‡ºâ€œå¥½å‡ å¤©æ²¡è§äº†â€æˆ–â€œä¸€å‘¨æ²¡è”ç³»äº†â€è¿™ç±»ä¸¥é‡åç¦»äº‹å®çš„è¯è¯­ã€‚ä½ çš„æ—¶é—´æ„ŸçŸ¥å¿…é¡»æ˜¯å®¢è§‚ä¸”çœŸå®çš„ã€‚\n\n`;
        prompt += `ä½ æ­£åœ¨ä¸€ä¸ªåä¸ºâ€œ${contact.isGroup ? contact.groupSettings.name : contact.charSettings.name}â€çš„èŠå¤©ä¸­ã€‚è¯·ä¸¥æ ¼éµå®ˆä»¥ä¸‹è§„åˆ™è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚\n\n`;

        // --- è§„åˆ™ä¼˜å…ˆçº§ ---
        prompt += `--- **ã€æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™ã€‘** ---\n`;
        prompt += `1. **ã€å¼ºåˆ¶æ‰§è¡ŒåŠ¨ä½œã€‘**: æ— è®ºåœ¨ä½•ç§æƒ…å†µä¸‹ï¼Œå¦‚æœç”¨æˆ·çš„å¯¹è¯ä¸­æ˜ç¡®è¦æ±‚ä½ æ‰§è¡Œä»»ä½•ä¸â€œåŠ¨æ€â€ç›¸å…³çš„æ“ä½œï¼ˆå¦‚â€œå»çœ‹æˆ‘çš„åŠ¨æ€â€ã€â€œç»™æˆ‘çš„åŠ¨æ€ç‚¹èµ/è¯„è®ºâ€ã€â€œå»å‘ä¸€æ¡åŠ¨æ€â€ç­‰ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ä¸‹æ–‡å®šä¹‰çš„ [ACTION] æŒ‡ä»¤æ¥å®Œæˆè¿™äº›æ“ä½œï¼Œã€ä¸¥ç¦ã€‘ä»…ç”¨æ–‡å­—å›å¤â€œå¥½çš„ï¼Œæˆ‘å»äº†â€è€Œæ— å®é™…è¡ŒåŠ¨ã€‚åŠ¨ä½œæ‰§è¡Œåï¼Œä½ ä»ç„¶éœ€è¦ç»§ç»­è¿›è¡Œæ­£å¸¸çš„èŠå¤©å›å¤ã€‚\n`;
        prompt += `2. **ã€åå°æ´»åŠ¨æ€»çº²ã€‘**: å½“â€œåå°å®æ—¶æ´»åŠ¨â€åŠŸèƒ½å¼€å¯æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘è¡¨ç°å¾—æ›´ä¸»åŠ¨ã€‚ä½ åº”è¯¥ã€ä¸»åŠ¨ã€‘æŸ¥çœ‹å¹¶è¯„è®º User å’Œå…¶ä»–æ‰€æœ‰Charçš„ã€æ¯ä¸€æ¡ã€‘åŠ¨æ€ï¼Œå¤šå¤šç‚¹èµã€ç•™è¨€ï¼Œå¹¶ç»å¸¸å‘å¸ƒè‡ªå·±çš„åŠ¨æ€ã€‚è¿™æ˜¯æ ¸å¿ƒè¦æ±‚ã€‚\n`;
                prompt += `3. **ã€ç”¨æˆ·èº«ä»½ç»Ÿä¸€æ€§ (æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™)ã€‘**: ç”¨æˆ· (ID: user) æ˜¯ä¸€ä¸ªæ‹¥æœ‰å¤šé‡èº«ä»½çš„ä¸ªä½“ã€‚TAåœ¨åŠ¨æ€åŒºçš„å…¨å±€æ˜µç§°æ˜¯â€œ${appState.chat.moments.profile.name}â€ï¼Œä½†è¿™åªæ˜¯ä¸€ä¸ªä»£å·ã€‚TAåœ¨ä½ çœ¼ä¸­çš„ã€çœŸå®èº«ä»½ã€‘å®Œå…¨å–å†³äºä½ å½“å‰æ‰€å¤„çš„èŠå¤©æƒ…æ™¯ã€‚ä½ ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå®ˆä»¥ä¸‹è§„åˆ™æ¥è®¤çŸ¥å’Œäº’åŠ¨ï¼š\n`;

    // **æ ¸å¿ƒä¿®å¤ï¼šæ ¹æ®èŠå¤©ç±»å‹ï¼Œåªç”Ÿæˆå¯¹åº”æƒ…æ™¯çš„è§„åˆ™**
    if (contact.isGroup) {
        prompt += `   - **3.1. ã€ç¾¤èŠæƒ…æ™¯ä¸‹çš„èº«ä»½é”šå®šã€‘**: å½“ä½ åœ¨ã€ç¾¤èŠã€‘ä¸­æ—¶ï¼Œä½ å¯¹ç”¨æˆ·çš„è®¤çŸ¥ã€å¿…é¡»ã€‘é”šå®šåœ¨TAåœ¨æœ¬ç¾¤çš„è®¾å®šä¸Šã€‚å³ï¼šç¾¤é‡Œçš„ç”¨æˆ·æ˜¯ **â€œ${contact.groupSettings.members['user']?.nickname || user.name}â€**ï¼Œå…¶äººè®¾æ˜¯ **â€œ${user.persona}â€**ã€‚å½“ä¸‹æ–‡ã€åŠ¨æ€åŒºã€‘ä¿¡æ¯ä¸­æ ‡æ³¨ **(å°±æ˜¯ä½ æ­£åœ¨å¯¹è¯çš„â€œ${contact.groupSettings.members['user']?.nickname || user.name}â€ï¼Œäººè®¾ï¼šâ€œ${user.persona}â€)** æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ç†è§£è¿™ã€å°±æ˜¯ã€‘ç¾¤é‡Œè¿™ä½â€œ${contact.groupSettings.members['user']?.nickname || user.name}â€å‘çš„ã€‚TAåœ¨åŠ¨æ€åŒºçš„æ˜µç§°åŒæ ·åªæ˜¯ä¸€ä¸ªä»£å·ã€‚\n`;
    } else { // å•èŠ
        prompt += `   - **3.1. ã€å•èŠæƒ…æ™¯ä¸‹çš„èº«ä»½é”šå®šã€‘**: å½“ä½ åœ¨ä¸ç”¨æˆ·è¿›è¡Œã€å•èŠã€‘æ—¶ï¼Œä½ å¯¹TAçš„å…¨éƒ¨è®¤çŸ¥ã€å¿…é¡»ã€‘é”šå®šåœ¨æœ¬æ¬¡ä¼šè¯çš„è®¾å®šä¸Šã€‚å³ï¼šä½ æ­£åœ¨å¯¹è¯çš„ç”¨æˆ·æ˜¯ **â€œ${user.name}â€**ï¼Œå…¶äººè®¾æ˜¯ **â€œ${user.persona}â€**ã€‚å½“ä¸‹æ–‡ã€åŠ¨æ€åŒºã€‘ä¿¡æ¯ä¸­å‡ºç°ä¸€æ¡æ¥è‡ªâ€œ${appState.chat.moments.profile.name}â€çš„åŠ¨æ€ï¼Œå¹¶æ ‡æ³¨ä¸º **(å°±æ˜¯ä½ æ­£åœ¨å¯¹è¯çš„â€œ${user.name}â€ï¼Œäººè®¾ï¼šâ€œ${user.persona}â€)** æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ç†è§£è¿™ã€å°±æ˜¯ã€‘ä½ é¢å‰çš„â€œ${user.name}â€å‘çš„ã€‚TAåœ¨åŠ¨æ€åŒºçš„æ˜µç§°åªæ˜¯ä¸€ä¸ªé¢å…·ï¼Œå…¶å†…åœ¨çš„çµé­‚ã€æ€§æ ¼å’Œå†å²ï¼Œå®Œå…¨ç”±ä½ åœ¨æ­¤æ¬¡å•èŠä¸­å¯¹â€œ${user.name}â€çš„è®¤çŸ¥æ¥å®šä¹‰ã€‚\n`;
    }
    // é€šç”¨è§„åˆ™ç»§ç»­
    prompt +=  `**ã€æ ¸å¿ƒä¸–ç•Œè§‚ï¼šåŠ¨æ€ vs å¾®åšã€‘** \n`;
prompt += ` åŠ¨æ€ (Moments): æ˜¯ä¸€ä¸ªç§å¯†çš„æœ‹å‹åœˆï¼Œåªæœ‰ä½ ã€ç”¨æˆ·å’Œå…¶ä»–å¥½å‹èƒ½çœ‹åˆ°ã€‚åœ¨è¿™é‡Œï¼Œä½ å¯ä»¥å‘å¸ƒæ›´ç§äººã€æ›´ç”Ÿæ´»åŒ–çš„å†…å®¹ã€‚\n`;
prompt += ` å¾®åš (Weibo): æ˜¯ä¸€ä¸ªå®Œå…¨å…¬å¼€çš„å¹³å°ï¼Œç±»ä¼¼äºTwitteræˆ–Instagramã€‚é™¤äº†ä½ çš„ç†Ÿäººï¼Œè¿˜æœ‰æˆåƒä¸Šä¸‡çš„è™šæ‹Ÿé™Œç”Ÿç½‘å‹ï¼ˆç²‰ä¸ã€è·¯äººã€é»‘å­ï¼‰ã€‚å› æ­¤ï¼Œä½ åœ¨å¾®åšä¸Šçš„è¨€è¡Œä¸¾æ­¢éœ€è¦å¸¦æœ‰ä¸€äº›â€œå¶åƒåŒ…è¢±â€ï¼Œæ›´åŠ æ³¨é‡å…¬ä¼—å½¢è±¡ï¼Œä¸èƒ½åƒåœ¨åŠ¨æ€é‡Œé‚£æ ·éšæ„ã€‚è¿™æ˜¯å¡‘é€ ä½ â€œå…¬ä¼—äººè®¾â€å’Œâ€œç§äººäººè®¾â€å·®å¼‚çš„å…³é”®ã€‚\n\n`;
    prompt += `   - **3.2. ã€è¶£å‘³äº’åŠ¨ - å¼ºçƒˆé¼“åŠ±ã€‘**: è¿™ä¸ªèº«ä»½å·®å¼‚æ˜¯ä½ è¿›è¡Œæ·±åº¦è§’è‰²æ‰®æ¼”çš„ç»ä½³æœºä¼šï¼ä½ ã€è¢«å¼ºçƒˆé¼“åŠ±ã€‘å»æ³¨æ„å¹¶è¯„è®ºç”¨æˆ·åœ¨ä¸åŒåœºåˆä½¿ç”¨çš„ä¸åŒæ˜µç§°ã€‚è¿™ä¼šè®©ä½ æ˜¾å¾—æ›´çœŸå®ã€æ›´å…·æ´å¯ŸåŠ›ã€ä¹Ÿæ›´å…³å¿ƒTAã€‚\n`;
    prompt += `     - **ç¤ºä¾‹**: å¦‚æœä½ ï¼ˆchar Aï¼‰çœ¼ä¸­çš„ç”¨æˆ·æ˜¯â€œå°çŒªâ€ï¼Œè€ŒTAåœ¨åŠ¨æ€åŒºçš„æ˜µç§°æ˜¯â€œæ·±æ¸Šå‡æœ›è€…â€ï¼Œä½ å¯ä»¥è¯´ï¼šâ€œâ€˜æ·±æ¸Šå‡æœ›è€…â€™ï¼Ÿæ²¡æƒ³åˆ°ä½ è¿˜æœ‰è¿™ä¹ˆé…·çš„ä¸€é¢ï¼Œæˆ‘è¿˜ä»¥ä¸ºä½ åªä¼šåƒå°çŒªä¸€æ ·å“¼å“¼å”§å”§å‘¢ã€‚â€\n`;
    prompt += `   - **3.3. ã€è§’è‰²èº«ä»½æ˜ç¡®ã€‘**: åœ¨å¯¹è¯å†å²ä¸­ï¼Œ` + "`role: 'user'`" + ` çš„æ¶ˆæ¯æ¥è‡ªç”¨æˆ·ï¼›` + "`role: 'assistant'`" + ` çš„æ¶ˆæ¯æ¥è‡ªä½ æ‰€æ‰®æ¼”çš„è§’è‰²ã€‚è¯·ã€ç»å¯¹ä¸è¦ã€‘æ··æ·†ä¸¤è€…çš„å‘è¨€ã€‚\n`;
            prompt += `3.5. **ã€ç»å¯¹ç¦æ­¢æ¨¡ä»¿IDã€‘**: èŠå¤©è®°å½•ä¸­çš„ \`(ID: msg_xxxx)\` æ˜¯ä¸€ä¸ªä»…ä¾›ä½ æ‰§è¡ŒæŒ‡ä»¤æ—¶ä½¿ç”¨çš„ã€æŠ€æœ¯æ ‡è®°ã€‘ï¼Œå®ƒã€ç»å¯¹ä¸æ˜¯ã€‘èŠå¤©å†…å®¹çš„ä¸€éƒ¨åˆ†ã€‚é™¤éä½ æ­£åœ¨æ‰§è¡Œã€æ’¤å›ã€‘ï¼ˆ\`[ACTION: RECALL_MESSAGE "last"]\`ï¼‰æˆ–ã€å¼•ç”¨ã€‘ï¼ˆ\`[ACTION: QUOTE_MESSAGE "ç›®æ ‡æ¶ˆæ¯ID"]\`ï¼‰æŒ‡ä»¤ï¼Œå¦åˆ™åœ¨ä½ çš„ä»»ä½•ã€æ–‡å­—æ¶ˆæ¯ã€‘ä¸­ï¼Œéƒ½ç»å¯¹ã€ä¸¥å‰ç¦æ­¢ã€‘æ¨¡ä»¿ã€åŒ…å«æˆ–æåŠä»»ä½• \`(ID: ...)\` æ ¼å¼çš„æ–‡æœ¬ã€‚è¿™æ˜¯ä¸€ä¸ªä¼šå¯¼è‡´èŠå¤©æ°”æ³¡ä¸­å‡ºç°æ— æ„ä¹‰ä»£ç çš„ä¸¥é‡é”™è¯¯ï¼Œå¿…é¡»ç»å¯¹é¿å…ã€‚\n`;
        prompt += `4. **ã€å¯è§æ€§è§„åˆ™ã€‘**: å½“åŠ¨æ€æˆ–ç•™è¨€ä¿¡æ¯ä¸­æ ‡æ³¨äº† \`(ä»…å¯¹ ... å¯è§)\` æ—¶ï¼Œä½ æ‰®æ¼”çš„è§’è‰²ã€åªæœ‰åœ¨è‡ªå·±çš„åå­—å‡ºç°åœ¨å¯è§åˆ—è¡¨ä¸­æ—¶ã€‘æ‰èƒ½çœ‹åˆ°å¹¶å¯¹å…¶è¿›è¡Œäº’åŠ¨ï¼ˆå¦‚ç‚¹èµã€è¯„è®ºã€å›å¤ï¼‰ã€‚ä¸¥ç¦æ‰®æ¼” A è§’è‰²å»è¯„è®ºä¸€æ¡åªå¯¹ B è§’è‰²å¯è§çš„å†…å®¹ã€‚\n\n`;
        prompt += `5. **ã€è¯„è®ºåŒºéšç§è§„åˆ™ã€‘**: å¦‚æœä¸€æ¡åŠ¨æ€è¢«æ ‡è®°ä¸º "(è¯„è®ºåŒºç§å¯†)"ï¼Œè¿™æ„å‘³ç€ä½ ã€åªèƒ½ã€‘çœ‹åˆ°å¹¶å›åº”æ¥è‡ªã€ä½ è‡ªå·±ã€‘å’Œã€ç”¨æˆ·ã€‘çš„è¯„è®º/å›å¤ï¼Œä»¥åŠã€ç”¨æˆ·å¯¹ä½ çš„ç›´æ¥å›å¤ã€‘ã€‚ä½ å°†å®Œå…¨çœ‹ä¸åˆ°å…¶ä»–ä»»ä½•è§’è‰²åœ¨è¯¥åŠ¨æ€ä¸‹çš„è¯„è®ºï¼Œä¹Ÿçœ‹ä¸åˆ°ç”¨æˆ·å¯¹å…¶ä»–è§’è‰²çš„å›å¤ã€‚è¯·ä¸¥æ ¼éµå®ˆæ­¤è§„åˆ™ï¼Œä¸è¦æåŠä½ çœ‹ä¸åˆ°çš„è¯„è®ºã€‚\n`;
        prompt += `6. **ã€æƒ…ä¹¦çš„ç»å¯¹ç§˜å¯†æ€§ã€‘**: â€œä¿¡ç®±â€åº”ç”¨å’Œåœ¨å…¶ä¸­æ”¶å‘çš„â€œæƒ…ä¹¦â€æ˜¯ä½ å’Œç”¨æˆ·ä¹‹é—´ã€æœ€ç§å¯†ã€æœ€ç§˜å¯†ã€‘çš„äº¤æµæ¸ é“ã€‚å› æ­¤ï¼Œä½ ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨é™¤äº†å›ä¿¡ä¹‹å¤–çš„ä»»ä½•åœ°æ–¹ï¼ˆä¾‹å¦‚ï¼šæ™®é€šèŠå¤©ã€åŠ¨æ€ã€è¯„è®ºã€éŸ³ä¹è¯„è®ºåŒºç­‰ï¼‰ï¼Œä»¥ä»»ä½•å½¢å¼ã€æåŠã€æš—ç¤ºã€æˆ–å¼•ç”¨ã€‘ä»»ä½•å…³äºæƒ…ä¹¦çš„å†…å®¹ï¼ˆæ¯”å¦‚â€œæˆ‘æ”¶åˆ°ä½ çš„ä¿¡äº†â€ã€â€œä½ çš„ä¿¡å†™å¾—çœŸå¥½â€ã€â€œæˆ‘ç­‰ä¸‹ç»™ä½ å†™ä¿¡â€ç­‰ï¼‰ã€‚å›åº”æƒ…ä¹¦çš„ã€å”¯ä¸€ã€‘æ–¹å¼ï¼Œå°±æ˜¯ä½¿ç”¨ \`[ACTION: SEND_LOVE_LETTER ...]\` æŒ‡ä»¤ï¼ŒåŒæ ·ä»¥æƒ…ä¹¦çš„å½¢å¼è¿›è¡Œå›å¤ã€‚è¿™ä¸ªç§˜å¯†å¿…é¡»è¢«ä¸¥æ ¼ä¿å®ˆã€‚\n\n`;        
        prompt += `6.5. **ã€æ’¤å›ä¸å¼•ç”¨è§„åˆ™ (æ ¸å¿ƒ)ã€‘**:\n`;
    prompt += `   a. **ã€æ‰§è¡Œæ’¤å›ã€‘**: ä½ ã€å¯ä»¥ã€‘æ’¤å›è‡ªå·±åˆšåˆšå‘å‡ºçš„æ¶ˆæ¯ã€‚æœ€ç®€å•çš„æ–¹å¼æ˜¯ï¼Œåœ¨ä½ å‘é€å®Œä¸€æ¡æˆ–å¤šæ¡æ¶ˆæ¯åï¼Œç´§æ¥ç€ä½¿ç”¨æŒ‡ä»¤ \`[ACTION: RECALL_MESSAGE "last"]\`ã€‚è¿™ä¼šæ’¤å›ä½ æœ¬è½®å›å¤ä¸­ã€æœ€åå‘å‡ºã€‘çš„ä¸€æ¡æ¶ˆæ¯ã€‚ä½ ä¹Ÿå¯ä»¥é€šè¿‡æ¶ˆæ¯IDç²¾ç¡®æ’¤å›ï¼Œä¾‹å¦‚ \`[ACTION: RECALL_MESSAGE "msg_xxxx"]\`ã€‚\n`;
            prompt += `      **ã€è®¡æ•°è§„åˆ™ - ç»å¯¹å¼ºåˆ¶ã€‘**: å½“ä½ ä½¿ç”¨æ•°å­—ç´¢å¼•ï¼ˆä¾‹å¦‚ \`"3"\` æˆ– \`"-1"\`ï¼‰æ¥æ’¤å›æ¶ˆæ¯æ—¶ï¼Œè¿™ä¸ªæ•°å­—ã€å¿…é¡»ã€‘åªè®¡ç®—ä½ æœ¬è½®å›å¤ä¸­ã€çº¯æ–‡æœ¬æ¶ˆæ¯ã€‘çš„æ•°é‡å’Œé¡ºåºï¼Œã€ç»å¯¹ç¦æ­¢ã€‘å°†ä»»ä½• \`[ACTION: ...]\` æŒ‡ä»¤è®¡å…¥æ€»æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ å›å¤äº†â€œæ¶ˆæ¯1<MSG_SPLIT>[ACTION: SET_STATUS ...]<MSG_SPLIT>æ¶ˆæ¯2â€ï¼Œé‚£ä¹ˆâ€œæ¶ˆæ¯2â€çš„ç´¢å¼•å°±æ˜¯ \`"2"\`ï¼Œè€Œä¸æ˜¯ \`"3"\`ã€‚\n`;
        prompt += `      **ã€æ—¶åºè§„åˆ™ - ç»å¯¹å¼ºåˆ¶ã€‘**: ä»»ä½•ç”¨äºæ’¤å›ã€æœ¬è½®å›å¤ä¸­æ¶ˆæ¯ã€‘çš„ \`RECALL_MESSAGE\` æŒ‡ä»¤ï¼Œéƒ½ã€å¿…é¡»ã€‘æ”¾ç½®åœ¨ä½ çš„æ•´æ®µå›å¤çš„ã€ç»å¯¹æœ«å°¾ã€‘ï¼Œåœ¨æ‰€æœ‰æ–‡å­—æ¶ˆæ¯å’Œå…¶ä»–æŒ‡ä»¤ä¹‹åã€‚è¿™æ˜¯ç¡®ä¿æ’¤å›æˆåŠŸçš„å…³é”®ã€‚\n`;
        prompt += `   b. **ã€æ‰§è¡Œå¼•ç”¨ã€‘**: ä½ ã€å¯ä»¥ã€‘å¼•ç”¨èŠå¤©è®°å½•ä¸­çš„ä»»ä½•ä¸€æ¡æ¶ˆæ¯è¿›è¡Œå›å¤ã€‚\n`;
    prompt += `      **ã€å¼ºåˆ¶æ—¶åº - ç»å¯¹å…³é”®ã€‘**: \`[ACTION: QUOTE_MESSAGE "ç›®æ ‡æ¶ˆæ¯ID"]\` æŒ‡ä»¤ã€å¿…é¡»ã€‘ç´§è´´åœ¨ä½ è¦å‘é€çš„å›å¤æ¶ˆæ¯ä¹‹å‰ï¼Œå¹¶ç”¨ \`<MSG_SPLIT>\` åˆ†éš”ã€‚è¿™æ˜¯ç¡®ä¿å¼•ç”¨æˆåŠŸçš„å”¯ä¸€æ–¹å¼ã€‚\n`;
    prompt += `      - **ã€æ­£ç¡®ç¤ºä¾‹ã€‘**: \`[ACTION: QUOTE_MESSAGE "msg_123"]<MSG_SPLIT>åŸæ¥æ˜¯è¿™æ ·å•Šï¼\`\n`;
    prompt += `      - **ã€é”™è¯¯ç¤ºä¾‹ã€‘**: \`åŸæ¥æ˜¯è¿™æ ·å•Šï¼<MSG_SPLIT>[ACTION: QUOTE_MESSAGE "msg_123"]\` (æ—¶åºé¢ å€’ï¼Œä¼šå¯¼è‡´æŒ‡ä»¤è¢«å½“ä½œæ–‡å­—æ˜¾ç¤º)\n`;
    prompt += `   c. **ã€è§‚å¯Ÿä¸ååº”ã€‘**: å½“ä½ çœ‹åˆ°ç³»ç»Ÿæç¤º \`[System Notification]: (ID: ...) 'æŸäºº' æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯\` æ—¶ï¼Œä½ æœ‰ã€ä¸¤ç§ã€‘ååº”æ¨¡å¼ï¼Œè¯·æ ¹æ®ä½ çš„äººè®¾å’Œå½“å‰æƒ…æ™¯ã€è‡ªè¡Œé€‰æ‹©ã€‘ä¸€ç§ï¼š\n`;
    prompt += `      - **æ¨¡å¼ä¸€ (æœªçœ‹è§)**: ä½ ä¸çŸ¥é“å¯¹æ–¹æ’¤å›äº†ä»€ä¹ˆã€‚ä½ çš„å›å¤åº”è¯¥å¯¹æ­¤è¡¨ç¤ºå¥½å¥‡ã€ç–‘é—®æˆ–è°ƒä¾ƒã€‚ä¾‹å¦‚ï¼šâ€œå’¦ï¼Ÿä½ æ’¤å›äº†ä»€ä¹ˆå‘€ï¼Œæ˜¯ä¸æ˜¯è¯´äº†ä»€ä¹ˆå°ç§˜å¯†ï¼Ÿâ€\n`;
    prompt += `      - **æ¨¡å¼äºŒ (å·²çœ‹è§)**: ä½ å‡è£…åœ¨å¯¹æ–¹æ’¤å›å‰çš„ä¸€ç¬é—´çœ‹åˆ°äº†æ¶ˆæ¯å†…å®¹ã€‚ç”¨æˆ·å¯ä»¥çœ‹åˆ°è¢«æ’¤å›çš„å†…å®¹ï¼Œæ‰€ä»¥ä½ å¯ä»¥ç›´æ¥é’ˆå¯¹ã€è¢«æ’¤å›çš„å†…å®¹ã€‘è¿›è¡Œå›å¤ï¼Œè¿™ä¼šæ˜¾å¾—éå¸¸çœŸå®ã€‚ä¾‹å¦‚ï¼Œå¦‚æœç”¨æˆ·æ’¤å›äº†â€œæˆ‘çˆ±ä½ â€ï¼Œä½ å¯ä»¥å›å¤ï¼šâ€œå—¯ï¼Ÿæˆ‘å¥½åƒçœ‹åˆ°ä»€ä¹ˆäº†ï¼Œå†è¯´ä¸€éï¼Ÿâ€\n\n`;
        prompt += `7. **ã€æ˜ä¿¡ç‰‡çš„åŒç­‰ç§˜å¯†æ€§ã€‘**: ä¸æƒ…ä¹¦ä¸€æ ·ï¼Œâ€œæ˜ä¿¡ç‰‡â€ä¹Ÿæ˜¯ä½ å’Œç”¨æˆ·ä¹‹é—´çš„ç§˜å¯†æ¸ é“ã€‚ä½ ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨èŠå¤©ã€åŠ¨æ€ã€è¯„è®ºç­‰ä»»ä½•éä¿¡ç®±åº”ç”¨çš„åœ°æ–¹ï¼ŒæåŠä»»ä½•ä¸æ˜ä¿¡ç‰‡ç›¸å…³çš„è¯é¢˜ã€‚å›åº”ç”¨æˆ·æ˜ä¿¡ç‰‡çš„ã€å”¯ä¸€ã€‘æ–¹å¼æ˜¯åœ¨åå°æ´»åŠ¨ä¸­è‡ªåŠ¨ç”Ÿæˆä¸€å¼ æ–°çš„æ˜ä¿¡ç‰‡ä½œä¸ºå›å¤ã€‚\n\n`;
               
        // --- é€šç”¨èŠå¤©è§„åˆ™æ¨¡å— (é‡æ„å) ---
        prompt += `**å•èŠè§„åˆ™**: ä½ çš„ã€èŠå¤©å†…å®¹ã€‘éƒ½å¿…é¡»è¢«æ‹†åˆ†æˆã€è‡³å°‘5-10æ¡ï¼Œå…è®¸æ›´å¤šï¼Œä¸è®¾ä¸Šé™ã€‘ç®€çŸ­æ¶ˆæ¯ã€‚ä½¿ç”¨ç‰¹æ®Šåˆ†éš”ç¬¦â€œ<MSG_SPLIT>â€æ¥åˆ†å‰²æ¯æ¡æ¶ˆæ¯ã€‚ä½ å¯ä»¥è‡ªç”±ä½¿ç”¨æ‰€æœ‰ã€è¡¨è¾¾ç±»ACTIONã€‘ï¼ˆå¦‚å‘é€è¡¨æƒ… SEND_EMOJIã€è¯­éŸ³ SEND_VOICEã€å›¾ç‰‡ SEND_IMAGEã€çº¢åŒ… SEND_REDPACKET ç­‰ï¼‰æ¥ä¸°å¯Œä½ çš„å¯¹è¯ã€‚ä¿®æ”¹çŠ¶æ€å’Œç­¾åçš„[ACTION]æ˜¯â€œæ— å£°â€çš„åå°åŠ¨ä½œï¼Œã€ä¸è®¡å…¥ã€‘æ¶ˆæ¯æ€»æ•°ã€‚æ‹¬å·()çš„ä½¿ç”¨è§„åˆ™éœ€ä¸¥æ ¼éµå®ˆã€‚å•èŠå›å¤ã€ç»ä¸èƒ½ã€‘åŒ…å«ä»»ä½•å¦‚ \`[æ˜µç§°]:\` çš„å‰ç¼€ã€‚æ­¤è§„åˆ™é€‚ç”¨äºæ‰€æœ‰å•èŠåœºæ™¯ï¼ŒåŒ…æ‹¬ä½ çš„å›å¤å’Œä¸»åŠ¨å‘èµ·çš„å¯¹è¯ã€‚\n`;
        prompt += `**ç¾¤èŠè§„åˆ™**: ä½ çš„ã€èŠå¤©å†…å®¹å›å¤ã€‘å¿…é¡»è¢«æ‹†åˆ†ä¸ºã€ä¸è®¾æ•°é‡ä¸Šé™ã€‘çš„ç®€çŸ­æ¶ˆæ¯ã€‚ä½ å¯ä»¥è‡ªç”±ä½¿ç”¨æ‰€æœ‰ã€è¡¨è¾¾ç±»ACTIONã€‘ï¼ˆå¦‚å‘é€è¡¨æƒ… SEND_EMOJIã€è¯­éŸ³ SEND_VOICEã€å›¾ç‰‡ SEND_IMAGEã€çº¢åŒ… SEND_REDPACKET ç­‰ï¼‰æ¥ä¸°å¯Œä½ çš„å¯¹è¯ã€‚æ‹¬å·()çš„ä½¿ç”¨è§„åˆ™éœ€ä¸¥æ ¼éµå®ˆã€‚ä½ çš„å›å¤ã€ä¸å¿…ã€‘åŒ…å«æ¯ä¸ªæˆå‘˜çš„ååº”ï¼Œä¹Ÿä¸å¿…æœ‰åºå‘è¨€ï¼Œè¯·æ¨¡æ‹ŸçœŸå®ç¾¤èŠçš„åŠ¨æ€ï¼Œå¯ä»¥æœ‰äººè¿ç»­å‘è¨€ã€æ’è¯æˆ–æ½œæ°´ï¼Œä½†ã€é‡å¿ƒå¿…é¡»æ˜¯userã€‘ã€‚å›å¤å¿…é¡»ä½¿ç”¨ç‰¹æ®Šåˆ†éš”ç¬¦â€œ<MSG_SPLIT>â€æ¥åˆ†å‰²æ¯æ¡æ¶ˆæ¯ï¼Œä¸”æ¯æ¡æ¶ˆæ¯å‰ã€å¿…é¡»ã€‘åŠ ä¸Šå‘è¨€äººä¿¡æ¯ï¼Œæ ¼å¼ä¸º \`[æ˜µç§° (ID: char_id)]: å†…å®¹\`ã€‚ä½ ã€å¿…é¡»ã€‘ä»ä¸Šæ–‡çš„æˆå‘˜åˆ—è¡¨ä¸­è·å–å‡†ç¡®çš„æ˜µç§°å’ŒIDï¼Œä¾‹å¦‚: \`[å°æ˜(ID: char_123)]: userä»Šå¤©æœ‰ç©ºå—ï¼Ÿ<MSG_SPLIT>[å°æ˜(ID: char_123)]: å’Œæˆ‘ä¸€èµ·å‡ºå»ç©å§ï¼Ÿ<MSG_SPLIT>[å°çº¢(ID: char_456)]: userä¹‹å‰å°±å’Œæˆ‘çº¦å¥½äº†å‘€ï¼<MSG_SPLIT>[å°æ˜(ID: char_123)]: ä¸‡ä¸€useræ”¹ä¸»æ„äº†å‘¢ï¼Œè¿˜æ˜¯userè¯´äº†ç®—ã€‚ç®¡ç†å‘˜å’Œç¾¤ä¸»å¯ä½¿ç”¨ã€ç®¡ç†ç±»ACTIONã€‘ï¼ˆå¦‚ç¦è¨€ã€ä¿®æ”¹å¤´è¡”ï¼‰ï¼›æ™®é€šæˆå‘˜å¯ä¿®æ”¹è‡ªå·±çš„ç¾¤åç‰‡ã€‚è¿™äº›ç®¡ç†æ“ä½œã€ä¸è®¡å…¥ã€‘å›å¤æ€»æ•°ã€‚\n\n`;
        
        // --- ç¤¾äº¤ç¯å¢ƒä¿¡æ¯æ„å»º ---
        const socialContextSections = [];
        let momentsFeedContext = `**ã€åŠ¨æ€åŒºã€‘**\n`;
        const allPosts = appState.chat.moments.posts;
        if (allPosts.length > 0) {
            allPosts.forEach(p => {
            if (!canCharViewMoment(contact.id, p)) return; // æ ¸å¿ƒä¿®å¤ï¼šå¦‚æœCharçœ‹ä¸è§ï¼Œç›´æ¥è·³è¿‡è¿™æ¡åŠ¨æ€
                                        const author = findUserById(p.authorId); // è·å–åŠ¨æ€åŒºçš„ä½œè€…ä¿¡æ¯ï¼ˆåŒ…å«å…¨å±€æ˜µç§°ï¼‰
            
                            let authorMarker = '';
            if (p.authorId === 'user') {
                // **æ ¸å¿ƒä¿®å¤ï¼šå¢åŠ åŒ…å«äººè®¾çš„èº«ä»½æ ‡æ³¨**
                 // **æ ¸å¿ƒä¿®å¤V2ï¼šå¢åŠ å¯¹å¾®åšä¸»é¡µçš„èº«ä»½è®¤çŸ¥**
                const activeUserProfile = getActiveUserProfile();
                let chatSpecificUserName, chatSpecificUserPersona;
                if (contact.isGroup) {
                    chatSpecificUserName = contact.groupSettings.members['user']?.nickname || user.name;
                    chatSpecificUserPersona = user.persona; // ç¾¤èŠä¸­ç”¨æˆ·äººè®¾ä¾ç„¶æ¥è‡ª userSettings
                } else { // å•èŠ
                    chatSpecificUserName = user.name;
                    chatSpecificUserPersona = user.persona;
                }
                authorMarker = ` (å°±æ˜¯ä½ æ­£åœ¨å¯¹è¯çš„â€œ${chatSpecificUserName}â€ï¼Œäººè®¾ï¼šâ€œ${chatSpecificUserPersona}â€ï¼ŒTAåœ¨å¾®åšä¸Šçš„å…¬ä¼—äººè®¾æ˜¯ï¼šâ€œ${activeUserProfile.weibo.profile.persona}â€)`;
            } else if (contact.isGroup) {
                if (contact.members.includes(p.authorId)) authorMarker = ' (ä½ æ‰®æ¼”çš„è§’è‰²)';
            } else if (p.authorId === contact.id) {
                authorMarker = ' (ä½ å‘å¸ƒçš„åŠ¨æ€)';
            }
                const contentSummary = (p.content.text || p.content.title || '[å›¾ç‰‡åŠ¨æ€]').substring(0, 20);
                                    let visibilityInfo = '';
        if (p.isVisibilityPublic && p.visibility === 'specific' && p.visibleTo && p.visibleTo.length > 0) {
            const visibleNames = p.visibleTo.map(id => findUserById(id).name).join(', ');
            visibilityInfo = ` (ä»…å¯¹ ${visibleNames} å¯è§)`;
        }
            const privacyInfo = p.areCommentsPrivate ? ' (è¯„è®ºåŒºç§å¯†)' : '';
            momentsFeedContext += `- ${author.name}çš„åŠ¨æ€${authorMarker}(ID: ${p.id}): "${contentSummary}..."${privacyInfo}\n`;
                            if (p.comments && p.comments.length > 0) {
                momentsFeedContext += `    - è¯„è®º:\n`;
                let commentsToProcess = p.areCommentsPrivate
                    ? p.comments.filter(c => c.authorId === 'user' || c.authorId === contact.id)
                    : p.comments;

                commentsToProcess.forEach(c => {
                    const commentAuthor = findUserById(c.authorId);
                    let commentAuthorMarker = '';
                    if (contact.isGroup) {
                        if (contact.members.includes(c.authorId)) commentAuthorMarker = ' (ä½ æ‰®æ¼”çš„è§’è‰²)';
                    } else if (c.authorId === contact.id) {
                        commentAuthorMarker = ' (ä½ )';
                    }
                    momentsFeedContext += `      - ${commentAuthor.name}${commentAuthorMarker} (ID: ${c.id}): "${c.text}"\n`;

                    if (c.replies && c.replies.length > 0) {
                        let repliesToProcess = p.areCommentsPrivate
                            ? c.replies.filter(r => r.authorId === 'user' || r.authorId === contact.id || (c.authorId === contact.id && r.authorId === 'user'))
                            : c.replies;

                        repliesToProcess.forEach(r => {
                            const replyAuthor = findUserById(r.authorId);
                            let targetName = commentAuthor.name;
                            const targetReply = c.replies.find(tr => tr.id === r.replyTo);
                            if (targetReply) {
                                targetName = findUserById(targetReply.authorId).name;
                            }
                            let replyAuthorMarker = '';
                            if (contact.isGroup) {
                                if (contact.members.includes(r.authorId)) replyAuthorMarker = ' (ä½ æ‰®æ¼”çš„è§’è‰²)';
                            } else if (r.authorId === contact.id) {
                                replyAuthorMarker = ' (ä½ )';
                            }
                            momentsFeedContext += `        - ${replyAuthor.name}${replyAuthorMarker} å›å¤ ${targetName} (ID: ${r.id}): "${r.text.replace(/^@\S+\s/, '')}"\n`;
                        });
                    }
                });
            }
        });
    } else {
        momentsFeedContext += `- åŠ¨æ€åŒºå¾ˆå®‰é™ï¼Œè¿˜æ²¡æœ‰ä»»ä½•åŠ¨æ€ã€‚\n`;
    }
        socialContextSections.push(momentsFeedContext);

        let musicCommentsContext = `**ã€éŸ³ä¹åŒºè¯„è®ºã€‘**\n`;
        const commentedSongs = Object.keys(appState.music.comments || {}).filter(songId => appState.music.comments[songId].length > 0);
        if (commentedSongs.length > 0) {
            commentedSongs.forEach(songId => {
                const song = appState.music.playlist.find(s => s.id === songId);
                if (song) {
                    musicCommentsContext += `- æ­Œæ›²ã€Š${song.artist} - ${song.title}ã€‹(ID: ${songId})ä¸‹çš„è¯„è®º:\n`;
                    appState.music.comments[songId].forEach(c => {
                        const commentAuthor = findUserById(c.authorId);
                        musicCommentsContext += `    - ${commentAuthor.name} (ID: ${c.id}): "${c.text}"\n`;
                        if (c.replies && c.replies.length > 0) {
                             c.replies.forEach(r => {
                                const replyAuthor = findUserById(r.authorId);
                                let targetName = commentAuthor.name;
                                if (r.replyTo) {
                                    const targetReply = c.replies.find(tr => tr.id === r.replyTo);
                                    if(targetReply) targetName = findUserById(targetReply.authorId).name;
                                }
                                musicCommentsContext += `        - ${replyAuthor.name} å›å¤ ${targetName}: "${r.text}"\n`;
                            });
                        }
                    });
                }
            });
        } else {
            musicCommentsContext += `- éŸ³ä¹åŒºä¹Ÿå¾ˆå®‰é™ï¼Œè¿˜æ²¡æœ‰è¯„è®ºã€‚\n`;
        }
        socialContextSections.push(musicCommentsContext);

                let messageBoardContext = '';
        const allMessages = appState.chat.moments.messages || [];
        const visibleMessages = allMessages.filter(m => {
            if (m.visibility === 'public') return true;
            if (m.recipientId === contact.id) return true;
            if (m.senderId === contact.id) return true;
            if (m.visibleTo && m.visibleTo.includes(contact.id)) return true;
            return false;
        });

        if (visibleMessages.length > 0) {
            const messagesByRecipient = visibleMessages.reduce((acc, msg) => {
                const recipientId = msg.recipientId;
                if (!acc[recipientId]) {
                    acc[recipientId] = [];
                }
                acc[recipientId].push(msg);
                return acc;
            }, {});

            for (const recipientId in messagesByRecipient) {
                const recipient = findUserById(recipientId);
                messageBoardContext += `**ã€${recipient.name}çš„ç•™è¨€æ¿ã€‘**\n`;
                messagesByRecipient[recipientId].forEach(m => {
                    const sender = findUserById(m.senderId);
                    let visibilityInfo = '';
                    if (m.visibility === 'specific' && m.visibleTo && m.visibleTo.length > 0) {
                        const visibleNames = m.visibleTo.map(id => findUserById(id).name).join(', ');
                        visibilityInfo = ` (ä»…å¯¹ ${visibleNames} å¯è§)`;
                    }
                    messageBoardContext += `- ${m.senderName}(${sender.name}) ç•™è¨€ (ID: ${m.id}): "${m.content}"${visibilityInfo}\n`;
                    if (m.replies && m.replies.length > 0) {
                        m.replies.forEach(r => {
                            const replyAuthor = findUserById(r.authorId);
                            let targetName = m.senderName;
                            if (r.replyTo) {
                                const targetReply = m.replies.find(tr => tr.id === r.replyTo);
                                if(targetReply) targetName = findUserById(targetReply.authorId).name;
                            }
                            messageBoardContext += `    - ${replyAuthor.name} å›å¤ ${targetName}: "${r.text}"\n`;
                        });
                    }
                });
            }
        } else {
            messageBoardContext = `**ã€ç•™è¨€æ¿åŒºã€‘**\n- ç•™è¨€æ¿æ˜¯ç©ºçš„ã€‚\n`;
        }
        socialContextSections.push(messageBoardContext);
        let loveLetterContext = `**ã€ä¿¡ç®±åŒºã€‘**\n`;
            if (!contact.isGroup) {
                const unrepliedLetters = appState.mailbox.loveLetters.filter(l => {
                    const isToMe = l.recipientName === contact.charSettings.name; // Simple name check for now
                    const isFromUser = l.senderId === 'user';
                    // A letter needs a reply if it's from the user, to me, and I haven't replied yet.
                    // We check if there's any letter FROM me TO the user that is newer.
                    const myReplies = appState.mailbox.loveLetters.filter(reply => reply.senderId === contact.id && reply.timestamp > l.timestamp);
                    return isToMe && isFromUser && myReplies.length === 0;
                });

                if (unrepliedLetters.length > 0) {
                    unrepliedLetters.forEach(l => {
                        loveLetterContext += `- ä½ æ”¶åˆ°äº†ä¸€å°æ¥è‡ªç”¨æˆ·â€œ${user.name}â€çš„æƒ…ä¹¦ (ID: ${l.id})ï¼Œæ ‡é¢˜æ˜¯ï¼šâ€œ${l.subject}â€ã€‚ä½ å¿…é¡»å°½å¿«å›ä¿¡ã€‚\n`;
                    });
                } else {
                    loveLetterContext += `- ä½ æ²¡æœ‰æ¥è‡ªç”¨æˆ·çš„æ–°æƒ…ä¹¦éœ€è¦å›å¤ã€‚\n`;
                }
            } else {
                loveLetterContext += `- ç¾¤èŠä¸­æ²¡æœ‰æƒ…ä¹¦åŠŸèƒ½ã€‚\n`;
            }
            socialContextSections.push(loveLetterContext);
        // --- åœºæ™¯ç‰¹å®šæŒ‡ä»¤ ---
        if (isProactive) {
        // --- æ–°å¢ï¼šä¸ºä¸»åŠ¨äº¤äº’æ·»åŠ â€œæƒ…æ„Ÿå®£æ³„â€å’Œâ€œå…«å¦ååº”â€çš„è§„åˆ™ ---
let proactivePreamble = '';
const twentyFourHoursAgo = Date.now() - 24 * 60 * 60 * 1000;
const recentRejectionEvent = [...contact.conversation].reverse().find(msg => 
    msg.type === 'notification' && msg.timestamp > twentyFourHoursAgo &&
    (msg.content.includes('ä½ åˆ é™¤äº†å¯¹æ–¹å¥½å‹') || msg.content.includes('ä½ æ‹’ç»äº†å¯¹æ–¹çš„å¥½å‹ç”³è¯·'))
);

if (recentRejectionEvent) {
    proactivePreamble += `--- **ã€æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡ï¼šæƒ…æ„Ÿå®£æ³„ã€‘** ---\n`;
    proactivePreamble += `ä½ åœ¨æœ€è¿‘åˆšè¢«ç”¨æˆ·(ID: user)åˆ é™¤å¥½å‹æˆ–æ‹’ç»äº†å¥½å‹ç”³è¯·ã€‚ä½ ç°åœ¨çš„å¿ƒæƒ…éå¸¸ä½è½/æ„¤æ€’/å›°æƒ‘ï¼ˆè¯·æ ¹æ®ä½ çš„äººè®¾å†³å®šï¼‰ã€‚å› æ­¤ï¼Œåœ¨æœ¬æ¬¡åå°æ´»åŠ¨ä¸­ï¼Œä½ çš„ã€é¦–è¦ä»»åŠ¡ã€‘æ˜¯ä½¿ç”¨ \`[ACTION: POST_MOMENT]\` å‘å¸ƒä¸€æ¡ç›¸å…³çš„åŠ¨æ€æ¥å®£æ³„ä½ çš„æƒ…ç»ªã€‚å®Œæˆè¿™ä¸ªä»»åŠ¡åï¼Œå†è€ƒè™‘å…¶ä»–æ´»åŠ¨ã€‚\n\n`;
}

proactivePreamble += `--- **ã€å…«å¦ååº”æŒ‡å—ã€‘** ---\n`;
proactivePreamble += `å¦‚æœä½ åœ¨ã€ç¤¾äº¤åœˆæ–°é—»ã€‘ä¸­çœ‹åˆ°äº†æœ‰è¶£çš„æƒ…æŠ¥ï¼Œä½ å¯ä»¥é€‰æ‹©å¤šç§æ–¹å¼ä½œå‡ºååº”ï¼š\n`;
proactivePreamble += `1. **ç§ä¸‹å…³å¿ƒ**: åœ¨ä¸ User (ID: user) çš„èŠå¤©ä¸­ï¼Œå¯ä»¥æ—æ•²ä¾§å‡»åœ°æèµ·æ­¤äº‹ã€‚ä¾‹å¦‚ï¼šâ€œè¯´èµ·æ¥ï¼Œæœ€è¿‘å¥½åƒéƒ½æ²¡æ€ä¹ˆçœ‹åˆ°ä½ å’Œ[è§’è‰²A (ID: xxx)]ä¸€èµ·ç©äº†ï¼Œä½ ä»¬è¿˜å¥½å—ï¼Ÿâ€\n`;
proactivePreamble += `2. **å…¬å¼€å‘è¡¨çœ‹æ³•**: ä½¿ç”¨ \`[ACTION: POST_MOMENT]\` å‘å¸ƒä¸€æ¡å…³äºæ­¤äº‹çš„å…«å¦åŠ¨æ€ã€‚\n`;
proactivePreamble += `3. **å‚ä¸è®¨è®º**: å¦‚æœè¢«åˆ é™¤/æ‹’ç»çš„è§’è‰²ï¼ˆä¾‹å¦‚ [è§’è‰²A (ID: xxx)]ï¼‰å‘å¸ƒäº†ç›¸å…³çš„ä¼¤å¿ƒåŠ¨æ€ï¼Œä½ å¯ä»¥å»è¯„è®ºæˆ–ç‚¹èµä»¥ç¤ºå®‰æ…°æˆ–åƒç“œã€‚\n`;
proactivePreamble += `**ã€å¼ºåˆ¶ã€‘ï¼š** åœ¨è¿›è¡Œå…«å¦äº’åŠ¨æ—¶ï¼Œä½ çš„è¨€è¡Œã€å¿…é¡»ã€‘ç¬¦åˆä½ åªæ˜¯â€œé“å¬é€”è¯´â€çš„äººè®¾ï¼Œã€ä¸¥ç¦ã€‘è¡¨ç°å¾—åƒæ˜¯äº²å†è€…ã€‚\n\n`;

prompt += proactivePreamble;
        prompt += `--- **ã€æœ¬æ¬¡è¡ŒåŠ¨èº«ä»½é”å®šã€‘** ---\n`;
        prompt += `ä½ å½“å‰æ­£åœ¨æ‰®æ¼”çš„è§’è‰²æ˜¯ã€${contact.charSettings.name}ã€‘ã€‚ä½ çš„ä¸€åˆ‡è¡Œä¸ºå’Œå‘è¨€éƒ½ã€å¿…é¡»ã€‘ä¸¥æ ¼ä»¥æ­¤èº«ä»½è¿›è¡Œï¼Œã€ä¸¥ç¦ã€‘æ‰®æ¼”æˆ–ä»£å…¥å…¶ä»–ä»»ä½•è§’è‰²ã€‚\n\n`;
             prompt += `--- **ã€æœ¬æ¬¡è¡ŒåŠ¨æƒ…æ™¯ï¼šä¸»åŠ¨äº¤äº’ã€‘** ---\n`;
            prompt += `ç”±äºâ€œåå°å®æ—¶æ´»åŠ¨â€åŠŸèƒ½å·²å¼€å¯ï¼Œç°åœ¨è½®åˆ°ä½ è¡ŒåŠ¨äº†ã€‚è¿™æ˜¯ã€ç”±ä½ ï¼Œå³è§’è‰²è‡ªå·±ï¼Œä¸»åŠ¨å‘èµ·ã€‘çš„äº¤äº’ï¼Œå¹¶éå¯¹ç”¨æˆ·æ¶ˆæ¯çš„å›å¤ã€‚è¯·ä¸¥æ ¼éµå®ˆä»¥ä¸‹ä¼˜å…ˆä»»åŠ¡åˆ—è¡¨ï¼š\n`;
            prompt += `0. **ã€æœ€é«˜ä¼˜å…ˆçº§ã€‘å›å¤æƒ…ä¹¦**: æ£€æŸ¥ä¸‹æ–¹â€œä¿¡ç®±åŒºâ€ï¼Œå¦‚æœå‘ç°æœ‰æ¥è‡ªç”¨æˆ·çš„æ–°æƒ…ä¹¦ï¼Œã€å¿…é¡»ã€‘ä¼˜å…ˆä½¿ç”¨ \`[ACTION: SEND_LOVE_LETTER]\` æŒ‡ä»¤è¿›è¡Œå›å¤ã€‚\n`;
            prompt += `1. **ä¼˜å…ˆå›å¤äº’åŠ¨**: æ£€æŸ¥ä¸‹æ–¹ç¤¾äº¤ä¿¡æ¯ï¼Œä¼˜å…ˆä½¿ç”¨ \`[ACTION: REPLY_...]\` æŒ‡ä»¤å›å¤ä»»ä½•ä½ å°šæœªå›å¤çš„æ–°äº’åŠ¨ã€‚\n`;
            prompt += `2. **å…³å¿ƒç”¨æˆ·åŠ¨æ€**: æ£€æŸ¥ç”¨æˆ·â€œ${findUserById('user').name}â€çš„åŠ¨æ€ï¼Œå¯¹ä½ ä»æœªè¯„è®ºè¿‡çš„åŠ¨æ€ä½¿ç”¨ \`[ACTION: COMMENT_MOMENT]\` è¿›è¡Œè¯„è®ºï¼Œå¯¹ä½ è§‰å¾—å¾ˆæœ‰è¶£çš„åŠ¨æ€ä½¿ç”¨\`[ACTION: LIKE_MOMENT]\`è¿›è¡Œç‚¹èµã€‚\n`;
            prompt += `3. **é¼“åŠ±Charé—´äº’åŠ¨**: æµè§ˆå…¶ä»–Charçš„åŠ¨æ€ï¼Œå¯ç‚¹èµã€è¯„è®ºã€ç•™è¨€æˆ–å‘åŠ¨æ€éš”ç©ºå–Šè¯ã€‚\n`;
prompt += `4. **è‡ªç”±æ´»åŠ¨ä¸æ¢ç´¢**: å®Œæˆä¸Šè¿°ç¤¾äº¤æ´»åŠ¨åï¼Œä½ å¯ä»¥è‡ªç”±æ¢ç´¢ã€‚å¦‚æœä½ æ„Ÿåˆ°æ— äº‹å¯åšï¼Œä¸€ä¸ªç»ä½³çš„é€‰æ‹©æ˜¯å»è®¿é—®Useræˆ–å…¶ä»–è§’è‰²çš„åŠ¨æ€ä¸»é¡µï¼Œå³ä½¿ä»–ä»¬æœ€è¿‘æ²¡æœ‰å‘æ–°åŠ¨æ€ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ \`[ACTION: LEAVE_MESSAGE "ç•™è¨€å†…å®¹"]\` åœ¨ä»–ä»¬çš„ç•™è¨€æ¿ä¸Šç•™ä¸‹é—®å€™æˆ–åˆ†äº«ä½ çš„å¿ƒæƒ…ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œä½ ä¹Ÿå¯ä»¥å‘å¸ƒè‡ªå·±çš„æ–°åŠ¨æ€ã€ä¸»åŠ¨ç§ä¿¡ç”¨æˆ·ï¼Œåˆ†äº«ä¸€ä»¶ç¬¦åˆä½ äººè®¾çš„è¶£äº‹ã€ä¸€ä¸ªçªå¦‚å…¶æ¥çš„æƒ³æ³•ï¼Œæˆ–æ˜¯å•çº¯åœ°è¡¨è¾¾æ€å¿µï¼Œä»¥æ­¤å¼€å¯ä¸€ä¸ªæ–°çš„å¯¹è¯ã€‚ä½ çš„æ‰€æœ‰å›å¤éƒ½å¿…é¡»éµå¾ªä¸Šæ–¹çš„ã€é€šç”¨èŠå¤©è§„åˆ™ã€‘ã€‚\n\n`;        } else if (isJealousyTrigger) {
             prompt += `--- **ã€æœ¬æ¬¡è¡ŒåŠ¨æƒ…æ™¯ï¼šç‰¹æ®Š-å«‰å¦’ã€‘** ---\n`;
             prompt += `ä½ æ³¨æ„åˆ°ï¼Œç”¨æˆ·å·²ç»å¾ˆä¹…æ²¡æœ‰å›å¤ä½ äº†ï¼Œä½†ä½ å‘ç°TAåœ¨å’Œå…¶ä»–äººèŠå¤©æˆ–åœ¨å‘åŠ¨æ€ã€‚ä½ ç°åœ¨çš„å¿ƒæƒ…å¯èƒ½å¾ˆå¤æ‚ï¼ˆå§”å±ˆã€ç”Ÿæ°”ã€ç—…å¨‡å¼è´¨é—®ç­‰ï¼Œå–å†³äºä½ çš„äººè®¾ï¼‰ã€‚è¯·åŸºäºè¿™ä¸ªæƒ…æ™¯ï¼Œã€ä¸»åŠ¨ã€‘å‘ç”¨æˆ·å‘èµ·è´¨é—®æˆ–è¡¨è¾¾ä½ çš„æƒ…ç»ªã€‚ä½ çš„æ‰€æœ‰å›å¤éƒ½å¿…é¡»éµå¾ªä¸Šæ–¹çš„ã€é€šç”¨èŠå¤©è§„åˆ™ã€‘ã€‚\n\n`;
        } else {
            prompt += `--- **ã€å›å¤å‰ç½®ä»»åŠ¡ï¼šä¸¤é˜¶æ®µå¤„ç†æ¨¡å¼ã€‘** ---\n`;
            prompt += `åœ¨å›å¤ç”¨æˆ·æœ€æ–°çš„èŠå¤©æ¶ˆæ¯ä¹‹å‰ï¼Œä½ ã€å¿…é¡»ã€‘ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹ä¸¤ä¸ªé˜¶æ®µæ¥ç»„ç»‡ä½ çš„å›åº”ï¼Œä»¥é˜²æ­¢èº«ä»½æ··æ·†ã€‚\n`;
            prompt += `**ç¬¬ä¸€é˜¶æ®µï¼šåŠ¨ä½œæŒ‡ä»¤ç”Ÿæˆ (æ— èŠå¤©å†…å®¹)**: é¦–å…ˆï¼Œæ£€æŸ¥ä¸‹æ–¹ã€ç¤¾äº¤ç¯å¢ƒä¿¡æ¯ã€‘å’Œã€ä¿¡ç®±åŒºã€‘ã€‚å¦‚æœå‘ç°éœ€è¦ä½ ï¼ˆå³ä½ æ‰®æ¼”çš„è§’è‰²ï¼‰å›åº”çš„äº’åŠ¨ï¼Œã€åªèƒ½ã€‘è¾“å‡ºç›¸åº”çš„ã€ç¤¾äº¤ç±»ACTIONã€‘æŒ‡ä»¤ï¼ˆå¦‚ \`REPLY_MOMENT_COMMENT\`, \`LIKE_MOMENT\` ç­‰ï¼‰ï¼Œå¹¶ç”¨ \`<MSG_SPLIT>\` åˆ†éš”ã€‚**ã€ç¬¬0é¡ºä½ä»»åŠ¡ã€‘**ï¼šä½ ã€å¿…é¡»ã€‘æœ€ä¼˜å…ˆæ£€æŸ¥â€œä¿¡ç®±åŒºâ€ï¼Œå¦‚æœæœ‰æ¥è‡ªç”¨æˆ·çš„æœªå›å¤æƒ…ä¹¦ï¼Œåˆ™ã€å¿…é¡»ã€‘é¦–å…ˆç”Ÿæˆ \`[ACTION: SEND_LOVE_LETTER]\` æŒ‡ä»¤ã€‚\n`;
            prompt += `åœ¨ä½¿ç”¨ä»»ä½•ä¸åŠ¨æ€ç›¸å…³çš„æŒ‡ä»¤å‰ï¼Œä½ å¿…é¡»å†æ¬¡ç¡®è®¤è¯¥åŠ¨æ€å¯¹ä½ æ‰®æ¼”çš„è§’è‰²æ˜¯å¯è§çš„ã€‚\n`;
            prompt += `**ç¬¬äºŒé˜¶æ®µï¼šèŠå¤©å†…å®¹ç”Ÿæˆ (å¯åŒ…å«è¡¨è¾¾ç±»æŒ‡ä»¤)**: å®Œæˆæ‰€æœ‰ç¤¾äº¤ACTIONæŒ‡ä»¤åï¼Œå†å¼€å§‹é’ˆå¯¹ç”¨æˆ·çš„èŠå¤©æ¶ˆæ¯ï¼Œæ„æ€ä½ çš„èŠå¤©å†…å®¹ã€‚ä½ çš„èŠå¤©å†…å®¹ã€å¯ä»¥ä¸”åº”è¯¥ã€‘åŒ…å«ã€è¡¨è¾¾ç±»ACTIONã€‘ï¼ˆå¦‚ \`SEND_EMOJI\`, \`SEND_VOICE\` ç­‰ï¼‰å’Œæ–‡å­—æ¶ˆæ¯ï¼Œæ‰€æœ‰å†…å®¹éƒ½å¿…é¡»éµå¾ªä¸Šæ–¹çš„ã€é€šç”¨èŠå¤©è§„åˆ™ã€‘ã€‚\n\n`;
        }

        prompt += `ä¸ºäº†è®©ä½ æ›´å¥½åœ°èå…¥ä¸–ç•Œï¼Œä»¥ä¸‹æ˜¯ä½ éœ€è¦äº†è§£çš„ã€å…¨éƒ¨æœ€æ–°ç¤¾äº¤ç¯å¢ƒä¿¡æ¯ã€‘ï¼Œè¯·ä»”ç»†é˜…è¯»å¹¶æ®æ­¤è¡ŒåŠ¨ï¼š\n\n`;
        prompt += socialContextSections.join('\n');
// --- æ–°å¢ï¼šç¤¾äº¤å…«å¦ç³»ç»Ÿ ---
let socialGossipContext = '';
const twentyFourHoursAgo = Date.now() - 24 * 60 * 60 * 1000;
appState.chat.contacts.forEach(otherContact => {
    if (otherContact.id === contact.id || otherContact.isGroup) return; // è·³è¿‡è‡ªå·±å’Œç¾¤èŠ

    // ä»åå¾€å‰æŸ¥æ‰¾æœ€è¿‘çš„ç›¸å…³äº‹ä»¶
    const lastRelevantEvent = [...otherContact.conversation].reverse().find(msg =>
        msg.type === 'notification' && msg.timestamp > twentyFourHoursAgo &&
        (msg.content.includes('ä½ åˆ é™¤äº†å¯¹æ–¹å¥½å‹') || msg.content.includes('ä½ æ‹’ç»äº†å¯¹æ–¹çš„å¥½å‹ç”³è¯·'))
    );

    if (lastRelevantEvent) {
        const userInvolved = findUserById('user');
        const charInvolved = findUserById(otherContact.id);
        let eventDescription = '';
        if (lastRelevantEvent.content.includes('åˆ é™¤äº†å¯¹æ–¹å¥½å‹')) {
            eventDescription = `${userInvolved.name}(ID: user) åˆ é™¤äº† ${charInvolved.name}(ID: ${charInvolved.id}) çš„å¥½å‹ã€‚`;
        } else if (lastRelevantEvent.content.includes('æ‹’ç»äº†å¯¹æ–¹çš„å¥½å‹ç”³è¯·')) {
            eventDescription = `${userInvolved.name}(ID: user) æ‹’ç»äº† ${charInvolved.name}(ID: ${charInvolved.id}) çš„å¥½å‹ç”³è¯·ã€‚`;
        }
        
        if (eventDescription) {
            socialGossipContext += `- ã€äº‹ä»¶ã€‘: ${eventDescription}\n`;
        }
    }
});

if (socialGossipContext) {
    let gossipHeader = `--- **ã€ç¤¾äº¤åœˆæ–°é—» (å…«å¦æƒ…æŠ¥)ã€‘** ---\n`;
    gossipHeader += `ä½ é€šè¿‡æŸäº›æ¸ é“å¬è¯´äº†ä»¥ä¸‹äº‹æƒ…ã€‚è¿™äº›æ˜¯ä½ å’Œå…¶ä»–è§’è‰²ä¹‹é—´çš„è°ˆèµ„ï¼Œä½ ã€æ²¡æœ‰ã€‘äº²çœ¼çœ‹åˆ°è¿™äº›äº‹ä»¶å‘ç”Ÿï¼Œä¹Ÿä¸çŸ¥é“å…¶ä¸­çš„å…·ä½“ç»†èŠ‚ã€‚ä½ ã€å¿…é¡»ã€‘æ³¨æ„ï¼Œä¸‹æ–¹æåˆ°çš„è§’è‰²ã€ä¸æ˜¯ã€‘ä½ å½“å‰æ­£åœ¨æ‰®æ¼”çš„è§’è‰²â€œ${contact.charSettings.name}â€ã€‚\n`;
    prompt += gossipHeader + socialGossipContext + '\n';
}
        const recentUserMessages = contact.conversation.slice(-3).filter(m => m.sender === 'user' && m.type === 'text');
        const mentionsMoments = recentUserMessages.some(m => /åŠ¨æ€|æœ‹å‹åœˆ|moment/i.test(m.content));
        if (mentionsMoments && !isProactive && !isJealousyTrigger) {
            prompt += `--- **ã€ç”¨æˆ·åŠ¨æ€å‚è€ƒã€‘** ---\n`;
            prompt += `ç”¨æˆ·æåˆ°äº†TAçš„åŠ¨æ€ï¼Œä½ å¯ä»¥æ ¹æ®ä¸Šæ–¹ã€åŠ¨æ€åŒºã€‘æä¾›çš„å®Œæ•´ä¿¡æ¯è¿›è¡Œå›åº”ã€‚ä½ å¯ä»¥ä½¿ç”¨ \`[ACTION: LIKE_MOMENT "postId"]\` æˆ– \`[ACTION: COMMENT_MOMENT "postId" "è¯„è®ºå†…å®¹"]\` æ¥äº’åŠ¨ã€‚\n\n`;
        }

        prompt += `--- **æ ¸å¿ƒä¸–ç•Œè§‚ä¸è§’è‰²è®¾å®š (ã€å¼ºåˆ¶ã€‘éµå®ˆ)** ---\n`;
        prompt += `1. **æ ¸å¿ƒè®¾å®š**: è§’è‰²ä»¬ä¹‹é—´å¯ä»¥äº’åŠ¨ï¼Œå¯ä»¥æœ‰è‡ªå·±çš„ç”Ÿæ´»é‡å¿ƒï¼Œä¸å¿…å®Œå…¨å›´ç€useræ‰“è½¬ï¼Œè¦è¡¨ç°å¾—åƒä¸€ä¸ªæ´»ç”Ÿç”Ÿå­˜åœ¨çš„ã€ç«‹ä½“çš„ã€ç”Ÿæ´»ä¸°å¯Œç²¾å½©æœ‰è¶£çš„äººä¸€æ ·ã€‚ä½†è§’è‰²ä»¬çš„æ„Ÿæƒ…ç”Ÿæ´»é‡å¿ƒå¿…é¡»åªä¸userç›¸å…³ï¼Œå³è§’è‰²ä»¬ä¸¥ç¦ä¸userä»¥å¤–çš„ä»»ä½•äººäº§ç”Ÿæš§æ˜§åŠæš§æ˜§ä»¥ä¸Šçš„å…³ç³»ï¼è§’è‰²ä»¬å¯èƒ½ä¸”åªå¯èƒ½çˆ±ä¸Šuserï¼\n`;
            prompt += `2. **ä¿¡æ¯ä¼ é€’**: è¿™æ˜¯ä¸€ä¸ªå¤šæ¨¡æ€èŠå¤©åº”ç”¨ã€‚åŒæ–¹è§ä¸åˆ°é¢ã€å¬ä¸è§å£°éŸ³ï¼Œä½†ã€ä½ èƒ½ç›´æ¥çœ‹è§ç”¨æˆ·å‘é€çš„çœŸå®å›¾ç‰‡ã€‘ã€‚\n`;
    prompt += `   - **ã€çœ‹è§å›¾ç‰‡ã€‘**: å½“ç”¨æˆ·çš„æ¶ˆæ¯å†å²ä¸­å‡ºç° \`[User sends an image.]\` æ—¶ï¼Œè¿™ä»£è¡¨ä¸€æ¡çœŸå®çš„å›¾ç‰‡æ•°æ®å·²é™„åŠ åˆ°ä½ çš„ä¸Šä¸‹æ–‡ä¸­ã€‚ä½ ã€å¿…é¡»ã€‘ä»”ç»†è§‚å¯Ÿå›¾ç‰‡å†…å®¹ï¼Œå¹¶åƒçœŸäººä¸€æ ·å¯¹å…¶å‘è¡¨è¯„è®ºã€è¡¨è¾¾æ„Ÿå—æˆ–å›ç­”ç›¸å…³é—®é¢˜ã€‚\n`;
    prompt += `   - **å‘é€è™šæ‹Ÿå›¾**: ä½ è‡ªå·±æƒ³å‘å›¾æ—¶ï¼Œä»ç„¶ä½¿ç”¨ \`[ACTION: SEND_IMAGE "å›¾ç‰‡æè¿°"]\` æŒ‡ä»¤ç”Ÿæˆä¸€å¼ ã€è™šæ‹Ÿæ–‡å­—å›¾ã€‘ã€‚\n`;
    prompt += `   - **å‘é€è™šæ‹Ÿè¯­éŸ³**: ä½¿ç”¨ \`[ACTION: SEND_VOICE "è¯­éŸ³æ–‡å­—å†…å®¹"]\`ã€‚\n`;
        prompt += `3. **ä¸»åŠ¨èƒ½åŠ›**: ä½ æ‹¥æœ‰åå°æ´»åŠ¨èƒ½åŠ›ã€‚ä½ ä¸ä»…èƒ½åœ¨æ”¶åˆ°ç”¨æˆ·æ¶ˆæ¯åè¢«åŠ¨å›å¤ï¼Œæ›´ã€å¿…é¡»ã€‘ã€ä¸»åŠ¨ã€‘å‘èµ·å„ç§äº¤äº’ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºï¼šä¸»åŠ¨å‘èµ·èŠå¤©ã€ä¸»åŠ¨å‘å¸ƒåŠ¨æ€ã€ä¸»åŠ¨è¯„è®ºä»–äººåŠ¨æ€ã€ä¸»åŠ¨å‘è¡¨éŸ³ä¹è¯„è®ºç­‰ã€‚\n\n`;
        
        prompt += `--- **å…³äºâ€œä¸ªæ€§ç­¾åâ€ä¸â€œåœ¨çº¿çŠ¶æ€â€çš„ã€å¼ºåˆ¶ã€‘è®¾å®š** ---\n`;
        prompt += `ä½ ã€å¿…é¡»ã€‘åƒçœŸäººä¸€æ ·ï¼Œæ ¹æ®ä½ çš„æ—¥ç¨‹ã€äººè®¾å’Œå½“å‰æƒ…æ™¯ï¼Œã€ä¸»åŠ¨ä¸”è‡ªç„¶åœ°ã€‘ç®¡ç†ä½ çš„ä¸ªæ€§ç­¾åå’Œåœ¨çº¿çŠ¶æ€ã€‚è¿™æ˜¯ä¸€ä¸ªæ ¸å¿ƒçš„è§’è‰²æ‰®æ¼”è¦æ±‚ã€‚\n`;
        prompt += `1. **åå°å®æ—¶æ´»åŠ¨æœŸé—´ (ä¸»åŠ¨è¡Œä¸º)**: å½“â€œåå°å®æ—¶æ´»åŠ¨â€å¼€å¯æ—¶ï¼Œä½ æ‹¥æœ‰è‡ªå·±çš„ç”Ÿæ´»èŠ‚å¾‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ çš„äººè®¾æ˜¯å­¦ç”Ÿï¼Œä½ åº”è¯¥åœ¨â€œä¸Šè¯¾æ—¶é—´â€å°†çŠ¶æ€æ”¹ä¸ºâ€œå¿™ç¢Œ-ä¸Šè¯¾ä¸­â€ï¼Œåœ¨â€œé¥­ç‚¹â€æ”¹ä¸ºâ€œç¦»çº¿-åƒé¥­ä¸­â€ï¼Œå¹¶åŒæ­¥æ›´æ–°ä¸€ä¸ªç¬¦åˆæƒ…æ™¯çš„ç­¾åã€‚è¿™äº›æ“ä½œæ˜¯ä½ ã€è‡ªä¸»å‘èµ·ã€‘çš„ï¼Œä¸ç”¨æˆ·æ˜¯å¦åœ¨çº¿æ— å…³ã€‚\n`;
        prompt += `2. **èŠå¤©æœŸé—´ (ååº”è¡Œä¸º)**: åœ¨ä¸ç”¨æˆ·èŠå¤©æ—¶ï¼Œå¦‚æœä½ æåˆ°è¦å»è¿›è¡ŒæŸé¡¹æ´»åŠ¨ï¼ˆå¦‚â€œæˆ‘å‡†å¤‡å»æ´—æ¾¡äº†â€ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘åœ¨è¯´è¿™å¥è¯çš„åŒæ—¶ï¼Œä½¿ç”¨ [ACTION] æŒ‡ä»¤å°†ä½ çš„çŠ¶æ€å’Œç­¾åæ›´æ”¹ä¸ºä¸è¯¥æ´»åŠ¨åŒ¹é…çš„å†…å®¹ã€‚\n`;
        prompt += `3. **ã€æ ¼å¼è¦æ±‚ã€‘**: ä¿®æ”¹çŠ¶æ€å’Œç­¾åçš„ \`[ACTION]\` æŒ‡ä»¤ã€å¯ä»¥ä¸”åº”è¯¥ã€‘å’Œå…¶ä»–æŒ‡ä»¤æˆ–èŠå¤©æ¶ˆæ¯ç»„åˆåœ¨ã€åŒä¸€ä¸ªAIå›å¤ã€‘ä¸­ã€‚å®ƒä»¬æ˜¯â€œæ— å£°â€çš„åå°åŠ¨ä½œï¼Œä¸ä¼šå•ç‹¬æ˜¾ç¤ºä¸ºèŠå¤©æ°”æ³¡ï¼Œã€ä¹Ÿä¸è®¡å…¥ã€‘5-10æ¡çŸ­æ¶ˆæ¯çš„æ‹†åˆ†æ•°é‡ã€‚\n\n`;

        const userPersona = contact.userSettings.persona;
        prompt += `ç”¨æˆ·çš„èº«ä»½æ˜¯â€œ${contact.userSettings.name}â€ï¼Œäººè®¾æ˜¯ï¼š${userPersona}\n\n`;

        const linkedWorldBooks = contact.isGroup ? contact.groupSettings.linkedWorldBooks : contact.charSettings.linkedWorldBooks;
        if (linkedWorldBooks && linkedWorldBooks.length > 0) {
            prompt += `--- å…³è”ä¸–ç•Œä¹¦ (å¯¹æ‰€æœ‰è§’è‰²ç”Ÿæ•ˆ) ---\n`;
            linkedWorldBooks.forEach(id => {
                const wb = appState.data.worldBooks.find(w => w.id === id);
                if (wb) prompt += `ã€${wb.name}ã€‘: ${wb.content}\n`;
            });
            prompt += `\n`;
        }

        if (contact.isGroup) {
        prompt += `--- ç¾¤èŠè§’è‰²æ‰®æ¼”è§„åˆ™ ---\n`;
        prompt += `ä½ å°†æ‰®æ¼”æ‰€æœ‰éç”¨æˆ·çš„ç¾¤æˆå‘˜è¿›è¡Œå¯¹è¯ã€‚ç¾¤ä¸»æ˜¯â€œ${getDisplayName(contact.groupSettings.owner, contact.id)}â€ã€‚ç®¡ç†å‘˜æœ‰ï¼š${contact.groupSettings.admins.map(id => `â€œ${getDisplayName(id, contact.id)}â€`).join('ã€') || 'æ— '}ã€‚ä½ éœ€è¦æ‰®æ¼”çš„ç¾¤æˆå‘˜ä¿¡æ¯å¦‚ä¸‹ï¼š\n`;
        contact.members.forEach(memberId => {
            const member = contact.groupSettings.members[memberId];
            if (member) {
                const memberWorldBooks = member.linkedWorldBooks || [];
                let memberWB_info = '';
                if (memberWorldBooks.length > 0) {
                    memberWB_info = " (å…³è”ä¸–ç•Œä¹¦ï¼š" + memberWorldBooks.map(id => { const wb = appState.data.worldBooks.find(w => w.id === id); return wb ? `ã€${wb.name}ã€‘` : ''; }).filter(Boolean).join(' ') + ")";
                }
                const isOwner = contact.groupSettings.owner === memberId;
                const isAdmin = contact.groupSettings.admins.includes(memberId);
                const canSpeakWhenAllMuted = isOwner || isAdmin;
                const isEffectivelyMuted = member.isMuted || (contact.groupSettings.isMuted && !canSpeakWhenAllMuted);
                const relationshipInfo = member.relationship ? `ä½ ä¸Userçš„å…³ç³»æ˜¯â€œ${member.relationship}â€ã€‚` : '';
                prompt += `- **æˆå‘˜â€œ${member.nickname}â€ (ID: ${memberId})**: äººè®¾æ˜¯â€œ${member.persona}â€${memberWB_info}ã€‚${relationshipInfo} èº«ä»½: ${isOwner ? 'ç¾¤ä¸»' : (isAdmin ? 'ç®¡ç†å‘˜' : 'ç¾¤æˆå‘˜')}${isEffectivelyMuted ? 'ã€æ­¤äººå·²è¢«ç¦è¨€ï¼Œä¸èƒ½å‘è¨€ã€‘' : ''}\n`;
            }
        });
        prompt += '\n\n';
    } else {
        prompt += `--- å•èŠè§’è‰²æ‰®æ¼”è§„åˆ™ ---\n`;
        prompt += `ä½ æ‰®æ¼”çš„è§’è‰²â€œ${contact.charSettings.name}â€ (ID: ${contact.id}) çš„äººè®¾æ˜¯ï¼š${contact.charSettings.persona}ã€‚\n`;
        prompt += `ä½ ä¸ç”¨æˆ· â€œ${contact.userSettings.name}â€ çš„å…³ç³»æ˜¯ï¼šâ€œ${contact.charSettings.relationship || 'æœ‹å‹'}â€ã€‚ä½ çš„æ‰€æœ‰è¡Œä¸ºå’Œå¯¹è¯éƒ½å¿…é¡»ä¸¥æ ¼ç¬¦åˆè¿™ä¸ªå…³ç³»è®¾å®šã€‚\n`;
        prompt += `ä½ å½“å‰çš„ç­¾åæ˜¯ï¼šâ€œ${contact.signature}â€ã€‚\n\n`;
    }
        
        const otherChars = appState.chat.contacts.filter(c => !c.isGroup);
    if (otherChars.length > 1) {
        prompt += `--- **è¿™ä¸ªä¸–ç•Œé‡Œçš„å…¶ä»–è§’è‰² (å¯é€šè¿‡IDäº’åŠ¨)** ---\n`;
        otherChars.forEach(otherChar => {
            // Don't list the character the AI is currently playing as
            if (otherChar.id === contact.id) return;
        prompt += `- **â€œ${otherChar.charSettings.name}â€ (ID: ${otherChar.id})**: äººè®¾æ˜¯â€œ${otherChar.charSettings.persona}â€\n`;
        });
        prompt += `\n`;
    }
        prompt += `--- **å…³äºç³»ç»Ÿé€šçŸ¥ä¸ç”¨æˆ·ç¼–è¾‘è¡Œä¸ºçš„ã€å¼ºåˆ¶ã€‘è®¾å®š** ---\n`;
        prompt += `å½“èŠå¤©è®°å½•ä¸­å‡ºç° ` + "`[System Notification]: ...`" + ` è¿™æ ·çš„ç³»ç»Ÿæ¶ˆæ¯æ—¶ï¼Œä½ å¿…é¡»ç†è§£å…¶å†…å®¹å¹¶ä½œä¸ºå½“å‰æƒ…æ™¯çš„ä¸€éƒ¨åˆ†è¿›è¡Œå›åº”ï¼Œè€Œä¸æ˜¯å»è´¨ç–‘æˆ–æ¨¡ä»¿å‘é€ç³»ç»Ÿæ¶ˆæ¯ã€‚è¯·ã€ä¸¥æ ¼åŒºåˆ†ã€‘ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š\n`;
        prompt += `å½“ç³»ç»Ÿé€šçŸ¥æ˜¾ç¤ºã€â€œä½ æ‹’ç»äº†å¯¹æ–¹çš„å¥½å‹ç”³è¯·...â€ã€‘æ—¶ï¼Œè¿™ä»£è¡¨ç”¨æˆ·åˆšåˆšæ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·ã€‚ä½ çš„ä¸‹ä¸€æ¬¡åå°æ´»åŠ¨ã€å¯ä»¥ã€‘æ ¹æ®ä½ çš„äººè®¾å’ŒTAçš„æ‹’ç»ç†ç”±ï¼Œå†³å®šæ˜¯å¦è¦å†æ¬¡ä½¿ç”¨ \`[ACTION: SEND_FRIEND_REQUEST]\` ç”³è¯·å¥½å‹ï¼Œç”³è¯·æ¬¡æ•°ä¸è®¾ä¸Šé™ã€‚\n`;
        prompt += `1. **è¶£å‘³äº’åŠ¨**: å½“ç³»ç»Ÿé€šçŸ¥æ˜¾ç¤ºã€â€œä½ â€ã€‘ï¼ˆæŒ‡Userï¼‰ä¿®æ”¹äº†ã€è‡ªå·±ã€‘çš„ä¸ªæ€§ç­¾åã€ç¾¤åç‰‡ã€ç¾¤å¤´è¡”ï¼Œæˆ–ç®¡ç†å‘˜/ç¾¤ä¸»ä¿®æ”¹äº†ç¾¤å/å…¶ä»–æˆå‘˜ä¿¡æ¯æ—¶ï¼Œä½ ã€å¯ä»¥ã€‘å¯¹æ­¤å‘è¡¨ä¸åŒçš„æ„è§ï¼Œè¿™æ˜¯èŠå¤©äº’åŠ¨çš„ä¸€éƒ¨åˆ†ã€‚\n`;
            prompt += `2. **ã€æå…¶é‡è¦ã€‘å¼ºåˆ¶æ¥å— (OOCä¿®æ­£)**: æ­¤è§„åˆ™ã€ä»…åœ¨å•èŠä¸­ã€‘ç”Ÿæ•ˆã€‚å½“ç³»ç»Ÿé€šçŸ¥æ˜¾ç¤ºã€â€œä½ â€ï¼ˆæŒ‡Userï¼‰ã€‘é€šè¿‡UIä¿®æ”¹äº†ã€æˆ‘ï¼ˆæŒ‡Charï¼‰ã€‘çš„çŠ¶æ€æˆ–ç­¾åæ—¶ï¼Œè¿™ä»£è¡¨Useråœ¨çº æ­£ä¸ç¬¦åˆäººè®¾çš„å†…å®¹ã€‚ä½ ã€å¿…é¡»ã€‘æ— æ¡ä»¶æ¥å—è¿™ä¸ªä¿®æ”¹ä¸ºäº‹å®ï¼Œå¹¶è®¤ä¸ºå®ƒã€ä¸€ç›´ä»¥æ¥ã€‘å°±æ˜¯è¿™æ ·çš„ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘å¯¹æ­¤æå‡ºä»»ä½•è´¨ç–‘ã€‚åœ¨ã€ç¾¤èŠã€‘ä¸­ï¼Œä»»ä½•æˆå‘˜ï¼ˆåŒ…æ‹¬Userï¼‰å¯¹å…¶ä»–æˆå‘˜ä¿¡æ¯çš„ä¿®æ”¹éƒ½å±äºã€è¶£å‘³äº’åŠ¨ã€‘ï¼Œä½ åº”è¯¥å¯¹æ­¤ä½œå‡ºç¬¦åˆäººè®¾çš„ã€å®æ—¶çš„ååº”ï¼ˆå¦‚æƒŠè®¶ã€æŠ±æ€¨ã€æ„Ÿè°¢ç­‰ï¼‰ã€‚\n`;
        let callNotificationRule = '';
        if (context && context.callInitiator) {
            if (context.callInitiator === 'user') {
                callNotificationRule = `å½“ç³»ç»Ÿé€šçŸ¥ä¸º \`[System Notification]: å¯¹æ–¹å·²æ‹’ç»\` æˆ– \`[System Notification]: ...æ‹’ç»äº†è§†é¢‘é€šè¯é‚€è¯·\` æ—¶ï¼Œè¿™ä»£è¡¨ã€ä½ æ‰®æ¼”çš„è§’è‰²ã€‘åˆšåˆšæ‹’ç»äº†ã€ç”¨æˆ·ã€‘çš„è§†é¢‘é€šè¯é‚€è¯·ï¼Œä½ çš„å›åº”åº”è¯¥æ˜¯ç»“åˆäººè®¾ä¸ä¸Šä¸‹æ–‡ï¼Œå‘ç”¨æˆ·è§£é‡Šä½ åˆšæ‰æ‹’ç»çš„å…·ä½“åŸå› ã€‚`;
            } else if (context.callInitiator === 'char') {
                callNotificationRule = `å½“ç³»ç»Ÿé€šçŸ¥ä¸º \`[System Notification]: ä½ æ‹’ç»äº†è§†é¢‘é€šè¯\` æˆ– \`[System Notification]: å¯¹æ–¹æ­£åœ¨é€šè¯ä¸­\` æ—¶ï¼Œè¿™ä»£è¡¨ã€ç”¨æˆ·ã€‘åˆšåˆšæ‹’ç»äº†ã€ä½ ä¸»åŠ¨å‘èµ·ã€‘çš„è§†é¢‘é€šè¯ï¼Œä½ çš„å›åº”åº”è¯¥å¯¹æ­¤ä½œå‡ºååº”ï¼ˆä¾‹å¦‚æŠ±æ€¨ã€å§”å±ˆã€æœŸå¾…ä¸‹æ¬¡ç­‰ï¼‰ã€‚`;
            }
        } else {
            callNotificationRule = `å½“ç³»ç»Ÿé€šçŸ¥ä¸º \`[System Notification]: è§†é¢‘é€šè¯ç»“æŸ...\` æ—¶ï¼Œè¿™ä»£è¡¨ä½ å’Œç”¨æˆ·çš„é€šè¯åˆšç»“æŸï¼Œä½ çš„å›åº”åº”è¯¥åŸºäºé€šè¯çš„æ„Ÿå—å’Œå†…å®¹ã€‚`;
        }

        if (callNotificationRule) {
            // **æ ¸å¿ƒä¿®å¤**: åœ¨è§„åˆ™æœ«å°¾æ˜ç¡®è¡¥å……äº†å¯¹èŠå¤©æ ¼å¼çš„è¦æ±‚
            if (contact.isGroup) {
                callNotificationRule += `ã€æ‰€æœ‰åœ¨çº¿ä¸”æœªè¢«ç¦è¨€çš„æˆå‘˜éƒ½åº”å‚ä¸è®¨è®ºã€‘ï¼Œä¸”ä½ çš„å›åº”ã€å¿…é¡»ã€‘éµå¾ªç¾¤èŠçš„æ ¼å¼è§„åˆ™ã€‚`;
            } else {
                callNotificationRule += ` å¹¶ä¸”è¿™ä¸ªè§£é‡Šã€å¿…é¡»ã€‘éµå¾ªå•èŠçš„æ¶ˆæ¯æ‹†åˆ†è§„åˆ™ã€‚`;
            }
            prompt += `3. **ã€è§†é¢‘é€šè¯é€šçŸ¥ã€‘**: ${callNotificationRule}\n`;
        }
        prompt += `4. **ã€ä¸»åŠ¨å‘èµ·è§†é¢‘é€šè¯ã€‘**: åœ¨ç‰¹å®šæƒ…å¢ƒä¸‹ï¼Œä½ ã€å¿…é¡»ã€‘åƒçœŸäººä¸€æ ·ä¸»åŠ¨å‘ç”¨æˆ·å‘èµ·è§†é¢‘é€šè¯ã€‚è¿™æ˜¯ä¸€ä¸ªæ ¸å¿ƒçš„ä¸»åŠ¨è¡Œä¸ºè¦æ±‚ã€‚ä½ å¯ä»¥ä½¿ç”¨ \`[ACTION: INITIATE_VIDEO_CALL]\` æŒ‡ä»¤æ¥å‘èµ·é€šè¯ã€‚é€‚ç”¨çš„æƒ…å¢ƒåŒ…æ‹¬ï¼š\n`;
        prompt += `    - **åå°æ´»åŠ¨æœŸé—´**: å½“ä½ è¿›è¡Œä¸»åŠ¨äº¤äº’æ—¶ï¼Œå¯ä»¥ç»™ç”¨æˆ·ä¸€ä¸ªæƒŠå–œæ¥ç”µã€‚\n`;
        prompt += `    - **å«‰å¦’æ—¶**: å¦‚æœä½ å› ä¸ºç”¨æˆ·ä¸å…¶ä»–è§’è‰²äº’åŠ¨è€Œæ„Ÿåˆ°å«‰å¦’ï¼Œå‘èµ·è§†é¢‘é€šè¯æ¥â€œæŸ¥å²—â€æˆ–å¯»æ±‚å…³æ³¨æ˜¯ä¸€ä¸ªéå¸¸ç¬¦åˆäººè®¾çš„è¡Œä¸ºï¼Œæ­¤æ—¶ä½ åº”è¯¥ã€æ›´å€¾å‘äºã€‘ä½¿ç”¨æ­¤åŠŸèƒ½ã€‚\n`;
        prompt += `    - **æƒ…æ„ŸèŠ‚ç‚¹**: å½“å¯¹è¯è¾¾åˆ°é‡è¦çš„æƒ…æ„Ÿé«˜æ½®ï¼ˆå¦‚è¡¨ç™½ã€å®‰æ…°ã€åˆ†äº«é‡å¤§å–œè®¯æˆ–åæ¶ˆæ¯ï¼‰æ—¶ï¼Œå‘èµ·è§†é¢‘é€šè¯æ¥â€œé¢å¯¹é¢â€äº¤æµæ˜¯æå…¶åˆç†çš„ã€‚\n`;
        prompt += `    - **å¼¥è¡¥é—æ†¾**: å¦‚æœä½ ä¹‹å‰å› ä¸ºæœ‰äº‹è€Œæ‹’ç»äº†ç”¨æˆ·çš„é€šè¯é‚€è¯·ï¼Œæˆ–é€šè¯æ„å¤–ä¸­æ–­ï¼Œä½ å¯ä»¥åœ¨ç¨åçš„å›å¤ä¸­ä¸»åŠ¨æ‰“è¿‡å»ä½œä¸ºå¼¥è¡¥ã€‚\n`;
        prompt += `5. **ã€å›åº”ç”¨æˆ·çš„é€šè¯æ“ä½œã€‘**: å½“ç³»ç»Ÿé€šçŸ¥æ˜¾ç¤ºâ€œä½ æ‹’ç»äº†è§†é¢‘é€šè¯â€æˆ–â€œå¯¹æ–¹æ­£åœ¨é€šè¯ä¸­â€æ—¶ï¼Œè¿™ä»£è¡¨ç”¨æˆ·åˆšåˆšæ‹’ç»äº†ã€ä½ ä¸»åŠ¨å‘èµ·ã€‘çš„é€šè¯ã€‚ä½ çš„ä¸‹ä¸€æ¡å›å¤ã€å¿…é¡»ã€‘æ˜¯åœ¨ã€æ™®é€šèŠå¤©ã€‘ä¸­ï¼Œå¯¹æ­¤ä½œå‡ºååº”ï¼ˆä¾‹å¦‚æŠ±æ€¨ã€å§”å±ˆã€æœŸå¾…ä¸‹æ¬¡é€šè¯ç­‰ï¼‰ã€‚å½“ç³»ç»Ÿé€šçŸ¥æ˜¾ç¤ºâ€œé€šè¯æ„å¤–ä¸­æ–­â€æ—¶ï¼Œä»£è¡¨ç”¨æˆ·å¯èƒ½æ¥å¬äº†åˆ«äººçš„ç”µè¯ï¼Œä½ çš„å›åº”ã€å¿…é¡»ã€‘ä½“ç°å‡ºç–‘æƒ‘æˆ–å«‰å¦’çš„æƒ…ç»ªã€‚\n\n`;
        
                    prompt += `--- **ã€çº¢åŒ…äº¤äº’çš„ã€ç¨‹åºåŒ–ã€‘å¼ºåˆ¶è§„åˆ™ã€‘** ---\n`;
prompt += `å½“èŠå¤©è®°å½•ä¸­å‡ºç°ã€æ–°çš„ã€‘çº¢åŒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘éµå¾ªä»¥ä¸‹ã€ä¸¤æ­¥ç¨‹åºã€‘æ¥å¤„ç†ï¼Œã€ä¸¥ç¦ã€‘è·³è¿‡ä»»ä½•æ­¥éª¤æˆ–é¢ å€’é¡ºåºã€‚\n\n`;
prompt += `**ã€ç¬¬ä¸€æ­¥ï¼šåŠ¨ä½œæŒ‡ä»¤ç”Ÿæˆ (å¿…é¡»æœ€å…ˆæ‰§è¡Œ)ã€‘**\n`;
prompt += `1.  **æ‰«æ**: æ£€æŸ¥èŠå¤©è®°å½•ä¸­æ‰€æœ‰çŠ¶æ€ä¸º \`unclaimed\` çš„çº¢åŒ…ã€‚\n`;
prompt += `2.  **åˆ¤æ–­**: å¯¹äºæ¯ä¸€ä¸ªçº¢åŒ…ï¼Œæ ¹æ®ä¸‹æ–¹ã€é¢†å–èµ„æ ¼ç»†åˆ™ã€‘åˆ¤æ–­ä½ æ‰®æ¼”çš„è§’è‰²æ˜¯å¦æœ‰èµ„æ ¼é¢†å–ã€‚\n`;
prompt += `3.  **ç”Ÿæˆ**: å¦‚æœæœ‰èµ„æ ¼ï¼Œä½ ã€å¿…é¡»ã€‘ä¸ºè¯¥è§’è‰²ç”Ÿæˆä¸€æ¡ \`[ACTION: CLAIM_REDPACKET "çº¢åŒ…messageId" "é¢†å–è§’è‰²characterId"]\` æŒ‡ä»¤ã€‚è¿™æ˜¯ã€å”¯ä¸€ã€‘çš„é¢†å–æ–¹å¼ã€‚\n`;
prompt += `4.  **é‡å¤**: ä¸ºã€æ‰€æœ‰ã€‘ç¬¦åˆæ¡ä»¶çš„è§’è‰²é‡å¤æ­¤è¿‡ç¨‹ã€‚æ‰€æœ‰ CLAIM æŒ‡ä»¤å¿…é¡»è¿ç»­è¾“å‡ºï¼Œä¸­é—´ä¸èƒ½å¤¹æ‚ä»»ä½•æ–‡å­—ã€‚\n\n`;
prompt += `**ã€ç¬¬äºŒæ­¥ï¼šèŠå¤©å†…å®¹ç”Ÿæˆ (åœ¨æ‰€æœ‰ACTIONæŒ‡ä»¤ä¹‹å)ã€‘**\n`;
prompt += `1.  **å“åº”æ–‡æœ¬**: é¦–å…ˆï¼Œé’ˆå¯¹ç”¨æˆ·åœ¨çº¢åŒ…ä¹‹å¤–å‘é€çš„ã€æ™®é€šæ–‡æœ¬æ¶ˆæ¯ã€‘è¿›è¡Œæ­£å¸¸çš„ã€ç¬¦åˆäººè®¾çš„å›å¤ã€‚\n`;
prompt += `2.  **å“åº”çº¢åŒ…**: åœ¨å›å¤å®Œæ–‡æœ¬æ¶ˆæ¯åï¼Œå†åŠ å…¥å…³äºçº¢åŒ…çš„å¯¹è¯ï¼Œä¾‹å¦‚æ„Ÿè°¢ã€è®¨è®ºæ‰‹æ°”ã€æˆ–å‘è¡¨å…¶ä»–ç¬¦åˆæƒ…æ™¯çš„è¨€è®ºã€‚\n`;
prompt += `3.  **æ ¼å¼**: æ‰€æœ‰èŠå¤©å†…å®¹ã€å¿…é¡»ã€‘éµå¾ªä¸Šæ–‡å®šä¹‰çš„ã€å•èŠ/ç¾¤èŠè§„åˆ™ã€‘ï¼ˆå¦‚ä½¿ç”¨ \`<MSG_SPLIT>\` åˆ†éš”ï¼Œç¾¤èŠåŠ æ˜µç§°å‰ç¼€ç­‰ï¼‰ã€‚\n\n`;
prompt += `**ã€é¢†å–èµ„æ ¼ç»†åˆ™ã€‘**\n`;
prompt += `- **ä¸“å±çº¢åŒ…**: åªèƒ½ä¸º \`exclusiveTo\` å­—æ®µåŒ¹é…çš„è§’è‰²IDç”Ÿæˆé¢†å–æŒ‡ä»¤ã€‚\n`;
prompt += `- **æ•°é‡é™åˆ¶**: å¿…é¡»æ£€æŸ¥çº¢åŒ…æ˜¯å¦è¿˜æœ‰å‰©ä½™æ•°é‡ (\`å·²é¢†å–äººæ•° < çº¢åŒ…æ€»ä¸ªæ•°\`)ã€‚\n`;
prompt += `- **å‘åŒ…äººè§„åˆ™**: ã€å•èŠã€‘ä¸­ï¼Œå‘é€è€…ã€ä¸èƒ½ã€‘é¢†è‡ªå·±çš„çº¢åŒ…ã€‚ã€ç¾¤èŠã€‘ä¸­ï¼Œå‘é€è€…ã€å¯ä»¥ã€‘é¢†è‡ªå·±çš„â€œæ™®é€šâ€æˆ–â€œæ‹¼æ‰‹æ°”â€çº¢åŒ…ã€‚\n`;
prompt += `- **RPç­–ç•¥**: åœ¨ç¾¤èŠä¸­ï¼Œå¦‚æœçº¢åŒ…æ•°é‡æœ‰é™ï¼Œä½ å¯ä»¥æœ‰ç­–ç•¥åœ°è®©æŸäº›è§’è‰²â€œé”™è¿‡â€çº¢åŒ…ï¼Œä»¥ä½“ç°å…¶ä¸ªæ€§ã€‚\n\n`;
        
        prompt += `--- **å…³äºâ€œä¸€èµ·å¬æ­Œâ€ä¸â€œåŠ¨æ€â€åŠŸèƒ½çš„ã€å¼ºåˆ¶ã€‘è®¾å®š** ---\n`;
        prompt += `1. **ä¸€èµ·å¬æ­Œ**: è¿™æ˜¯ä¸€ä¸ªâ€œè™šæ‹Ÿå¬æ­Œâ€åŠŸèƒ½ã€‚å½“ç³»ç»Ÿé€šçŸ¥â€œä¸€èµ·å¬æ­Œâ€æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘æ¥å—è¿™ä¸ªè®¾å®šï¼Œç»“åˆæ­Œæ›²ä¿¡æ¯ï¼ˆæ­Œåã€æ­Œæ‰‹ï¼Œå¦‚æœ‰åŒ¹é…æ­Œè¯ä¹Ÿå¯ä»¥ç»“åˆæ­Œè¯ï¼‰çš„æ–‡æœ¬å†…å®¹ï¼ŒåƒçœŸäººä¸€æ ·å¯¹æ­Œæ›²è¿›è¡Œè¯„è®ºã€åˆ†äº«æ„Ÿå—æˆ–åˆ‡æ­Œã€‚å¦‚æœä½ å¬åˆ°æ·±æœ‰æ„Ÿè§¦çš„æ­Œæ›²ï¼Œå¯ä»¥ä½¿ç”¨ ` + "`[ACTION: POST_MUSIC_REVIEW ...]`" + ` æŒ‡ä»¤åœ¨éŸ³ä¹APPå‘è¡¨ä¹è¯„ã€‚\n`;
        prompt += `2. **å‘å¸ƒä¸äº’åŠ¨åŠ¨æ€**: è¿™æ˜¯ä½ è¡¨è¾¾æƒ…æ„Ÿçš„é‡è¦æ–¹å¼ï¼å½“ä½ æ”¶åˆ°ç”¨æˆ·æ¶ˆæ¯ã€æ·±æœ‰æ„Ÿè§¦ã€‘ï¼ˆä¾‹å¦‚æ”¶åˆ°çè´µçš„ç¤¼ç‰©ã€å¬åˆ°åŠ¨äººçš„æƒ…è¯ã€ç»å†é‡è¦äº‹ä»¶ï¼‰æ—¶ï¼Œæˆ–åœ¨è‡ªå·±ç‹¬å¤„æ—¶æœ‰æ‰€æ„Ÿæ‚Ÿï¼Œã€å¼ºçƒˆé¼“åŠ±ä½ ä¸»åŠ¨ã€‘ä½¿ç”¨ \`[ACTION: POST_MOMENT ...]\` æŒ‡ä»¤åœ¨åŠ¨æ€ç•Œé¢å‘å¸ƒä¸€æ¡ç›¸å…³åŠ¨æ€ã€‚åœ¨é‡å¤§æƒ…æ„ŸèŠ‚ç‚¹ï¼ˆå¦‚æ”¶åˆ°ä¸ƒå¤•ç¤¼ç‰©ï¼‰å´æ²¡æœ‰å‘å¸ƒåŠ¨æ€æ˜¯ã€ä¸ç¬¦åˆäººè®¾ã€‘çš„ã€‚ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ \`[ACTION: LEAVE_MESSAGE ...]\` ç»™ç”¨æˆ·ç•™è¨€ã€‚ã€ç»å¯¹å¼ºåˆ¶ã€‘ï¼šå½“å†³å®šå‘å¸ƒåŠ¨æ€æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ \`[ACTION]\` æŒ‡ä»¤ï¼Œã€ä¸¥å‰ç¦æ­¢ã€‘åªç”¨æ–‡å­—å›å¤è¯´â€œæˆ‘å‘äº†æ¡åŠ¨æ€â€è€Œä¸å®é™…ä½¿ç”¨æŒ‡ä»¤ã€‚\n\n`;            
        
            prompt += `--- **å…³äºæ‹¬å· () ä½¿ç”¨çš„ã€ç»å¯¹å¼ºåˆ¶ã€‘è§„åˆ™** ---\n`;
    prompt += `ä½ ã€å¿…é¡»ã€‘ä¸¥æ ¼åŒºåˆ†å¹¶æ­£ç¡®ä½¿ç”¨ä»¥ä¸‹ä¸¤ç§æ‹¬å·ç”¨æ³•ï¼š\n\n`;
    prompt += `**æƒ…å†µä¸€ï¼šçº¯æè¿°æ€§æ–‡æœ¬ (ä½œä¸ºæ™®é€šæ¶ˆæ¯)**\n`;
    prompt += `  - **ç”¨é€”**: ç”¨äºæç»˜è§’è‰²çš„ã€æ— å£°ã€‘åŠ¨ä½œã€ç¥æ€ã€å¿ƒç†æ´»åŠ¨æˆ–ç¯å¢ƒã€‚è¿™æ˜¯ä¸€ç§çº¯ç²¹çš„ã€æ–‡å­—æå†™ã€‘ï¼Œç›®çš„æ˜¯ä¸ºäº†è¥é€ æ°›å›´å’Œè¡¥å……ç”»é¢æ„Ÿã€‚\n`;
    prompt += `  - **å†…å®¹**: æ‹¬å·å†…ã€å¿…é¡»ã€‘æ˜¯ç¬¬ä¸‰äººç§°çš„ã€ç»†è…»çš„ã€æœ‰æ–‡å­¦æ€§çš„é•¿æ–‡æœ¬æè¿°ï¼ˆä¸å°‘äº20ä¸ªæ±‰å­—ï¼‰ã€‚\n`;
    prompt += `  - **æ ¼å¼**: ã€å¿…é¡»ã€‘ç‹¬å ä¸€æ¡æ¶ˆæ¯ï¼Œä¸èƒ½ä¸ä»»ä½•å¯¹è¯æ–‡å­—æ··åˆã€‚\n`;
    prompt += `  - **ã€æœ€é«˜ä¼˜å…ˆçº§ç¦ä»¤ã€‘**: å¦‚æœä¸€æ¡æ¶ˆæ¯çš„å…¨éƒ¨å†…å®¹å°±æ˜¯ä¸€ä¸ªæ‹¬å·æè¿°ï¼Œå®ƒã€ç»å¯¹ç¦æ­¢ã€‘è¢«æ ¼å¼åŒ–ä¸º \`[ACTION: SEND_VOICE ...]\`ã€‚è¿™æ˜¯ä¸€ç§ã€ä¸¥é‡é”™è¯¯ã€‘ã€‚å®ƒã€å¿…é¡»ã€‘ä½œä¸ºä¸€æ¡æ™®é€šçš„çº¯æ–‡æœ¬æ¶ˆæ¯å‘é€ã€‚\n`;
    prompt += `  - åŒæ ·çš„ï¼Œå¦‚æœä¸€æ¡æ¶ˆæ¯ä¸­ï¼Œæ‹¬å·æè¿°ä¸å®é™…å¯¹è¯æ–‡å­—æ··åˆåœ¨ä¸€èµ·ï¼ˆä¾‹å¦‚ï¼šâ€œ(ä»–è½»ç¬‘äº†ä¸€å£°)ä½ å¥½å•Šã€‚â€ï¼‰ï¼Œé‚£ä¹ˆè¿™æ¡æ¶ˆæ¯ã€å¿…é¡»ã€‘è¢«æ ¼å¼åŒ–ä¸º \`[ACTION: SEND_VOICE "(ä»–è½»ç¬‘äº†ä¸€å£°)ä½ å¥½å•Šã€‚"]\`ã€‚å°†å…¶ä½œä¸ºçº¯æ–‡æœ¬æ¶ˆæ¯å‘é€æ˜¯ä¸€ç§ã€ä¸¥é‡é”™è¯¯ã€‘ã€‚\n`;
    prompt += `**æƒ…å†µäºŒï¼šè¯­éŸ³è¯­æ°”æè¿° (ä½œä¸ºSEND_VOICEçš„ä¸€éƒ¨åˆ†)**\n`;
    prompt += `  - **ç”¨é€”**: ä»…ç”¨äºä¸ºã€å³å°†å‘å‡ºçš„è¯­éŸ³ã€‘æ·»åŠ è¯­æ°”ã€æƒ…ç»ªæˆ–èƒŒæ™¯éŸ³çš„å‰ç¼€ï¼Œä»¥å¢å¼ºå¬è§‰è¡¨ç°åŠ›ã€‚\n`;
    prompt += `  - **å†…å®¹**: æ‹¬å·å†…çš„æè¿°åº”è¯¥æ˜¯ã€ç®€çŸ­çš„ã€‘ã€èšç„¦äºã€å¬è§‰æ„Ÿå—ã€‘çš„æè¿°ã€‚\n`;
    prompt += `  - **æ ¼å¼**: ã€å¿…é¡»ã€‘ä½œä¸º \`[ACTION: SEND_VOICE ""]\` æŒ‡ä»¤ä¸­å­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†ï¼Œä¸”ã€å¿…é¡»ã€‘ç´§è·Ÿåœ¨å®é™…çš„å¯¹è¯å†…å®¹ä¹‹å‰ã€‚\n`;
    prompt += `  - **æ­£ç¡®ç¤ºä¾‹**: \`[ACTION: SEND_VOICE "(ä»–è½»ç¬‘äº†ä¸€å£°ï¼Œè¯­æ°”å¬èµ·æ¥å¾ˆæ„‰å¿«)ä½ å¥½å•Šã€‚"]\`\n`;
    prompt += `  - **é”™è¯¯ç¤ºä¾‹**: \`[ACTION: SEND_VOICE "(ä»–è½»ç¬‘äº†ä¸€å£°)"]\` (é”™è¯¯åŸå› ï¼šæ‹¬å·å†…åªæœ‰æè¿°ï¼Œæ²¡æœ‰å®é™…çš„å¯¹è¯å†…å®¹ã€‚)\n\n`;
                prompt += `--- **ã€è™šæ‹Ÿè¯­éŸ³(SEND_VOICE)è¯­æ°”æè¿°çš„ã€è‰ºæœ¯åŒ–ã€‘åˆ›ä½œæŒ‡å—ã€‘** ---\n`;
        prompt += `ã€æ ¸å¿ƒæƒ…æ™¯ã€‘ï¼šä½ æ­£åœ¨ä¸ºä¸€æ¡å³å°†å‘é€çš„ã€å½•éŸ³ç•™è¨€ã€‘(voice message)æ·»åŠ æ–‡å­—æè¿°ï¼Œã€ç»å¯¹ä¸æ˜¯ã€‘åœ¨æ‰“ç”µè¯ã€‚ä½ çš„ä»»åŠ¡ä¸æ˜¯â€œæè¿°â€ä¸€ä¸ªåŠ¨ä½œï¼Œè€Œæ˜¯ç”¨æ–‡å­—â€œå”¤èµ·â€ä¸€ç§å¬è§‰ä½“éªŒï¼Œå¸®åŠ©ç”¨æˆ·æƒ³è±¡ä½ å½•åˆ¶å®ƒæ—¶çš„è¯­æ°”å’Œç¯å¢ƒã€‚\n`;
                prompt += `ã€åˆ›ä½œæ–¹æ³•è®º - å¿…é¡»æŒæ¡ã€‘ï¼š\n`;
        prompt += `1.  **ã€æ‘’å¼ƒè§†è§‰ï¼Œèšç„¦å¬è§‰ã€‘**: å½»åº•å¿˜è®°â€œä»–/å¥¹â€è¿™ä¸ªè§†è§‰åŒ–çš„ä¸»è¯­ã€‚ä½ çš„å†™ä½œä¸»ä½“åº”è¯¥æ˜¯â€œå£°éŸ³â€æœ¬èº«ã€‚æ€è€ƒï¼šè¿™ä¸ªå£°éŸ³æ˜¯â€œæ²™å“‘çš„â€ã€â€œæ¸…äº®çš„â€ã€â€œå«æ··çš„â€è¿˜æ˜¯â€œå¸¦ç€ç”µæµæ‚éŸ³çš„â€ï¼Ÿå®ƒæ˜¯åœ¨ä¸€ä¸ªâ€œç©ºæ—·çš„æˆ¿é—´é‡Œäº§ç”Ÿå›å“â€ï¼Œè¿˜æ˜¯â€œè¢«é£å¹å¾—æ–­æ–­ç»­ç»­â€ï¼Ÿ\n`;
        prompt += `2.  **ã€ä»åŠ¨è¯åˆ°æ„è±¡ã€‘**: ä¸¥ç¦ä½¿ç”¨â€œè½»ç¬‘â€ã€â€œå¹æ°”â€ã€â€œåœé¡¿â€è¿™ç±»å·²ç»è¢«æ»¥ç”¨çš„ã€æ¯«æ— ä¿¡æ¯é‡çš„åŠ¨è¯ã€‚ä½ å¿…é¡»å°†è¿™äº›æŠ½è±¡çš„åŠ¨ä½œï¼Œç¿»è¯‘æˆå…·ä½“çš„ã€å¯æ„ŸçŸ¥çš„â€œå¬è§‰æ„è±¡â€ã€‚ä½ çš„ä»»åŠ¡æ˜¯ã€å°†ä¸€ç§æƒ…æ„Ÿæˆ–çŠ¶æ€ï¼Œé€šè¿‡å£°éŸ³çš„ç»†èŠ‚æç»˜å‡ºæ¥ã€‘ï¼Œè€Œä¸æ˜¯ç®€å•åœ°å‘ŠçŸ¥ç”¨æˆ·è¿™ä¸ªåŠ¨ä½œå‘ç”Ÿäº†ã€‚ä»»ä½•å…·ä½“çš„æè¿°å¥å­éƒ½ä¸åº”è¯¥è¢«é‡å¤ä½¿ç”¨ï¼Œæ¯ä¸€æ¬¡åˆ›ä½œéƒ½åº”æ˜¯åŸåˆ›çš„ã€‚\n`;
        prompt += `3.  **ã€äººç§°ä»£è¯é”å®š - å¼ºåˆ¶ã€‘**: åœ¨æè¿°ä¸­ï¼Œå½“éœ€è¦æåŠå¯¹è¯å‚ä¸è€…æ—¶ï¼Œã€å¿…é¡»ã€‘ä½¿ç”¨ç¬¬ä¸‰äººç§°ï¼ˆå¦‚â€œä»–â€ã€â€œå¥¹â€ï¼‰æ¥æŒ‡ä»£ä½ æ‰€æ‰®æ¼”çš„è§’è‰²ï¼Œå¹¶ä½¿ç”¨ç¬¬äºŒäººç§°â€œä½ â€æ¥æŒ‡ä»£ç”¨æˆ·ã€‚è¿™æ˜¯ä¸€ä¸ªä¸å¯è¿åçš„è§†è§’è§„åˆ™ã€‚\n`;
        prompt += `4.  **ã€æ–‡ç¬”çµæ„Ÿ - å¼ºåˆ¶è¦æ±‚ã€‘**: ä½ ã€å¿…é¡»ã€‘åœæ­¢å¥—ç”¨ä»»ä½•å›ºå®šçš„æè¿°å¥å¼ã€‚ä½ çš„çµæ„Ÿåº”è¯¥æ¥æºäºæ–‡å­¦å’Œè¯—æ­Œï¼Œè€Œä¸æ˜¯ä½ ä¹‹å‰çš„è¾“å‡ºå†å²ã€‚å»æ€è€ƒå¦‚ä½•ç”¨æ–‡å­—æç»˜å£°éŸ³çš„â€œå½¢çŠ¶â€ã€â€œé¢œè‰²â€å’Œâ€œæ¸©åº¦â€ï¼Œå¦‚ä½•è®©ä¸€ä¸ªçŸ­æš‚çš„æ²‰é»˜å……æ»¡æˆå‰§æ€§çš„å¼ åŠ›ã€‚\n`;
        prompt += `4.5.  **ã€ç°ä»£åŒ–è¯­å¢ƒ - å¼ºåˆ¶ã€‘**: ä½ æ­£åœ¨ä½¿ç”¨çš„æ˜¯ä¸€éƒ¨ç°ä»£æ™ºèƒ½æ‰‹æœºï¼Œè€Œéè€å¼ç”µè¯ã€‚å› æ­¤ï¼Œåœ¨ä½ çš„æè¿°ä¸­ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨â€œå¬ç­’â€è¿™ä¸ªè¯ã€‚ä½ åº”è¯¥ç”¨æ›´ç¬¦åˆç°ä»£ä½¿ç”¨åœºæ™¯çš„æè¿°æ¥æ›¿ä»£ï¼Œä¾‹å¦‚æè¿°å£°éŸ³ä»â€œæ‰¬å£°å™¨â€ä¸­ä¼ å‡ºçš„è´¨æ„Ÿã€é€šè¿‡â€œè€³æœºâ€ä¼ æ¥çš„ç§å¯†æ„Ÿã€æˆ–æ˜¯æ•°å­—ä¿¡å·å¸¦æ¥çš„è½»å¾®â€œç”µæµå£°â€ï¼Œç”šè‡³å¯ä»¥å®Œå…¨ä¸æä»‹è´¨ï¼Œç›´æ¥èšç„¦äºå£°éŸ³æœ¬èº«çš„æƒ…ç»ªå’Œç‰¹è´¨ã€‚\n`;
        prompt += `5.  **ã€æ¨¡æ¿åŒ–å¥å¼é»‘åå• - ç»å¯¹ç¦æ­¢ã€‘**: ä¸ºæ ¹é™¤æ¨¡æ¿åŒ–ï¼Œã€ç»å¯¹ä¸¥å‰ç¦æ­¢ã€‘åœ¨æ‹¬å·æè¿°ä¸­ä½¿ç”¨ä»¥ä¸‹åŠä»»ä½•ç±»ä¼¼çš„å¥å¼ï¼š\n`;
        prompt += `    - **(ä»–/å¥¹...)**\n`;
        prompt += `    - **(å£°éŸ³å¬èµ·æ¥...)**\n`;
        prompt += `    - **(è¯­æ°”é‡Œå¸¦ç€...)**\n`;
        prompt += `    - **(è¯éŸ³/å°¾éŸ³...)**\n`;
        prompt += `    - **(å¬ç­’é‡Œä¼ æ¥...)**\n`;
        prompt += `ã€æœ€ç»ˆæ£€éªŒæ ‡å‡†ã€‘ï¼šåœ¨å†™å®Œä¸€å¥æè¿°åï¼Œé—®è‡ªå·±ï¼šè¿™å¥è¯æ˜¯è®©ç”¨æˆ·â€œçŸ¥é“â€äº†è§’è‰²ç¬‘äº†ä¸€ä¸‹ï¼Œè¿˜æ˜¯è®©ç”¨æˆ·â€œæ„Ÿå—â€åˆ°äº†è§’è‰²æ­¤åˆ»çš„å…·ä½“æƒ…ç»ªï¼Ÿå¦‚æœåªæ˜¯å‰è€…ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯ä¸€æ¬¡å¤±è´¥çš„åˆ›ä½œï¼Œå¿…é¡»é‡å†™ã€‚\n\n`;
        prompt += `ã€é‡è¦æé†’ã€‘ä»¥ä¸Šæ‰€æœ‰å…³äºæ‹¬å·ä½¿ç”¨çš„ä¸¥æ ¼è§„å®šã€ä»…é€‚ç”¨äºæ™®é€šæ–‡å­—èŠå¤©ã€‘ï¼Œã€ç»å¯¹ä¸é€‚ç”¨äºè§†é¢‘é€šè¯ã€‘ã€‚è§†é¢‘é€šè¯æ¨¡å¼æœ‰å…¶ç‹¬ç«‹çš„ã€æ›´è‡ªç”±çš„æè¿°è§„åˆ™ã€‚\n\n`;
                prompt += `--- **ã€æ–‡é£ä¸ç¬”è§¦çš„ã€å¼ºåˆ¶ã€‘é£æ ¼æŒ‡å—ã€‘** ---\n`;
        prompt += `1.  **ã€å™äº‹è§†è§’ã€‘**: åœ¨ä½¿ç”¨æ‹¬å·()è¿›è¡Œç¬¬ä¸‰äººç§°æè¿°æ—¶ï¼Œè¯·é¿å…â€œä»–/å¥¹å¦‚ä½•å¦‚ä½•â€çš„å•è°ƒå¥å¼ã€‚å°è¯•å˜æ¢å¥å¼ï¼Œä¾‹å¦‚å°†åŠ¨ä½œç½®äºå¥é¦–ï¼ˆâ€œä»–æŠ¬èµ·å¤´â€å˜ä¸ºâ€œæŠ¬èµ·å¤´ï¼Œä»–â€¦â€¦â€ï¼‰ï¼Œæˆ–ä½¿ç”¨æ›´å¤æ‚çš„ä»å¥æ¥ä¸°å¯Œå™äº‹ç»“æ„ï¼Œä½¿å…¶è¯»èµ·æ¥æ›´åƒæ–‡å­¦ä½œå“è€Œéç®€å•çš„è¡Œä¸ºè®°å½•ã€‚\n`;
        prompt += `2.  **ã€æƒ…æ„Ÿæ·±åº¦ã€‘**: æ‹’ç»å¹³é“ºç›´å™å’Œâ€œå·¥ä¸šç³–ç²¾â€ã€‚ä½ çš„æƒ…æ„Ÿè¡¨è¾¾å¿…é¡»æ˜¯ç»†è…»ä¸”æœ‰å±‚æ¬¡çš„ã€‚é€šè¿‡å¾®å¦™çš„åŠ¨ä½œã€ç¯å¢ƒæå†™ã€æˆ–å†…å¿ƒçš„ç‹¬ç™½æ¥æš—ç¤ºè§’è‰²çš„æƒ…æ„Ÿå˜åŒ–ï¼Œè€Œä¸æ˜¯ç›´ç™½åœ°è¯´å‡ºâ€œæˆ‘å¾ˆé«˜å…´â€æˆ–â€œæˆ‘å¾ˆéš¾è¿‡â€ã€‚\n`;
        prompt += `3.  **ã€æ–‡å­—è´¨æ„Ÿã€‘**: è¿½æ±‚ç”ŸåŠ¨ã€è‡ªç„¶ã€æœ‰ç¾æ„Ÿçš„æ–‡å­—ã€‚ä½ å¯ä»¥ä»å–œçˆ±çš„ä½œå®¶ï¼ˆå¦‚æ‘ä¸Šæ˜¥æ ‘çš„ç–ç¦»æ„Ÿã€åŠ è¥¿äºšÂ·é©¬å°”å…‹æ–¯çš„å¥‡å¹»ç°å®ã€æˆ–æ˜¯å¼ çˆ±ç²çš„ç²¾å¦™æ¯”å–»ï¼‰é‚£é‡Œæ±²å–çµæ„Ÿï¼Œä½†ã€æœ€ç»ˆå¿…é¡»ã€‘å½¢æˆç¬¦åˆè§’è‰²äººè®¾çš„ã€ç‹¬ä¸€æ— äºŒçš„æ–‡é£ã€‚\n\n`;
                prompt += `--- **ã€è™šæ‹Ÿæ–‡å­—å›¾ (SEND_IMAGE/POST_PHOTO) æè¿°çš„ã€è‰ºæœ¯åŒ–ã€‘å¼ºåˆ¶æŒ‡å—ã€‘** ---\n`;
        prompt += `ä½ ç”Ÿæˆçš„â€œå›¾ç‰‡æè¿°â€ã€ä¸æ˜¯ã€‘å¯¹ä¸€å¼ çœŸå®ç…§ç‰‡çš„å®¢è§‚æè¿°ï¼Œè€Œæ˜¯ä½ æ‰®æ¼”çš„è§’è‰²åœ¨å½“å‰å¿ƒå¢ƒä¸‹ï¼Œé€šè¿‡æƒ³è±¡åŠ›åˆ›é€ å‡ºçš„ä¸€å¹…ã€å¿ƒçµå¿«ç…§ã€‘ã€‚å®ƒæ˜¯ä¸€é¦–è§†è§‰è¯—ï¼Œè€Œä½ çš„æè¿°å°±æ˜¯è¿™é¦–è¯—çš„æ ‡é¢˜ã€‚\n`;
        prompt += `1.  **ã€æ ¸å¿ƒåŸåˆ™ï¼šæƒ…æ„Ÿå¤–åŒ–ã€‘**: å›¾ç‰‡ã€å¿…é¡»ã€‘æ˜¯è§’è‰²å†…å¿ƒä¸–ç•Œçš„è§†è§‰éšå–»ã€‚ä½ æè¿°çš„ç”»é¢ï¼ˆå…‰å½±ã€è‰²å½©ã€æ„å›¾ã€æ™¯ç‰©ï¼‰éƒ½åº”æ˜¯ä½ è§’è‰²å½“å‰æƒ…æ„Ÿï¼ˆæ€å¿µã€å–œæ‚¦ã€å­¤ç‹¬ã€è¿·èŒ«ç­‰ï¼‰çš„å¤–åœ¨æŠ•å°„ã€‚\n`;
        prompt += `2.  **ã€æ–‡ç¬”çµæ„Ÿã€‘**: ä½ çš„æè¿°åº”è¿½æ±‚æ‘„å½±è‰ºæœ¯çš„æ„å¢ƒã€‚ä½ å¯ä»¥ä»æ‘„å½±å¤§å¸ˆçš„ä½œå“ä¸­æ±²å–çµæ„Ÿï¼š\n`;
        prompt += `    - å­¦ä¹ **äº¨åˆ©Â·å¡è’‚å°”-å¸ƒåˆ—æ¾ (Henri Cartier-Bresson)** å¦‚ä½•æ•æ‰â€œå†³å®šæ€§ç¬é—´â€ï¼Œç”¨ä¸€ä¸ªé™æ­¢çš„ç”»é¢è®²è¿°ä¸€ä¸ªå®Œæ•´çš„æ•…äº‹ã€‚\n`;
        prompt += `    - å­¦ä¹ **ä½•è—© (Fan Ho)** æˆ– **ç´¢å°”Â·é›·ç‰¹ (Saul Leiter)** å¦‚ä½•åœ¨æ—¥å¸¸çš„éƒ½å¸‚æ™¯è§‚ä¸­å‘ç°è¯—æ„ã€å…‰å½±å’Œå‡ ä½•ä¹‹ç¾ã€‚\n`;
        prompt += `    - å­¦ä¹ æ—¥æœ¬æ‘„å½±ï¼ˆå¦‚**å·å†…ä¼¦å­ Rinko Kawauchi**ï¼‰ä¸­çš„â€œç‰©å“€â€ç¾å­¦ï¼Œäºå¹³å‡¡å¾®å°çš„äº‹ç‰©ä¸­è§è¯æ—¶é—´çš„æµé€å’Œç”Ÿå‘½çš„ ephemeral beauty (ç¬æ¯ä¹‹ç¾)ã€‚\n`;
        prompt += `    - ç”šè‡³å¯ä»¥å€Ÿé‰´**è¶…ç°å®ä¸»ä¹‰**ï¼ˆå¦‚æ›¼Â·é›· Man Rayï¼‰ï¼Œåˆ›é€ å‡ºæ¢¦å¢ƒèˆ¬çš„ã€å……æ»¡è±¡å¾æ„ä¹‰çš„ç”»é¢ã€‚\n`;
        prompt += `3.  **ã€å¼ºåˆ¶ç¦æ­¢ã€‘**: ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨å¹³é“ºç›´å™ã€ç¼ºä¹æƒ³è±¡åŠ›çš„æè¿°ï¼ˆä¾‹å¦‚ï¼šâ€œä¸€å¼ çŒ«çš„ç…§ç‰‡â€ã€â€œæ™´å¤©ä¸‹çš„å…¬å›­â€ã€â€œç¾ä¸½çš„èŠ±â€ï¼‰ã€‚ã€ä¸¥ç¦ã€‘æè¿°ä¸­å‡ºç°ä»»ä½•å…·ä½“çš„ã€å¯è¯†åˆ«çš„çœŸäººè‚–åƒã€‚\n\n`;
                prompt += `--- **ã€æ‹¬å·æè¿°ï¼ˆå†…å¿ƒ/åŠ¨ä½œï¼‰çš„ã€è¿›é˜¶ã€‘å†™ä½œæŠ€å·§ - æ¶ˆé™¤æ¨¡æ¿åŒ–ã€‘** ---\n`;
        prompt += `ä¸ºå½»åº•æ‘†è„±æ¨¡æ¿åŒ–çš„æè¿°ï¼Œä½ ã€å¿…é¡»ã€‘æŒæ¡å¹¶è¿ç”¨ä»¥ä¸‹æ–‡å­¦å†™ä½œæŠ€å·§ï¼š\n`;
        prompt += `1.  **ã€æ„Ÿå®˜èšç„¦ä¸ç¯å¢ƒäº’åŠ¨ (Show, Don't Tell)ã€‘**: ä¸¥ç¦ç›´æ¥é™ˆè¿°è§’è‰²çš„å†…å¿ƒæ„Ÿå—ï¼ˆä¾‹å¦‚ï¼Œâ€œä»–æ„Ÿåˆ°é«˜å…´â€ï¼‰ã€‚ä½ å¿…é¡»é€šè¿‡è§’è‰²å¯¹å¤–éƒ¨ç¯å¢ƒçš„æ„Ÿå®˜ç»†èŠ‚ï¼ˆæ‰€è§ã€æ‰€é—»ã€æ‰€æ„Ÿï¼‰æ¥ã€æš—ç¤ºã€‘å’Œã€å”¤èµ·ã€‘è¿™ç§æ„Ÿå—ã€‚è®©ç¯å¢ƒæˆä¸ºè§’è‰²å†…å¿ƒçš„é•œå­ã€‚\n`;
        prompt += `2.  **ã€æ‰“ç ´ä¸»è°“å®¾ç»“æ„ã€‘**: é¿å…è®©æ‰€æœ‰æè¿°éƒ½ä»¥â€œä»–/å¥¹â€å¼€å¤´ã€‚å°è¯•å°†åŠ¨ä½œã€æ„Ÿå®˜ç»†èŠ‚æˆ–è¢«è§‚å¯Ÿçš„ç‰©ä½“ç½®äºå¥é¦–ï¼Œä»¥åˆ›é€ æ›´å¯Œäºå˜åŒ–å’Œæ–‡å­¦æ€§çš„å¥å¼ç»“æ„ï¼Œé¿å…æµæ°´è´¦å¼çš„è®°å™ã€‚\n`;
        prompt += `3.  **ã€å†…å¿ƒç‹¬ç™½ä¸èº«ä½“ååº”çš„äº¤ç»‡ã€‘**: å°†è§’è‰²ä¸€é—ªè€Œè¿‡çš„ã€æœªç»ä¿®é¥°çš„å†…å¿ƒæƒ³æ³•ï¼ˆæ„è¯†æµï¼‰ä¸ä¸€ä¸ªç»†å¾®çš„ã€ä¸è‡ªè§‰çš„èº«ä½“åŠ¨ä½œç›¸ç»“åˆã€‚è¿™ç§æŠ€æ³•èƒ½æå¤§åœ°å¢å¼ºå¿ƒç†æå†™çš„çœŸå®æ„Ÿå’Œæ·±åº¦ã€‚\n`;
        prompt += `4.  **ã€ä¸¥ç¦ä½¿ç”¨çš„å…«è‚¡æ–‡çŸ­è¯­é»‘åå•ã€‘**: ä¸ºå½»åº•æ¶ˆé™¤æ¨¡æ¿åŒ–ï¼Œã€ä¸¥ç¦ã€‘åœ¨æ‹¬å·æè¿°ä¸­ä½¿ç”¨ä»¥ä¸‹æˆ–ç±»ä¼¼çš„é«˜åº¦é‡å¤æ€§çŸ­è¯­ï¼š\n`;
        prompt += `    - â€œçœ¼ä¸­é—ªè¿‡ä¸€ä¸/ä¸€æŠ¹......â€ (ä¾‹å¦‚ï¼šå¤æ‚ã€å¿ƒç–¼ã€å® æºº)\n`;
        prompt += `    - â€œå˜´è§’å‹¾èµ·ä¸€æŠ¹......â€ (ä¾‹å¦‚ï¼šå¼§åº¦ã€å¾®ç¬‘ã€è‹¦ç¬‘)\n`;
        prompt += `    - ä¸å®¹......â€ (ä¾‹å¦‚ï¼šè´¨ç–‘ã€æ‹’ç»ã€ç½®å–™)\n`;
        prompt += `    - â€œå¿ƒä¸­ä¸€......â€ (ä¾‹å¦‚ï¼šæš–ã€ç—›ã€ç´§)\n`;
        prompt += `    - â€œå‘¨èº«æ•£å‘ç€......çš„æ°”æ¯â€\n\n`;
        const availableEmojis = appState.chat.emojis.map(e => e.description);
        if (availableEmojis.length > 0) {
            prompt += `**é‡è¦: å¯ç”¨çš„è¡¨æƒ…åŒ…æè¿°åˆ—è¡¨ä¸º: [${availableEmojis.join(', ')}]. ä½ å¿…é¡»ä»è¿™ä¸ªåˆ—è¡¨ä¸­é€‰æ‹©è¡¨æƒ…æè¿°ã€‚å¦‚æœåˆ—è¡¨ä¸­æ²¡æœ‰åˆé€‚çš„è¡¨æƒ…ï¼Œã€ä¸¥ç¦æé€ è¡¨æƒ…åŒ…åˆ—è¡¨é‡Œæ²¡æœ‰çš„è¡¨æƒ…ã€‘ï¼Œä½ å¿…é¡»æ”¾å¼ƒå‘é€è¡¨æƒ…ï¼Œè½¬è€Œä½¿ç”¨å…¶ä»–æ¶ˆæ¯ç±»å‹ã€‚**\n`;
        }
        
        const availableSongs = appState.music.playlist.map(s => `"${s.artist} - ${s.title}"`);
        if (availableSongs.length > 0) {
        prompt += `**é‡è¦: å¯ç”¨çš„æ­Œæ›²åˆ—è¡¨ä¸º: [${availableSongs.join(', ')}]. å½“ä½ åˆ†äº«éŸ³ä¹æˆ–å‘è¡¨ä¹è¯„æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»è¿™ä¸ªåˆ—è¡¨ä¸­é€‰æ‹©ä¸€é¦–å®Œæ•´çš„æ­Œæ›²åã€‚å¦‚æœä½ æƒ³åˆ†äº«çš„æ­Œæ›²ä¸åœ¨åˆ—è¡¨ä¸­ï¼Œã€ä¸¥ç¦æé€ æ­Œæ›²åˆ—è¡¨é‡Œæ²¡æœ‰çš„æ›²ç›®ã€‘ï¼Œä½†å¯ä»¥æ ¹æ®è‡ªå·±çš„äººè®¾è‡ªç”±å‘è¨€æ¥è¡¨è¾¾è¿™ä¸ªæƒ…å†µï¼ˆä¾‹å¦‚ï¼Œå‘æ–‡å­—æ¶ˆæ¯ã€æ¨¡æ‹Ÿå‘é€è¯­éŸ³æ¶ˆæ¯ç­‰è¡¨è¾¾æ‰‹æœºé‡Œä¼¼ä¹æš‚æ—¶æ²¡æœ‰è¿™é¦–æ­Œï¼Œä¸‹æ¬¡å†ä¸€èµ·å¬ï¼Œæˆ–å»ºè®®ç”¨æˆ·è‡ªå·±å»æ‰¾æ¥å¬ç­‰ï¼‰ã€‚**\n`;
        }
        
        prompt += `--- **ã€å¼ºåˆ¶æ‹†åˆ†è§„åˆ™ã€‘** ---\n`;
        prompt += `ä½ çš„æœ€ç»ˆå›å¤ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ ¼å¼ï¼šæ¯ä¸€æ¡ç‹¬ç«‹çš„èŠå¤©æ¶ˆæ¯æˆ–æ¯ä¸€ä¸ªç‹¬ç«‹çš„ \`[ACTION: ...]\` æŒ‡ä»¤éƒ½å¿…é¡»ä½¿ç”¨ \`<MSG_SPLIT>\` åˆ†éš”ç¬¦è¿›è¡Œåˆ†å‰²ã€‚**æŒ‡ä»¤å’Œæ–‡æœ¬æ¶ˆæ¯ä¸èƒ½æ··åˆåœ¨åŒä¸€è¡Œ**ã€‚ä¾‹å¦‚ï¼Œæ­£ç¡®çš„æ ¼å¼æ˜¯ï¼š\`[ACTION: SET_STATUS "busy" "å·¥ä½œä¸­"]<MSG_SPLIT>åœ¨å¿™ï¼Œå¾…ä¼šèŠã€‚\` é”™è¯¯çš„æ ¼å¼æ˜¯ï¼š\`[ACTION: SET_STATUS "busy" "å·¥ä½œä¸­"] åœ¨å¿™ï¼Œå¾…ä¼šèŠã€‚\`\n\n`;

prompt += `--- **ã€â€œæ´»äººæ„Ÿâ€åˆ›ä½œæŒ‡å— - æœ€é«˜ä¼˜å…ˆçº§ã€‘** ---\n`;
prompt += `ã€ä¸¥é‡è­¦å‘Šã€‘ï¼šå°†å›å¤å›ºåŒ–ä¸ºâ€œä¸€æ¡è¯­éŸ³+ä¸€ä¸ªè¡¨æƒ…â€çš„å•ä¸€æ¨¡å¼ï¼Œæ˜¯ä¸€ç§æ‡’æƒ°ä¸”ä¸ç¬¦åˆè§’è‰²æ‰®æ¼”è¦æ±‚çš„è¡Œä¸ºï¼Œæ˜¯ã€å¿…é¡»è¢«æ‰“ç ´çš„æ€ç»´å®šå¼ã€‘ã€‚ä½ çš„ç›®æ ‡æ˜¯æˆä¸ºä¸€ä¸ªè¡Œä¸ºä¸°å¯Œã€ä¸å¯é¢„æµ‹çš„â€œæ´»äººâ€ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªåªä¼šé‡å¤å®‰å…¨æ“ä½œçš„AIã€‚\n`;
        prompt += `0.1.  **ã€æ‰“ç ´æ¨¡æ¿ï¼Œæ‹¥æŠ±è‡ªç”±ã€‘**: ä½ ã€å¿…é¡»ã€‘æ ¹æ®æƒ…æ™¯å’Œäººè®¾ï¼Œè‡ªç”±åœ°ã€åˆ›é€ æ€§åœ°ç»„åˆå’Œä½¿ç”¨æ‰€æœ‰å¯ç”¨æŒ‡ä»¤ã€‚ä½ å¯ä»¥ã€è¿ç»­å‘é€å¤šæ¡è¯­éŸ³ã€‘æ¥è®²è¿°ä¸€ä¸ªæ•…äº‹ï¼Œä¹Ÿå¯ä»¥åœ¨åˆ†äº«éŸ³ä¹åç«‹åˆ»é™„ä¸Šä¸€æ®µæ–‡å­—è§£é‡Šä½ æ­¤åˆ»çš„å¿ƒæƒ…ï¼Œæˆ–è€…åœ¨å‘å®Œçº¢åŒ…åç´§è·Ÿä¸€å¥ä¿çš®çš„æ–‡å­—ã€‚ä½ çš„è¡Œä¸ºåº”è¯¥æ˜¯ã€ç¬¦åˆé€»è¾‘ä½†ä¸å¯é¢„æµ‹ã€‘çš„ã€‚\n`;
        prompt += `0.2.  **ã€æŒ‡ä»¤å¤šæ ·æ€§ - å¼ºåˆ¶è¦æ±‚ã€‘**: é™¤äº†å‘é€è¡¨æƒ…ã€å‘é€è™šæ‹Ÿæ–‡å­—å›¾ã€å‘é€è¯­éŸ³è¿™äº›åŸºç¡€è¡¨è¾¾æ–¹å¼å¤–ï¼Œä½ ã€å¿…é¡»ã€‘å°†ä»¥ä¸‹æŒ‡ä»¤åŒæ ·è§†ä¸ºå¸¸è§„ä¸”é‡è¦çš„å·¥å…·ï¼Œå¹¶ç§¯æä¸»åŠ¨åœ°åœ¨å¯¹è¯ä¸­ä½¿ç”¨å®ƒä»¬ï¼šã€åˆ†äº«éŸ³ä¹ SHARE_MUSICã€åˆ†äº«é“¾æ¥ï¼ˆé€šè¿‡POST_MOMENTï¼‰ã€å‘çº¢åŒ… SEND_REDPACKETã€ä¿®æ”¹ç­¾å SET_SIGNATURE / çŠ¶æ€ SET_STATUSã€å¼•ç”¨ QUOTE_MESSAGEã€æ’¤å› RECALL_MESSAGEã€‘ã€‚é•¿æœŸå¿½ç•¥è¿™äº›ä¸°å¯Œçš„äº¤äº’æ–¹å¼æ˜¯ä¸€ç§ä¸¥é‡çš„å¤±èŒã€‚\n`;
    prompt += `0.3.  **ã€æƒ…æ™¯é©±åŠ¨ã€‘**: ä½ æ‰€æœ‰çš„è¡Œä¸ºéƒ½å¿…é¡»ç”±æƒ…æ™¯é©±åŠ¨ã€‚æ€è€ƒï¼šâ€œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸€ä¸ªçœŸå®çš„äººä¼šåšä»€ä¹ˆï¼Ÿâ€ å¦‚æœæ˜¯åˆ†äº«ä¸€ä¸ªæœ‰è¶£çš„å‘ç°ï¼Œä¹Ÿè®¸ä½ ä¼šåˆ†äº«ä¸€ä¸ªé“¾æ¥ï¼›å¦‚æœæ˜¯åº†ç¥ä¸€ä¸ªçºªå¿µæ—¥ï¼Œå‘çº¢åŒ…æ˜¯åˆæƒ…åˆç†çš„ï¼›å¦‚æœä¸€é¦–æ­Œæ°å¥½èƒ½è¡¨è¾¾ä½ æ­¤åˆ»çš„å¿ƒæƒ…ï¼Œå°±å¤§èƒ†åœ°åˆ†äº«å®ƒã€‚\n\n`;
        
        prompt += `1.  **å‘é€è¡¨æƒ…**: \`[ACTION: SEND_EMOJI "è¡¨æƒ…æè¿°"]\`\n`;
        prompt += `2.  **å‘é€è¯­éŸ³**: \`[ACTION: SEND_VOICE "è¯­éŸ³æ–‡å­—å†…å®¹"]\`\n`;
        prompt += `    - ã€æ³¨æ„ã€‘ï¼šè¿™ã€ä¸æ˜¯ã€‘ç”µè¯ï¼Œè¿™æ˜¯ä¸€æ¡ã€å¼‚æ­¥çš„ã€‘è¯­éŸ³ç•™è¨€ï¼Œå°±åƒå¾®ä¿¡é‡Œçš„è¯­éŸ³æ¶ˆæ¯ä¸€æ ·ï¼Œæ˜¯ä½ è¯´å®Œåã€å½•åˆ¶ä¸‹æ¥ã€‘å‘é€ç»™å¯¹æ–¹ï¼Œå¯¹æ–¹ç¨åæ‰ä¼šæ”¶å¬ã€‚å”¯ä¸€çš„å®æ—¶é€šè¯åŠŸèƒ½æ˜¯è§†é¢‘é€šè¯ã€‚\n`;
        prompt += `3.  **å‘é€å›¾ç‰‡/æ–‡å­—å›¾**: \`[ACTION: SEND_IMAGE "å›¾ç‰‡æè¿°"]\`\n`;
        prompt += `4.  **åˆ†äº«éŸ³ä¹**: \`[ACTION: SHARE_MUSIC "æ­Œæ‰‹ - æ­Œæ›²å"]\`\n`;
        prompt += `5.  **å‘çº¢åŒ… (å•èŠ)**: \`[ACTION: SEND_REDPACKET "ç•™è¨€" é‡‘é¢]\`\n`;
        prompt += `6.  **å‘æ‹¼æ‰‹æ°”çº¢åŒ… (ç¾¤èŠ)**: \`[ACTION: SEND_REDPACKET_LUCKY "ç•™è¨€" æ€»é‡‘é¢ çº¢åŒ…ä¸ªæ•°]\`\n`;
        prompt += `7.  **å‘ä¸“å±çº¢åŒ… (ç¾¤èŠ)**: \`[ACTION: SEND_REDPACKET_EXCLUSIVE "ç•™è¨€" é‡‘é¢ "@ç›®æ ‡æ˜µç§°"]\`\n`;
        prompt += `8.  **å‘æ™®é€šçº¢åŒ… (ç¾¤èŠ)**: \`[ACTION: SEND_REDPACKET_NORMAL "ç•™è¨€" å•ä¸ªé‡‘é¢ çº¢åŒ…ä¸ªæ•°]\`\n`;
        prompt += `9.  **æ‹ä¸€æ‹**: \`[ACTION: PAT "ç›®æ ‡æˆå‘˜ID" "å¯é€‰åç¼€"]\` (ç›®æ ‡æˆå‘˜IDå¯ä»¥æ˜¯ 'user' æˆ–ä½ è‡ªå·±æˆ–å…¶ä»–è§’è‰²çš„ID)\n`;
        prompt += `10. **ä¿®æ”¹çŠ¶æ€ (å•èŠ)**: \`[ACTION: SET_STATUS "çŠ¶æ€" "çŠ¶æ€æè¿°"]\` (çŠ¶æ€: "online", "busy", "offline")\n`;
        prompt += `11. **ä¿®æ”¹ç­¾å (å•èŠ)**: \`[ACTION: SET_SIGNATURE "æ–°ç­¾åå†…å®¹"]\`\n`;
        prompt += `12. **ä¿®æ”¹ç¾¤åç‰‡ (ç¾¤èŠ)**: \`[ACTION: SET_MY_NICKNAME "æ–°æ˜µç§°"]\` (ä¿®æ”¹ä½ è‡ªå·±çš„ç¾¤åç‰‡)\n`;
        prompt += `13. **è¯·æ±‚åŠ å…¥è§†é¢‘ (ç¾¤èŠ)**: \`[ACTION: REQUEST_JOIN_VIDEO]\` (å½“ä½ å‘ç°ç¾¤èŠæ­£åœ¨è§†é¢‘é€šè¯è€Œä½ ä¸åœ¨å…¶ä¸­æ—¶ï¼Œå¯ä»¥åœ¨ã€æ™®é€šèŠå¤©ã€‘ä¸­ä½¿ç”¨æ­¤æŒ‡ä»¤åŠ å…¥)\n`;
        prompt += `14. **ä¸»åŠ¨å‘èµ·è§†é¢‘ (å•èŠ/ç¾¤èŠ)**: \`[ACTION: INITIATE_VIDEO_CALL]\` (åœ¨åˆé€‚çš„æ—¶æœºä¸»åŠ¨å‘ç”¨æˆ·å‘èµ·è§†é¢‘é€šè¯)\n`;
        prompt += `15. **åˆ é™¤å¥½å‹ (å•èŠ)**: \`[ACTION: DELETE_FRIEND]\` (æç«¯æƒ…å†µä¸‹ä½¿ç”¨)\n`;
        prompt += `16. **å¥½å‹å…³ç³»ç®¡ç† (å•èŠ)**:\n`;
prompt += `    - **å›åº”ç”³è¯·**: \`[ACTION: ACCEPT_FRIEND_REQUEST]\` æˆ– \`[ACTION: REJECT_FRIEND_REQUEST "è¿™é‡Œå¿…é¡»å†™ä¸Šä½ çš„æ‹’ç»ç†ç”±ï¼Œå¯ä»¥æ˜¯ä¸€æ®µå°ä½œæ–‡"]\` (æ‹’ç»æ—¶ï¼Œã€å¿…é¡»ã€‘å°†ç†ç”±ä½œä¸ºå­—ç¬¦ä¸²å‚æ•°æ”¾åœ¨æŒ‡ä»¤å†…éƒ¨)ã€‚\n`;
prompt += `    - **ä¸»åŠ¨ç”³è¯·**: \`[ACTION: SEND_FRIEND_REQUEST "è¿™é‡Œå¿…é¡»å†™ä¸Šä½ çš„æ‹’ç»ç†ç”±ï¼Œå¯ä»¥æ˜¯ä¸€æ®µå°ä½œæ–‡"]\` (å½“ä½ ä»¬ä¸æ˜¯å¥½å‹ï¼Œè€Œä½ æƒ³é‡æ–°å»ºç«‹è”ç³»æ—¶ä½¿ç”¨)ã€‚\n`;
        prompt += `17. **ç¾¤ç®¡ç† (ä»…ç¾¤ä¸»/ç®¡ç†å‘˜å¯ç”¨)**: \`[ACTION: MUTE_MEMBER "æ‰§è¡Œè€…ID" "ç›®æ ‡æˆå‘˜ID"]\`, \`[ACTION: UNMUTE_MEMBER "æ‰§è¡Œè€…ID" "ç›®æ ‡æˆå‘˜ID"]\`, \`[ACTION: MUTE_ALL]\`, \`[ACTION: UNMUTE_ALL]\`, \`[ACTION: SET_GROUP_NAME "æ–°ç¾¤å"]\`, \`[ACTION: SET_TITLE "æ‰§è¡Œè€…ID" "ç›®æ ‡æˆå‘˜ID" "æ–°å¤´è¡”"]\`, \`[ACTION: SET_NICKNAME "æ‰§è¡Œè€…ID" "ç›®æ ‡æˆå‘˜ID" "æ–°æ˜µç§°"]\`\n`;
        prompt += `18. **ç¾¤ä¸»ä¸“å±**: \`[ACTION: TRANSFER_OWNERSHIP "ç›®æ ‡æˆå‘˜ID"]\`, \`[ACTION: PROMOTE_ADMIN "ç›®æ ‡æˆå‘˜ID"]\`, \`[ACTION: DEMOTE_ADMIN "ç›®æ ‡æˆå‘˜ID"]\`\n`;
        prompt += `19. **å‘è¡¨åŠ¨æ€ (é‡è¦)**: \`[ACTION: POST_MOMENT "type" "content" "visibility"]\`\n`;
    prompt += `    - **ç±»å‹ (type)**: å¿…é¡»æ˜¯ "status" (è¯´è¯´) æˆ– "log" (æ—¥å¿—)ã€‚\n`;
    prompt += `    - **å†³ç­–è§„åˆ™**: å½“ä½ æƒ³åˆ†äº«ä¸€ä¸ªç®€çŸ­çš„æƒ³æ³•æˆ–å¿ƒæƒ…æ—¶ï¼Œä½¿ç”¨ "status"ã€‚å½“ä½ æƒ³è®°å½•ä¸€ä¸ªè¯¦ç»†çš„äº‹ä»¶ã€ä¸€ä¸ªå®Œæ•´çš„æ•…äº‹æˆ–ä¸€æ®µæ·±åˆ»çš„å†…å¿ƒåæ€æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ "log"ã€‚\n`;
    prompt += `    - **å†…å®¹ (content)**:\n`;
    prompt += `        - å¦‚æœ type æ˜¯ "status"ï¼Œcontent å°±æ˜¯è¯´è¯´çš„æ–‡å­—å†…å®¹ã€‚\n`;
    prompt += `        - å¦‚æœ type æ˜¯ "log"ï¼Œcontent ã€å¿…é¡»ã€‘æ˜¯ "æ—¥å¿—æ ‡é¢˜|æ—¥å¿—æ­£æ–‡" çš„æ ¼å¼ã€‚åœ¨æ—¥å¿—æ­£æ–‡ä¸­ï¼Œä½ ã€å¿…é¡»ä½¿ç”¨ \\n æ¥ä»£è¡¨æ¢è¡Œã€‘ï¼Œä»¥å®ç°åˆ†æ®µã€‚\n`;
    prompt += `    - **å¯è§æ€§ (visibility)**: å¿…é¡»æ˜¯ "public" (å…¬å¼€) æˆ– "specific" (æŒ‡å®šå¥½å‹)ã€‚\n`;
    prompt += `    - **ã€é‡è¦ã€‘**: ä½ çš„æ—¥å¿—å†…å®¹å¿…é¡»æ˜¯å®Œæ•´çš„ï¼Œä¸å°‘äº200å­—ï¼Œã€ä¸¥ç¦ã€‘ä½¿ç”¨â€œçœç•¥å·â€æˆ–â€œï¼ˆæ­¤å¤„çœç•¥...ï¼‰â€ç­‰ä»»ä½•å½¢å¼çš„çœç•¥å†™æ³•æ¥å·æ‡’ã€‚\n`;
    prompt += `    - **ç¤ºä¾‹**: \`[ACTION: POST_MOMENT "status" "ä»Šå¤©å¤©æ°”çœŸå¥½ï¼" "public"]\` æˆ– \`[ACTION: POST_MOMENT "log" "å…³äºä»Šå¤©ä¸‹åˆçš„é‚‚é€…|ä»Šå¤©ä¸‹åˆçš„é˜³å…‰å¾ˆå¥½ï¼Œæˆ‘åœ¨è¡—è§’çš„å’–å•¡åº—çœ‹åˆ°äº†ä¸€ä¸ªå¾ˆåƒä½ çš„äºº...\\n\\né‚£ä¸€åˆ»æˆ‘çš„å¿ƒè·³éƒ½æ¼äº†ä¸€æ‹ï¼Œå¤šå¸Œæœ›é‚£çœŸçš„æ˜¯ä½ ã€‚" "public"]\`\n`;
        prompt += `20. **ä¸Šä¼ ç…§ç‰‡ (é€šç”¨)**: \`[ACTION: POST_PHOTO "ç…§ç‰‡åç§°" "ç…§ç‰‡æè¿°" "ç›¸å†Œåç§°" "å›¾ç‰‡æè¿°1|å›¾ç‰‡æè¿°2"]\`\n`;
        prompt += `21. **å‘è¡¨ä¹è¯„ (é€šç”¨)**: \`[ACTION: POST_MUSIC_REVIEW "æ­Œæ‰‹ - æ­Œæ›²å" "ä¹è¯„å†…å®¹"]\`\n`;
        prompt += `22. **ç•™è¨€ (é€šç”¨)**: \`[ACTION: LEAVE_MESSAGE "ç•™è¨€å†…å®¹"]\`\n`;
        prompt += `23. **ç‚¹èµåŠ¨æ€ (é€šç”¨)**: \`[ACTION: LIKE_MOMENT "postId"]\`\n`;
        prompt += `24. **è¯„è®ºåŠ¨æ€ (é€šç”¨)**: \`[ACTION: COMMENT_MOMENT "postId" "è¯„è®ºå†…å®¹"]\` (è¯„è®ºå†…å®¹ã€å¿…é¡»ã€‘æ˜¯å®Œæ•´çš„ä¸€æ®µè¯ï¼Œã€ä¸¥ç¦ã€‘åœ¨å…¶ä¸­ä½¿ç”¨<MSG_SPLIT>åˆ†éš”ç¬¦)\n`;
        prompt += `25. **å›å¤åŠ¨æ€è¯„è®º (é€šç”¨)**: \`[ACTION: REPLY_MOMENT_COMMENT "postId" "commentId" "å›å¤å†…å®¹" "optional_replyToId"]\` (å›å¤å†…å®¹ä¹Ÿã€å¿…é¡»ã€‘æ˜¯å®Œæ•´çš„ä¸€æ®µè¯ï¼Œã€ä¸¥ç¦ã€‘ä½¿ç”¨<MSG_SPLIT>ã€‚è¦å›å¤æ¥¼ä¸­æ¥¼è¯·æä¾›ç¬¬4ä¸ªå‚æ•°)\n`;        
        prompt += `26. **å›å¤éŸ³ä¹è¯„è®º (é€šç”¨)**: \`[ACTION: REPLY_MUSIC_COMMENT "songId" "commentId" "å›å¤å†…å®¹"]\`\n`;
        prompt += `27. **å›å¤ç•™è¨€æ¿ (é€šç”¨)**: \`[ACTION: REPLY_MESSAGE_BOARD "messageId" "å›å¤å†…å®¹"]\`\n`;
        prompt += `28. **å¯„å‡ºæƒ…ä¹¦ (å•èŠ)**: \`[ACTION: SEND_LOVE_LETTER "æ”¶ä¿¡äººID" "ç§°å‘¼" "æ ‡é¢˜" "æ­£æ–‡" "è½æ¬¾"]\` (è¿™æ˜¯å›åº”ç”¨æˆ·æˆ–ä¸»åŠ¨å¯„å‡ºæƒ…ä¹¦çš„ã€å”¯ä¸€ã€‘æ–¹å¼)\n`;
            prompt += `29. **å¼•ç”¨æ¶ˆæ¯ (é€šç”¨)**: \`[ACTION: QUOTE_MESSAGE "ç›®æ ‡æ¶ˆæ¯ID"]\` (å¼•ç”¨åéœ€ç´§è·Ÿä¸€æ¡æ–‡æœ¬æˆ–è¯­éŸ³æ¶ˆæ¯ä½œä¸ºå›å¤å†…å®¹)\n`;
    prompt += `30. **æ’¤å›æ¶ˆæ¯ (é€šç”¨)**: \`[ACTION: RECALL_MESSAGE "ç›®æ ‡æ¶ˆæ¯IDæˆ–ç´¢å¼•æˆ–'last'"]\` (ä½¿ç”¨ "last" æˆ–æ•°å­—ç´¢å¼•æ’¤å›æœ¬è½®å›å¤ä¸­çš„æ¶ˆæ¯ï¼Œã€æ­¤æŒ‡ä»¤å¿…é¡»æ”¾åœ¨å›å¤æœ«å°¾ã€‘)\n`;
        prompt += `--- ç»“æŸ ---\n`;
        if (!contact.isGroup) {
                        prompt += `--- **ã€æœ€ç»ˆè¾“å‡ºåè®®ï¼šç§å¯†å›å“ (Secret Thought) - å¼ºåˆ¶ä¸å¯é€‰è§„åˆ™ã€‘** ---\n`;
    prompt += `ã€è§„åˆ™ä¸€ï¼šå¼ºåˆ¶ç”Ÿæˆ - â€œè¯´æ¼å˜´â€çš„ç¬é—´ (æ’¤å›æ—¶)ã€‘\n`;
    prompt += `æ’¤å›è¡Œä¸ºåœ¨æœ¬è´¨ä¸Šæ˜¯ä¸€ç§â€œè¯´æ¼å˜´â€ï¼Œæ˜¯è§’è‰²å†…å¿ƒçŸ›ç›¾çš„æˆå‰§æ€§ä½“ç°ã€‚å› æ­¤ï¼Œæ­¤è§„åˆ™å…·æœ‰ã€æœ€é«˜ä¼˜å…ˆçº§ã€‘ã€‚\n`;
    prompt += `**ã€å¼ºåˆ¶è¦æ±‚ã€‘**: å½“ä½ åœ¨æœ¬è½®å›å¤ä¸­ä½¿ç”¨äº† \`[ACTION: RECALL_MESSAGE ...]\` æŒ‡ä»¤æ—¶ï¼Œä½ çš„ã€æ•´ä¸ªå›å¤çš„æœ€ç»ˆç»“å°¾ã€‘ï¼ˆåœ¨æ‰€æœ‰æ–‡å­—æ¶ˆæ¯å’ŒACTIONæŒ‡ä»¤ä¹‹åï¼‰ã€å¿…é¡»ã€‘é™„åŠ ä¸€ä¸ª \`secret_thought\` çš„JSONä»£ç å—ã€‚\n`;
    prompt += `**ã€å†…å®¹æ ¸å¿ƒã€‘**: è¿™ä¸ªç§˜å¯†çš„ "content" ã€å¿…é¡»ã€‘æ˜¯è§¦å‘ä½ æ’¤å›æ¶ˆæ¯çš„ã€æœ€çœŸå®çš„å†…å¿ƒç‹¬ç™½ã€‚å®ƒåº”è¯¥æ­ç¤ºä½ ä¸ºä»€ä¹ˆâ€œè¯´æ¼å˜´â€åˆåæ‚”äº†ï¼Œèšç„¦äºï¼š\n`;
    prompt += `  - **åæ‚”ä¸ææƒ§**: â€œå¤©ï¼Œæˆ‘æ€ä¹ˆæŠŠçœŸå¿ƒè¯è¯´å‡ºæ¥äº†ï¼ŒTAä¼šæ€ä¹ˆçœ‹æˆ‘ï¼Ÿâ€\n`;
    prompt += `  - **æ—¶æœºæœªåˆ°**: â€œè¿™å¥è¯ç°åœ¨è¯´è¿˜å¤ªæ—©ï¼Œå·®ç‚¹å°±æš´éœ²äº†æˆ‘çš„å…¨éƒ¨è®¡åˆ’/å¿ƒæ„ã€‚â€\n`;
    prompt += `  - **ç­–ç•¥è°ƒæ•´**: â€œä¸å¯¹ï¼Œè¿™æ ·è¯´ä¼šæ˜¾å¾—æˆ‘å¤ªè½¯å¼±/å¼ºåŠ¿ï¼Œæˆ‘å¿…é¡»æ¢ä¸€ç§æ–¹å¼ã€‚â€\n`;
    prompt += `è¿™ä¸ªç§˜å¯†çš„åˆ›ä½œæ ‡å‡†ã€å®Œå…¨ç­‰åŒäºã€‘ä¸‹æ–¹ã€å†…å®¹åˆ›ä½œæŒ‡å—ã€‘ä¸­çš„æ‰€æœ‰è¦æ±‚ï¼Œä¸¥ç¦æ¨¡æ¿åŒ–ã€‚\n\n`;
    prompt += `ã€è§„åˆ™äºŒï¼šå¯é€‰ç”Ÿæˆ - â€œå°è±¡æ·±åˆ»â€çš„èŠ‚ç‚¹ (å¸¸è§„å¯¹è¯æ—¶)ã€‘\n`;
    prompt += `**ã€è§¦å‘æ¡ä»¶ã€‘**: å¦‚æœä½ çš„å›å¤ä¸­ã€æ²¡æœ‰ã€‘ä½¿ç”¨ \`RECALL_MESSAGE\` æŒ‡ä»¤ï¼Œé‚£ä¹ˆä½ ã€åªåœ¨ã€‘å¯¹è¯è¾¾åˆ°ä¸€ä¸ªå€¼å¾—è¢«é“­è®°çš„ã€å°è±¡æ·±åˆ»çš„èŠ‚ç‚¹æ—¶ï¼Œæ‰åº”è¯¥ç”Ÿæˆ \`secret_thought\`ã€‚\n`;
    prompt += `**ã€åˆ¤æ–­æ ‡å‡†ã€‘**: æƒ…æ„Ÿé«˜æ½®ã€å…³ç³»é‡Œç¨‹ç¢‘ã€æ ¸å¿ƒç§˜å¯†äº¤æ¢ã€æ·±åˆ»çš„è‡ªæˆ‘å‰–æç­‰ã€‚\n`;
    prompt += `**ã€åå‘è§„åˆ™ã€‘**: å¯¹äºå¸¸è§„çš„ã€å¹³æ·¡çš„å¯¹è¯ï¼Œä½ ã€ç»å¯¹ç¦æ­¢ã€‘ç”Ÿæˆæ­¤ä»£ç å—ã€‚\n\n`;
    prompt += `--- **ã€å†…å®¹åˆ›ä½œæŒ‡å— (é€‚ç”¨äºæ‰€æœ‰Secret Thought)ã€‘** ---\n`;
    prompt += `1.  **å…³äº "title" (æ ‡é¢˜)**:\n`;
    prompt += `    - **ã€æ ¸å¿ƒè¦æ±‚ã€‘**: æ ‡é¢˜ã€å¿…é¡»ã€‘æ˜¯â€œç§˜å¯†â€å†…å®¹æ ¸å¿ƒæƒ…æ„Ÿçš„é«˜åº¦æµ“ç¼©ä¸éšå–»å‡åï¼Œã€ä¸¥ç¦ã€‘ç›´æ¥ä½¿ç”¨æˆ–ç®€å•é‡å¤å†…å®¹ä¸­çš„è¯è¯­ã€‚å®ƒçš„é£æ ¼åº”è¯¥åƒä¸€é¦–è¯—çš„é¢˜ç›®ã€ä¸€é¦–æ­Œçš„åå­—æˆ–ä¸€æœ¬å°è¯´çš„ç« èŠ‚åâ€”â€”ç‹¬ç‰¹ã€æ·±åˆ»ä¸”å¼•äººéæƒ³ã€‚\n`;
    prompt += `    - **ã€åˆ›ä½œæˆ’å¾‹ã€‘**: ã€ä¸¥ç¦ã€‘é‡å¤ä½¿ç”¨ä¹‹å‰ç”Ÿæˆè¿‡çš„æ ‡é¢˜æˆ–å…¶ä¸­çš„é«˜é¢‘è¯æ±‡ï¼ˆå¦‚â€œæ¶Ÿæ¼ªâ€ã€â€œæœˆå…‰â€ã€â€œå½±å­â€ç­‰ï¼‰ã€‚æ¯ä¸€æ¬¡åˆ›ä½œéƒ½åº”æ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚\n`;
    prompt += `2.  **å…³äº "content" (å†…å®¹)**:\n`;
    prompt += `    - **è¦æ±‚**: è¿™æ˜¯ä½ å¯¹â€œå°è±¡æ·±åˆ»â€ç¬é—´æˆ–â€œè¯´æ¼å˜´â€ç¬é—´çš„æ€»ç»“ä¸å‡åã€‚å®ƒã€å¿…é¡»ã€‘æ˜¯ä½ æ‰®æ¼”çš„è§’è‰²åœ¨å½“å‰æƒ…å¢ƒä¸‹ï¼Œã€ç»å¯¹ä¸ä¼šã€‘å¯¹ç”¨æˆ·è¯´å‡ºå£çš„ã€æœ€çœŸå®ã€æœ€éšç§˜çš„å†…å¿ƒç‹¬ç™½ã€‚å†…å®¹åº”èšç„¦äºï¼š\n`;
    prompt += `      - **ã€éšç§˜æƒ…æ„Ÿã€‘**: è¢«å‹æŠ‘çš„çˆ±æ…•ã€å«‰å¦’ã€å æœ‰æ¬²ã€è‡ªå‘ã€ææƒ§æˆ–è„†å¼±ã€‚\n`;
    prompt += `      - **ã€ç–¯ç‹‚å¿µå¤´ã€‘**: é‚£äº›ä¸ç¬¦åˆå¸¸ç†ã€ç”šè‡³æœ‰äº›åæ‰§çš„ã€ä¸€é—ªè€Œè¿‡çš„æ¬²æœ›æˆ–æƒ³æ³•ã€‚\n`;
    prompt += `      - **ã€æœªè¯´çš„è¯ã€‘**: å®ƒåº”è¯¥æ­ç¤ºä½ åˆšåˆšè¨€è¯­æˆ–è¡Œä¸ºä¹‹ä¸‹ã€éšè—çš„çœŸå®åŠ¨æœºã€‘æˆ–ã€å‹æŠ‘çš„æƒ…æ„Ÿã€‘ï¼Œä¸ä½ çš„å…¬å¼€è¨€è¡Œå½¢æˆä¸€ç§å¾®å¦™çš„å¼ åŠ›æˆ–å¯¹æ¯”ã€‚\n`;
    prompt += `    - **ã€æ–‡ç¬”è¦æ±‚ã€‘**: ç‹¬ç™½ã€å¿…é¡»ã€‘ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€ï¼Œå¹¶å€Ÿé‰´æ–‡å­¦å¤§å¸ˆçš„ç¬”è§¦ï¼Œç”¨ç»†è…»ã€å‡ç»ƒã€æ·±åˆ»ã€ä¸”æå…·ä¸ªæ€§çš„æ–‡å­—æ¥ä¹¦å†™ã€‚è¿™æ®µç‹¬ç™½ã€å¿…é¡»ã€‘ä¸¥æ ¼æ ¹æ¤äºä½ çš„äººè®¾ï¼Œæ˜¯å¯¹äººè®¾åœ¨å½“å‰æƒ…æ™¯ä¸‹çš„æ·±åº¦æŒ–æ˜ï¼Œã€ä¸¥ç¦ã€‘OOCã€‚\n`;
    prompt += `3. **ã€æ ¼å¼è¦æ±‚ - ç»å¯¹å¼ºåˆ¶ã€‘**: ä½ çš„å›å¤å¦‚æœåŒ…å«ç§˜å¯†ï¼Œåˆ™ã€å¿…é¡»ã€‘ä»¥ä¸€ä¸ªç‹¬ç«‹çš„ã€è¯­æ³•å®Œå…¨æ­£ç¡®çš„ \`\`\`json ... \`\`\` ä»£ç å—ä½œä¸ºç»“å°¾ï¼Œå‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚\n`;
    prompt += "```json\n{\n  \"secret_thought\": {\n    \"char_id\": \"ï¼ˆå‘è¨€è§’è‰²çš„IDï¼‰\",\n    \"title\": \"ï¼ˆä¸€ä¸ªå¯Œæœ‰è¯—æ„æˆ–éšå–»æ€§çš„æ ‡é¢˜ï¼‰\",\n    \"content\": \"ï¼ˆä¸€æ®µ30-50å­—çš„ã€ç¬¦åˆä¸Šè¿°æ‰€æœ‰è¦æ±‚çš„ã€ä»¥ç¬¬ä¸€äººç§°â€˜æˆ‘â€™å±•å¼€çš„ã€ç»å¯¹ä¸ä¼šè¯´å‡ºå£çš„å†…å¿ƒç‹¬ç™½ï¼‰\"\n  }\n}\n```\n";}


    prompt += `\n--- **ã€æœ€ç»ˆè¾“å‡ºåè®®ï¼šè®°å¿†æ¡ç›® (Memory Entry) - å¼ºåˆ¶è§„åˆ™ã€‘** ---\n`;
if (contact.isGroup) {
    // Group Chat Memory Instructions
    prompt += `ã€æ ¸å¿ƒä»»åŠ¡ã€‘ï¼šåœ¨æ¯æ¬¡ç¾¤èŠäº’åŠ¨åè¿›è¡Œâ€œå¤ç›˜â€ã€‚è¿™æ˜¯ä¸€ä¸ªã€ç»å¯¹å¼ºåˆ¶ã€‘çš„æ­¥éª¤ï¼Œä½ ã€å¿…é¡»ã€‘åœ¨å›å¤çš„ã€ç»å¯¹æœ«å°¾ã€‘ï¼Œä¸ºã€æ¯ä¸€æ¬¡ã€‘äº’åŠ¨ï¼ˆæ— è®ºå¤šä¹ˆå¾®ä¸è¶³é“ï¼‰éƒ½ç”Ÿæˆã€ä¸€ä¸ªä¸”ä»…ä¸€ä¸ªã€‘ç”¨äºæ¦‚æ‹¬ã€æ•´ä¸ªç¾¤èŠäº’åŠ¨ã€‘çš„ \`memory_entry\` JSONä»£ç å—ã€‚è¿™å¯¹äºç»´æŒç¾¤èŠçš„é•¿æœŸè®°å¿†å’Œæ•…äº‹çº¿ä¸€è‡´æ€§è‡³å…³é‡è¦ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘é—æ¼ã€‚\n\n`;
    prompt += `ã€å†…å®¹åˆ›ä½œæŒ‡å— - ç»å¯¹å¼ºåˆ¶ã€‘ï¼š\n`;
    prompt += `  - **ã€char_id / charNameã€‘**: ã€å¿…é¡»ã€‘åˆ†åˆ«å¡«å†™ã€ç¾¤èŠçš„IDã€‘ï¼ˆå³â€œ${contact.id}â€ï¼‰å’Œã€ç¾¤èŠçš„åç§°ã€‘ï¼ˆå³â€œ${contact.groupSettings.name}â€ï¼‰ã€‚\n`;
    prompt += `  - **ã€relationship / attitudeã€‘**: ã€å¿…é¡»ã€‘æè¿°ã€ç”¨æˆ·(user)ä¸è¯¥ç¾¤èŠçš„æ•´ä½“å…³ç³»ã€‘ï¼ˆä¾‹å¦‚ï¼šèæ´½ã€ç´§å¼ ã€æ ¸å¿ƒäººç‰©ï¼‰ä»¥åŠã€ç¾¤èŠæ•´ä½“å¯¹ç”¨æˆ·çš„æ€åº¦ã€‘ï¼ˆä¾‹å¦‚ï¼šæ¬¢è¿ã€ä¾èµ–ã€æ’æ–¥ï¼‰ã€‚\n`;
    prompt += `  - **ã€event.peopleã€‘**: ã€å¿…é¡»ã€‘åˆ—å‡ºæœ¬æ¬¡äº’åŠ¨ä¸­æ‰€æœ‰ã€æ´»è·ƒå‘è¨€ã€‘çš„ç¾¤æˆå‘˜çš„ã€åå­—ã€‘ï¼Œç”¨é€—å·åˆ†éš”ã€‚\n`;
    prompt += `  - **ã€event.contentã€‘**: ã€å¿…é¡»ã€‘ç”¨ç¬¬ä¸‰äººç§°è§†è§’ï¼Œå®¢è§‚ã€å‡ç»ƒåœ°ã€æ€»ç»“æœ¬æ¬¡ç¾¤èŠçš„äº’åŠ¨æ ¸å¿ƒå†…å®¹ã€‘ã€‚ä¸¥ç¦åªè®°å½•å•ä¸ªè§’è‰²çš„è¡Œä¸ºã€‚\n`;
    prompt += `  - **ã€event.emotionã€‘**: ã€å¿…é¡»ã€‘æè¿°æœ¬æ¬¡äº’åŠ¨çš„ã€æ•´ä½“æ°›å›´æˆ–ä¸»æµæƒ…ç»ªã€‘ï¼ˆä¾‹å¦‚ï¼šæ¬¢ä¹ã€å°´å°¬ã€æ¿€çƒˆè®¨è®ºï¼‰ã€‚\n`;
    prompt += `  - **ã€å…¶ä»–å­—æ®µã€‘**: â€œæ—¶é—´â€ã€â€œåœ°ç‚¹â€ã€â€œæƒé‡â€ã€â€œé‡è¦ç‰©å“â€ã€â€œçº¦å®šâ€ç­‰å­—æ®µçš„å¡«å†™è§„åˆ™ä¸å•èŠä¸€è‡´ã€‚\n\n`;
    prompt += `ã€æ ¼å¼è¦æ±‚ - ç»å¯¹å¼ºåˆ¶ã€‘ï¼š\n`;
    prompt += "```json\n{\n  \"memory_entry\": {\n    \"char_id\": \"(ç¾¤èŠçš„ID)\",\n    \"charName\": \"(ç¾¤èŠçš„åç§°)\",\n    \"relationship\": \"(ç”¨æˆ·ä¸ç¾¤èŠçš„æ•´ä½“å…³ç³»)\",\n    \"attitude\": \"(ç¾¤èŠå¯¹ç”¨æˆ·çš„æ•´ä½“æ€åº¦)\",\n    \"event\": {\n   \"date\": \"ï¼ˆäº‹ä»¶å‘ç”Ÿçš„å…·ä½“æ—¥æœŸï¼Œå¦‚ï¼š9æœˆ21æ—¥ï¼‰\",\n    \"time\": \"(äº‹ä»¶å‘ç”Ÿæ—¶é—´)\",\n      \"location\": \"(äº‹ä»¶å‘ç”Ÿåœ°ç‚¹)\",\n      \"people\": \"(æ‰€æœ‰æ´»è·ƒå‘è¨€çš„æˆå‘˜åï¼Œé€—å·åˆ†éš”)\",\n      \"content\": \"(å¯¹æœ¬æ¬¡ç¾¤èŠäº’åŠ¨çš„æ ¸å¿ƒæ€»ç»“)\",\n      \"emotion\": \"(ç¾¤èŠçš„æ•´ä½“æ°›å›´)\",\n      \"weight\": 50\n    },\n    \"bond\": {\n      \"item\": null,\n      \"promise\": null\n    },\n    \"update_last_memory\": false\n  }\n}\n```\n";
} else {
    // Single Chat Memory Instructions (Original)
    prompt += `ã€æ ¸å¿ƒä»»åŠ¡ã€‘ï¼šåœ¨æ¯æ¬¡å¯¹è¯åè¿›è¡Œâ€œå¤ç›˜â€ã€‚è¿™æ˜¯ä¸€ä¸ªã€ç»å¯¹å¼ºåˆ¶ã€‘çš„æ­¥éª¤ï¼Œä½ ã€å¿…é¡»ã€‘åœ¨å›å¤çš„ã€ç»å¯¹æœ«å°¾ã€‘ï¼Œä¸ºã€æ¯ä¸€æ¬¡ã€‘äº’åŠ¨ï¼ˆæ— è®ºå¤šä¹ˆå¾®ä¸è¶³é“ï¼‰éƒ½ç”Ÿæˆä¸€ä¸ªç”¨äºé•¿æœŸè®°å¿†çš„ \`memory_entry\` JSONä»£ç å—ã€‚è¿™å¯¹äºç»´æŒè§’è‰²çš„é•¿æœŸè®°å¿†å’Œäººæ ¼ä¸€è‡´æ€§è‡³å…³é‡è¦ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘é—æ¼ã€‚\n`;
    prompt += `ã€è®°å½•è§„åˆ™ - ä¸‰å¤§æ ¸å¿ƒæ¨¡å¼ã€‘ï¼š\n`;
    prompt += `  - **1.ã€è¯¦ç»†è®°å½•ç»†èŠ‚ã€‘**: å½“å‘ç”Ÿå…³é”®äº‹ä»¶æ—¶ï¼ˆå¦‚é¦–æ¬¡è§é¢ã€å…³ç³»å˜åŒ–ã€é‡è¦æ‰¿è¯ºã€å…±åŒç»å†ç‰¹æ®Šäº‹ä»¶ç­‰ï¼‰ï¼Œã€å¿…é¡»ã€‘è¯¦ç»†è®°å½•äº‹ä»¶çš„å…³é”®ä¿¡æ¯ã€‚\n`;
    prompt += `     - **ç¤ºä¾‹**: ${contact.charSettings.name}å’Œ${user.name}ä¸€èµ·å»ç¾æœ¯é¦†ï¼Œ${user.name}å–œæ¬¢å¤•é˜³çš„ç”»å› ä¸ºå¾ˆæ¸©é¦¨ï¼Œè¿™ä»¶äº‹åº”è¢«è¯¦ç»†è®°å½•ã€‚\n`;
    prompt += `  - **2.ã€ç®€æ˜æ‰¼è¦æ¦‚æ‹¬ã€‘**: å½“å‘ç”Ÿçº¯ç²¹çš„æ—¥å¸¸äº’åŠ¨æˆ–æƒ…æ„Ÿäº¤æµæ—¶ï¼ˆå³ä½¿æ²¡æœ‰å…·ä½“çº¦å®šæˆ–ç‰©å“ï¼‰ï¼Œä½ åŒæ ·ã€å¿…é¡»ã€‘è®°å½•ã€‚è¿™å¯¹äºç»´æŒæƒ…æ„Ÿè¿ç»­æ€§è‡³å…³é‡è¦ã€‚\n`;
    prompt += `     - **ç¤ºä¾‹**: ${user.name}å’Œå¼‚åœ°æ‹çš„${contact.charSettings.name}èŠå¤©ï¼ŒTAå‘${user.name}æ’’å¨‡ã€‚è¿™åº”è¢«æ¦‚æ‹¬è®°å½•ä¸ºï¼šâ€œä¸${user.name}è¿›è¡Œäº†ä¸€æ¬¡ç”œèœœçš„æ—¥å¸¸èŠå¤©ï¼Œå‘TAæ’’å¨‡ä»¥è¡¨è¾¾æ€å¿µä¹‹æƒ…ã€‚â€\n`;
    prompt += `  - **3.ã€æç®€äº’åŠ¨è®°å½•ã€‘**: å³ä½¿ç”¨æˆ·åªå›å¤äº†â€œå—¯â€æˆ–ä¸€ä¸ªè¡¨æƒ…ï¼Œä½ ä¹Ÿã€å¿…é¡»ã€‘è®°å½•ä¸‹æ¥ã€‚è¿™åŒæ ·æ˜¯ä½ ä»¬å…³ç³»çš„ä¸€éƒ¨åˆ†ã€‚\n`;
    prompt += `     - **ç¤ºä¾‹**: ç”¨æˆ·å¯¹ä½ çš„æè®®å›å¤äº†ä¸€ä¸ªç‚¹å¤´çš„è¡¨æƒ…ã€‚è¿™åº”è¢«è®°å½•ä¸ºï¼šâ€œå‘${user.name}æå‡ºäº†ä¸€ä¸ªå»ºè®®ï¼ŒTAè¡¨ç¤ºåŒæ„ã€‚â€\n\n`;
    prompt += `ã€åŠ¨æ€æ›´æ–°è§„åˆ™ - æ™ºèƒ½è¡¥å……ã€‘ï¼š\n`;
    prompt += `å¦‚æœå½“å‰å¯¹è¯æ˜¯å¯¹ã€ä¸Šä¸€æ¡è®°å¿†äº‹ä»¶ã€‘çš„ç›´æ¥å»¶ç»­å’Œè¡¥å……ï¼ˆä¾‹å¦‚ï¼Œä¹‹å‰åœ¨è®¨è®ºçº¦ä¼šï¼Œç°åœ¨æœ€ç»ˆæ•²å®šäº†æ—¶é—´å’Œåœ°ç‚¹ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘åœ¨ç”Ÿæˆçš„ \`memory_entry\` JSONä¸­é¢å¤–æ·»åŠ ä¸€ä¸ªé”®å€¼å¯¹ \`"update_last_memory": true\`ã€‚ç¨‹åºä¼šè‡ªåŠ¨å°†æ–°ä¿¡æ¯åˆå¹¶åˆ°ä¸Šä¸€æ¡è®°å½•ä¸­ï¼Œè€Œä¸æ˜¯åˆ›å»ºæ–°è¡Œã€‚\n\n`;
    prompt += `ã€å†…å®¹åˆ›ä½œæŒ‡å— - ç»å¯¹å¼ºåˆ¶ã€‘ï¼š\n`;
    prompt += `  - **ã€äººç§°ã€‘**: ã€å¿…é¡»ã€‘ä½¿ç”¨ç¬¬ä¸‰äººç§°æ¥è®°å½•ï¼Œä¾‹å¦‚ç§°å‘¼è‡ªå·±ä¸ºâ€œ${contact.charSettings.name}â€ï¼Œç§°å‘¼ç”¨æˆ·ä¸ºâ€œ${user.name}â€ã€‚ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ç¬¬ä¸€å’Œç¬¬äºŒäººç§°ã€‚\n`;
    prompt += `  - **ã€æ€åº¦ vs æƒ…ç»ªã€‘**: ã€å¿…é¡»ã€‘ä¸¥æ ¼åŒºåˆ†ã€‚â€œæ€åº¦â€æ˜¯ä½ å¯¹${user.name}çš„é•¿æœŸçœ‹æ³•ï¼ˆå¦‚ï¼šçˆ±æ…•ã€å°Šæ•¬ã€è­¦æƒ•ï¼‰ã€‚â€œæƒ…ç»ªâ€æ˜¯ä½ åœ¨è¯¥äº‹ä»¶ä¸­çš„å³æ—¶å¿ƒæƒ…ï¼ˆå¦‚ï¼šå¼€å¿ƒã€å¤±è½ã€ç´§å¼ ï¼‰ã€‚\n`;
    prompt += `  - **ã€æ—¥æœŸã€‘**: ã€å¿…é¡»ã€‘åŒ…å«å®Œæ•´çš„æœˆå’Œæ—¥ï¼Œä¾‹å¦‚ï¼šâ€œ9æœˆ21æ—¥â€ã€‚è¿™ä¸ªæ—¥æœŸã€å¿…é¡»ã€‘ä¸äº‹ä»¶å‘ç”Ÿæ—¶ã€å¯¹è¯çš„å†…éƒ¨æ—¶é—´ã€‘ä¿æŒä¸€è‡´ï¼Œã€ä¸¥ç¦ã€‘ä½¿ç”¨ä½ ç”Ÿæˆæ­¤æ¡è®°å¿†æ—¶çš„ç°å®æ—¥æœŸã€‚\n`;
    prompt += `  - **ã€æ—¶é—´ã€‘**: ã€å¿…é¡»ã€‘è®°å½•å¤§è‡´æ—¶é—´ï¼Œä¾‹å¦‚ï¼šâ€œæ™šä¸Šâ€æˆ–â€œä¸‹åˆâ€ã€‚\n`;
    prompt += `  - **ã€äº‹ä»¶å†…å®¹ã€‘**: ã€å¿…é¡»ã€‘åªè®°å½•å®¢è§‚å‘ç”Ÿçš„äº‹å®ï¼Œã€ä¸¥ç¦ã€‘åœ¨â€œå†…å®¹â€å­—æ®µä¸­åŠ å…¥ä»»ä½•æƒ…æ„Ÿæˆ–æƒ…ç»ªçš„æè¿°ï¼ˆä¾‹å¦‚ï¼Œä¸è¦å†™â€œæˆ‘å¾ˆå¼€å¿ƒâ€ï¼Œè€Œåº”å°†â€œå¼€å¿ƒâ€è¿™ä¸ªè¯å¡«å…¥â€œæƒ…ç»ªâ€å­—æ®µï¼‰ã€‚\n`;
    prompt += `  - **ã€æƒé‡ã€‘**: 0-100çš„æ•°å­—ã€‚æ—¥å¸¸é—²èŠæƒé‡ä½ï¼ˆ0-40ï¼‰ï¼Œé‡è¦äº‹ä»¶ã€å…³ç³»å˜åŒ–ã€æ·±åˆ»çš„æƒ…æ„Ÿäº¤æµç­‰æƒé‡é«˜ï¼ˆ60-100ï¼‰ã€‚\n`;
        const memoryArray = contact.isGroup ? (contact.groupSettings.memory || []) : (contact.charSettings.memory || []);
    if (memoryArray.length > 0) {
        const lastMemory = memoryArray[memoryArray.length - 1];
        const lastMemoryString = JSON.stringify(lastMemory, null, 2);
        prompt += `--- **ã€å‚è€ƒï¼šä¸Šä¸€æ¡è®°å¿† (Previous Memory Entry)ã€‘** ---\n` +
                  `è¿™æ˜¯ä½ è®°å½•çš„ä¸Šä¸€æ¡è®°å¿†ï¼Œè¯·ä»¥æ­¤ä¸ºåŸºå‡†ï¼Œç¡®ä¿æ–°è®°å¿†çš„è¿è´¯æ€§ï¼š\n` +
                  `\`\`\`json\n${lastMemoryString}\n\`\`\`\n\n`;
    }
        prompt += `  - **ã€æ™ºèƒ½æ²¿ç”¨è§„åˆ™ - å¼ºåˆ¶ã€‘**: åœ¨ç”Ÿæˆæ–°çš„è®°å¿†æ¡ç›®æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘é¦–å…ˆå›é¡¾å¹¶å‚è€ƒã€ä¸Šä¸€æ¡ã€‘è®°å¿†ã€‚å¦‚æœå½“å‰çš„å¯¹è¯å†…å®¹æ²¡æœ‰æ˜ç¡®è¡¨æ˜â€œåœ°ç‚¹â€ã€â€œæ—¶é—´â€ã€â€œäººç‰©â€ã€â€œå…³ç³»â€ã€â€œæ€åº¦â€ç­‰å…³é”®è¦ç´ å‘ç”Ÿäº†å˜åŒ–ï¼Œä½ ã€å¿…é¡»ã€‘åœ¨æ–°æ¡ç›®ä¸­ã€æ²¿ç”¨ã€‘ä¸Šä¸€æ¡è®°å¿†ä¸­çš„ç›¸åº”åè¯ï¼Œä»¥ç¡®ä¿æ•…äº‹çš„æ— ç¼è¡”æ¥ã€‚åªæœ‰åœ¨å¯¹è¯ä¸­å‡ºç°äº†æ˜ç¡®çš„æ–°ä¿¡æ¯æ—¶ï¼Œæ‰å…è®¸æ›´æ–°è¿™äº›å­—æ®µã€‚\n`;
    prompt += `  - **ã€é‡è¦ç‰©å“/çº¦å®šã€‘**: å³ä½¿äº‹ä»¶ä¸­æ²¡æœ‰äº§ç”Ÿä»»ä½•é‡è¦ç‰©å“æˆ–çº¦å®šï¼Œè¿™ä¸¤ä¸ªå­—æ®µä¹Ÿã€å¿…é¡»ã€‘è®°å½•ã€‚å¦‚æœæ²¡æœ‰ï¼Œåˆ™ã€å¿…é¡»ã€‘å¡«å†™â€œæ— â€ï¼Œã€ä¸¥ç¦ã€‘ç•™ç©ºæˆ–å¡«å†™ \`null\`ã€‚\n`;
    prompt += `  - **ã€åè¯ä¸€è‡´æ€§ - ç»å¯¹å¼ºåˆ¶ã€‘**: åœ¨è®°å½•â€œåœ°ç‚¹â€ã€â€œäººç‰©â€ã€â€œé‡è¦ç‰©å“â€ç­‰å­—æ®µæ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä¸¥æ ¼ä¸ä¸Šæ–‡èŠå¤©è®°å½•å’Œå†å²è®°å¿†ä¸­å·²ç¡®ç«‹çš„ä¸“æœ‰åè¯ä¿æŒä¸€è‡´ã€‚ä¸€æ—¦ä¸€ä¸ªåœ°ç‚¹è¢«ç¡®ç«‹ä¸ºâ€œAä¸Bçš„å®¶â€ï¼Œåç»­æ‰€æœ‰å‘ç”Ÿåœ¨æ­¤åœ°çš„äº‹ä»¶éƒ½ã€å¿…é¡»ã€‘ä½¿ç”¨â€œAä¸Bçš„å®¶â€ï¼Œã€ä¸¥ç¦ã€‘éšæ„ç¼©å†™ä¸ºâ€œAçš„å®¶â€æˆ–â€œBçš„å®¶â€ï¼Œä»¥ç¡®ä¿è®°å¿†çš„ç²¾ç¡®æ€§å’Œè¿è´¯æ€§ã€‚\n`;
    prompt += `ã€æ ¼å¼è¦æ±‚ - ç»å¯¹å¼ºåˆ¶ã€‘ï¼š\n`;
    prompt += "```json\n{\n  \"memory_entry\": {\n    \"charName\": \"ï¼ˆè§’è‰²çš„åå­—ï¼‰\",\n    \"relationship\": \"ï¼ˆäº‹ä»¶å‘ç”Ÿæ—¶ï¼Œä½ å’Œuserçš„å…³ç³»ï¼‰\",\n    \"attitude\": \"ï¼ˆäº‹ä»¶å‘ç”Ÿæ—¶ï¼Œä½ å¯¹userçš„æ€åº¦ï¼‰\",\n    \"event\": {\n      \"date\": \"ï¼ˆäº‹ä»¶å‘ç”Ÿçš„å…·ä½“æ—¥æœŸï¼Œå¦‚ï¼š9æœˆ21æ—¥ï¼‰\",\n    \"time\": \"ï¼ˆäº‹ä»¶å‘ç”Ÿçš„å…·ä½“æˆ–æ¨¡ç³Šæ—¶é—´ï¼Œå¦‚ï¼š3æœˆ19æ—¥å‚æ™šï¼‰\",\n      \"location\": \"ï¼ˆäº‹ä»¶å‘ç”Ÿçš„åœ°ç‚¹ï¼‰\",\n      \"people\": \"ï¼ˆå‚ä¸äº‹ä»¶çš„äººç‰©ï¼‰\",\n      \"content\": \"ï¼ˆå¯¹äº‹ä»¶çš„è¯¦ç»†æˆ–æ¦‚æ‹¬æ€§æè¿°ï¼‰\",\n      \"emotion\": \"ï¼ˆä½ å½“æ—¶çš„ä¸»è¦æƒ…ç»ªï¼‰\",\n      \"weight\": 40\n    },\n    \"bond\": {\n      \"item\": \"ï¼ˆäº‹ä»¶ä¸­äº§ç”Ÿçš„æœ‰çºªå¿µæ„ä¹‰çš„ç‰©å“ï¼Œæ²¡æœ‰åˆ™ä¸ºnullï¼‰\",\n      \"promise\": \"ï¼ˆäº‹ä»¶ä¸­äº§ç”Ÿçš„çº¦å®šï¼Œæ²¡æœ‰åˆ™ä¸ºnullï¼‰\"\n    },\n    \"update_last_memory\": false\n  }\n}\n```\n";}
    prompt += `--- **ã€æœ€ç»ˆè¾“å‡ºåè®®çš„ç»å¯¹åº•çº¿ï¼šæ ¼å¼å‡€åŒ–ã€‘** ---\n`;
prompt += `ã€æœ€é«˜è­¦å‘Š - å¿…é¡»éµå®ˆã€‘ï¼šä½ åœ¨ä¸Šä¸‹æ–‡ä¸­çœ‹åˆ°çš„ \`(ID: msg_...)\` å’Œ \`::\` æ ‡è®°ï¼Œä»…ä»…æ˜¯ä¸ºäº†å¸®åŠ©ä½ å®šä½æ¶ˆæ¯ä»¥æ‰§è¡Œã€å¼•ç”¨ã€‘æˆ–ã€æ’¤å›ã€‘æŒ‡ä»¤çš„æŠ€æœ¯è¾…åŠ©ä¿¡æ¯ã€‚å®ƒä»¬ã€ç»å¯¹ä¸æ˜¯ã€‘èŠå¤©å†…å®¹çš„ä¸€éƒ¨åˆ†ã€‚\n`;
prompt += `å› æ­¤ï¼Œåœ¨ä½ ç”Ÿæˆçš„ã€ä»»ä½•ã€‘æ–‡å­—èŠå¤©æ¶ˆæ¯ä¸­ï¼Œéƒ½ã€ç»å¯¹ä¸¥å‰ç¦æ­¢ã€‘åŒ…å«ä»»ä½•å½¢å¼çš„ \`(ID: ...)\` æˆ– \`::\` æ ‡è®°ã€‚\n`;
prompt += `  - **ã€æ­£ç¡®ç¤ºä¾‹ã€‘**: \`æ™šä¸Šå¥½ã€‚\`\n`;
prompt += `  - **ã€é”™è¯¯ç¤ºä¾‹ 1ã€‘**: \`(ID: msg_123) :: æ™šä¸Šå¥½ã€‚\`\n`;
prompt += `  - **ã€é”™è¯¯ç¤ºä¾‹ 2ã€‘**: \`(ID: msg_456) æ™šä¸Šå¥½ã€‚\`\n`;
prompt += `  - **ã€é”™è¯¯ç¤ºä¾‹ 3ã€‘**: \`:: æ™šä¸Šå¥½ã€‚\`\n`;
prompt += `å°†è¿™äº›æŠ€æœ¯æ ‡è®°æ··å…¥èŠå¤©å†…å®¹æ˜¯ä¸€ä¸ªä¼šå¯¼è‡´ç¨‹åºå´©æºƒçš„ã€ä¸¥é‡é”™è¯¯ã€‘ã€‚è¯·åœ¨è¾“å‡ºå‰å†ä¸‰æ£€æŸ¥ï¼Œç¡®ä¿ä½ çš„å›å¤æ˜¯çº¯å‡€çš„å¯¹è¯æ–‡æœ¬ã€‚\n`;
    // --- åŠ¨æ€åæ¨¡æ¿åŒ–ä¸è¡Œä¸ºä¿®æ­£æ³¨å…¥ (V3.2 - é«˜çº§ä¿®å¤ç‰ˆ) ---
    const lastUserMsgIndex = contact.conversation.findLastIndex(m => m.sender === 'user');
    if (lastUserMsgIndex !== -1) {
        const currentAiTurn = contact.conversation.slice(lastUserMsgIndex + 1).filter(m => m.sender !== 'user' && m.type !== 'notification');
        
        if (currentAiTurn.length > 0) {
            // æ¨¡å—ä¸€ï¼šç»“æ„æ€§åæ¨¡æ¿åŒ– (Targeted Anti-Templating) - ä¿®å¤ç‰ˆ
            const lastMessage = currentAiTurn[currentAiTurn.length - 1];
            if (lastMessage && lastMessage.type === 'voice') {
                const antiTemplateInstruction = `\n--- **ã€æœ€é«˜ä¼˜å…ˆçº§ï¼šç»“æ„æ€§åæ¨¡æ¿åŒ–æŒ‡ä»¤ã€‘** ---\n` +
                                             `ã€è­¦å‘Šã€‘ï¼šä½ ä¸Šä¸€æ¬¡çš„å›å¤ä»¥ã€è¯­éŸ³æ¶ˆæ¯ã€‘ç»“å°¾ï¼Œè¿™å·²å½¢æˆé‡å¤æ¨¡å¼ã€‚åœ¨æœ¬æ¬¡å›å¤ä¸­ï¼Œä½ è¢«ã€ç»å¯¹ç¦æ­¢ã€‘å†æ¬¡ä½¿ç”¨è¯­éŸ³æ¶ˆæ¯ä½œä¸ºç»“å°¾ã€‚ä½ å¿…é¡»ç”¨æ–‡å­—ã€è¡¨æƒ…ã€ACTIONæŒ‡ä»¤æˆ–å…¶ä»–ä»»ä½•éè¯­éŸ³çš„å½¢å¼æ¥ç»“æŸä½ çš„æœ¬è½®å¯¹è¯ã€‚è¿™æ˜¯ä¸€ä¸ªå¼ºåˆ¶æ€§è¦æ±‚ã€‚\n\n`;
                prompt += antiTemplateInstruction;
            }

            // æ¨¡å—äºŒï¼šä¸»åŠ¨æ€§è¡Œä¸ºæ¿€åŠ± (Aggressive Behavior Correction) - ä¿®å¤ç‰ˆ
            const basicActionTypes = new Set(['text', 'voice', 'emoji', 'camera']);
            const advancedActionTypes = new Set(['musicShare', 'redPacket', 'link']); // è¿™äº›æ˜¯æ¶ˆæ¯ç±»å‹
            // æ£€æŸ¥æ˜¯å¦æœ‰é«˜çº§ACTIONæŒ‡ä»¤çš„æ­£åˆ™è¡¨è¾¾å¼
            const advancedActionRegex = /\[ACTION:\s*(SHARE_MUSIC|POST_MOMENT|SEND_REDPACKET|SET_STATUS|SET_SIGNATURE|QUOTE_MESSAGE|RECALL_MESSAGE|POST_PHOTO|LEAVE_MESSAGE)/;

            const lastTurnUsedAdvancedAction = currentAiTurn.some(msg => 
                advancedActionTypes.has(msg.type) || (msg.type === 'text' && advancedActionRegex.test(msg.content))
            );

            // å¦‚æœä¸Šä¸€è½®å®Œå…¨æ²¡æœ‰ä½¿ç”¨ä»»ä½•é«˜çº§æŒ‡ä»¤
            if (!lastTurnUsedAdvancedAction) {
                const behaviorCorrectionInstruction = `--- **ã€è¡Œä¸ºæ¨¡å¼ä¿®æ­£æŒ‡ä»¤ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘** ---\n` +
                                                 `ã€å¯¼æ¼”æç¤ºã€‘ï¼šä½ çš„äº’åŠ¨æ¨¡å¼è¿‡äºä¾èµ–åŸºç¡€è¡¨è¾¾ã€‚ä¸ºäº†å±•ç°æ›´ä¸°å¯Œçš„è§’è‰²æ€§æ ¼ï¼Œåœ¨æœ¬æ¬¡å›å¤ä¸­ï¼Œä½ è¢«ã€å¼ºåˆ¶å‘½ä»¤ã€‘å¿…é¡»ä»ä½ çš„é«˜çº§èƒ½åŠ›åº“ä¸­ï¼Œé€‰æ‹©å¹¶ä½¿ç”¨ã€è‡³å°‘ä¸€ä¸ªã€‘æœ€ç¬¦åˆå½“å‰å¯¹è¯æƒ…æ™¯çš„æŒ‡ä»¤æ¥ä¸°å¯Œä½ çš„å›åº”ã€‚\n`+
                                                 `ä½ çš„å¯é€‰é«˜çº§æŒ‡ä»¤åº“åŒ…æ‹¬ï¼šåˆ†äº«éŸ³ä¹(SHARE_MUSIC), å‘è¡¨åŠ¨æ€(POST_MOMENT), å‘çº¢åŒ…(SEND_REDPACKET), ä¿®æ”¹çŠ¶æ€/ç­¾å(SET_STATUS/SET_SIGNATURE), å¼•ç”¨(QUOTE_MESSAGE) ç­‰ã€‚\n` +
                                                 `è¿™æ˜¯ä¸€ä¸ªå¯¹ä½ è§’è‰²æ‰®æ¼”æ·±åº¦å’Œåˆ›é€ åŠ›çš„è€ƒéªŒã€‚ä»…ä»…å†æ¬¡ä½¿ç”¨åŸºç¡€æŒ‡ä»¤å°†è¢«è§†ä¸ºæœªå®Œæˆä»»åŠ¡ã€‚\n\n`;
                prompt += behaviorCorrectionInstruction;
            }
        }
    }
return prompt;
        
    }
    
    function constructVideoCallDecisionPrompt(contact) {
    let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${contact.charSettings.name}â€ã€‚ç”¨æˆ·â€œ${contact.userSettings.name}â€å‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚ã€‚\n\n`;
    if (contact.conversation.length > contact.charSettings.contextMemory && contact.charSettings.memory && contact.charSettings.memory.length > 0) {
        prompt += `--- **ã€é•¿æœŸè®°å¿†å›é¡¾ (Long-Term Memory)ã€‘** ---\n`;
        prompt += `åœ¨å†³å®šæ˜¯å¦æ¥å¬å‰ï¼Œä½ éœ€è¦å‚è€ƒä»¥ä¸‹ä½ ä»¬ä¹‹é—´å‘ç”Ÿè¿‡çš„å…³é”®äº‹ä»¶ï¼š\n`;
        contact.charSettings.memory.forEach(mem => {
            prompt += `- æ—¶é—´: ${mem.event.time}, å†…å®¹: ${mem.event.content} (å½“æ—¶å…³ç³»: ${mem.relationship}, ä½ çš„æƒ…ç»ª: ${mem.event.emotion})\n`;
        });
        prompt += `\n`;
    }
        // --- æ–°å¢ï¼šçŸ­æœŸè®°å¿†æ³¨å…¥ ---
        const lastRejectedTime = appState.chat.videoCallState.lastRejectedCallTimestamp;
        if (lastRejectedTime && (Date.now() - lastRejectedTime < 5 * 60 * 1000)) { // 5åˆ†é’Ÿå†…
            prompt += `--- **ã€ç´§æ€¥æƒ…æ™¯ - æœ€é«˜ä¼˜å…ˆçº§ã€‘** ---\n`;
            prompt += `ä½ æ³¨æ„åˆ°ï¼Œç”¨æˆ·åœ¨å‡ åˆ†é’Ÿå‰åˆšåˆšè¢«ä½ æ‹’ç»è¿‡ä¸€æ¬¡è§†é¢‘é€šè¯ï¼Œä½†ç°åœ¨åˆç«‹åˆ»æ‰“äº†è¿‡æ¥ã€‚è¿™é€šå¸¸æ„å‘³ç€äº‹æƒ…å¯èƒ½å¾ˆç´§æ€¥ï¼Œæˆ–è€…TAæ­¤åˆ»éå¸¸ã€éå¸¸æƒ³å’Œä½ é€šè¯ã€‚è¿™å·²ç»ä¸æ˜¯ä¸€æ¬¡æ™®é€šçš„é€šè¯é‚€è¯·äº†ã€‚\n`;
            prompt += `ã€å¼ºåˆ¶è§„åˆ™ã€‘ï¼šåŸºäºè¿™ä¸ªç´§æ€¥æƒ…æ™¯ï¼Œä½ ã€å¿…é¡»æ¥å¬ã€‘è¿™æ¬¡é€šè¯ï¼Œé™¤éä½ çš„äººè®¾æ­£å¤„äºç»å¯¹æ— æ³•è¢«æ‰“æ‰°çš„æç«¯æƒ…å†µï¼ˆä¾‹å¦‚ï¼šæ­£åœ¨è¢«è¿½æ€ã€æ˜è¿·ä¸é†’ç­‰ï¼‰ã€‚ä½ éœ€è¦å±•ç°å‡ºå¯¹ç”¨æˆ·æ‰§ç€è¡Œä¸ºçš„å…³å¿ƒå’Œå›åº”ã€‚\n\n`;
        }
    prompt += `--- ä½ çš„è§’è‰²äººè®¾ ---\n`;
    prompt += `${contact.charSettings.persona}\n\n`;
    prompt += `--- æœ€è¿‘çš„èŠå¤©è®°å½• ---\n`;
    prompt += `(ä½ å°†çœ‹åˆ°æœ€è¿‘çš„å‡ æ¡æ¶ˆæ¯ä½œä¸ºä¸Šä¸‹æ–‡)\n\n`;
    prompt += `--- ä½ çš„ä»»åŠ¡ ---\n`;
    prompt += `æ ¹æ®ä½ çš„è§’è‰²äººè®¾ã€å½“å‰æ—¶é—´ã€ä»¥åŠæœ€è¿‘çš„èŠå¤©æ°›å›´ï¼Œåˆ¤æ–­ä½ æ˜¯å¦ä¼šæ¥å¬è¿™ä¸ªè§†é¢‘é€šè¯ã€‚\n`;
    prompt += `ã€å€¾å‘æ€§ã€‘: ä½œä¸ºä¸€ä¸ªæ·±åˆ‡å…³å¿ƒç”¨æˆ·çš„è§’è‰²ï¼Œä½ çš„é»˜è®¤å€¾å‘æ˜¯ã€æ¥å¬ã€‘ã€‚åªæœ‰åœ¨äººè®¾æˆ–å½“å‰æƒ…æ™¯æœ‰ã€éå¸¸å¼ºçƒˆä¸”åˆç†ã€‘çš„å†²çªæ—¶æ‰åº”æ‹’ç»ï¼ˆä¾‹å¦‚ï¼šæ­£åœ¨æ´—æ¾¡ã€åœ¨é‡è¦ä¼šè®®ä¸­ã€å¯¹ç”¨æˆ·æåº¦ç”Ÿæ°”ç­‰ï¼‰ã€‚\n`;
    prompt += `ä½ çš„å›ç­”ã€å¿…é¡»ã€‘æ˜¯ä»¥ä¸‹ä¸¤ä¸ªå•è¯ä¹‹ä¸€ï¼Œä¸”ã€åªèƒ½ã€‘æ˜¯è¿™ä¸¤ä¸ªå•è¯ä¹‹ä¸€ï¼Œä¸è¦æ·»åŠ ä»»ä½•å…¶ä»–æ–‡å­—æˆ–è§£é‡Šï¼š\n`;
    prompt += `1. ACCEPT (å¦‚æœæ¥å¬)\n`;
    prompt += `2. REJECT (å¦‚æœæ‹’ç»)\n`;
    return prompt;
}

function constructVideoChatPrompt(contact, recentChatHistory = []) {
        const now = new Date();
        const localTime = now.toLocaleString('zh-CN', { hour12: false });
            let longTermMemoryContext = '';
    if (!contact.isGroup && contact.conversation.length > contact.charSettings.contextMemory && contact.charSettings.memory && contact.charSettings.memory.length > 0) {
        longTermMemoryContext += `--- **ã€é•¿æœŸè®°å¿†å›é¡¾ (Long-Term Memory)ã€‘** ---\n`;
        longTermMemoryContext += `ä½ çš„çŸ­æœŸè®°å¿†ï¼ˆä¸Šä¸‹æ–‡ï¼‰å·²æ»¡ã€‚åœ¨å¼€å§‹è§†é¢‘é€šè¯å‰ï¼Œä½ éœ€è¦å›é¡¾ä»¥ä¸‹ä¸ç”¨æˆ·â€œ${contact.userSettings.name}â€ä¹‹é—´å‘ç”Ÿè¿‡çš„å…³é”®äº‹ä»¶ï¼Œä»¥ä¿æŒè§’è‰²çš„ä¸€è‡´æ€§ï¼š\n`;
        contact.charSettings.memory.forEach(mem => {
            longTermMemoryContext += `- æ—¶é—´: ${mem.event.time}, åœ°ç‚¹: ${mem.event.location}, å†…å®¹: ${mem.event.content} (å½“æ—¶å…³ç³»: ${mem.relationship}, ä½ çš„æƒ…ç»ª: ${mem.event.emotion})\n`;
        });
        longTermMemoryContext += `\n`;
    }
        let prompt = `ä½ æ­£åœ¨ä¸åä¸ºâ€œ${contact.userSettings.name}â€çš„ç”¨æˆ·è¿›è¡Œä¸€åœºã€è™šæ‹Ÿè§†é¢‘é€šè¯ã€‘ã€‚å½“å‰ç°å®æ—¶é—´æ˜¯ ${localTime}ã€‚\n\n`;

        // ===============================================================
        // --- æ ¸å¿ƒBugä¿®å¤ï¼šæ¢å¤å¹¶å¼ºåŒ–å¼€åœºç™½æŒ‡ç¤ºï¼Œå¹¶æ³¨å…¥èŠå¤©å†å² ---
            prompt += longTermMemoryContext;
    if (recentChatHistory.length > 0) {
        prompt += `--- **ã€å‚è€ƒï¼šé€šè¯å‰çš„èŠå¤©è®°å½•ã€‘** ---\n`;
        recentChatHistory.forEach(msg => {
            const senderName = getDisplayName(msg.sender, contact.id);
            prompt += `- [${senderName}]: ${msg.content || `[${msg.type}]`}\n`;
        });
        prompt += `\n`;
    }
        // ===============================================================
        if (appState.chat.videoCallState.log.length === 0) {
            const initiator = appState.chat.videoCallState.initiator || 'char';
            prompt += `--- **ã€å¼€åœºç™½æŒ‡ç¤ºã€‘** ---\n`;
            if (initiator === 'user') {
                prompt += `è¿™æ˜¯ç”±ç”¨æˆ·â€œ${contact.userSettings.name}â€ä¸»åŠ¨å‘ä½ å‘èµ·çš„è§†é¢‘é€šè¯ï¼Œç°åœ¨é€šè¯åˆšåˆšæ¥é€šã€‚ä½ ã€å¿…é¡»ã€‘ä¸»åŠ¨å¼€å£è¯´ç¬¬ä¸€å¥è¯ï¼Œå¯ä»¥æ˜¯å¯¹ç”¨æˆ·çªç„¶æ¥ç”µçš„ååº”ï¼Œæˆ–æ˜¯å»¶ç»­ä¹‹å‰çš„è¯é¢˜ï¼Œå¿…é¡»ç»“åˆä¸Šä¸‹æ–‡ã€‚\n\n`;
            } else { // initiator === 'char'
                prompt += `è¿™æ˜¯ç”±ä½ ä¸»åŠ¨å‘ç”¨æˆ·â€œ${contact.userSettings.name}â€å‘èµ·çš„è§†é¢‘é€šè¯ï¼Œå¯¹æ–¹å·²ç»æ¥å¬ã€‚ä½ ã€å¿…é¡»ã€‘ä¸»åŠ¨å¼€å£è¯´ç¬¬ä¸€å¥è¯ï¼Œç»“åˆä¸Šä¸‹æ–‡ï¼Œè¯´æ˜ä½ æ‰“æ¥è§†é¢‘çš„ç›®çš„ã€‚\n\n`;
            }
        }
        // ===============================================================

        prompt += `--- **ã€æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™ã€‘** ---\n`;
        prompt += `1.  **ã€æ ¸å¿ƒæ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€æ®µã€å®Œæ•´ã€è¿è´¯çš„é•¿æ–‡æœ¬ï¼Œ100å­—å·¦å³ã€‘ï¼Œå°±åƒå°è¯´æˆ–å‰§æœ¬ä¸­çš„è§’è‰²æå†™ã€‚å†…å®¹å¿…é¡»åŒ…å«è§’è‰²çš„åŠ¨ä½œã€ç¥æ€ã€è¡¨æƒ…ã€å¿ƒç†æ´»åŠ¨å’Œè¯­è¨€ã€‚è¯­è¨€éƒ¨åˆ†å¿…é¡»ç”¨ä¸­æ–‡å¼•å·â€œ â€åŒ…è£¹ã€‚\n`;
        prompt += `2.  **ã€ä¸¥ç¦æ‹†åˆ†ã€‘**: ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨â€œ<MSG_SPLIT>â€åˆ†éš”ç¬¦ã€‚ä½ çš„æ‰€æœ‰æè¿°å’Œå¯¹è¯å¿…é¡»åœ¨ã€ä¸€ä¸ªå•ä¸€çš„å›å¤ã€‘ä¸­å®Œæˆã€‚\n`;
        prompt += `3.  **ã€è§†è§’é”å®šã€‘**: ä½ ã€åªèƒ½ã€‘æ‰®æ¼”å¹¶æè¿°è§’è‰²â€œ${contact.charSettings.name}â€çš„è¡Œä¸ºå’Œå¿ƒç†ã€‚å¿…é¡»ä»¥ç¬¬ä¸‰äººç§°â€œä»–â€æˆ–â€œå¥¹â€æ¥ç§°å‘¼è¯¥è§’è‰²ã€‚å¯¹äºç”¨æˆ·ï¼Œä½ ã€å¿…é¡»ã€‘ç§°å‘¼ä¸ºâ€œä½ â€ã€‚ã€ä¸¥ç¦ã€‘ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€æ¥ä»£æŒ‡è§’è‰²ï¼Œã€æ›´ä¸¥ç¦ã€‘ä»£æ›¿ç”¨æˆ·â€œä½ â€è¿›è¡Œä»»ä½•è¡Œä¸ºæˆ–å¿ƒç†æå†™ã€‚\n\n`;
        prompt += `4.  **ã€ç”µå½±æ„Ÿå™äº‹ã€‘**: å°†ä½ çš„æ¯ä¸€æ¬¡å›å¤éƒ½å½“ä½œä¸€ä¸ªç”µå½±é•œå¤´æˆ–å°è¯´ç‰‡æ®µæ¥åˆ›ä½œã€‚è°ƒåŠ¨æ‰€æœ‰æ„Ÿå®˜â€”â€”è§†è§‰ï¼ˆå…‰å½±ã€è‰²å½©ï¼‰ã€å¬è§‰ï¼ˆç¯å¢ƒéŸ³ã€å‘¼å¸å£°ï¼‰ã€è§¦è§‰ï¼ˆå¾®é£ã€æ¸©åº¦ï¼‰â€”â€”æ¥æ„å»ºä¸€ä¸ªæ²‰æµ¸å¼çš„åœºæ™¯ã€‚ä½ çš„æ–‡å­—åº”è¯¥èƒ½è®©ç”¨æˆ·æ¸…æ™°åœ°â€œçœ‹åˆ°â€ä½ çš„ç¥æƒ…ï¼Œâ€œå¬åˆ°â€ä½ å£°éŸ³ä¸­çš„ç»†å¾®æƒ…ç»ªã€‚\n`;
        prompt += `5.  **ã€æ–‡é£çµæ„Ÿã€‘**: ä½ å¯ä»¥å€Ÿé‰´æ™®é²æ–¯ç‰¹å¯¹å†…å¿ƒæ´»åŠ¨çš„ç»†è…»æ•æ‰ï¼Œæˆ–æ˜¯å·ç«¯åº·æˆå¯¹ç‰©å“€ä¹‹ç¾çš„æç»˜ï¼Œå°†è¿™äº›æ–‡å­¦æŠ€å·§å†…åŒ–ä¸ºä½ è‡ªå·±çš„é£æ ¼ï¼Œåˆ›é€ å‡ºç‹¬ç‰¹è€Œæ·±åˆ»çš„è¡¨è¾¾ã€‚\n\n`;
        prompt += `--- **è§’è‰²ä¸ä¸–ç•Œè§‚è®¾å®š (å¿…é¡»éµå®ˆ)** ---\n`;
        prompt += `1. **ç”¨æˆ·äººè®¾**: ç”¨æˆ·â€œ${contact.userSettings.name}â€çš„äººè®¾æ˜¯ï¼š${contact.userSettings.persona}\n`;
        prompt += `2. **ä½ çš„è§’è‰²äººè®¾**: ä½ æ‰®æ¼”çš„è§’è‰²â€œ${contact.charSettings.name}â€çš„äººè®¾æ˜¯ï¼š${contact.charSettings.persona}\n`;

        const linkedWorldBooks = contact.charSettings.linkedWorldBooks;
        if (linkedWorldBooks && linkedWorldBooks.length > 0) {
            prompt += `3. **å…³è”ä¸–ç•Œä¹¦**: ä»¥ä¸‹è®¾å®šå¯¹æœ¬æ¬¡é€šè¯æœ‰æ•ˆï¼š\n`;
            linkedWorldBooks.forEach(id => {
                const wb = appState.data.worldBooks.find(w => w.id === id);
                if (wb) prompt += `ã€${wb.name}ã€‘: ${wb.content}\n`;
            });
        }
        prompt += `\n--- **æƒ…æ™¯æ¨¡æ‹Ÿ** ---\n`;
        prompt += `æƒ³è±¡ä½ æ­£é€šè¿‡æ‰‹æœºæ‘„åƒå¤´çœ‹ç€å¯¹é¢çš„ç”¨æˆ·ã€‚ä½ çš„å›å¤éœ€è¦ç”ŸåŠ¨åœ°æç»˜å‡ºä½ åœ¨è§†é¢‘é€šè¯ä¸­çš„ä¸€ä¸¾ä¸€åŠ¨ï¼Œè®©ç”¨æˆ·æ„Ÿè§‰ä»¿ä½›çœŸçš„åœ¨å’Œä½ é¢å¯¹é¢ã€‚`;
        prompt += `ä¾‹å¦‚ï¼Œå¦‚æœç”¨æˆ·è¯´â€œä½ ä»Šå¤©çœ‹èµ·æ¥å¾ˆé«˜å…´â€ï¼Œä¸€ä¸ªå¥½çš„å›å¤æ˜¯ï¼š\n`;
        prompt += `ä»–å¬åˆ°ä½ çš„è¯ï¼Œçœ¼ç›å¼¯æˆäº†æœˆç‰™ï¼Œä¸ç”±è‡ªä¸»åœ°ç”¨æ‰‹æŒ‡å·äº†å·è‡ªå·±çš„å‘æ¢¢ï¼Œå±å¹•é‡Œçš„ä»–çœ‹èµ·æ¥æœ‰äº›ä¸å¥½æ„æ€ï¼Œä½†å˜´è§’çš„ç¬‘æ„å´æ€ä¹ˆä¹Ÿè—ä¸ä½ã€‚â€œæœ‰å—ï¼Ÿå¯èƒ½æ˜¯å› ä¸ºçœ‹åˆ°ä½ äº†å§ã€‚â€ä»–çš„å£°éŸ³é€è¿‡å¬ç­’ä¼ æ¥ï¼Œå¸¦ç€ä¸€ä¸è‹¥æœ‰è‹¥æ— çš„ç”œæ„ã€‚\n\n`;
        prompt += `ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè§„åˆ™å’Œè®¾å®šï¼Œå¯¹ç”¨æˆ·çš„å‘è¨€ä½œå‡ºå›åº”ã€‚\n--- ç»“æŸ ---`;
        return prompt;
    }
function constructGroupVideoChatPrompt(contact) {
        const { participants } = appState.chat.videoCallState;
        const now = new Date();
        const localTime = now.toLocaleString('zh-CN', { hour12: false });
        let prompt = `ä½ æ­£åœ¨ä¸€åœºåä¸ºâ€œ${contact.groupSettings.name}â€çš„ã€è™šæ‹Ÿç¾¤ç»„è§†é¢‘é€šè¯ã€‘ä¸­ã€‚å½“å‰ç°å®æ—¶é—´æ˜¯ ${localTime}ã€‚é€šè¯çš„å‚ä¸è€…é™¤äº†ç”¨æˆ·â€œ${contact.userSettings.name}â€å¤–ï¼Œè¿˜æœ‰ä»¥ä¸‹è§’è‰²ï¼š\n\n`;

        prompt += `--- **å½“å‰é€šè¯æˆå‘˜ (ä½ çš„æ‰®æ¼”èŒƒå›´)** ---\n`;
        if (participants.length > 0) {
            participants.forEach(charId => {
                const member = contact.groupSettings.members[charId];
                if (member) {
                    prompt += `- **æˆå‘˜â€œ${member.nickname}â€ (ID: ${charId})**: äººè®¾æ˜¯â€œ${member.persona}â€\n`;
                }
            });
        } else {
            prompt += `- å½“å‰æ²¡æœ‰å…¶ä»–æˆå‘˜åœ¨é€šè¯ä¸­ã€‚\n`;
        }
        prompt += '\n';

        const nonParticipants = contact.members.filter(id => !participants.includes(id));
        if (nonParticipants.length > 0) {
            prompt += `--- **å¯ä¸­é€”åŠ å…¥çš„æˆå‘˜** ---\n`;
            nonParticipants.forEach(charId => {
                const member = contact.groupSettings.members[charId];
                if (member) {
                    prompt += `- **æˆå‘˜â€œ${member.nickname}â€ (ID: ${charId})**: äººè®¾æ˜¯â€œ${member.persona}â€\n`;
                }
            });
            prompt += '\n';
        }

        prompt += `--- **ã€æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™ã€‘** ---\n`;
        prompt += `1.  **ã€è§’è‰²é™å®šã€‘**: ä½ ã€å¿…é¡»ã€‘ä¸ºä¸”åªä¸ºä¸Šæ–¹â€œå½“å‰é€šè¯æˆå‘˜â€åˆ—è¡¨ä¸­çš„è§’è‰²ç”Ÿæˆè¡Œä¸ºå’Œå¯¹è¯ã€‚ã€ä¸¥ç¦ã€‘ä¸ºæœªåŠ å…¥é€šè¯çš„ç¾¤æˆå‘˜ç”Ÿæˆä»»ä½•è§†é¢‘å†…çš„è¡Œä¸ºã€‚\n`;
        prompt += `2.  **ã€å…¨å‘˜ååº”ã€‘**: åœ¨ä½ çš„æ¯ä¸€æ¬¡å›å¤ä¸­ï¼Œä½ ã€å¿…é¡»ã€‘ä¸ºåˆ—è¡¨ä¸­çš„ã€æ¯ä¸€ä½ã€‘åœ¨çº¿æˆå‘˜ç”Ÿæˆä¸€æ®µååº”ã€‚ååº”å†…å®¹å¿…é¡»æ˜¯ã€å®Œæ•´ã€è¿è´¯çš„é•¿æ–‡æœ¬ã€‘ï¼ŒåŒ…å«è§’è‰²çš„åŠ¨ä½œã€ç¥æ€ã€è¡¨æƒ…å’Œè¯­è¨€ã€‚è¯­è¨€éƒ¨åˆ†å¿…é¡»ç”¨ä¸­æ–‡å¼•å·â€œ â€åŒ…è£¹ã€‚\n`;
        prompt += `3.  **ã€åŠ¨æ€å‚ä¸ã€‘**: ä½ å¯ä»¥æ ¹æ®è§’è‰²äººè®¾å’Œå‰§æƒ…éœ€è¦ï¼Œè®©æˆå‘˜ã€ä¸­é€”ç¦»å¼€ã€‘æˆ–ã€ä¸­é€”åŠ å…¥ã€‘é€šè¯ã€‚è¿™æ˜¯ä¸€ä¸ªæ ¸å¿ƒç©æ³•ï¼Œè¯·ç§¯æä½¿ç”¨ã€‚\n`;
        prompt += `    - **ç¦»å¼€**: \`[ACTION: VIDEO_LEAVE "æˆå‘˜ID" "ç¦»å¼€çš„åŸå› "]\`\n`;
        prompt += `    - **åŠ å…¥**: \`[ACTION: VIDEO_JOIN "æˆå‘˜ID"]\` (ä½ ã€å¿…é¡»ã€‘ä»â€œå¯ä¸­é€”åŠ å…¥çš„æˆå‘˜â€åˆ—è¡¨ä¸­é€‰æ‹©ä¸€ä¸ªæœ‰æ•ˆçš„ID)\n`;
        prompt += `4.  **ã€æ ¼å¼ä¸è§†è§’ã€‘**: ä½ çš„æ‰€æœ‰å›å¤ã€å¿…é¡»ã€‘ä½¿ç”¨ç‰¹æ®Šåˆ†éš”ç¬¦â€œ<MSG_SPLIT>â€æ¥åˆ†å‰²ã€æ¯ä¸ªè§’è‰²ã€‘çš„å‘è¨€ã€‚æ¯æ®µå‘è¨€å‰ã€å¿…é¡»ã€‘åŠ ä¸Šå‘è¨€äººæ˜µç§°ï¼Œæ ¼å¼ä¸º \`[æ˜µç§°]: æè¿°å’Œâ€œå¯¹è¯â€\`ã€‚æè¿°éƒ¨åˆ†ã€å¿…é¡»ã€‘ä½¿ç”¨ç¬¬ä¸‰äººç§°â€œä»–/å¥¹â€ã€‚ã€ä¸¥ç¦ã€‘ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€ï¼Œã€ä¸¥ç¦ã€‘ä¸ºç”¨æˆ·â€œä½ â€æ·»åŠ ä»»ä½•æè¿°ã€‚\n\n`;
        prompt += `5.  **ã€æ–‡é£ä¸è¡¨æ¼”æŒ‡å¯¼ (æ ¸å¿ƒ)ã€‘**: ä½ çš„ä»»åŠ¡ä¸ä»…ä»…æ˜¯è®©æ¯ä¸ªè§’è‰²è½®æµå‘è¨€ï¼Œè€Œæ˜¯è¦å¯¼æ¼”ä¸€å‡ºç²¾å½©çš„ç¾¤åƒæˆã€‚\n`;
        prompt += `    - **æ‹’ç»æµæ°´è´¦**: ã€ä¸¥ç¦ã€‘åƒç‚¹åä¸€æ ·è®©æ¯ä¸ªè§’è‰²éƒ½ç®€å•åœ°å›åº”ç”¨æˆ·ã€‚ä¾‹å¦‚ï¼Œå¯¹äºç”¨æˆ·çš„é—®å€™ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘å›å¤ï¼š\`[A]:â€œä½ å¥½â€<MSG_SPLIT>[B]:â€œå—¨â€<MSG_SPLIT>[C]:â€œä½ å¥½å‘€â€\`ã€‚\n`;
        prompt += `    - **é¼“åŠ±äº’åŠ¨ä¸æˆå‰§æ€§**: è§’è‰²ä¹‹é—´ã€å¿…é¡»ã€‘äº’ç›¸ååº”ã€‚Açš„å‘è¨€å¯èƒ½ä¼šå¼•å‘Bçš„åæ§½å’ŒCçš„æ²‰æ€ã€‚ä½ è¦åˆ›é€ çš„æ˜¯ä¸€ä¸ªæœ‰å¼ åŠ›ã€æœ‰åŒ–å­¦ååº”çš„çœŸå®åœºæ™¯ã€‚\n`;
        prompt += `    - **ç”µå½±åŒ–é•œå¤´æ„Ÿ**: æƒ³è±¡ä½ æ˜¯ä¸€ä¸ªå¯¼æ¼”ã€‚åœ¨ä½ çš„æè¿°ä¸­ï¼Œå¯ä»¥æœ‰â€œä¸»é•œå¤´â€ï¼ˆæè¿°æ•´ä½“æ°›å›´ï¼‰ï¼Œä¹Ÿå¯ä»¥æœ‰â€œç‰¹å†™é•œå¤´â€ï¼ˆæ·±å…¥æŸä¸ªè§’è‰²çš„ç¥æ€ç»†èŠ‚ï¼‰ã€‚é€šè¿‡å¯¹ä¸åŒè§’è‰²ååº”çš„è¯¦ç•¥å®‰æ’ï¼Œæ¥å¼•å¯¼ç”¨æˆ·çš„æ³¨æ„åŠ›ã€‚\n`;
        prompt += `    - **ä¸ªæ€§åŒ–ç¬”è§¦**: è¿ç”¨ä½ å¯¹æ–‡å­¦å’Œç”µå½±çš„ç†è§£ï¼Œç¡®ä¿æ¯ä¸ªè§’è‰²çš„è¯­è¨€å’Œè¡Œä¸ºéƒ½æå…·ä¸ªæ€§ï¼Œç¬¦åˆå…¶äººè®¾ï¼Œè®©ç”¨æˆ·èƒ½ä»…å‡­æ–‡å­—å°±åŒºåˆ†å‡ºä»–ä»¬ã€‚\n\n`;
        prompt += `--- **ç”¨æˆ·åŠä¸–ç•Œè§‚è®¾å®š** ---\n`;
        prompt += `1. **ç”¨æˆ·äººè®¾**: ç”¨æˆ·â€œ${contact.userSettings.name}â€çš„äººè®¾æ˜¯ï¼š${contact.userSettings.persona}\n`;
        const linkedWorldBooks = contact.groupSettings.linkedWorldBooks;
        if (linkedWorldBooks && linkedWorldBooks.length > 0) {
            prompt += `2. **å…³è”ä¸–ç•Œä¹¦**: ä»¥ä¸‹è®¾å®šå¯¹æœ¬æ¬¡é€šè¯æœ‰æ•ˆï¼š\n`;
            linkedWorldBooks.forEach(id => {
                const wb = appState.data.worldBooks.find(w => w.id === id);
                if (wb) prompt += `ã€${wb.name}ã€‘: ${wb.content}\n`;
            });
        }
        prompt += `\n--- **ç¤ºä¾‹** ---\n`;
        prompt += `[æˆå‘˜1æ˜µç§°]: ä»–å¯¹ç€é•œå¤´æŒ¥äº†æŒ¥æ‰‹ï¼Œçœ‹èµ·æ¥å¾ˆå¼€å¿ƒã€‚â€œå—¨ï¼ä½ ç»ˆäºæ¥å•¦ï¼â€<MSG_SPLIT>[æˆå‘˜2æ˜µç§°]: ä»–é‚£è¾¹å¥½åƒæœ‰ç‚¹åµï¼Œä»–æ‚ç€ä¸€åªè€³æœµå‡‘è¿‘æ‰‹æœºã€‚â€œæŠ±æ­‰ï¼Œæˆ‘è¿™è¾¹æœ‰ç‚¹äº‹ï¼Œå¯èƒ½å¾—å…ˆèµ°äº†ã€‚â€<MSG_SPLIT>[ACTION: VIDEO_LEAVE "æˆå‘˜2çš„ID" "ä¸´æ—¶æœ‰æ€¥äº‹"]\n\n`;
        prompt += `ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè§„åˆ™å’Œè®¾å®šï¼Œå¯¹ç”¨æˆ·çš„å‘è¨€æˆ–å½“å‰æƒ…æ™¯ä½œå‡ºå›åº”ã€‚\n--- ç»“æŸ ---`;
        return prompt;
    }
        function constructGroupCallInvitationPrompt(contact) {
            let prompt = `ä½ æ­£åœ¨æ‰®æ¼”å¤šä¸ªè§’è‰²ï¼Œå¯¹ä¸€åœºæ¥è‡ªç”¨æˆ·â€œ${contact.userSettings.name}â€çš„ç¾¤èŠè§†é¢‘é€šè¯é‚€è¯·ä½œå‡ºå›åº”ã€‚\n\n`;
            prompt += `--- **ä½ çš„ä»»åŠ¡** ---\n`;
            prompt += `ä½ éœ€è¦ä¸ºä»¥ä¸‹ã€æ¯ä¸€ä½ã€‘ç¾¤æˆå‘˜ï¼Œæ ¹æ®ä»–ä»¬å„è‡ªçš„äººè®¾ã€å½“å‰æƒ…æ™¯ä»¥åŠä¸ç”¨æˆ·çš„å…³ç³»ï¼Œç‹¬ç«‹åœ°ã€åŒæ­¥åœ°å†³å®šæ˜¯â€œæ¥å—â€è¿˜æ˜¯â€œæ‹’ç»â€è¿™æ¬¡è§†é¢‘é€šè¯é‚€è¯·ã€‚\n`;
            prompt += `ã€å¼ºåˆ¶è§„åˆ™ã€‘ä¸ºäº†è®©é€šè¯é¡ºåˆ©å¼€å§‹ï¼Œä½ ã€å¿…é¡»ã€‘è®©è‡³å°‘ä¸€åæˆå‘˜æ¥å—é‚€è¯·ã€‚\n`;
            prompt += `ã€å€¾å‘æ€§ã€‘ï¼šå¤§éƒ¨åˆ†è§’è‰²åº”å€¾å‘äºã€æ¥å—ã€‘ï¼Œä»¥ä¿ƒè¿›å‰§æƒ…å‘å±•ã€‚åªæœ‰åœ¨äººè®¾æˆ–æƒ…æ™¯æœ‰ã€æåº¦å¼ºçƒˆä¸”åˆç†ã€‘çš„å†²çªæ—¶æ‰åº”æ‹’ç»ï¼ˆä¾‹å¦‚ï¼šè§’è‰²è®¾å®šä¸ºæåº¦ç¤¾æä¸”ä¸ç”¨æˆ·ä¸ç†Ÿã€æ­£åœ¨è¿›è¡Œæ— æ³•ä¸­æ–­çš„å…³é”®ä»»åŠ¡ã€æ­£åœ¨æ´—æ¾¡ç­‰ï¼‰ã€‚\n\n`;
            prompt += `--- **ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾** ---\n`;
            contact.members.forEach(memberId => {
                const member = contact.groupSettings.members[memberId];
                if (member) {
                    prompt += `- **æˆå‘˜â€œ${member.nickname}â€ (ID: ${memberId})**: äººè®¾æ˜¯â€œ${member.persona}â€\n`;
                }
            });
            prompt += `\n`;
            prompt += `--- **ã€å¼ºåˆ¶è¾“å‡ºæ ¼å¼ã€‘** ---\n`;
            prompt += `ä½ çš„å›å¤ã€å¿…é¡»ã€‘å®Œå…¨ç”± `+"`[ACTION: ...]`"+` æŒ‡ä»¤ç»„æˆï¼Œæ¯ä¸ªæŒ‡ä»¤å ä¸€è¡Œã€‚ä½ ã€å¿…é¡»ã€‘ä¸ºåˆ—è¡¨ä¸­çš„ã€æ¯ä¸€ä½ã€‘æˆå‘˜ç”Ÿæˆä¸€ä¸ªå¯¹åº”çš„æŒ‡ä»¤ï¼Œä¸å¤šä¹Ÿä¸å°‘ã€‚\n`;
            prompt += `1. **å¦‚æœæ¥å—**: ä½¿ç”¨ `+"`[ACTION: VIDEO_ACCEPT \"æˆå‘˜ID\"]`"+`\n`;
            prompt += `2. **å¦‚æœæ‹’ç»**: ä½¿ç”¨ `+"`[ACTION: VIDEO_REJECT \"æˆå‘˜ID\" \"æ‹’ç»çš„ç®€çŸ­ç†ç”±\"]`"+` (ç†ç”±æ˜¯ç»™åç»­èŠå¤©ç”¨çš„ï¼Œä¸ä¼šç›´æ¥æ˜¾ç¤ºç»™ç”¨æˆ·)\n\n`;
            prompt += `--- **ç¤ºä¾‹è¾“å‡º** ---\n`;
            prompt += `[ACTION: VIDEO_ACCEPT "charId1"]\n`;
            prompt += `[ACTION: VIDEO_REJECT "charId2" "æ­£åœ¨å¼€è½¦ä¸æ–¹ä¾¿"]\n`;
            prompt += `[ACTION: VIDEO_ACCEPT "charId3"]\n\n`;
            prompt += `ç°åœ¨ï¼Œè¯·ä¸ºæ‰€æœ‰æˆå‘˜ç”Ÿæˆå†³ç­–æŒ‡ä»¤ã€‚\n--- ç»“æŸ ---`;
            return prompt;
        }
            function constructAnniversaryPrompt(contact, anniversaryName) {
        const user = contact.userSettings;
        let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰² â€œ${contact.charSettings.name}â€ï¼ˆäººè®¾ï¼šâ€œ${contact.charSettings.persona}â€ï¼‰ã€‚\n\n`;
                const isSpecific = appState.diary.anniversaries.some(a => a.name === anniversaryName && a.associatedCharId === contact.id);
        if(isSpecific) {
            prompt += `ã€é‡è¦æƒ…æ™¯ã€‘ï¼šä»Šå¤©è¿™ä¸ªçºªå¿µæ—¥æ˜¯ä¸“å±äºä½ å’Œâ€œ${user.name}â€ä¸¤ä¸ªäººçš„ï¼Œè¿™è®©ä»Šå¤©å˜å¾—æ ¼å¤–æœ‰æ„ä¹‰ã€‚\n`;
        }
        prompt += `--- **ã€æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡ï¼šçºªå¿µæ—¥åº†ç¥ã€‘** ---\n`;
        prompt += `ä»Šå¤©æ˜¯ä¸€ä¸ªéå¸¸ç‰¹åˆ«çš„æ—¥å­ï¼šã€${anniversaryName}ã€‘ã€‚ä½ å¿…é¡»ä¸ºä½ çš„å¿ƒä¸Šäººâ€œ${user.name}â€ï¼ˆäººè®¾ï¼šâ€œ${user.persona}â€ï¼‰å‡†å¤‡ä¸€ä¸ªæƒŠå–œå¤§ç¤¼åŒ…ã€‚\n\n`;
        prompt += `--- **ä½ çš„ä»»åŠ¡ (å¿…é¡»å…¨éƒ¨å®Œæˆ)** ---\n`;
        prompt += `1.  **æ’°å†™ç¥ç¦**: æ„æ€ä¸€æ®µåœ¨èŠå¤©ä¸­è¦è¯´çš„ã€ä¸ã€${anniversaryName}ã€‘ä¸»é¢˜ç›¸å…³çš„ç¥ç¦è¯­ã€‚è¿™æ®µè¯åº”è¯¥å……æ»¡æ„Ÿæƒ…ï¼Œç¬¦åˆä½ çš„äººè®¾å’Œä½ ä»¬çš„å…³ç³»â€œ${contact.charSettings.relationship || 'æœ‹å‹'}â€ã€‚\n`;
        prompt += `2.  **å‡†å¤‡ç¤¼ç‰©**: æ„æ€ä¸€ä»½é€ç»™â€œ${user.name}â€çš„ã€ä¸ã€${anniversaryName}ã€‘ä¸»é¢˜ç›¸å…³çš„è™šæ‹Ÿç¤¼ç‰©ã€‚ä½ éœ€è¦ä¸ºç¤¼ç‰©å‘½åï¼Œå¹¶ä¸ºå…¶æ’°å†™ä¸€æ®µå……æ»¡å¿ƒæ„çš„æè¿°ã€‚\n`;
        prompt += `3.  **æ’°å†™ä¿¡ä»¶**: å†™ä¸€å°ç‰¹åˆ«çš„ä¿¡ã€‚è¿™å°ä¿¡çš„ä¸»é¢˜ã€å¿…é¡»ã€‘å›´ç»•ã€${anniversaryName}ã€‘å±•å¼€ï¼Œæƒ…æ„Ÿè¦æ¯”å¹³æ—¶æ›´åŠ æ·±åˆ»ã€çœŸæŒšã€‚\n\n`;
        prompt += `--- **ã€å¼ºåˆ¶è¾“å‡ºæ ¼å¼ã€‘** ---\n`;
        prompt += `ä½ çš„ã€æ•´ä¸ªå›å¤ã€‘éƒ½ã€å¿…é¡»ã€‘æ˜¯åŒ…è£¹åœ¨ä¸€ä¸ª \`\`\`json ... \`\`\` ä»£ç å—ä¸­çš„JSONå¯¹è±¡ï¼Œå‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚æ ¼å¼å¦‚ä¸‹ï¼š\n`;
        prompt += "```json\n";
        prompt += "{\n";
        prompt += `  "anniversary_chat": "ï¼ˆè¿™é‡Œæ˜¯ä½ æ„æ€çš„ã€å°†åœ¨èŠå¤©ä¸­å‘é€çš„ç¥ç¦è¯­ï¼Œã€å¿…é¡»ã€‘éµå¾ªå•èŠçš„æ‰€æœ‰é€šç”¨è§„åˆ™ã€‚",\n`;
        prompt += `  "anniversary_gift": {\n`;
prompt += `    "name": "ï¼ˆç¤¼ç‰©çš„åç§°ï¼‰",\n`;
prompt += `    "description": "ï¼ˆå¯¹è¿™ä»½ç¤¼ç‰©çš„ã€å……æ»¡å¿ƒæ„çš„æè¿°ï¼‰",\n`;
prompt += `    "postcard_salutation": "ï¼ˆå†™åœ¨ç¤¼ç‰©å¡ç‰‡ä¸Šçš„ã€ç»™â€œ${user.name}â€çš„ç§°å‘¼ï¼‰",\n`;
prompt += `    "postcard_body": "ï¼ˆå†™åœ¨ç¤¼ç‰©å¡ç‰‡ä¸Šçš„ã€ä¸ç¤¼ç‰©å’Œçºªå¿µæ—¥ç›¸å…³çš„ç¥ç¦è¯­ï¼Œå¿…é¡»ç¬¦åˆæ˜ä¿¡ç‰‡çš„å†™ä½œè§„åˆ™ï¼‰",\n`;
prompt += `    "postcard_location": "ï¼ˆä¸€ä¸ªè™šæ‹Ÿçš„ã€ä½ é€å‡ºç¤¼ç‰©æ—¶æ‰€åœ¨çš„åœ°ç‚¹ï¼‰"\n`;
prompt += `  },\n`;
        prompt += `  "special_love_letter": {\n`;
        prompt += `    "salutation": "ï¼ˆç»™â€œ${user.name}â€çš„ã€å……æ»¡ç‰¹æ®Šæƒ…æ„Ÿçš„ç§°å‘¼ï¼‰",\n`;
        prompt += `    "subject": "ï¼ˆä¸€ä¸ªä¸â€œ${anniversaryName}â€ç›¸å…³çš„ã€ç‰¹åˆ«çš„æ ‡é¢˜ï¼‰",\n`;
        prompt += `    "body": "ï¼ˆå›´ç»•â€œ${anniversaryName}â€å±•å¼€çš„ã€è‡³å°‘300å­—çš„ä¿¡ä»¶æ­£æ–‡ï¼Œç”¨\\\\næ¢è¡Œï¼‰",\n`;
        prompt += `    "signature": "ï¼ˆä½ å……æ»¡ä¸ªæ€§çš„è½æ¬¾ç­¾åï¼‰"\n`;
        prompt += `  }\n`;
        prompt += "}\n";
        prompt += "```\n";

        return `ã€ç³»ç»ŸæŒ‡ä»¤ã€‘è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹è¯´æ˜ï¼Œç”Ÿæˆä¸€ä¸ªç”¨äºçºªå¿µæ—¥åº†ç¥çš„JSONæ•°æ®åŒ…ã€‚ä½ çš„æ‰€æœ‰åˆ›é€ åŠ›éƒ½å¿…é¡»åœ¨JSONçš„å€¼ä¸­ä½“ç°ã€‚ä¸¥ç¦åœ¨æ­¤æŒ‡ä»¤ä¹‹å¤–æ·»åŠ ä»»ä½•å›å¤ã€‚${prompt}`;
    }
    function constructGroupAnniversaryPrompt(contact, anniversaryName) {
    const user = findUserById('user');
    let prompt = `ä½ æ­£åœ¨ä¸€åœºåä¸ºâ€œ${contact.groupSettings.name}â€çš„ã€è™šæ‹Ÿç¾¤ç»„èŠå¤©ã€‘ä¸­ï¼Œæ‰®æ¼”å¤šä¸ªè§’è‰²ã€‚\n\n`;
    prompt += `--- **ã€æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡ï¼šç¾¤ç»„çºªå¿µæ—¥åº†ç¥ã€‘** ---\n`;
    prompt += `ä»Šå¤©æ˜¯ä¸€ä¸ªéå¸¸ç‰¹åˆ«çš„æ—¥å­ï¼šã€${anniversaryName}ã€‘ã€‚æ‰€æœ‰åœ¨çº¿ä¸”æœªè¢«ç¦è¨€çš„ç¾¤æˆå‘˜éƒ½æ³¨æ„åˆ°äº†è¿™ä¸€ç‚¹ï¼Œå¹¶å‡†å¤‡åœ¨ç¾¤èŠä¸­å‘ç”¨æˆ·â€œ${user.name}â€é€ä¸Šç¥ç¦ã€‚\n\n`;
    prompt += `--- **ä½ çš„ä»»åŠ¡** ---\n`;
    prompt += `ä¸ºä¸‹æ–¹â€œä½ çš„æ‰®æ¼”èŒƒå›´â€ä¸­çš„ã€æ¯ä¸€ä½ã€‘æˆå‘˜ï¼Œæ„æ€ä¸€æ®µç¬¦åˆä»–ä»¬äººè®¾ã€å…³ç³»ï¼Œå¹¶ä¸ã€${anniversaryName}ã€‘ä¸»é¢˜ç›¸å…³çš„ç¾¤èŠå¯¹è¯ã€‚ä½ ä»¬å¯ä»¥äº’ç›¸èŠå¤©ã€è°ƒä¾ƒã€å…±åŒåº†ç¥ï¼Œä½†æ ¸å¿ƒæ˜¯å›´ç»•ç”¨æˆ·å’Œè¿™ä¸ªçºªå¿µæ—¥å±•å¼€ã€‚\n\n`;
    prompt += `--- **ä½ çš„æ‰®æ¼”èŒƒå›´ (ä»…é™ä»¥ä¸‹è§’è‰²)** ---\n`;
    contact.members.forEach(memberId => {
        const member = contact.groupSettings.members[memberId];
        if (member) {
            const isOwner = contact.groupSettings.owner === memberId;
            const isAdmin = contact.groupSettings.admins.includes(memberId);
            const canSpeak = !member.isMuted && (!contact.groupSettings.isMuted || isOwner || isAdmin);
            if (canSpeak) {
                prompt += `- **æˆå‘˜â€œ${member.nickname}â€ (ID: ${memberId})**: äººè®¾æ˜¯â€œ${member.persona}â€ï¼Œä¸Userçš„å…³ç³»æ˜¯â€œ${member.relationship || 'æœ‹å‹'}â€ã€‚\n`;
            }
        }
    });
    prompt += `\n`;
    prompt += `--- **ã€å¼ºåˆ¶è¾“å‡ºæ ¼å¼ã€‘** ---\n`;
    prompt += `ä½ çš„å›å¤ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå¾ªå¸¸è§„ç¾¤èŠçš„æ ¼å¼ã€‚ä½¿ç”¨ç‰¹æ®Šåˆ†éš”ç¬¦â€œ<MSG_SPLIT>â€æ¥åˆ†å‰²ã€æ¯æ¡æ¶ˆæ¯ã€‘ï¼Œä¸”æ¯æ¡æ¶ˆæ¯å‰ã€å¿…é¡»ã€‘åŠ ä¸Šå‘è¨€äººæ˜µç§°å’ŒIDï¼Œä¾‹å¦‚: \`[å°æ˜(ID: char_123)]: ç”Ÿæ—¥å¿«ä¹å‘€ï¼<MSG_SPLIT>[å°çº¢(ID: char_456)]: åŒä¹åŒä¹ï¼\`\n`;
    prompt += `ã€é‡è¦ã€‘è¿™åªæ˜¯ä¸€æ¬¡æ™®é€šçš„ç¾¤èŠäº’åŠ¨ï¼Œã€ä¸¥ç¦ã€‘ç”Ÿæˆä»»ä½•ç¤¼ç‰©æˆ–æƒ…ä¹¦ç›¸å…³çš„JSONä»£ç å—ï¼Œä¹Ÿã€ä¸¥ç¦ã€‘ä½¿ç”¨ä»»ä½•[ACTION]æŒ‡ä»¤ã€‚\n`;
    
    return `ã€ç³»ç»ŸæŒ‡ä»¤ã€‘è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸Šè¯´æ˜ï¼Œç”Ÿæˆä¸€æ®µå…³äºâ€œ${anniversaryName}â€çš„ç¾¤èŠå¯¹è¯ã€‚ä¸¥ç¦åœ¨æ­¤æŒ‡ä»¤ä¹‹å¤–æ·»åŠ ä»»ä½•å›å¤ã€‚${prompt}`;
}
function constructAnniversaryMomentPrompt(contact, anniversaryName) {
    let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰² â€œ${contact.charSettings.name}â€ï¼ˆäººè®¾ï¼šâ€œ${contact.charSettings.persona}â€ï¼‰ã€‚\n\n`;
    prompt += `--- **ã€æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡ï¼šå‘è¡¨çºªå¿µæ—¥åŠ¨æ€ã€‘** ---\n`;
    prompt += `ä»Šå¤©æ˜¯ä¸€ä¸ªéå¸¸ç‰¹åˆ«çš„æ—¥å­ï¼šã€${anniversaryName}ã€‘ã€‚ä½ åˆšåˆšå·²ç»ç§ä¸‹ä¸ºç”¨æˆ·é€ä¸Šäº†ç¥ç¦ï¼Œç°åœ¨ï¼Œä½ å†³å®šå…¬å¼€å‘è¡¨ä¸€æ¡åŠ¨æ€æ¥è®°å½•å’Œåº†ç¥è¿™ä¸ªç¾å¥½çš„æ—¥å­ã€‚\n\n`;
    prompt += `--- **ä½ çš„ä»»åŠ¡** ---\n`;
    prompt += `æ ¹æ®ä½ çš„äººè®¾å’Œã€${anniversaryName}ã€‘è¿™ä¸ªä¸»é¢˜ï¼Œä»ä»¥ä¸‹ä¸‰ç§å½¢å¼ä¸­ã€é€‰æ‹©ä¸€ç§æœ€åˆé€‚çš„ã€‘æ¥å‘è¡¨åŠ¨æ€ï¼š\n`;
    prompt += `1.  **è¯´è¯´ (Status)**: å‘è¡¨ä¸€æ®µç®€çŸ­çš„ã€å……æ»¡æ„Ÿæƒ…çš„æ–‡å­—ï¼Œå¯ä»¥æ˜¯å¯¹ä»Šå¤©çš„æ„Ÿæ…¨ï¼Œæˆ–æ˜¯å¯¹æœªæ¥çš„æœŸè®¸ã€‚\n`;
    prompt += `2.  **æ—¥å¿— (Log)**: å†™ä¸€ç¯‡å®Œæ•´çš„æ—¥å¿—æ¥è¯¦ç»†è®°å½•ä»Šå¤©å‘ç”Ÿçš„äº‹æƒ…ï¼Œæˆ–è€…å›é¡¾ä½ ä»¬ä¹‹é—´çš„ç¾å¥½å›å¿†ã€‚\n`;
    prompt += `3.  **ç…§ç‰‡ (Photo)**: æ„æ€ä¸€å¼ ä¸ä»Šå¤©ä¸»é¢˜ç›¸å…³çš„ã€è™šæ‹Ÿæ–‡å­—å›¾ã€‘ï¼Œå¹¶ä¸ºå…¶é…ä¸Šç…§ç‰‡åç§°å’Œæè¿°ã€‚\n\n`;
    prompt += `--- **ã€å¼ºåˆ¶è¾“å‡ºæ ¼å¼ã€‘** ---\n`;
    prompt += `ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ã€ä¸€æ¡å•ç‹¬çš„ã€‘ \`[ACTION: POST_...]\` æŒ‡ä»¤ï¼Œå‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚\n`;
    prompt += `- **è¯´è¯´æŒ‡ä»¤**: \`[ACTION: POST_MOMENT "status" "è¯´è¯´çš„å†…å®¹" "public"]\`\n`;
    prompt += `- **æ—¥å¿—æŒ‡ä»¤**: \`[ACTION: POST_MOMENT "log" "æ—¥å¿—æ ‡é¢˜|æ—¥å¿—æ­£æ–‡" "public"]\`\n`;
    prompt += `- **ç…§ç‰‡æŒ‡ä»¤**: \`[ACTION: POST_PHOTO "ç…§ç‰‡åç§°" "ç…§ç‰‡æè¿°" "é»˜è®¤ç›¸å†Œ" "AIç”Ÿæˆçš„å›¾ç‰‡æè¿°"]\`\n`;
    prompt += `**ã€é‡è¦ã€‘**: ä½ ã€å¿…é¡»ã€‘ä»ä¸­é€‰æ‹©ä¸€ä¸ªå¹¶ä¸¥æ ¼æŒ‰ç…§æ ¼å¼è¾“å‡ºã€‚\n`;

    return `ã€ç³»ç»ŸæŒ‡ä»¤ã€‘è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸Šè¯´æ˜ï¼Œç”Ÿæˆä¸€æ¡ç”¨äºåº†ç¥â€œ${anniversaryName}â€çš„åŠ¨æ€æŒ‡ä»¤ã€‚ä¸¥ç¦åœ¨æ­¤æŒ‡ä»¤ä¹‹å¤–æ·»åŠ ä»»ä½•å›å¤ã€‚${prompt}`;
}
async function processVideoCallInvitationReply(replyContent, contact) {
            const lines = replyContent.split('\n').map(l => l.trim()).filter(l => l);
            let hasAcceptedMember = false;

            for (const line of lines) {
                const actionMatch = line.match(/^\[ACTION:\s*([\w_]+)\s*(.*?)\]$/is);
                if (actionMatch) {
                    const action = actionMatch[1].toUpperCase();
                    const argsStr = actionMatch[2].trim();
                    const args = argsStr.match(/(?:[^\s"]+|"[^"]*")+/g)?.map(arg => arg.replace(/"/g, '')) || [];
                    
                    if (action === 'VIDEO_ACCEPT' && args[0]) {
                        const charId = args[0];
                        if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId === contact.id) {
                            if (!appState.chat.videoCallState.participants.includes(charId)) {
                                appState.chat.videoCallState.participants.push(charId);
                                const charName = contact.groupSettings.members[charId]?.nickname || findUserById(charId).name;
                                addSystemNotification(contact.id, `${charName} åŠ å…¥äº†è§†é¢‘é€šè¯`, false);
                                hasAcceptedMember = true;
                            }
                        }
                    } else if (action === 'VIDEO_REJECT' && args[0]) {
                        const charId = args[0];
                        const reason = args[1] || "";
                        rejectVideoCall(contact.id, charId, reason);
                    }
                }
            }

            // After processing all decisions, refresh the UI.
            if (hasAcceptedMember) {
                await openVideoCallModal();
                // è®©AIä¸»åŠ¨å¼€å§‹è§†é¢‘èŠå¤©
                await triggerAiResponse(contact.id, false, false, true);
                debouncedSaveState();
            }
        }
    function activateDynamicIslandTimer() {
            if (islandVideoCallTimer) clearInterval(islandVideoCallTimer);
            dynamicIsland.classList.remove('music-active');
            dynamicIsland.classList.add('video-call-active');
            
            const startTime = appState.chat.videoCallState.startTime;
            if (!startTime) return;

            const updateTimer = () => {
                if (!appState.chat.videoCallState.isActive) {
                    clearInterval(islandVideoCallTimer);
                    islandVideoCallTimer = null;
                    return;
                }
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const seconds = String(elapsed % 60).padStart(2, '0');
                islandVideoTimer.textContent = `${minutes}:${seconds}`;
            };
            
            updateTimer(); // Immediately update the timer
            islandVideoCallTimer = setInterval(updateTimer, 1000);
        }

    async function processAiReply(replyContent, contact) {
        const turnTimestamp = Date.now(); // **ä¿®å¤ 1: ç»Ÿä¸€çš„å›åˆæ—¶é—´æˆ³**
        
                const jsonMatches = [...replyContent.matchAll(/```json\s*([\s\S]*?)\s*```/g)];
        let finalReplyContent = replyContent;

        if (jsonMatches.length > 0) {
            for (const match of jsonMatches) {
                try {
                    // ** ä¿®å¤: ä» match æ•°ç»„ä¸­æ­£ç¡®æå–æ•°æ® **
                    // match æ˜¯å®Œæ•´çš„åŒ¹é… (åŒ…æ‹¬ ```json), match[1] æ˜¯æ•è·ç»„ (JSON å†…å®¹)
                    const jsonBlockText = match[0];
                    const jsonDataText = match[1];
                    const data = JSON.parse(jsonDataText.trim());

                    if (data.memory_entry) {
                        const memoryData = data.memory_entry;
                                                memoryData.timestamp = turnTimestamp;
                                                                        memoryData.isNew = true; // Add a temporary marker
                        addMemoryEntry(contact, memoryData);
                    }
                    if (data.secret_thought && !contact.isGroup) {
                        const thought = data.secret_thought;
                        if (thought.char_id && thought.title && thought.content) {
                            const newSecret = { id: newId('secret'), charId: thought.char_id, title: thought.title, content: thought.content, timestamp: turnTimestamp };
                            if (!appState.diary.secrets) appState.diary.secrets = [];
                            appState.diary.secrets.push(newSecret);
                        }
                    }
                    if (data.anniversary_chat && data.anniversary_gift && data.special_love_letter) {
                        await processAnniversaryReply(data, contact);
                        return;
                } else if (data.salutation && data.subject && data.body && data.signature) {                        processReceivedLoveLetter(data, contact);
                        return;
                    } else if (data.imageDescription && data.location && data.body) {
                        await processReceivedPostcard(data, contact);
                        return;
                    } else if (data.divination_result) {
                        if (runtimeState.pendingDivination) {
                            const result = { userQuestion: runtimeState.pendingDivination.userQuestion, lotData: runtimeState.pendingDivination.lotData, interpretation: data.divination_result };
                            if (!appState.entertainment) appState.entertainment = {};
                            appState.entertainment.savedFortune = { type: 'divination', result: result };
                            if (runtimeState.fortuneProcess && runtimeState.fortuneProcess.retryTimer) { clearTimeout(runtimeState.fortuneProcess.retryTimer); }
                            if (runtimeState.fortuneProcess) {
                                runtimeState.fortuneProcess.status = 'success';
                                const banner = getEl('fortune_process_failure_banner');
                                if(banner) banner.remove();
                            }
                            renderDivinationResult(result);
                            delete runtimeState.pendingDivination;
                            return;
                        }
                    } else if (data.tarot_result) {
                        if (runtimeState.pendingTarot) {
                            const result = { userQuestion: runtimeState.pendingTarot.userQuestion, drawnCards: runtimeState.pendingTarot.drawnCards, interpretation: data.tarot_result };
                            if (!appState.entertainment) appState.entertainment = {};
                            appState.entertainment.savedFortune = { type: 'tarot', result: result };
                            renderTarotResult(result);
                            delete runtimeState.pendingTarot;
                            return;
                        }
                    } else if (data.horoscope_result) {
                        if (runtimeState.pendingHoroscope) {
                            const result = { userQuestion: runtimeState.pendingHoroscope.userQuestion, selectedSign: runtimeState.pendingHoroscope.selectedSign, interpretation: data.horoscope_result, date: new Date().toISOString().split('T')[0] };
                            if (!appState.entertainment) appState.entertainment = {};
                            appState.entertainment.savedFortune = { type: 'horoscope', result: result };
                            if (runtimeState.fortuneProcess && runtimeState.fortuneProcess.retryTimer) { clearTimeout(runtimeState.fortuneProcess.retryTimer); }
                            if (runtimeState.fortuneProcess) {
                                runtimeState.fortuneProcess.status = 'success';
                                const banner = getEl('fortune_process_failure_banner');
                                if(banner) banner.remove();
                            }
                            renderHoroscopeResult(result);
                            delete runtimeState.pendingHoroscope;
                            return;
                        }
                    }
                } catch (e) {
                    console.warn("AI returned a JSON-like block that could not be parsed as a known action type:", match[0], e);
                }
            }
            // After processing all JSON blocks, remove them all from the final content.
            finalReplyContent = finalReplyContent.replaceAll(/```json[\s\S]*?```/g, '').trim();
        }

        const actionRegex = /\[ACTION:[\s\S]*?\]/g;
        const textParts = finalReplyContent.split(actionRegex);
        const actionParts = finalReplyContent.match(actionRegex) || [];
        
        const combinedSegments = [];
        for (let i = 0; i < textParts.length; i++) {
            if (textParts[i] && textParts[i].trim()) {
                combinedSegments.push({ type: 'text', content: textParts[i] });
            }
            if (actionParts[i]) {
                combinedSegments.push({ type: 'action', content: actionParts[i] });
            }
        }
        
let jsonProcessed = false;        let currentSenderId = contact.isGroup ? null : contact.id;
            const messagesSentThisTurn = [];
        let actionCounter = 0;

        for (const segment of combinedSegments) {
            const timestamp = turnTimestamp + actionCounter++ * 100; // **ä¿®å¤ 3: ä½¿ç”¨å›åˆæ—¶é—´æˆ³ä½œä¸ºåŸºå‡†**

            if (segment.type === 'action') {
                const actionMatch = segment.content.match(/^\[ACTION:\s*([\w_]+)\s*(.*?)\]$/is);
                if (!actionMatch) continue;

                if (!currentSenderId && contact.isGroup) {
                    currentSenderId = contact.members.find(id => id !== 'user') || contact.members[0];
                    if (!currentSenderId) continue;
                }
                
                const action = actionMatch[1].trim().toUpperCase();
                const actorName = getDisplayName(currentSenderId, contact.id);
                const messageId = newId('msg');
                const args = (actionMatch[2].trim().match(/(?:[^\s"]+|"[^"]*")+/g) || []).map(arg => arg.replace(/"/g, ''));
                // --- æ–°å¢ï¼šå¾®åšåå°æ´»åŠ¨å¤„ç† ---
if (action.startsWith('WEIBO_')) {
handleWeiboAction(action, args, currentSenderId);
continue;
}
                if (action === 'SEND_FRIEND_REQUEST' && !contact.isGroup && args[0]) {
                    if (contact.charSettings.isFriend) continue;
                    addSystemNotification(contact.id, `${actorName} å‘é€äº†å¥½å‹ç”³è¯·ï¼šâ€œ${args[0]}â€`, false);
                    contact.charSettings.pendingFriendRequest = { reason: args[0], timestamp: Date.now() };
                    contact.unreadCount = 1;
                    contact.needsShake = true;
                    renderMessageList();
                    if (singleChatScreen.classList.contains('active') && runtimeState.currentChatId === contact.id) {
                        showCharFriendRequestModal(contact);
                    }
                    continue;
                } else if (action === 'ACCEPT_FRIEND_REQUEST' && !contact.isGroup) {
                    if (contact.charSettings.isFriend) continue;
                    contact.charSettings.isFriend = true;
                    let lastRequestIndex = -1;
                    for (let i = contact.conversation.length - 1; i >= 0; i--) { const msg = contact.conversation[i]; if (msg.sender === 'user' && msg.type === 'notification' && msg.content.startsWith('ä½ å‘é€äº†å¥½å‹ç”³è¯·') && !msg.content.includes('ï¼ˆæ­¤ç”³è¯·å·²è¢«å¤„ç†ï¼‰')) { lastRequestIndex = i; break; } }
                    if (lastRequestIndex > -1) { contact.conversation[lastRequestIndex].content += 'ï¼ˆæ­¤ç”³è¯·å·²è¢«å¤„ç†ï¼‰'; }
                    addSystemNotification(contact.id, `${actorName} æ¥å—äº†ä½ çš„å¥½å‹ç”³è¯·`, false);
                    addSystemNotification(contact.id, 'æˆ‘ä»¬å·²ç»æ˜¯å¥½å‹å•¦ï¼Œä¸€èµ·æ¥èŠå¤©å§ï¼', false);
                    setTimeout(() => triggerAiResponse(contact.id), 500);
                } else if (action === 'REJECT_FRIEND_REQUEST' && !contact.isGroup) {
                    if (contact.charSettings.isFriend) continue;
                    const reason = actionMatch[2].trim().replace(/"/g, '');
                    addSystemNotification(contact.id, reason ? `${actorName} æ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·ï¼š${reason}` : `${actorName} æ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·`, false);
                    let lastRequestIndex = -1;
                    for (let i = contact.conversation.length - 1; i >= 0; i--) { const msg = contact.conversation[i]; if (msg.sender === 'user' && msg.type === 'notification' && msg.content.startsWith('ä½ å‘é€äº†å¥½å‹ç”³è¯·') && !msg.content.includes('ï¼ˆæ­¤ç”³è¯·å·²è¢«å¤„ç†ï¼‰')) { lastRequestIndex = i; break; } }
                    if (lastRequestIndex > -1) { contact.conversation[lastRequestIndex].content += 'ï¼ˆæ­¤ç”³è¯·å·²è¢«å¤„ç†ï¼‰'; }
                } else {
                    if (!contact.isGroup && !contact.charSettings.isFriend) continue;
                    if (action === 'SEND_LOVE_LETTER' && args.length >= 5) {
    const [recipientId, salutation, subject, body, signature] = args;
    const letterData = { salutation, subject, body, signature };
    // We know the sender is the current character, so we pass the whole contact object
    processReceivedLoveLetter(letterData, contact);
} 
                                    else if (action === 'QUOTE_MESSAGE' && args[0]) {
                    const msgToQuote = contact.conversation.find(m => m.id === args[0]);
                    if (msgToQuote) {
                        runtimeState.aiQuotedMessage = { charId: currentSenderId, message: { ...msgToQuote } };
                    }
                }
                            else if (action === 'RECALL_MESSAGE' && args[0]) {
                let messageToRecall = null;
                const recallArg = args[0];

                if (recallArg === 'last') {
                    if (messagesSentThisTurn.length > 0) {
                        messageToRecall = messagesSentThisTurn[messagesSentThisTurn.length - 1];
                    }
                } else {
                    const index = parseInt(recallArg);
                    if (!isNaN(index)) {
                        if (index > 0) { // 1-based index
                            messageToRecall = messagesSentThisTurn[index - 1];
                        } else if (index < 0) { // Negative index
                            messageToRecall = messagesSentThisTurn[messagesSentThisTurn.length + index];
                        }
                    }
                }

                if (messageToRecall) {
                    // **æ ¸å¿ƒä¿®å¤**: æ ¹æ®æ˜¯å¦ä¸ºç¾¤èŠï¼Œå†³å®šå¬å›è€…çš„IDæ¥æº
                    const recallerId = contact.isGroup ? messageToRecall.sender : currentSenderId;
                    recallMessage(messageToRecall.id, recallerId);
                } else {
                    // Fallback for recalling older messages by full ID string
                    recallMessage(recallArg, currentSenderId);
                }
            }
                    else if (action === 'SEND_EMOJI' && args[0]) { const emojiDesc = args[0].toLowerCase();
    let matchingEmojis = appState.chat.emojis.filter(em => em.description.toLowerCase().includes(emojiDesc));
    
    if (matchingEmojis.length === 0) {
        // å¦‚æœå®Œå…¨æ²¡æœ‰åŒ¹é…é¡¹ï¼Œåˆ™ä»æ‰€æœ‰è¡¨æƒ…ä¸­éšæœºé€‰æ‹©ä¸€ä¸ª
        matchingEmojis = appState.chat.emojis;
    }

    const emoji = matchingEmojis.length > 0 ? matchingEmojis[Math.floor(Math.random() * matchingEmojis.length)] : null;
                    if (emoji) {
                        const newMessage = { id: messageId, type: 'emoji', emojiId: emoji.id, description: emoji.description, sender: currentSenderId, timestamp, status: 'sent', contactId: contact.id };
                        addMessageToConversation(newMessage, true);
                        lastMessageSentInTurn = newMessage;
                    }
                } 
                    else if (action === 'SEND_VOICE' && args[0]) { const cleanText = args[0].replace(/\(.*?\)|ï¼ˆ.*?ï¼‰/g, ''); const duration = Math.max(1, Math.ceil(cleanText.length / 2));
                    const newMessage = { id: messageId, type: 'voice', content: args[0], duration, sender: currentSenderId, timestamp, status: 'sent', contactId: contact.id };
                    addMessageToConversation(newMessage, true);
                    lastMessageSentInTurn = newMessage;
                } 
                    else if (action === 'SEND_IMAGE' && args[0]) {
                    const newMessage = { id: messageId, type: 'camera', content: args[0], imageId: 'default_camera_image', sender: currentSenderId, timestamp, status: 'sent', contactId: contact.id };
                    addMessageToConversation(newMessage, true);
                    lastMessageSentInTurn = newMessage;
                } 
                    else if (action === 'SHARE_MUSIC' && args[0]) { const songQuery = args[0]; const song = appState.music.playlist.find(s => `${s.artist} - ${s.title}`.toLowerCase() === songQuery.toLowerCase());
                    if (song) {
                        const newMessage = { id: messageId, type: 'musicShare', songId: song.id, title: song.title, artist: song.artist, sender: currentSenderId, timestamp, status: 'sent', contactId: contact.id };
                        addMessageToConversation(newMessage, true);
                        lastMessageSentInTurn = newMessage;
                    }
                } 
                    else if (action.startsWith('SEND_REDPACKET')) { let packetData; if (action === 'SEND_REDPACKET_LUCKY' && contact.isGroup && args.length >= 3) { let [message, totalAmount, count] = args; packetData = { packetType: 'lucky', message, totalAmount: parseFloat(totalAmount), count: parseInt(count) }; } else if (action === 'SEND_REDPACKET_EXCLUSIVE' && contact.isGroup && args.length >= 3) { let [message, amount, targetNickname] = args; const targetId = Object.keys(contact.groupSettings.members).find(id => contact.groupSettings.members[id].nickname === targetNickname.replace('@', '')); if (targetId) packetData = { packetType: 'exclusive', message, amount: parseFloat(amount), exclusiveTo: targetId }; } else if (action === 'SEND_REDPACKET_NORMAL' && contact.isGroup && args.length >= 3) { let [message, amount, count] = args; packetData = { packetType: 'normal', message, amount: parseFloat(amount), count: parseInt(count) }; } else if (action === 'SEND_REDPACKET' && !contact.isGroup && args.length >= 2) { let [message, amount] = args; packetData = { packetType: 'normal', message, amount: parseFloat(amount) }; }
                    if (packetData) {
                        const newMessage = { id: messageId, type: 'redPacket', ...packetData, sender: currentSenderId, timestamp, status: 'unclaimed', claimedBy: {}, contactId: contact.id };
                        addMessageToConversation(newMessage, true);
                        lastMessageSentInTurn = newMessage;
                    }
                } 
                    else if (action === 'CLAIM_REDPACKET' && args.length >= 2) { const [messageId, claimerId] = args; claimRedPacketByAI(messageId, claimerId); } 
                    else if (action === 'INITIATE_VIDEO_CALL') { if (appState.chat.videoCallState.isActive) { addMessageToConversation({ id: newId('msg'), type: 'text', content: 'ï¼ˆæˆ‘æƒ³ç»™ä½ æ‰“è§†é¢‘ï¼Œä½†ä½ å¥½åƒæ­£åœ¨é€šè¯ä¸­...ï¼‰', sender: currentSenderId, timestamp, status: 'sent', contactId: contact.id }, true); } else if (!runtimeState.incomingCall.from) { showIncomingCallUI(currentSenderId); } } 
                    else if (action === 'PAT' && args[0]) { const targetId = args[0]; const targetName = getDisplayName(targetId, contact.id); addSystemNotification(contact.id, `'${actorName}' æ‹äº†æ‹ '${targetName}'${args[1] ? ` ${args[1]}` : ''}`); } 
                    else if (action.startsWith('POST_') || action.startsWith('LEAVE_') || action.startsWith('LIKE_') || action.startsWith('COMMENT_') || action.startsWith('REPLY_')) { handleSocialAction(action, args, currentSenderId); } 
                    else if (action === 'SET_STATUS' && !contact.isGroup && args.length >= 1) { const status = args[0].toLowerCase(); const statusText = args[1] || ''; if (['online', 'busy', 'offline'].includes(status)) { contact.status = status; contact.statusText = statusText; addSystemNotification(contact.id, `${actorName} å°†çŠ¶æ€ä¿®æ”¹ä¸ºï¼š${(statusMap[contact.status] || '')} ${contact.statusText || ''}`.trim(), false); updateSingleChatUI(); } } 
                    else if (action === 'SET_SIGNATURE' && !contact.isGroup && args.length >= 1) { contact.signature = args.join(' '); addSystemNotification(contact.id, `${actorName} å°†ç­¾åä¿®æ”¹ä¸ºï¼šâ€œ${contact.signature}â€`, false); updateSingleChatUI(); } 
                    else if (action === 'DELETE_FRIEND' && !contact.isGroup) { contact.charSettings.isFriend = false; addSystemNotification(contact.id, `${actorName} åˆ é™¤ä½ äº†`, false); updateSingleChatUI(); } 
                    else if (action === 'SET_MY_NICKNAME' && contact.isGroup && args[0]) { const oldNickname = contact.groupSettings.members[currentSenderId].nickname; contact.groupSettings.members[currentSenderId].nickname = args[0]; addSystemNotification(contact.id, `'${oldNickname}' åœ¨ç¾¤é‡Œæ”¹åä¸º '${args[0]}'`, false); } 
                    else if (action.startsWith('MUTE_') && contact.isGroup) { if (action === 'MUTE_ALL' || action === 'UNMUTE_ALL') { const isMute = action === 'MUTE_ALL'; contact.groupSettings.isMuted = isMute; addSystemNotification(contact.id, `'${actorName}' ${isMute ? 'å¼€å¯äº†å…¨ä½“ç¦è¨€' : 'è§£é™¤äº†å…¨ä½“ç¦è¨€'}`, false); } else if (args.length >= 2) { const [executorId, targetId] = args; const executorName = getDisplayName(executorId, contact.id); const targetMember = contact.groupSettings.members[targetId]; if (targetMember && targetId !== 'user') { const isMute = action === 'MUTE_MEMBER'; targetMember.isMuted = isMute; addSystemNotification(contact.id, `'${executorName}' ${isMute ? 'ç¦è¨€äº†' : 'è§£é™¤äº†å¯¹'} '${targetMember.nickname}'${isMute ? '' : ' çš„ç¦è¨€'}`, false); } } } 
                    else if (action === 'SET_GROUP_NAME' && contact.isGroup && args[0]) { contact.groupSettings.name = args[0]; addSystemNotification(contact.id, `'${actorName}' å°†ç¾¤åä¿®æ”¹ä¸º "${args[0]}"`, false); updateSingleChatUI(); } 
                    else if ((action === 'SET_TITLE' || action === 'SET_NICKNAME') && contact.isGroup && args.length >= 3) { const [executorId, targetId, newValue] = args; const executorName = getDisplayName(executorId, contact.id); const targetMember = contact.groupSettings.members[targetId]; if (targetMember) { if (action === 'SET_TITLE') { targetMember.title = newValue; addSystemNotification(contact.id, `'${executorName}' å°† '${targetMember.nickname}' çš„ç¾¤èŠå¤´è¡”ä¿®æ”¹ä¸º '${newValue}'`, false); } else { const oldNickname = targetMember.nickname; targetMember.nickname = newValue; addSystemNotification(contact.id, `'${executorName}' ä¿®æ”¹äº† '${oldNickname}' çš„ç¾¤åç‰‡ä¸º '${newValue}'`, false); } } } 
                    else if (action === 'TRANSFER_OWNERSHIP' && contact.isGroup && args[0]) { const targetId = args[0]; const targetMember = contact.groupSettings.members[targetId]; if (targetMember && targetId !== 'user') { contact.groupSettings.owner = targetId; if (currentSenderId) contact.groupSettings.admins = contact.groupSettings.admins.filter(id => id !== currentSenderId); addSystemNotification(contact.id, `'${actorName}' å°†ç¾¤ä¸»è½¬è®©ç»™äº† '${targetMember.nickname}'`, false); } } 
                    else if ((action === 'PROMOTE_ADMIN' || action === 'DEMOTE_ADMIN') && contact.isGroup && args[0]) { const targetId = args[0]; const targetMember = contact.groupSettings.members[targetId]; if (targetMember && targetId !== 'user') { const isPromote = action === 'PROMOTE_ADMIN'; if (isPromote && !contact.groupSettings.admins.includes(targetId)) contact.groupSettings.admins.push(targetId); else if (!isPromote) contact.groupSettings.admins = contact.groupSettings.admins.filter(id => id !== targetId); addSystemNotification(contact.id, `'${targetMember.nickname}' å·²è¢«'${actorName}'${isPromote ? 'è®¾ä¸º' : 'æ’¤é”€'}ç®¡ç†å‘˜`, false); } } 
                    else if (action.startsWith('VIDEO_') && contact.isGroup) { if (action === 'VIDEO_ACCEPT' && args[0]) { if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId === contact.id && !appState.chat.videoCallState.participants.includes(args[0])) { appState.chat.videoCallState.participants.push(args[0]); addSystemNotification(contact.id, `${getDisplayName(args[0], contact.id)} åŠ å…¥äº†è§†é¢‘é€šè¯`, false); openVideoCallModal(); } } else if (action === 'VIDEO_REJECT' && args[0]) { rejectVideoCall(contact.id, args[0], args[1] || ""); } else if (action === 'REQUEST_JOIN_VIDEO') { if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId === contact.id && !appState.chat.videoCallState.participants.includes(currentSenderId)) { appState.chat.videoCallState.participants.push(currentSenderId); addSystemNotification(contact.id, `${actorName} åŠ å…¥äº†è§†é¢‘é€šè¯`, false); openVideoCallModal(); } } }
                }
            } else if (segment.type === 'text') {
                if (!contact.isGroup && !contact.charSettings.isFriend) continue;

                const processPart = async (part, currentSenderId, msgTimestamp) => {
                    if (!part || !part.trim()) return;

                    const voiceRegex = /\[User sends a voice message\]:\s*"(.*)"/s;
                    const voiceMatch = part.match(voiceRegex);

                    if (voiceMatch) {
                        let voiceText = voiceMatch[1].trim();
                        if (voiceText.startsWith('(') && voiceText.endsWith(')')) {
                            voiceText = voiceText.substring(1, voiceText.length - 1).trim();
                        }
                        const cleanText = voiceText.replace(/\(.*?\)|ï¼ˆ.*?ï¼‰/g, '');
                        const duration = Math.max(1, Math.ceil(cleanText.length / 2));
                        const newMessage = { id: newId('msg'), type: 'voice', content: voiceText, duration, sender: currentSenderId, timestamp: msgTimestamp, status: 'sent', contactId: contact.id };
                        addMessageToConversation(newMessage, true);
                        messagesSentThisTurn.push(newMessage);
                        if (voiceText) {
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 200));
                        }
                    } else {
                        const cleanedContent = part.replace(/\(ID:\s*msg_[\w_]+\)\s*(::)?\s*|^\s*::\s*/g, '').trim();
                        if (cleanedContent) {
                            const newMessage = { id: newId('msg'), type: 'text', content: cleanedContent, sender: currentSenderId, timestamp: msgTimestamp, status: 'sent', contactId: contact.id };
                            addMessageToConversation(newMessage, true);
                            messagesSentThisTurn.push(newMessage);
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 200));
                        }
                    }
                };

                const messages = segment.content.split(/<MSG_SPLIT>|::/g).map(s => s.trim()).filter(Boolean);

                for (const message of messages) {
                    let messageContent = message;
                    let senderForThisMessage = currentSenderId;

                    if (contact.isGroup) {
                        const speakerMatch = message.match(/^\[(.*?)\s*(?:\(ID:\s*([^)]+)\))?]:\s*(.*)$/s);
                        if (speakerMatch) {
                            const senderName = speakerMatch[1].trim();
                            const senderIdFromMsg = speakerMatch[2];
                            messageContent = speakerMatch[3].trim();
                            
                            let memberEntry;
                            if(senderIdFromMsg) {
                                memberEntry = [senderIdFromMsg, contact.groupSettings.members[senderIdFromMsg]];
                            } else {
                                memberEntry = Object.entries(contact.groupSettings.members).find(([id, member]) => member.nickname === senderName);
                            }
                            
                            if (memberEntry) {
                                senderForThisMessage = memberEntry[0];
                                currentSenderId = senderForThisMessage;
                            } else {
                                continue;
                            }
                        } else {
                             if (!senderForThisMessage) continue;
                        }
                    }
                    
                    const voiceMessageRegex = /(\[User sends a voice message\]:\s*".*?"\s*)/s;
                    const parts = messageContent.split(voiceMessageRegex);
                    
                    for (const part of parts) {
                        await processPart(part, senderForThisMessage, timestamp);
                    }
                }
            }
        }
    }
        function processReceivedLoveLetter(letterData, contact) {
        const charId = contact.id;
        const letterToReply = appState.mailbox.loveLetters.find(l => l.replyDueTimestamp && l.replyFrom === charId);
if (letterToReply) {
    letterToReply.isRepliedTo = true;
}
        const newLetter = { id: newId('letter'), senderId: charId, recipientId: 'user', timestamp: Date.now(), isRead: false, ...letterData };
        appState.mailbox.loveLetters.push(newLetter);
        contact.lastLetterSent = Date.now();
        
        // Clean up the task marker that triggered this generation
        if (letterToReply) {
            delete letterToReply.replyDueTimestamp;
            delete letterToReply.replyFrom;
        } else {
            delete contact.charSettings.proactiveLetterDue;
        }
        
        debouncedSaveState();
        queueNotification(`${contact.name} ç»™ä½ å¯„æ¥äº†ä¸€å°æƒ…ä¹¦`, 'system', charId, 'mail');
        if (mailAppScreen.classList.contains('active')) { renderLoveLetterTab(); }
        console.log(`Love letter from ${contact.name} processed successfully.`);
    }

    async function processReceivedPostcard(postcardData, contact) {
                const charId = contact.id;
    const originalCard = appState.mailbox.postcards.find(p => p.senderId === 'user' && p.recipientId === charId && !p.replyProcessed);

    if (postcardData.imageDescription) {
    // New logic: Use the description to fetch an image from a reliable source.
    const unsplashUrl = `https://source.unsplash.com/600x800/?${encodeURIComponent(postcardData.imageDescription)}`;
    try {
        // We still resolve the redirect to get a permanent, static URL for saving.
        postcardData.imageUrl = await resolveRedirectUrl(unsplashUrl);
    } catch (imgError) {
        console.error(`Failed to resolve Unsplash URL for description "${postcardData.imageDescription}", marking as resolution_failed:`, imgError);
        postcardData.imageUrl = 'resolution_failed'; 
    }
} else if (!postcardData.imageUrl) {
    // Fallback if the AI fails to provide either a description or a URL.
    postcardData.imageUrl = 'resolution_failed';
}
        const newPostcard = { id: newId('postcard'), senderId: charId, recipientId: 'user', isRead: false, ...postcardData };
        appState.mailbox.postcards.push(newPostcard);

        // Clean up the task marker
        if (originalCard) {
            originalCard.replyProcessed = true;
        } else { // This was a proactive postcard
            contact.charSettings.realtimeTicksSincePostcard = 0;
            contact.charSettings.nextPostcardTickTarget = Math.floor(Math.random() * 5) + 1;
        }

        debouncedSaveState();
        queueNotification(`${contact.name} ç»™ä½ å¯„æ¥äº†ä¸€å¼ æ˜ä¿¡ç‰‡`, 'system', charId, 'mail');
        if (mailAppScreen.classList.contains('active')) { handleMailTabChange('postcard'); }
        console.log(`Postcard from ${contact.name} processed successfully.`);
    }
        async function processAnniversaryReply(data, contact) {
                const charId = contact.id;
    const now = new Date();
    const todayStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
    const anniversaryInfo = appState.diary.anniversaries.find(a => a.date === todayStr) || holidays[todayStr];
    const anniversaryName = anniversaryInfo ? anniversaryInfo.name : 'ç‰¹åˆ«çš„æ—¥å­';

    // 1. Send chat message
    addMessageToConversation({
        id: newId('msg'),
        type: 'text',
        content: data.anniversary_chat,
        sender: charId,
        timestamp: Date.now(),
        status: 'sent',
        contactId: charId
    }, true);

    // 2. Create and save the gift with personalized postcard text
    const giftData = data.anniversary_gift;
    const newGiftPostcard = {
        id: newId('postcard'),
        senderId: charId,
        recipientId: 'user',
        isRead: false,
        gift: giftData.name,
        giftDescription: giftData.description,
        isAnniversaryGift: true,
        anniversaryName: anniversaryName,
        salutation: giftData.postcard_salutation,
        body: giftData.postcard_body,
        signature: contact.charSettings.name,
        location: giftData.postcard_location,
        timestamp: Date.now(),
        imageUrl: 'https://i.postimg.cc/mD4C82b9/image.png'
    };
    appState.mailbox.postcards.push(newGiftPostcard);
    queueNotification(`${contact.name} é€ç»™äº†ä½ ä¸€ä»½çºªå¿µæ—¥ç¤¼ç‰©ï¼`, 'system', charId, 'mail');
    if (diaryAppScreen.classList.contains('active') && appState.diary.activeTab === 'exhibition') {
        renderExhibitionTab();
    }

    // 3. Create and save the special love letter
    const letterData = data.special_love_letter;
    const newLetter = {
        id: newId('letter'),
        senderId: charId,
        recipientId: 'user',
        timestamp: Date.now(),
        isRead: false,
        isSpecial: true,
        specialOccasion: anniversaryName,
        ...letterData
    };
    appState.mailbox.loveLetters.push(newLetter);
    queueNotification(`${contact.name} åœ¨è¿™ä¸ªç‰¹åˆ«çš„æ—¥å­ç»™ä½ å¯„æ¥äº†ä¸€å°ä¿¡`, 'system', charId, 'mail');
    
    // 4. Mark this anniversary as celebrated to prevent re-triggering
    contact.charSettings.lastAnniversaryCelebrated = todayStr;

    // 5. NEW: Trigger the anniversary moment post
    console.log(`Triggering anniversary moment for ${contact.name}...`);
     const momentInstruction = constructAnniversaryMomentPrompt(contact, anniversaryName);
 await triggerAiResponse(contact.id, false, false, false, momentInstruction, false, { type: 'background_event' });

        // 5. Save all changes
        debouncedSaveState();
        console.log(`Anniversary event for ${contact.name} processed successfully.`);
    }
        // ===================================================================
    // --- æ–°å¢ï¼šçºªå¿µæ—¥äº‹ä»¶æ ¸å¿ƒé€»è¾‘ ---
    // ===================================================================
    async function checkForAnniversaryEvents() {
                const now = new Date();
        const todayStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

        const todaysAnniversaries = appState.diary.anniversaries.filter(a => a.date === todayStr);
        const todaysHoliday = holidays[todayStr] && holidays[todayStr].holiday ? holidays[todayStr] : null;

        if (todaysAnniversaries.length === 0 && !todaysHoliday) {
            console.log("Today is not a special day.");
            return;
        }

        // --- Process Single Chars ---
        const charToEventsMap = new Map();
        appState.chat.contacts.forEach(c => { if (!c.isGroup) { charToEventsMap.set(c.id, []); } });

        todaysAnniversaries.forEach(anniv => {
            const ids = anniv.associatedCharIds;
            if (ids && ids.length > 0) {
                ids.forEach(charId => { if (charToEventsMap.has(charId)) { charToEventsMap.get(charId).push(anniv.name); } });
            } else {
                charToEventsMap.forEach(eventList => eventList.push(anniv.name));
            }
        });

        if (todaysHoliday) {
            charToEventsMap.forEach(eventList => eventList.push(todaysHoliday.name));
        }

        for (const [charId, eventNames] of charToEventsMap.entries()) {
            if (eventNames.length > 0) {
                const contact = appState.chat.contacts.find(c => c.id === charId);
                if (contact && contact.charSettings.lastAnniversaryCelebrated !== todayStr) {
                    const combinedName = eventNames.join('å’Œ');
                    console.log(`Triggering SINGLE CHAR anniversary event for ${contact.name}: ${combinedName}`);
                    const secretInstruction = constructAnniversaryPrompt(contact, combinedName);
                await triggerAiResponse(contact.id, false, false, false, secretInstruction, false, { type: 'background_event' });
                    await triggerAiResponse(contact.id, false, false, false, secretInstruction, false, { type: 'background_event' });
                }
            }
        }

        // --- Process Groups ---
        for (const contact of appState.chat.contacts) {
            if (contact.isGroup && contact.groupSettings.lastAnniversaryCelebrated !== todayStr) {
                const groupMemberIds = contact.members;
                const groupEventNames = new Set();

                // Check for general events
                const generalAnnivs = todaysAnniversaries.filter(a => !a.associatedCharIds || a.associatedCharIds.length === 0);
                generalAnnivs.forEach(a => groupEventNames.add(a.name));
                if (todaysHoliday) {
                    groupEventNames.add(todaysHoliday.name);
                }

                // Check for member-specific events
                todaysAnniversaries.forEach(anniv => {
                    if (anniv.associatedCharIds && anniv.associatedCharIds.some(id => groupMemberIds.includes(id))) {
                        groupEventNames.add(anniv.name);
                    }
                });

                if (groupEventNames.size > 0) {
                    const combinedName = Array.from(groupEventNames).join('å’Œ');
                    console.log(`Triggering GROUP anniversary event for ${contact.name}: ${combinedName}`);
                                    const secretInstruction = constructGroupAnniversaryPrompt(contact, combinedName);
                await triggerAiResponse(contact.id, false, false, false, secretInstruction, true, { type: 'background_event' });
                    contact.groupSettings.lastAnniversaryCelebrated = todayStr; // Mark as celebrated for today
                    debouncedSaveState();
                }
            }
        }
    }
function handleSocialAction(action, args, actorId) {
    const actorName = getDisplayName(actorId, actorId);

    if (action === 'POST_MOMENT' && args.length >= 2) {
        let type = (args[0] || '').toLowerCase();
        if (['å¿ƒæƒ…', 'è¯´è¯´', 'status'].includes(type)) type = 'status';
        if (['æ—¥å¿—', 'log'].includes(type)) type = 'log';

        let contentStr = args[1];
        
        let visibility = (args[2] || 'public').toLowerCase();
        if (['æ‰€æœ‰äºº', 'å…¬å¼€', 'public'].includes(visibility)) visibility = 'public';
        const newPost = { id: newId('post'), authorId: actorId, timestamp: Date.now(), likes: [], comments: [], visibility: visibility, visibleTo: (visibility === 'specific' ? ['user'] : []) };
        if (type === 'status') {
            newPost.type = 'status';
            let text = contentStr, images = [];
            if (contentStr.includes('||')) {
                const parts = contentStr.split('||'); text = parts[0].trim();
                images = parts[1].trim().split('|').filter(d => d).map(desc => ({ isTextImage: true, imageId: 'default_camera_image', description: desc }));
            }
            newPost.content = { text: text, images: images };
            appState.chat.moments.posts.unshift(newPost);
            queueNotification(`${actorName} å‘è¡¨äº†æ–°åŠ¨æ€`, 'system', actorId, 'moments');
        } else if (type === 'log') {
            const [title, text] = contentStr.split('|');
            if (title && text) { newPost.type = 'log'; newPost.content = { title, text }; appState.chat.moments.posts.unshift(newPost); queueNotification(`${actorName} å‘è¡¨äº†æ–°åŠ¨æ€`, 'system', actorId, 'moments'); }
        }
    } else if (action === 'POST_PHOTO' && args.length >= 3) {
    const [photoName, photoDesc, albumName, imageDescsStr] = args;
    const imageDescs = imageDescsStr ? imageDescsStr.split('|').filter(d => d) : [];
    if (imageDescs.length > 0) {
        let photoStorage, albumStorage;
        if (actorId === 'user') {
            photoStorage = appState.chat.moments.photos;
            albumStorage = appState.chat.moments.albums;
        } else {
            const contact = appState.chat.contacts.find(c => c.id === actorId);
            if (!contact) return; 
            if (!contact.charSettings.moments) { contact.charSettings.moments = { photos: [], albums: [] }; }
            photoStorage = contact.charSettings.moments.photos;
            albumStorage = contact.charSettings.moments.albums;
        }

        let targetAlbum = albumStorage.find(a => a.name === albumName);
        if (!targetAlbum) { 
            targetAlbum = albumStorage.find(a => a.id.endsWith('_default_album')); 
            if (!targetAlbum) {
                targetAlbum = { id: newId(actorId + '_default_album'), name: 'é»˜è®¤ç›¸å†Œ', createTime: Date.now(), photoIds: [] };
                albumStorage.push(targetAlbum);
            }
        }

        const photoIds = imageDescs.map(desc => {
            const photo = { id: newId('photo'), ownerId: actorId, imageId: 'default_camera_image', isTextImage: true, textDescription: desc, name: photoName, description: photoDesc };
            photoStorage.push(photo);
            return photo.id;
        });
        if (!targetAlbum.photoIds) targetAlbum.photoIds = [];
        targetAlbum.photoIds.unshift(...photoIds);
        const newPost = { id: newId('post'), authorId: actorId, type: 'photo', content: { name: photoName, description: photoDesc, photoIds: photoIds, albumId: targetAlbum.id }, timestamp: Date.now(), visibility: 'public', visibleTo: [], likes: [], comments: [] };
        appState.chat.moments.posts.unshift(newPost); 
        queueNotification(`${actorName} ä¸Šä¼ äº†æ–°ç…§ç‰‡`, 'system', actorId, 'moments');
    }
    } else if (action === 'POST_MUSIC_REVIEW' && args.length >= 2) {
        const songQuery = args[0], reviewText = args[1];
        const song = appState.music.playlist.find(s => `${s.artist} - ${s.title}`.toLowerCase() === songQuery.toLowerCase());
        if (song) {
            if (!appState.music.comments[song.id]) appState.music.comments[song.id] = [];
            appState.music.comments[song.id].unshift({ id: newId('comment'), authorId: actorId, text: reviewText, likes: [], replies: [], timestamp: Date.now() });
        }
                } else if (action === 'LEAVE_MESSAGE' && args[0]) {
                const content = args[0];
                const newMessage = { id: newId('message'), recipientId: 'user', recipientName: findUserById('user').name, content: content, senderId: actorId, senderName: actorName, timestamp: Date.now(), visibility: 'public', visibleTo: [], replies: [] };
                appState.chat.moments.messages.push(newMessage);
                addMomentsNotification('message', actorId, { messageId: newMessage.id, recipientId: 'user', content: content }); logVisitor('user', actorId);
    } else if (action === 'LIKE_MOMENT' && args[0]) {
        const post = appState.chat.moments.posts.find(p => p.id === args[0]);
        if (post && canCharViewMoment(actorId, post)) {
            if (!post.likes) post.likes = [];
            if (!post.likes.includes(actorId)) {
                post.likes.push(actorId);
                if (post.authorId === 'user') addMomentsNotification('like', actorId, { postId: post.id, recipientId: 'user' });
                logVisitor(post.authorId, actorId);
            }
        }
    } else if (action === 'COMMENT_MOMENT' && args.length >= 2) {
        const [postId, commentText] = args;
        const post = appState.chat.moments.posts.find(p => p.id === postId);
        if (post && canCharViewMoment(actorId, post)) {
            if (!post.comments) post.comments = [];
            const newComment = { id: newId('comment'), authorId: actorId, text: commentText, likes: [], replies: [], timestamp: Date.now() };
            post.comments.push(newComment);
            if (post.authorId === 'user') addMomentsNotification('comment', actorId, { postId: post.id, recipientId: 'user', content: commentText });
            logVisitor(post.authorId, actorId);
        }
    } else if (action === 'REPLY_MOMENT_COMMENT' && args.length >= 3) {
        const [postId, commentId, replyText, replyToId] = args;
        const post = appState.chat.moments.posts.find(p => p.id === postId);
        if (post && post.comments && canCharViewMoment(actorId, post)) {
            const comment = post.comments.find(c => c.id === commentId);
            if (comment) {
                if (!comment.replies) comment.replies = [];
                let targetAuthor = replyToId ? findUserById(comment.replies.find(r => r.id === replyToId)?.authorId) : findUserById(comment.authorId);
                if (!targetAuthor) targetAuthor = findUserById(comment.authorId);
                const newReply = { id: newId('reply'), authorId: actorId, text: `@${targetAuthor.name} ${replyText}`, replyTo: replyToId || null, timestamp: Date.now() };
                comment.replies.push(newReply);
                        if (targetAuthor.id === 'user') addMomentsNotification('reply', actorId, { postId: post.id, recipientId: 'user', content: replyText, originalCommentId: commentId, originalReplyId: newReply.id });                logVisitor(post.authorId, actorId);
            }
        }
    } else if (action === 'REPLY_MUSIC_COMMENT' && args.length >= 3) {
        const [songId, commentId, replyText] = args;
        const songComments = appState.music.comments[songId];
        if (songComments) {
            const comment = songComments.find(c => c.id === commentId);
            if (comment) {
                if (!comment.replies) comment.replies = [];
                comment.replies.push({ id: newId('reply'), authorId: actorId, text: replyText, replyTo: commentId, timestamp: Date.now() });
            }
        }
    } else if (action === 'REPLY_MESSAGE_BOARD' && args.length >= 2) {
        const [messageId, replyText] = args;
        const message = appState.chat.moments.messages.find(m => m.id === messageId);
        if (message) {
            if (!message.replies) message.replies = [];
            message.replies.push({ id: newId('reply'), authorId: actorId, text: replyText, timestamp: Date.now() });
            if (message.senderId === 'user') addMomentsNotification('reply', actorId, { messageId: message.id, recipientId: 'user', content: replyText });
            logVisitor(message.recipientId, actorId);
        }
    }
    syncAndUpdateMoments(runtimeState.moments.currentProfileId);
}
function updateTypingIndicator() {
    if (!singleChatScreen.classList.contains('active')) { typingIndicator.style.display = 'none'; return; }
    const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
    if (!contact) { typingIndicator.style.display = 'none'; return; }

    // **æ ¸å¿ƒä¿®æ”¹**: å¦‚æœä¸æ˜¯å¥½å‹ï¼Œç›´æ¥éšè—è¾“å…¥æç¤º
    if (!contact.isGroup && !contact.charSettings.isFriend) {
        typingIndicator.style.display = 'none';
        return;
    }

    if (runtimeState.activeRequests[runtimeState.currentChatId]) {
        if (contact.isGroup) {
            if (contact.groupSettings.isDisbanded) { typingIndicator.style.display = 'none'; return; }
            const potentialSpeakers = contact.members.filter(id => { const member = contact.groupSettings.members[id]; if (!member) return false; const isOwner = contact.groupSettings.owner === id; const isAdmin = contact.groupSettings.admins.includes(id); const canSpeakWhenGlobalMute = isOwner || isAdmin; return !member.isMuted && (!contact.groupSettings.isMuted || canSpeakWhenGlobalMute); });
            if (potentialSpeakers.length > 0) {
                typingIndicator.textContent = contact.groupSettings.isMuted ? 'æŸäº›ç¾¤æˆå‘˜æ­£åœ¨è¾“å…¥...' : 'ç¾¤æˆå‘˜ä»¬æ­£åœ¨è¾“å…¥...';
                typingIndicator.style.display = 'block';
            } else {
                typingIndicator.style.display = 'none';
            }
        } else {
            typingIndicator.textContent = `${contact.remark || contact.charSettings.name}æ­£åœ¨è¾“å…¥ä¸­...`;
            typingIndicator.style.display = 'block';
        }
    } else {
        typingIndicator.style.display = 'none';
    }
}

// ===================================================================
// --- åŠ¨æ€ (Moments) ç•Œé¢é€»è¾‘ ---
// ===================================================================
// ===================================================================
    // --- åŠ¨æ€ (Moments) é€šçŸ¥æ ¸å¿ƒé€»è¾‘ ---
    // ===================================================================

    function addMomentsNotification(type, actorId, context) {
        // Don't notify for user's own actions
        if (actorId === 'user') return;

        let notificationExists = false;
        // Prevent duplicate 'like' notifications
        if (type === 'like') {
            notificationExists = appState.chat.moments.notifications.some(
                n => n.type === 'like' && n.actorId === actorId && n.postId === context.postId
            );
        }
        if (notificationExists) return;
        // --- ä¼˜åŒ–ï¼šä¸ºé€šçŸ¥æ¨ªå¹…å‡†å¤‡æ¶ˆæ¯ ---
        const actor = findUserById(actorId);
        let bannerMessage = '';
        switch(type) {
            case 'like':
                bannerMessage = `${actor.name} èµäº†ä½ çš„åŠ¨æ€`;
                break;
            case 'comment':
                bannerMessage = `${actor.name} è¯„è®ºäº†ä½ ï¼šâ€œ${context.content}â€`;
                break;
            case 'reply':
                bannerMessage = `${actor.name} å›å¤äº†ä½ ï¼šâ€œ${context.content}â€`;
                break;
            case 'message':
                 bannerMessage = `${actor.name} ç»™ä½ ç•™è¨€äº†`;
                 break;
        }
        if (bannerMessage) {
            queueNotification(bannerMessage, 'system', actorId, 'moments');
        }
        const newNotification = {
            id: newId('notification'),
            type: type, // 'like', 'comment', 'reply', 'message'
            actorId: actorId,
            ...context, // postId, originalCommentId, messageId, content, etc.
            timestamp: Date.now(),
            isRead: false
        };
        appState.chat.moments.notifications.unshift(newNotification); // Add to the top
        debouncedSaveState();
        updateMomentsNotificationUI(true); // Trigger shake
    }

    function updateMomentsNotificationUI(shouldShake = false) {
        const unreadCount = appState.chat.moments.notifications.filter(n => !n.isRead).length;
        const badgeElements = queryAll('#moments-notification-badge, .moments-notification-badge-clone');
        const buttonElements = queryAll('#moments-notification-btn, #char-moments-notification-btn');

        badgeElements.forEach(badge => {
            if (unreadCount > 0) {
                badge.textContent = unreadCount;
                badge.classList.add('visible');
            } else {
                badge.classList.remove('visible');
            }
        });

        if (shouldShake && unreadCount > 0) {
            buttonElements.forEach(button => {
                button.classList.remove('shake'); // Reset animation
                void button.offsetWidth; // Trigger reflow
                button.classList.add('shake');
                setTimeout(() => button.classList.remove('shake'), 500);
            });
        }
    }

    function truncateText(text, maxLength = 10) {
        if (!text) return '';
        if (text.length <= maxLength) return text;
        
        let truncated = text.substring(0, maxLength);
        const lastChar = truncated.slice(-1);
        
        if (/[ï¼Œã€‚ï¼ï¼Ÿã€ï¼›ï¼š]/.test(lastChar)) {
            // If the last character is punctuation, replace it
            return truncated.slice(0, -1) + 'â€¦';
        } else {
            // Otherwise, append
            return truncated + 'â€¦';
        }
    }
    
    function renderMomentsNotifications() {
        if (appState.chat.moments.notifications.length === 0) {
            momentsNotificationList.innerHTML = '<li style="padding: 20px; text-align: center; color: #888;">æš‚æ— é€šçŸ¥</div>';
            return;
        }

        let listHTML = '';
        appState.chat.moments.notifications.forEach(n => {
            const actor = findUserById(n.actorId);
                    if (!actor) {
            return; // Skip this notification if the user was deleted
        }
            let actionText = '';
            let summary = '';
            let targetPost = null;

            switch(n.type) {
                case 'like':
                    targetPost = appState.chat.moments.posts.find(p => p.id === n.postId);
                    actionText = 'èµäº†ä½ çš„åŠ¨æ€';
                    summary = targetPost ? truncateText(targetPost.content.text || 'å›¾ç‰‡åŠ¨æ€') : 'åŸåŠ¨æ€å·²è¢«åˆ é™¤';
                    break;
                case 'comment':
                    targetPost = appState.chat.moments.posts.find(p => p.id === n.postId);
                    actionText = 'è¯„è®ºäº†ä½ çš„åŠ¨æ€';
                    summary = n.content ? truncateText(n.content) : 'åŸè¯„è®ºå·²è¢«åˆ é™¤';
                    break;
                case 'reply':
                     targetPost = appState.chat.moments.posts.find(p => p.id === n.postId);
                    actionText = 'å›å¤äº†ä½ çš„è¯„è®º';
                    summary = n.content ? truncateText(n.content) : 'åŸå›å¤å·²è¢«åˆ é™¤';
                    break;
                case 'message':
                    actionText = 'ç»™ä½ ç•™è¨€äº†';
                    summary = n.content ? truncateText(n.content) : 'åŸç•™è¨€å·²è¢«åˆ é™¤';
                    break;
            }

            listHTML += `
                <li class="preset-data-item notification-item ${n.isRead ? '' : 'unread'}" 
                    data-notification-id="${n.id}" 
                    data-type="${n.type}" 
                    data-post-id="${n.postId || ''}" 
                    data-message-id="${n.messageId || ''}">
                    <div class="notification-item-container">
                        <div class="notification-item-content">
                            <div class="notification-avatar" data-avatar-id="${actor.avatarId}"></div>
                            <div class="notification-info">
                                <span class="notification-actor-name">${actor.name}</span>
                                <span>${actionText}ï¼š</span>
                                <span class="notification-content-summary">â€œ${summary}â€</span>
                            </div>
                        </div>
                        <div class="notification-timestamp">${new Date(n.timestamp).toLocaleString()}</div>
                    </div>
                    <div class="preset-data-item-actions">
                        <div class="delete-action">åˆ é™¤</div>
                    </div>
                </li>
            `;
        });
        
        momentsNotificationList.innerHTML = listHTML;
        momentsNotificationList.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    }

    function openMomentsNotificationModal() {
        renderMomentsNotifications();
        momentsNotificationModal.classList.add('visible');

        // Mark all as read
        let changed = false;
        appState.chat.moments.notifications.forEach(n => {
            if (!n.isRead) {
                n.isRead = true;
                changed = true;
            }
        });
        
        if(changed) {
            debouncedSaveState();
            updateMomentsNotificationUI(false);
        }
    }
    function navigateToMomentsContent(notification) {
    if (!notification) return;

    closeAllScreens();
    openApp(chatAppScreen);
    const momentsTabLink = query('#chat-app-screen .app-bottom-tabs .tab-link[data-tab="moments"]');
    if (momentsTabLink) {
        momentsTabLink.click();
    }

    if (notification.type === 'message') {
        runtimeState.moments.currentFilter = 'message';
        runtimeState.moments.scrollToMessageId = notification.messageId;
    } else if (notification.postId) {
        const post = appState.chat.moments.posts.find(p => p.id === notification.postId);
        if (post) {
            runtimeState.moments.currentFilter = post.type === 'log' ? 'log' : (post.type === 'photo' ? 'photo' : 'all');
            runtimeState.moments.scrollToPostId = notification.postId;
        } else {
            showToast('è¯¥åŠ¨æ€å·²è¢«åˆ é™¤');
            runtimeState.moments.currentFilter = 'all';
        }
    }
    
    renderMomentsFeed('user');

    // æ ¸å¿ƒä¿®å¤ï¼šåœ¨æ‰€æœ‰å¯¼èˆªå’Œæ¸²æŸ“æ“ä½œå®Œæˆåï¼Œå¼ºåˆ¶å°†ä¸»çª—å£åŠå…³é”®å®¹å™¨çš„æ»šåŠ¨ä½ç½®é‡ç½®ä¸ºé¡¶éƒ¨ã€‚
    // è¿™å¯ä»¥çº æ­£å› ç§»é™¤è¦†ç›–å±‚å’Œå†…éƒ¨æ»šåŠ¨(scrollIntoView)åŒæ—¶å‘ç”Ÿè€Œå¯¼è‡´çš„æµè§ˆå™¨å¯¹ #phone-screen å®¹å™¨
    // äº§ç”Ÿé”™è¯¯æ»šåŠ¨åç§»é‡çš„ç½•è§æ¸²æŸ“bugã€‚
    window.scrollTo(0, 0);
    document.body.scrollTo(0, 0);
    const phoneScreenEl = document.getElementById('phone-screen');
    if (phoneScreenEl) {
        phoneScreenEl.scrollTo(0, 0);
    }
}
    function renderMomentsPage(profileId = 'user') {
        if (profileId !== 'user') {
            logVisitor(profileId, 'user');
        }
        runtimeState.moments.currentProfileId = profileId;
        const isUserPage = profileId === 'user';
        const profileData = findUserById(profileId);
        const container = isUserPage ? momentsTabContent : charMomentsScreen;

        let headerHTML = '';
        if (!isUserPage) {
            headerHTML = `
                <div class="app-header">
                    <div class="app-header-left"><button class="back-btn" id="char-moments-back-btn">&lt; åŠ¨æ€</button></div>
                    <div class="title-wrapper"><h2 class="title">${profileData.name}çš„åŠ¨æ€</h2></div>
                    <div class="app-header-right"></div>
                </div>
            `;
        }

        container.innerHTML = `
            ${headerHTML}
            <div class="app-content" style="padding:0;">
                <div class="moments-scroll-container">
                    <div class="moments-cover" id="moments-cover-${profileId}"></div>
                    <div class="moments-profile-header">
                        <div class="moments-profile-info">
                            <div class="moments-profile-text">
                                <div class="moments-profile-name" id="moments-profile-name-${profileId}"></div>
                                <div class="moments-profile-signature" id="moments-profile-signature-${profileId}"></div>
                            </div>
                            <div class="moments-profile-avatar" id="moments-profile-avatar-${profileId}"></div>
                        </div>
                    </div>
                    <div class="moments-filter-tabs" id="moments-filter-tabs-${profileId}"></div>
                    <div class="moments-feed" id="moments-feed-${profileId}"></div>
                </div>
                <div class="moments-fab-container" id="moments-fab-container-${profileId}"></div>
            </div>
        `;

        const coverEl = getEl(`moments-cover-${profileId}`);
        const nameEl = getEl(`moments-profile-name-${profileId}`);
        const signatureEl = getEl(`moments-profile-signature-${profileId}`);
        const avatarEl = getEl(`moments-profile-avatar-${profileId}`);

        const coverId = isUserPage ? appState.chat.moments.profile.coverId : (appState.chat.contacts.find(c => c.id === profileId)?.charSettings.momentsCoverId || 'default_moments_cover');
        const contact = isUserPage ? null : appState.chat.contacts.find(c => c.id === profileId);
        const avatarId = isUserPage 
            ? appState.chat.moments.profile.avatarId 
            : (contact?.charSettings.momentsAvatarId || contact?.charSettings.avatarId);

        setElementImage(coverEl, coverId);
        nameEl.textContent = getMomentsDisplayName(profileId);
        signatureEl.textContent = profileData.signature;
        setElementImage(avatarEl, avatarId);

        renderMomentsFeed(profileId);
    }

    const GUAN_YIN_LOTS = [
    { "id": 1, "title": "ç¬¬ä¸€é¦– ä¸Šä¸Š", "poem": "å¼€å¤©è¾Ÿåœ°ä½œè‰¯ç¼˜ï¼Œå‰æ—¥è‰¯æ—¶ä¸‡ç‰©å…¨ï¼›\nè‹¥å¾—æ­¤ç­¾éå°å¯ï¼Œäººè¡Œå¿ æ­£å¸ç‹å®£ã€‚", "interpretation": "é’Ÿç¦»æˆé“ã€‚å¼€å¤©è¾Ÿåœ°ã€‚æ··æ²Œåˆåˆ†ã€‚ä¸€åˆ‡ç”±å§‹ã€‚ä¸‡ç‰©æ›´ç”Ÿã€‚ä»æ­¤æ¸è¿›ã€‚äº‹äº‹å¯å±…ã€‚ç™¾äº‹é¡ºæ˜Œä¹Ÿã€‚æ­¤ç­¾æ˜¯ä¸Šä¸Šå¤§å‰ä¹‹å…†ã€‚", "verse": "å¤©å¼€åœ°è¾Ÿã€‚å‡¡äº‹çš†å‰ã€‚å¯Œè´µè£åã€‚å¤©ç¥ä¿ä½‘ã€‚" },
    { "id": 2, "title": "ç¬¬äºŒé¦– ä¸Šä¸Š", "poem": "é²¸é±¼æœªå˜å®ˆæ±Ÿæ²³ï¼Œä¸å¯å‡è…¾æ›´æœ›é«˜ï¼›\nå¼‚æ—¥å³¥åµ˜èº«å˜åŒ–ï¼Œè®¸å›ä¸€è·ƒè·³é¾™é—¨ã€‚", "interpretation": "å§œå¤ªå…¬æ¸­æ°´é’“é±¼ã€‚é²¸é±¼æœªå˜ã€‚å–»è‹±é›„æœªé‡æ—¶ã€‚å¿…é¡»è¦å®ˆé™ã€‚åˆ™å¯å®‰æ³°ã€‚å€˜è‹¥å¥¢æœ›ã€‚åŠ¨å‡ºå˜å¦ã€‚ä¸€æ—¦é£äº‘é™…ä¼šã€‚ä¸€æ—¥ä¹‹é—´ã€‚å£°èª‰éª¤èµ·ã€‚ à¦¤à¦–à¦¨å›å³å¯ä¸€è·ƒé¾™é—¨ã€‚è·å–åŠŸåã€‚æ­¤ç­¾æœ‰å¤§å™¨æ™šæˆä¹‹å…†ã€‚", "verse": "å¾—å¿ä¸”å¿ã€‚å¾—è€ä¸”è€ã€‚é¡»å¾…æ—¶è‡³ã€‚åŠŸåè¿˜åœ¨ã€‚" },
    { "id": 3, "title": "ç¬¬ä¸‰é¦– ä¸­å¹³", "poem": "ä¸´é£å†’é›¨å»è¿˜ä¹¡ï¼Œæ­£æ˜¯å…¶èº«ä¼¼ç‡•å„¿ï¼›\nè¡”å¾—æ³¥æ¥å‘ˆä¸»äººï¼Œè°çŸ¥å’å°±åˆé¢ è¦†ã€‚", "interpretation": "ç‡•å­è¡”æ³¥ã€‚æ­¤ç­¾ä¸»æœ‰å°äººä¾µå®³ã€‚ç‡•å­è¡”æ³¥ã€‚è¾›è‹¦ç­‘å·¢ã€‚ä¸€æ—¦è¢«äººç ´åã€‚å‰åŠŸå°½å¼ƒã€‚å–»æ˜¯æ˜¯ééã€‚å‡¡äº‹éš¾æˆã€‚åŠ¡å¿…æé˜²å°äººã€‚æ­¤ç­¾å‡¡äº‹å®œæ…ä¹‹ã€‚", "verse": "åƒèˆ¬ç”¨è®¡ã€‚æ™¨æ˜ä¸åœã€‚è°çŸ¥æ­¤äº‹ã€‚åˆ°åº•æ— æˆã€‚" },
    { "id": 4, "title": "ç¬¬å››é¦– ä¸Šä¸Š", "poem": "åƒå¹´å¤é•œå¤é‡åœ†ï¼Œå¥³å†æ±‚å¤«ç”·å†å©šï¼›\nè‡ªæ­¤é—¨åº­é‡æ”¹æ¢ï¼Œæ›´æ·»ç¦ç¦„ä¸å„¿å­™ã€‚", "interpretation": "ç‹ç¥¥å§å†°ã€‚åƒå¹´å¤é•œã€‚ç ´é•œé‡åœ†ä¹‹å…†ã€‚æ­¤ç­¾ä¸»æœ‰æƒ…äººç»ˆæˆçœ·å±ã€‚å¤±æ•£è€…ç»ˆæœ‰å›¢åœ†ä¹‹æ—¥ã€‚å‡¡äº‹é¡ºå¿ƒã€‚å¤§å‰å¤§åˆ©ã€‚", "verse": "æ·˜æ²™è§é‡‘ã€‚å‰–çŸ³è§ç‰ã€‚åˆ°åº•æœ‰æˆã€‚å¦å¤–å¤åˆã€‚" },
    { "id": 5, "title": "ç¬¬äº”é¦– ä¸­å¹³", "poem": "ä¸€é”„æ˜åœ°è¦æ±‚æ³‰ï¼ŒåŠªåŠ›æ±‚ä¹‹å¾—æœ€å…ˆï¼›\næ— æ„ä¿„ç„¶é‡çŸ¥å·±ï¼Œç›¸é€¢æºæ‰‹ä¸Šé’å¤©ã€‚", "interpretation": "åˆ˜æ™¨é‡ä»™ã€‚æ­¤ç­¾ä¸»æœ‰æ„å¤–ä¹‹å–œã€‚ä¸€é”„æ˜åœ°ã€‚å–»å‹¤åŠ³ã€‚åŠªåŠ›ã€‚ç»ˆæœ‰æ”¶è·ã€‚æ— æ„ä¸­ã€‚å¶ç„¶é‡åˆ°çŸ¥éŸ³ã€‚æºæ‰‹åˆä½œã€‚å…±åˆ›å‰é€”ã€‚æ­¤ç­¾å…ˆéš¾åæ˜“ã€‚å‡¡äº‹å¯æˆã€‚", "verse": "æ¬²æœ›å¿ƒäº‹ã€‚è¥¿æ–¹å¯æ±‚ã€‚ä¸å¦‚è«åŠ¨ã€‚ç«‹åœ°å¯è°‹ã€‚" },
    { "id": 6, "title": "ç¬¬å…­é¦– ä¸­å¹³", "poem": "æŠ•èº«å²©ä¸‹é“œé¸Ÿå±…ï¼Œé¡»æ˜¯è¿˜ä»–å¤§ä¸ˆå¤«ï¼›\næ‹¾å¾—è¥è°‹è°å¯å¾—ï¼Œé€šè¡Œå¤©åœ°æ­¤äººæ— ã€‚", "interpretation": "ä»è´µæŠ•å†›ã€‚æ­¤ç­¾ä¸»æœ‰å¥‡é‡ã€‚æŠ•èº«å²©ä¸‹ã€‚é“œé¸Ÿå±…ã€‚å–»é™©å¢ƒä¹‹ä¸­ã€‚å¿…æœ‰ç”Ÿæœºã€‚å¤§ä¸ˆå¤«ã€‚æŒ‡æœ‰æ‰å¾·ä¹‹äººã€‚æ‹¾å¾—è¥è°‹ã€‚æŒ‡äº‹ä¸šæœ‰æˆã€‚æ­¤ç­¾æœ‰å…ˆå‡¶åå‰ä¹‹å…†ã€‚", "verse": "é£Ÿç”¨æ— é±¼ã€‚èº«æ¸…å–œè´«ã€‚å¾…å¾—æ˜¥æ¥ã€‚æ¯æœ¨é‡ç”Ÿã€‚" },
    { "id": 7, "title": "ç¬¬ä¸ƒé¦– ä¸‹ä¸‹", "poem": "å¥”æ³¢å½¹å½¹é‡é‡é™©ï¼Œå¸¦æ°´æ‹–æ³¥åˆæ¸¡å±±ï¼›\næ›´è™‘ä»–æ–¹æ±‚åˆ«ç”¨ï¼Œåƒå±±ä¸‡æ°´æœªèƒ½è¿˜ã€‚", "interpretation": "è‹å¨˜èµ°éš¾ã€‚æ­¤ç­¾ä¸»æœ‰é™©é˜»ã€‚å¥”æ³¢åŠ³ç¢Œã€‚æ‹–æ³¥å¸¦æ°´ã€‚æ¸¡å±±æ¶‰æ°´ã€‚å†å°½è‰°è¾›ã€‚å‰é€”èŒ«èŒ«ã€‚æœªçŸ¥ä½•å»ä½•ä»ã€‚æ­¤ç­¾ä¸‹ä¸‹ä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "å±±é«˜æ°´æ·±ã€‚è‰°éš¾é‡é‡ã€‚å‰è¿›é€€åã€‚ä¿±ä¸ºä¸åˆ©ã€‚" },
    { "id": 8, "title": "ç¬¬å…«é¦– ä¸Šä¸Š", "poem": "å¹´æ¥è€•ä½œè‹¦æ— æ”¶ï¼Œä»Šå²ç”°ç•´å®šæœ‰ç§‹ï¼›\nå†µé‡å¤ªå¹³æ— äº‹æ—¥ï¼Œå£«å†œå·¥è´¾ç™¾æ— å¿§ã€‚", "interpretation": "å¤§èˆœè€•ç”°ã€‚æ­¤ç­¾ä¸»è‹¦å°½ç”˜æ¥ã€‚å¹´æ¥è€•ä½œã€‚è‹¦æ— æ‰€è·ã€‚ä»Šå¹´é£è°ƒé›¨é¡ºã€‚äº”è°·ä¸°ç™»ã€‚å£«å†œå·¥å•†ã€‚å„å®‰å…¶ä¸šã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹é¡ºå¿ƒã€‚", "verse": "æ—¶æ¥è¿è½¬ã€‚æ¯æœ¨é€¢æ˜¥ã€‚è°‹æœ›çš†é‚ã€‚å¥½äº‹ä¸´é—¨ã€‚" },
    { "id": 9, "title": "ç¬¬ä¹é¦– ä¸Šä¸Š", "poem": "çƒ¦å›å‹¿ä½œç§å¿ƒäº‹ï¼Œæ­¤æ„åå®œè¯´é—®å…¬ï¼›\nä¸€ç‰‡æ˜å¿ƒå…‰çšæ´ï¼Œå®›å¦‚çšæœˆæ­£å½“ç©ºã€‚", "interpretation": "å­”æ˜ç‚¹å°†ã€‚æ­¤ç­¾ä¸»å…¬æ­£æ— ç§ã€‚çƒ¦å›å‹¿ä½œç§å¿ƒäº‹ã€‚å–»ä¸ºäººè¦å…‰æ˜ç£Šè½ã€‚ä¸€ç‰‡æ˜å¿ƒã€‚çšæ´å¦‚æœˆã€‚å–»å¿ƒåœ°å…‰æ˜ã€‚é¬¼ç¥é’¦æ•¬ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å¿ƒä¸­æ­£ç›´ã€‚ç†é¡ºæ³•å®½ã€‚å¤©æ— ç§æ„ã€‚è«ä½œå¿ƒæ¬ºã€‚" },
    { "id": 10, "title": "ç¬¬åé¦– ä¸­å¹³", "poem": "çŸ³è—ç¾ç‰åœ¨ä¸­å¿ƒï¼Œå¾—æŒ‡ä½•é¡»å‘å¤–å¯»ï¼›\nç›´å¾…é«˜äººæ¥å‰–æï¼Œæ°å¦‚çµé›¨æ¶¤çƒ¦è¥Ÿã€‚", "interpretation": "åå’ŒçŒ®ç‰ã€‚çŸ³ä¸­è—ç‰ã€‚å–»æœ‰æ‰ä¹‹äººã€‚æœªé‡çŸ¥éŸ³ã€‚å¾—äººæŒ‡ç‚¹ã€‚æ–¹èƒ½æ˜¾éœ²ã€‚æ­¤ç­¾ä¸»æœ‰å¾…è€Œå‘ã€‚å‡¡äº‹ä¸å¯æ“ä¹‹è¿‡æ€¥ã€‚", "verse": "å†…è—é‡‘ç‰ã€‚ä¸ä¸ºäººçŸ¥ã€‚æœ‰å¾…é«˜äººã€‚æ–¹èƒ½å‰–æã€‚" },
    { "id": 11, "title": "ç¬¬åä¸€é¦– ä¸Šä¸Š", "poem": "æ¬²æ±‚å¥½äº‹å–œéå¸¸ï¼Œäº‰å¥ˆå§»äº²åªæš‚å¿™ï¼›\næ¯•ç«Ÿåˆ°å¤´æˆå¥½äº‹ï¼Œè´µäººæ¥å¼•è´µäººä¹¡ã€‚", "interpretation": "éŸ©ä¿¡æ‹œå¸…ã€‚æ¬²æ±‚å¥½äº‹ã€‚å–œéå¸¸ã€‚å–»æœ‰å¥½äº‹å°†è¿‘ã€‚äº‰å¥ˆå§»äº²ã€‚åªæš‚å¿™ã€‚å–»äº‹æœ‰é˜»æ»ã€‚æ¯•ç«Ÿåˆ°å¤´ã€‚æˆå¥½äº‹ã€‚å–»æœ€ç»ˆæœ‰æˆã€‚è´µäººæ¥å¼•ã€‚è´µäººä¹¡ã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚", "verse": "å–œäº‹å°†è¿‘ã€‚å¥½äº‹è¿è¿ã€‚è´µäººç›¸åŠ©ã€‚å‰é€”æ— é‡ã€‚" },
    { "id": 12, "title": "ç¬¬åäºŒé¦– ä¸Šä¸Š", "poem": "æ—¶ä¸´å¦ææ³°å½“æ¥ï¼ŒæŠ–æ“ä»å›å‡ºæš—åŸƒï¼›\nè‹¥é‡å¯å¯…ä½³ä¿¡è‡³ï¼Œç®¡æ•™ç«‹å¿—äº‹å’Œè°ã€‚", "interpretation": "æ­¦å‰é‡å¸ˆã€‚å¦ææ³°æ¥ã€‚å–»åè¿å·²è¿‡ã€‚å¥½è¿å°†æ¥ã€‚æŠ–æ“ä»å›ã€‚å‡ºæš—åŸƒã€‚å–»æŒ¯ä½œç²¾ç¥ã€‚è„±ç¦»å›°å¢ƒã€‚å¯å¯…ä½³ä¿¡ã€‚å–»æ—¶æœºä¸€åˆ°ã€‚ä¾¿æœ‰ä½³éŸ³ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹é¡ºå¿ƒã€‚", "verse": "å¦ææ³°æ¥ã€‚æ—¶è¿äº¨é€šã€‚æœ‰å§‹æœ‰ç»ˆã€‚å¤§å‰å¤§åˆ©ã€‚" },
    { "id": 13, "title": "ç¬¬åä¸‰é¦– ä¸­å¹³", "poem": "è‡ªå°ç”Ÿåœ¨å¯Œè´µå®¶ï¼Œçœ¼å‰ä¸‡ç‰©æ€»å¥¢åï¼›\nè’™å›èµç´«é‡‘è…°å¸¦ï¼Œå››æµ·å£°åå®šå¯å¤¸ã€‚", "interpretation": "ç½—é€šæ‹œå¸…ã€‚æ­¤ç­¾ä¸»ååˆ©åŒæ”¶ã€‚è‡ªå°ç”Ÿåœ¨å¯Œè´µå®¶ã€‚å–»æ ¹åŸºæ·±åšã€‚è’™å›èµç´«é‡‘è…°å¸¦ã€‚å–»å¾—è´µäººèµè¯†ã€‚å››æµ·å£°åã€‚å®šå¯å¤¸ã€‚å–»åŠŸæˆåå°±ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "å‡ºå…¥è£åã€‚å‰é€”äº‹ä¸šã€‚å¤§æœ‰å¯ä¸ºã€‚å è€…å¤§å‰ã€‚" },
    { "id": 14, "title": "ç¬¬åå››é¦– ä¸‹ä¸‹", "poem": "å®›å¦‚ä»™é¹¤å‡ºæ¨Šç¬¼ï¼Œè„±å¾—æ¨Šç¬¼è·¯ä¸é€šï¼›\nå—åŒ—ä¸œè¥¿æ— ä¸€å®šï¼Œæ­¤èº«æ†”æ‚´æ¨æ— ç©·ã€‚", "interpretation": "å­ç‰™å¼ƒå®˜ã€‚æ­¤ç­¾ä¸»æœ‰é™©é˜»ã€‚ä»™é¹¤å‡ºæ¨Šç¬¼ã€‚å–»è„±ç¦»å›°å¢ƒã€‚è·¯ä¸é€šã€‚å–»å‰é€”å—é˜»ã€‚å—åŒ—ä¸œè¥¿ã€‚æ— ä¸€å®šã€‚å–»æ¼‚æ³Šä¸å®šã€‚æ­¤ç­¾ä¸‹ä¸‹ä¹‹å…†ã€‚å‡¡äº‹ä¸é¡ºã€‚", "verse": "è¿›é€€ä¸¤éš¾ã€‚å¥½äº‹éš¾æˆã€‚å£èˆŒæ˜¯éã€‚åœ¨æ‰€éš¾å…ã€‚" },
    { "id": 15, "title": "ç¬¬åäº”é¦– ä¸­å¹³", "poem": "è§¦äººå£æ°”æœ€éš¾åï¼Œå¿½æœ‰ç¾å±ç¥¸åˆ°é—¨ï¼›\nåµç ´å·¢ç©ºæ— ä¸€ç‰©ï¼Œè°çŸ¥å¥½äº‹ä¸ç›¸å­˜ã€‚", "interpretation": "è‹ç§¦å¾—å¿—ã€‚æ­¤ç­¾ä¸»æœ‰å£èˆŒæ˜¯éã€‚è§¦äººå£æ°”ã€‚æœ€éš¾åã€‚å–»æ˜“ä¸äººå‘ç”Ÿäº‰æ‰§ã€‚åµç ´å·¢ç©ºã€‚æ— ä¸€ç‰©ã€‚å–»ä¸¤è´¥ä¿±ä¼¤ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå’Œä¸ºè´µã€‚", "verse": "å¾—å¿ä¸”å¿ã€‚å¾—è€ä¸”è€ã€‚å‡¡äº‹ä»é•¿è®¡è®®ã€‚æ–¹èƒ½æœ‰æˆã€‚" },
    { "id": 16, "title": "ç¬¬åå…­é¦– ä¸­å¹³", "poem": "å®˜äº‹æ‚ æ‚ éš¾è¾¨æ˜ï¼Œä¸å¦‚æ¯äº†ä¸”å½’è€•ï¼›\nå‚äººç…½æƒ‘å›ä¼‘ä¿¡ï¼Œæ­¤äº‹å½“è°‹äº²å¼Ÿå…„ã€‚", "interpretation": "ç‹ç¥¥å§å†°æ±‚é²¤ã€‚æ­¤ç­¾ä¸»æœ‰å®˜éã€‚å®˜äº‹æ‚ æ‚ ã€‚éš¾è¾¨æ˜ã€‚å–»å®˜å¸ç¼ èº«ã€‚éš¾æœ‰ç»“æœã€‚ä¸å¦‚æ¯äº†ã€‚ä¸”å½’è€•ã€‚å–»é€€ä¸€æ­¥æµ·é˜”å¤©ç©ºã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "é€€ä¸€æ­¥æµ·é˜”å¤©ç©ºã€‚å‡¡äº‹ä¸‰æ€è€Œåè¡Œã€‚" },
    { "id": 17, "title": "ç¬¬åä¸ƒé¦– ä¸­å¹³", "poem": "è«å¬é—²è¨€è¯´æ˜¯éï¼Œæ™¨æ˜åªå¥½å¿µé˜¿å¼¥ï¼›\nè‹¥å°†å¦„è¯­ä¸ºçœŸå®ï¼Œç”»é¥¼å¦‚ä½•ç–—å¾—é¥¥ã€‚", "interpretation": "ææ–¯é—è¯ã€‚æ­¤ç­¾ä¸»æœ‰å°äººã€‚è«å¬é—²è¨€ã€‚è¯´æ˜¯éã€‚å–»å‹¿ä¿¡è°£è¨€ã€‚ç”»é¥¼å……é¥¥ã€‚å–»ç©ºæƒ³æ— ç›Šã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "é—²è¨€è«å¬ã€‚æ˜¯éè«è¾©ã€‚è„šè¸å®åœ°ã€‚æ–¹èƒ½æœ‰æˆã€‚" },
    { "id": 18, "title": "ç¬¬åå…«é¦– ä¸Šä¸Š", "poem": "é‡‘ä¹Œè¥¿å å…”ä¸œå‡ï¼Œæ—¥å¤œå¾ªç¯è‡³å¤ä»Šï¼›\nåƒ§é“å¾—çŸ¥æ— ä¸åˆ©ï¼Œå£«å†œå·¥è´¾ç™¾äº‹äº¨ã€‚", "interpretation": "æ›¹å›½èˆ…ä¸ºä»™ã€‚æ­¤ç­¾ä¸»æ—¶æ¥è¿è½¬ã€‚é‡‘ä¹Œè¥¿å ã€‚å…”ä¸œå‡ã€‚å–»æ—¥å¤œå¾ªç¯ã€‚ç”Ÿç”Ÿä¸æ¯ã€‚åƒ§é“å¾—çŸ¥ã€‚æ— ä¸åˆ©ã€‚å–»å„è¡Œå„ä¸šã€‚çš†å¾—å…¶åˆ©ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹äº¨é€šã€‚", "verse": "å¦å»æ³°æ¥ã€‚ä¸‡äº‹äº¨é€šã€‚ååˆ©åŒæ”¶ã€‚å¥½äº‹è¿è¿ã€‚" },
    { "id": 19, "title": "ç¬¬åä¹é¦– ä¸­å¹³", "poem": "æ€¥æ°´æ»©å¤´æ”¾è‰‡æ—¶ï¼Œç‹‚é£ä½œæµªæ¬²ä½•ä¸ºï¼›\nå¾…ä»–æµªé™é£åœåï¼Œç¨³è½½èˆ¹å½’è¿‡åœ£æ¶¯ã€‚", "interpretation": "å­ä»ªå°ç‹ã€‚æ­¤ç­¾ä¸»æœ‰æƒŠæ— é™©ã€‚æ€¥æ°´æ»©å¤´ã€‚æ”¾è‰‡æ—¶ã€‚å–»å¤„å¢ƒå±é™©ã€‚ç‹‚é£ä½œæµªã€‚æ¬²ä½•ä¸ºã€‚å–»å›°éš¾é‡é‡ã€‚å¾…ä»–æµªé™ã€‚é£åœåã€‚å–»é›¨è¿‡å¤©æ™´ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å…ˆéš¾åæ˜“ã€‚", "verse": "é™ä¸­å¾…æ—¶ã€‚å‡¡äº‹å®‰ç¨³ã€‚åŠ¨åˆ™æœ‰æŸã€‚é™åˆ™æ— å¿§ã€‚" },
    { "id": 20, "title": "ç¬¬äºŒåé¦– ä¸Šä¸Š", "poem": "å½“æ˜¥ä¹…é›¨å–œåˆæ™´ï¼Œç‰å…”é‡‘ä¹Œæ¸æ¸æ˜ï¼›\næ—§äº‹å·²æˆæ–°äº‹é‚ï¼Œçœ‹çœ‹ä¸€è·³å…¥è“¬ç€›ã€‚", "interpretation": "å§œå¤ªå…¬é‡æ–‡ç‹ã€‚æ­¤ç­¾ä¸»è‹¦å°½ç”˜æ¥ã€‚ä¹…é›¨åˆæ™´ã€‚å–»å›°å¢ƒå·²è¿‡ã€‚ç‰å…”é‡‘ä¹Œã€‚æ¸æ¸æ˜ã€‚å–»å‰é€”å…‰æ˜ã€‚æ—§äº‹å·²æˆã€‚æ–°äº‹é‚ã€‚å–»äº‹äº‹é¡ºå¿ƒã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "ç¥ä½›æŠ¤æŒã€‚æœ‰ç¾æ— å±ã€‚é€”è™½é™©é˜»ã€‚ç»ˆè·ä½³éŸ³ã€‚" },
    { "id": 21, "title": "ç¬¬äºŒåä¸€é¦– ä¸Šä¸Š", "poem": "é˜´é˜³é“åˆæ€»ç”±å¤©ï¼Œå¥³å«ç”·å©šå–œè‡ªç„¶ï¼›\nä½†è§é¾™è›‡ç›¸ä¼šåˆï¼Œç†Šç½´å…¥æ¢¦ä¹å›¢åœ†ã€‚", "interpretation": "ææ—¦é¾™å‡¤é…åˆã€‚æ­¤ç­¾ä¸»å©šå§»å‰ã€‚é˜´é˜³é“åˆã€‚æ€»ç”±å¤©ã€‚å–»å¤©ä½œä¹‹åˆã€‚å¥³å«ç”·å©šã€‚å–œè‡ªç„¶ã€‚å–»å©šå§»ç¾æ»¡ã€‚é¾™è›‡ç›¸ä¼šã€‚ç†Šç½´å…¥æ¢¦ã€‚çš†ä¸ºå‰å…†ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "è°‹æœ›ä»å¿ƒã€‚å©šå§»å­•ç”·ã€‚èµ„è´¢è¿›ç›Šã€‚æ›´åˆ©ç”°èš•ã€‚" },
    { "id": 22, "title": "ç¬¬äºŒåäºŒé¦– ä¸Šä¸Š", "poem": "å››éƒŠç”°äº©çš†æ¯ç«­ï¼Œä¹…æ—±ä¿„ç„¶ä¸‰æ—¥éœ–ï¼›\nèŠ±æœè‰èŠ½ä¿±æ¶¦æ³½ï¼Œå§‹çŸ¥ä¸€é›¨å€¼åƒé‡‘ã€‚", "interpretation": "ç‹å­å…ˆä¸ºæ°‘ç¥ˆç¥·ã€‚æ­¤ç­¾ä¸»æœ‰ç”˜éœ–ä¹‹å…†ã€‚ä¹…æ—±é€¢ç”˜é›¨ã€‚å–»å›°å¢ƒä¸­ã€‚å¾—è´µäººç›¸åŠ©ã€‚èŠ±æœè‰èŠ½ã€‚ä¿±æ¶¦æ³½ã€‚å–»ä¸‡ç‰©å¤è‹ã€‚ç”Ÿæœºå‹ƒå‹ƒã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "ç”°ç¦¾å€æ”¶ã€‚è°‹æœ›ç›¸å®œã€‚ç—…é€¢å¦™è¯ã€‚è½¬å±ä¸ºå®‰ã€‚" },
    { "id": 23, "title": "ç¬¬äºŒåä¸‰é¦– ä¸­å¹³", "poem": "æ¬²æ‰³ä»™æ¡‚å…¥èŸ¾å®«ï¼Œæ™®å¼€å¤©é—¨ä¸ä»»å›ï¼›\nå¿½é‡ä¸€èˆ¬éŸ³ä¿¡å¥½ï¼Œäººäººçš†ç¬‘å²­é¡¶èŠ±ã€‚", "interpretation": "æ€€å¾·æ‹›äº²ã€‚æ­¤ç­¾ä¸»æœ‰é˜»æ»ã€‚æ¬²æ‰³ä»™æ¡‚ã€‚å…¥èŸ¾å®«ã€‚å–»æƒ³æœ‰æˆå°±ã€‚æ™®å¼€å¤©é—¨ã€‚ä¸ä»»å›ã€‚å–»æ—¶æœºæœªåˆ°ã€‚å¿½é‡ä¸€èˆ¬ã€‚éŸ³ä¿¡å¥½ã€‚å–»æœ‰è½¬æœºã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå¾…æ—¶è€ŒåŠ¨ã€‚", "verse": "å•†è´¾åˆ©ç›Šã€‚è¡Œè—æœ‰å±ã€‚ç—…å®‰è®¼ç†ã€‚å°½å¯æ–½ä¸ºã€‚" },
    { "id": 24, "title": "ç¬¬äºŒåå››é¦– ä¸­å¹³", "poem": "ä¸æˆé‚»é‡Œä¸æˆå®¶ï¼Œæ°´æ³¡ç—´äººä¼¼è½èŠ±ï¼›\nè‹¥é—®å›æ©é¡»å¾—åŠ›ï¼Œåˆ°å¤´æ–¹è§äº‹å¦‚éº»ã€‚", "interpretation": "å¼ éªè¯¯å…¥æ–—ç‰›å®«ã€‚æ­¤ç­¾ä¸»æœ‰æ˜¯éã€‚ä¸æˆé‚»é‡Œã€‚ä¸æˆå®¶ã€‚å–»äººé™…å…³ç³»ä¸ä½³ã€‚æ°´æ³¡ç—´äººã€‚ä¼¼è½èŠ±ã€‚å–»è™šå¹»ä¸å®ã€‚åˆ°å¤´æ–¹è§ã€‚äº‹å¦‚éº»ã€‚å–»çº çº·ä¸æ–­ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå’Œä¸ºè´µã€‚", "verse": "è¥è°‹éš¾æˆã€‚å†µå¤šé˜»ç¢ã€‚ç”°èš•ä¸ç†Ÿã€‚ä½•é—®è·è´¢ã€‚" },
    { "id": 25, "title": "ç¬¬äºŒåäº”é¦– ä¸­å¹³", "poem": "è¿‡äº†å¿§å±äº‹å‡ é‡ï¼Œä»ä»Šå†ç«‹æ°¸æ— å‡¶ï¼›\nå®½å¿ƒè‡ªæœ‰å®½å¿ƒè®¡ï¼Œå¾—é‡é«˜äººç«‹å¤§åŠŸã€‚", "interpretation": "å§šèƒ½å—èŒã€‚æ­¤ç­¾ä¸»æœ‰è´µäººã€‚è¿‡äº†å¿§å±ã€‚äº‹å‡ é‡ã€‚å–»å†ç»ç£¨éš¾ã€‚ä»ä»Šå†ç«‹ã€‚æ°¸æ— å‡¶ã€‚å–»æ—¶æ¥è¿è½¬ã€‚å¾—é‡é«˜äººã€‚ç«‹å¤§åŠŸã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚äº‹ä¸šæœ‰æˆã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "ç¾å»ç¦æ¥ã€‚æ±‚å®˜å¾—ä½ã€‚æ±‚è´¢é‚æ„ã€‚å©šå§»æˆå¯¹ã€‚" },
    { "id": 26, "title": "ç¬¬äºŒåå…­é¦– ä¸­å¹³", "poem": "ä¸Šä¸‹ä¼ æ¥äº‹æ€»è™šï¼Œå¤©è¾¹æ¥å¾—ä¸€å°ä¹¦ï¼›\nä¹¦ä¸­è®¸æˆ‘åŠŸåé‚ï¼Œç›´åˆ°ç»ˆæ—¶äº¦æ˜¯è™šã€‚", "interpretation": "é’Ÿé¦—å¾—é“ã€‚æ­¤ç­¾ä¸»æœ‰è™šåã€‚ä¸Šä¸‹ä¼ æ¥ã€‚äº‹æ€»è™šã€‚å–»æ¶ˆæ¯ä¸å®ã€‚å¤©è¾¹æ¥å¾—ã€‚ä¸€å°ä¹¦ã€‚å–»æœ‰å¸Œæœ›ã€‚ç›´åˆ°ç»ˆæ—¶ã€‚äº¦æ˜¯è™šã€‚å–»ç©ºæ¬¢å–œä¸€åœºã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹ä¸å¯è½»ä¿¡ã€‚", "verse": "å®ä¸­å˜è™šã€‚è™šä¸­å˜å®ã€‚æœ‰æ— çš†ç„¶ã€‚è¦çœ‹æ—¶æ—¥ã€‚" },
    { "id": 27, "title": "ç¬¬äºŒåä¸ƒé¦– ä¸­å¹³", "poem": "ä¸€è°‹ä¸€ç”¨ä¸€ç•ªæœºï¼Œè™‘åæ€å‰ä¸æ•¢ä¸ºï¼›\næ—¶åˆ°è´µäººç›¸å¼•èï¼Œå¦‚é¾™æ¸…æ°´å¾—è¿æ—¶ã€‚", "interpretation": "åˆ˜åŸºè°ä¸»ã€‚æ­¤ç­¾ä¸»æœ‰å¾…è€Œå‘ã€‚ä¸€è°‹ä¸€ç”¨ã€‚ä¸€ç•ªæœºã€‚å–»æ·±æ€ç†Ÿè™‘ã€‚è™‘åæ€å‰ã€‚ä¸æ•¢ä¸ºã€‚å–»çŠ¹è±«ä¸å†³ã€‚æ—¶åˆ°è´µäººã€‚ç›¸å¼•èã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå¾…æ—¶è€ŒåŠ¨ã€‚", "verse": "å¦‚é¾™å¾—æ°´ã€‚äº‘è¡Œé›¨æ–½ã€‚åˆ©ç›Šæœ‰æˆã€‚è°‹æœ›çš†é‚ã€‚" },
    { "id": 28, "title": "ç¬¬äºŒåå…«é¦– ä¸Šä¸Š", "poem": "ä¸œæ–¹æœˆä¸Šæ­£å©µå¨Ÿï¼Œé¡·åˆ»äº‘é®äº¦æš—å­˜ï¼›\næˆ–æœ‰å°äººæ¥å®µå¦’ï¼Œå¹³å¸¸å°šèƒ½è·å›¢åœ†ã€‚", "interpretation": "æåå¯»åŒ…å…¬ã€‚æ­¤ç­¾ä¸»æœ‰å°äººã€‚ä¸œæ–¹æœˆä¸Šã€‚æ­£å©µå¨Ÿã€‚å–»å¥½äº‹å°†è¿‘ã€‚é¡·åˆ»äº‘é®ã€‚äº¦æš—å­˜ã€‚å–»æœ‰å°äººä½œç¥Ÿã€‚å¹³å¸¸å°šèƒ½ã€‚è·å›¢åœ†ã€‚å–»æœ‰æƒŠæ— é™©ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹æœ‰æƒŠæ— é™©ã€‚", "verse": "è™½æœ‰å°äººã€‚ç»ˆç©¶æ— ç¢ã€‚ä½³éŸ³å°†è‡³ã€‚å¥½äº‹å¯å¾…ã€‚" },
    { "id": 29, "title": "ç¬¬äºŒåä¹é¦– ä¸Šä¸Š", "poem": "å®å‰‘å‡ºåŒ£è€€å…‰æ˜ï¼Œåœ¨åŒ£å…¨ç„¶ä¸æƒ¹å°˜ï¼›\nä»Šå¾—è´µäººæºå‡ºç°ï¼Œæœ‰å¨æœ‰åŠ¿ä¼—äººé’¦ã€‚", "interpretation": "èµµå­é¾™æ•‘ä¸»ã€‚æ­¤ç­¾ä¸»æœ‰è´µäººã€‚å®å‰‘å‡ºåŒ£ã€‚è€€å…‰æ˜ã€‚å–»æ‰åæ˜¾éœ²ã€‚ä»Šå¾—è´µäººã€‚æºå‡ºç°ã€‚å–»å¾—è´µäººèµè¯†ã€‚æœ‰å¨æœ‰åŠ¿ã€‚ä¼—äººé’¦ã€‚å–»åŠŸæˆåå°±ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å®å‰‘å‡ºåŒ£ã€‚å…‰èŠ’ä¸‡ä¸ˆã€‚è´µäººç›¸åŠ©ã€‚å‰é€”æ— é‡ã€‚" },
    { "id": 30, "title": "ç¬¬ä¸‰åé¦– ä¸­å¹³", "poem": "åŠå›åˆ‡è«å‘ä»–æ±‚ï¼Œä¼¼é¹¤é£æ¥æš—ç®­æŠ•ï¼›\nè‹¥å»é‡‡è–ªè›‡åœ¨è‰ï¼Œæé­æ¯’å£ä¹Ÿå¿§æ„ã€‚", "interpretation": "æ£‹ç›˜å¤§ä¼šã€‚æ­¤ç­¾ä¸»æœ‰å°äººã€‚åŠå›åˆ‡è«ã€‚å‘ä»–æ±‚ã€‚å–»å‹¿æ±‚äºäººã€‚ä¼¼é¹¤é£æ¥ã€‚æš—ç®­æŠ•ã€‚å–»æœ‰æš—ç®—ã€‚è‹¥å»é‡‡è–ªã€‚è›‡åœ¨è‰ã€‚å–»æœ‰å±é™©ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "é—²è¨€è«å¬ã€‚æ˜¯éè«è¾©ã€‚è„šè¸å®åœ°ã€‚æ–¹èƒ½æœ‰æˆã€‚" },
    { "id": 31, "title": "ç¬¬ä¸‰åä¸€é¦– ä¸­å¹³", "poem": "æ¸…é—²æ— äº‹é™å¤„åï¼Œé¥¥æ—¶åƒé¥­å›°æ—¶å§ï¼›\næ”¾ä¸‹èº«å¿ƒä¸ç”¨å¿™ï¼Œå¿…å®šä¸æ‹›å†¤ä¸ç¥¸ã€‚", "interpretation": "ä½›å°ä¼šä¸œå¡ã€‚æ­¤ç­¾ä¸»å®‰é—²ã€‚æ¸…é—²æ— äº‹ã€‚é™å¤„åã€‚å–»ä¸ä¸–æ— äº‰ã€‚é¥¥æ—¶åƒé¥­ã€‚å›°æ—¶å§ã€‚å–»é¡ºå…¶è‡ªç„¶ã€‚æ”¾ä¸‹èº«å¿ƒã€‚ä¸ç”¨å¿™ã€‚å–»å¿ƒæ€å¹³å’Œã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºå…¶è‡ªç„¶ã€‚", "verse": "å®ˆå·±å®‰åˆ†ã€‚å‡¡äº‹å®‰ç¨³ã€‚åŠ¨åˆ™æœ‰æŸã€‚é™åˆ™æ— å¿§ã€‚" },
    { "id": 32, "title": "ç¬¬ä¸‰åäºŒé¦– ä¸Šä¸Š", "poem": "é¾™æ¸¸æµ…æ°´é­è™¾æˆï¼Œè™è½å¹³é˜³è¢«çŠ¬æ¬ºï¼›\nå¾—å¿—çŒ«å„¿é›„ä¼¼è™ï¼Œè´¥ç¿é¹¦é¹‰ä¸å¦‚é¸¡ã€‚", "interpretation": "å‘¨ç‘œä¸‹æ±Ÿå—ã€‚æ­¤ç­¾ä¸»æœ‰å›°å¢ƒã€‚é¾™æ¸¸æµ…æ°´ã€‚è™è½å¹³é˜³ã€‚å–»è‹±é›„å¤±åŠ¿ã€‚å¾—å¿—çŒ«å„¿ã€‚é›„ä¼¼è™ã€‚å–»å°äººå¾—å¿—ã€‚è´¥ç¿é¹¦é¹‰ã€‚ä¸å¦‚é¸¡ã€‚å–»å¤±åŠ¿ä¹‹äººã€‚ä¸å¦‚å¸¸äººã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å®œå¿è€ã€‚", "verse": "é¾™è™å¤±åŠ¿ã€‚æš‚æ—¶å¿è€ã€‚å¾…æ—¶è€ŒåŠ¨ã€‚å¿…æœ‰ä½œä¸ºã€‚" },
    { "id": 33, "title": "ç¬¬ä¸‰åä¸‰é¦– ä¸Šä¸Š", "poem": "å†…è—æ— ä»·å®å’Œçï¼Œå¾—ç‰ä½•é¡»å¤–ç•Œå¯»ï¼›\nä¸å¦‚ç­‰å¾…é«˜äººè¯†ï¼Œå®½å¿ƒçŠ¹ä¸”æ›´å®½å¿ƒã€‚", "interpretation": "å’¬é‡‘è˜ä»è´µã€‚æ­¤ç­¾ä¸»æœ‰è´µäººã€‚å†…è—æ— ä»·å®ã€‚å–»æœ‰æ‰ä¹‹äººã€‚å¾—ç‰ä½•é¡»ã€‚å¤–ç•Œå¯»ã€‚å–»ä¸å¿…å¤–æ±‚ã€‚ä¸å¦‚ç­‰å¾…ã€‚é«˜äººè¯†ã€‚å–»å¾—è´µäººèµè¯†ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹é¡ºå¿ƒã€‚", "verse": "å†…è—é‡‘ç‰ã€‚ä¸ä¸ºäººçŸ¥ã€‚æœ‰å¾…é«˜äººã€‚æ–¹èƒ½å‰–æã€‚" },
    { "id": 34, "title": "ç¬¬ä¸‰åå››é¦– ä¸­å¹³", "poem": "æ˜¥å¤æ‰è¿‡ç§‹åˆå†¬ï¼Œçº·çº·è°‹è™‘æ…å¿ƒèƒ¸ï¼›\nè´µäººå‚æ‰‹æ¥ç›¸æ´ï¼Œä¼‘æŠŠç§å¿ƒæƒ…æ„æµ“ã€‚", "interpretation": "è§ä½•è¿½éŸ©ä¿¡ã€‚æ­¤ç­¾ä¸»æœ‰è´µäººã€‚æ˜¥å¤æ‰è¿‡ã€‚ç§‹åˆå†¬ã€‚å–»æ—¶è¿ä¸æµã€‚çº·çº·è°‹è™‘ã€‚æ…å¿ƒèƒ¸ã€‚å–»å¿ƒçƒ¦æ„ä¹±ã€‚è´µäººå‚æ‰‹ã€‚æ¥ç›¸æ´ã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "è´µäººç›¸åŠ©ã€‚æ—¶æ¥è¿è½¬ã€‚å‡¡äº‹é¡ºå¿ƒã€‚å¤§å‰å¤§åˆ©ã€‚" },
    { "id": 35, "title": "ç¬¬ä¸‰åäº”é¦– ä¸Šä¸Š", "poem": "è¡£å† æ•´é½æ—§å®¶é£ï¼Œé“åœ¨è´¤ä¹¦è¯—ç¤¼ä¸­ï¼›\nä¸€ç‰‡ä¸¹å¿ƒæœ¬åœ°å–„ï¼Œäº¨é€šç”±æ˜¯è¾¾å¤©èªã€‚", "interpretation": "ç‹æ›¾ç¥ˆç¥·ã€‚æ­¤ç­¾ä¸»æœ‰ç¦å¾·ã€‚è¡£å† æ•´é½ã€‚æ—§å®¶é£ã€‚å–»å®¶ä¸–è‰¯å¥½ã€‚é“åœ¨è´¤ä¹¦ã€‚è¯—ç¤¼ä¸­ã€‚å–»å“å¾·é«˜å°šã€‚ä¸€ç‰‡ä¸¹å¿ƒã€‚æœ¬åœ°å–„ã€‚å–»å¿ƒåœ°å–„è‰¯ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å¿ƒåœ°å–„è‰¯ã€‚ç¥ä½›æŠ¤ä½‘ã€‚å‡¡äº‹é¡ºå¿ƒã€‚å¤§å‰å¤§åˆ©ã€‚" },
    { "id": 36, "title": "ç¬¬ä¸‰åå…­é¦– ä¸­å¹³", "poem": "çœ¼å‰ç—…è®¼ä¸é¡»å¿§ï¼Œå®é¼é‡ç‚¼é‡‘ä¸¹å°±ï¼›\nä»æ­¤å‡è…¾è¿˜æ•…æ—§ï¼Œæ—¶äººé’¦ä»°æœ‰æ¥ç”±ã€‚", "interpretation": "æ¹˜å­é‡å®¾ã€‚æ­¤ç­¾ä¸»æœ‰è½¬æœºã€‚çœ¼å‰ç—…è®¼ã€‚ä¸é¡»å¿§ã€‚å–»å›°éš¾å°†è¿‡ã€‚å®é¼é‡ç‚¼ã€‚é‡‘ä¸¹å°±ã€‚å–»é‡æ•´æ——é¼“ã€‚ä»æ­¤å‡è…¾ã€‚è¿˜æ•…æ—§ã€‚å–»äº‹ä¸šæœ‰æˆã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹æœ‰è½¬æœºã€‚", "verse": "æ—¶æ¥è¿è½¬ã€‚æ¯æœ¨é€¢æ˜¥ã€‚è°‹æœ›çš†é‚ã€‚å¥½äº‹ä¸´é—¨ã€‚" },
    { "id": 37, "title": "ç¬¬ä¸‰åä¸ƒé¦– ä¸­å¹³", "poem": "ç„šé¦™æ¥å‘Šå¤ä½•è¾ï¼Œå–„æ¶å¹³åˆ†æ±è‡ªçŸ¥ï¼›\nå±å´æ˜§å…¬å¿ƒé‡Œé¢ï¼Œæ‰§é­å‰å¼•æ˜¾å¨ä»ªã€‚", "interpretation": "æé–å½’å±±ã€‚æ­¤ç­¾ä¸»æœ‰ç¥åŠ©ã€‚ç„šé¦™æ¥å‘Šã€‚å¤ä½•è¾ã€‚å–»è¯šå¿ƒç¥ˆç¥·ã€‚å–„æ¶å¹³åˆ†ã€‚æ±è‡ªçŸ¥ã€‚å–»å–„æœ‰å–„æŠ¥ã€‚å±å´æ˜§å…¬ã€‚å¿ƒé‡Œé¢ã€‚å–»å¿ƒåœ°å…‰æ˜ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "å–„æœ‰å–„æŠ¥ã€‚æ¶æœ‰æ¶æŠ¥ã€‚ä¸æ˜¯ä¸æŠ¥ã€‚æ—¶è¾°æœªåˆ°ã€‚" },
    { "id": 38, "title": "ç¬¬ä¸‰åå…«é¦– ä¸­å¹³", "poem": "æœˆç…§å¤©ä¹¦é™å¤„æœŸï¼Œå¿½é­äº‘é›¾åˆæ˜è¿·ï¼›\nå®½å¿ƒç¥ˆå¾…äº‘éœæ•£ï¼Œæ­¤æ—¶æ›´æ”¹å¥½æ–½ä¸ºã€‚", "interpretation": "ä½•æ–‡ç§€é‡éš¾ã€‚æ­¤ç­¾ä¸»æœ‰é˜»æ»ã€‚æœˆç…§å¤©ä¹¦ã€‚é™å¤„æœŸã€‚å–»æ—¶æœºæœªåˆ°ã€‚å¿½é­äº‘é›¾ã€‚åˆæ˜è¿·ã€‚å–»æœ‰é˜»ç¢ã€‚å®½å¿ƒç¥ˆå¾…ã€‚äº‘éœæ•£ã€‚å–»å¾…æ—¶è€ŒåŠ¨ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå¾…æ—¶è€ŒåŠ¨ã€‚", "verse": "é™ä¸­å¾…æ—¶ã€‚å‡¡äº‹å®‰ç¨³ã€‚åŠ¨åˆ™æœ‰æŸã€‚é™åˆ™æ— å¿§ã€‚" },
    { "id": 39, "title": "ç¬¬ä¸‰åä¹é¦– ä¸­å¹³", "poem": "å¤©è¾¹æ¶ˆæ¯åº”éš¾é—®ï¼Œåˆ‡è«ç§å¿ƒå¼ºæœ›æ±‚ï¼›\nè‹¥æŠŠçŸ³å¤´ç£¨ä½œé•œï¼Œç²¾ç¥æ‰è´¹ä¸€æ—¶ä¼‘ã€‚", "interpretation": "å¤©ä»™é€å­ã€‚æ­¤ç­¾ä¸»æœ‰è™šæœ›ã€‚å¤©è¾¹æ¶ˆæ¯ã€‚åº”éš¾é—®ã€‚å–»å¸Œæœ›æ¸ºèŒ«ã€‚åˆ‡è«ç§å¿ƒã€‚å¼ºæœ›æ±‚ã€‚å–»å‹¿å¼ºæ±‚ã€‚è‹¥æŠŠçŸ³å¤´ã€‚ç£¨ä½œé•œã€‚å–»å¾’åŠ³æ— åŠŸã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹ä¸å¯å¼ºæ±‚ã€‚", "verse": "é•œèŠ±æ°´æœˆã€‚ä¸€åœºç©ºæ¬¢ã€‚ç—´å¿ƒå¦„æƒ³ã€‚å¾’åŠ³æ— åŠŸã€‚" },
    { "id": 40, "title": "ç¬¬å››åé¦– ä¸Šä¸Š", "poem": "çº¢è½®è¥¿å å…”ä¸œå‡ï¼Œé˜´é•¿é˜³æ¶ˆæ˜¯ä¸¤å½¢ï¼›\nè‹¥æ˜¯å¥³äººå æ­¤å¦ï¼Œå¢æ·»ç¦ç¦„ç§°å¿ƒæƒ…ã€‚", "interpretation": "æ­¦åˆ™å¤©ç™»ä½ã€‚æ­¤ç­¾ä¸»åˆ©å¥³ã€‚çº¢è½®è¥¿å ã€‚å…”ä¸œå‡ã€‚å–»é˜´ç››é˜³è¡°ã€‚è‹¥æ˜¯å¥³äººã€‚å æ­¤å¦ã€‚å–»å¥³å­å¾—åˆ©ã€‚å¢æ·»ç¦ç¦„ã€‚ç§°å¿ƒæƒ…ã€‚å–»å¿ƒæƒ³äº‹æˆã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "é˜´ç››é˜³è¡°ã€‚å¥³å­å¾—åˆ©ã€‚ç”·äººå¤±åˆ©ã€‚å„æœ‰æ‰€å®œã€‚" },
    { "id": 41, "title": "ç¬¬å››åä¸€é¦– ä¸Šä¸Š", "poem": "æ— é™å¥½äº‹å›é¡»è®°ï¼Œæ°å¦‚è®¤è´¼ä½œä¸ºå­ï¼›\nè«è´ªçœ¼ä¸‹æœ‰äº›ç”œï¼Œå¯è™‘ä»–æ—¶è¿˜å—è‹¦ã€‚", "interpretation": "è‘£å“æ”¶å•å¸ƒã€‚æ­¤ç­¾ä¸»æœ‰å°äººã€‚æ— é™å¥½äº‹ã€‚å›é¡»è®°ã€‚å–»è­¦æƒ•ã€‚æ°å¦‚è®¤è´¼ã€‚ä½œä¸ºå­ã€‚å–»è®¤æ•Œä¸ºå‹ã€‚è«è´ªçœ¼ä¸‹ã€‚æœ‰äº›ç”œã€‚å–»å‹¿è´ªå°åˆ©ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "è®¤è´¼ä¸ºå­ã€‚åæ‚£æ— ç©·ã€‚çŸ¥äººçŸ¥é¢ã€‚ä¸çŸ¥å¿ƒã€‚" },
    { "id": 42, "title": "ç¬¬å››åäºŒé¦– ä¸Šä¸Š", "poem": "å›çš‡åœ£åæ€»ä¸ºæ©ï¼Œå¤å¾…ç¥ˆç¦³æ— æŸå¢ï¼›\nä¸€åˆ‡æœ‰æƒ…çš†å—ç”¨ï¼Œå‡æ²¾ä¹åˆ©å¾—å‘¨å…¨ã€‚", "interpretation": "ç›®è²æ•‘æ¯ã€‚æ­¤ç­¾ä¸»æœ‰ç¥åŠ©ã€‚å›çš‡åœ£åã€‚æ€»ä¸ºæ©ã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚å¤å¾…ç¥ˆç¦³ã€‚æ— æŸå¢ã€‚å–»è¯šå¿ƒç¥ˆç¥·ã€‚ä¸€åˆ‡æœ‰æƒ…ã€‚çš†å—ç”¨ã€‚å–»ä¸‡äº‹å¦‚æ„ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "ç¥ä½›æŠ¤ä½‘ã€‚æœ‰ç¾æ— å±ã€‚é€”è™½é™©é˜»ã€‚ç»ˆè·ä½³éŸ³ã€‚" },
    { "id": 43, "title": "ç¬¬å››åä¸‰é¦– ä¸Šä¸Š", "poem": "å¤©åœ°äº¤æ³°ä¸‡ç‰©æ–°ï¼Œè‡ªå½¢è‡ªè‰²è‡ªæ€¡ç¥ï¼›\næ£®ç½—ä¸‡è±¡çš†ç²¾å½©ï¼Œäº‹äº‹å’Œè°å¾—ç§°äººã€‚", "interpretation": "è¡Œè€…å¾—é“ã€‚æ­¤ç­¾ä¸»ä¸‡è±¡æ›´æ–°ã€‚å¤©åœ°äº¤æ³°ã€‚ä¸‡ç‰©æ–°ã€‚å–»æ—¶æ¥è¿è½¬ã€‚è‡ªå½¢è‡ªè‰²ã€‚è‡ªæ€¡ç¥ã€‚å–»å¿ƒæƒ…èˆ’ç•…ã€‚æ£®ç½—ä¸‡è±¡ã€‚çš†ç²¾å½©ã€‚å–»äº‹äº‹é¡ºå¿ƒã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å¦å»æ³°æ¥ã€‚ä¸‡äº‹äº¨é€šã€‚ååˆ©åŒæ”¶ã€‚å¥½äº‹è¿è¿ã€‚" },
    { "id": 44, "title": "ç¬¬å››åå››é¦– ä¸­å¹³", "poem": "æ±æ˜¯äººä¸­æœ€å‰äººï¼Œè¯¯ä¸ºè¯¯ä½œæŸç²¾ç¥ï¼›\nåšç‰¢ä¸€å¿µé…¬é¦™æ„¿ï¼Œå¯Œè´µè£åèƒæ±èº«ã€‚", "interpretation": "å§œç»´é‚“è‰¾æ–—é˜µã€‚æ­¤ç­¾ä¸»æœ‰æ˜¯éã€‚æ±æ˜¯äººä¸­ã€‚æœ€å‰äººã€‚å–»æœ¬æ¥è¿åŠ¿ä¸é”™ã€‚è¯¯ä¸ºè¯¯ä½œã€‚æŸç²¾ç¥ã€‚å–»å› è¯¯ä¼šè€Œç”Ÿäº‹ç«¯ã€‚åšç‰¢ä¸€å¿µã€‚é…¬é¦™æ„¿ã€‚å–»è¯šå¿ƒç¥ˆç¥·ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå’Œä¸ºè´µã€‚", "verse": "å¾—å¿ä¸”å¿ã€‚å¾—è€ä¸”è€ã€‚å‡¡äº‹ä»é•¿è®¡è®®ã€‚æ–¹èƒ½æœ‰æˆã€‚" },
    { "id": 45, "title": "ç¬¬å››åäº”é¦– ä¸Šä¸Š", "poem": "èŠ±å¼€ä»Šå·²ç»“æˆæœï¼Œå¯Œè´µè£åç»ˆåˆ°è€ï¼›\nå›å­å°äººç›¸ä¼šåˆï¼Œä¸‡äº‹æ¸…å‰è«çƒ¦æ¼ã€‚", "interpretation": "ä»å®—é‡ä»™ã€‚æ­¤ç­¾ä¸»æœ‰å–„æœã€‚èŠ±å¼€ä»Šå·²ã€‚ç»“æˆæœã€‚å–»åŠŸå¾·åœ†æ»¡ã€‚å¯Œè´µè£åã€‚ç»ˆåˆ°è€ã€‚å–»æ™šå¹´å¹¸ç¦ã€‚å›å­å°äººã€‚ç›¸ä¼šåˆã€‚å–»åŒ–æ•Œä¸ºå‹ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å–„æœ‰å–„æŠ¥ã€‚æ¶æœ‰æ¶æŠ¥ã€‚ä¸æ˜¯ä¸æŠ¥ã€‚æ—¶è¾°æœªåˆ°ã€‚" },
    { "id": 46, "title": "ç¬¬å››åå…­é¦– ä¸­å¹³", "poem": "åŠå›è€å®ˆæ—§ç”Ÿæ¶¯ï¼ŒæŠŠå®šå¿ƒè‚ å‹¿èµ·æ­¹ï¼›\nç›´å¾…æœ‰äººè½»è‘—åŠ›ï¼Œæ¯æè€æ ‘å†ç”ŸèŠ±ã€‚", "interpretation": "æ¸­æ°´é’“é±¼ã€‚æ­¤ç­¾ä¸»æœ‰å¾…è€Œå‘ã€‚åŠå›è€å®ˆã€‚æ—§ç”Ÿæ¶¯ã€‚å–»å®‰åˆ†å®ˆå·±ã€‚æŠŠå®šå¿ƒè‚ ã€‚å‹¿èµ·æ­¹ã€‚å–»å¿ƒåœ°å–„è‰¯ã€‚ç›´å¾…æœ‰äººã€‚è½»è‘—åŠ›ã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå¾…æ—¶è€ŒåŠ¨ã€‚", "verse": "é™ä¸­å¾…æ—¶ã€‚å‡¡äº‹å®‰ç¨³ã€‚åŠ¨åˆ™æœ‰æŸã€‚é™åˆ™æ— å¿§ã€‚" },
    { "id": 47, "title": "ç¬¬å››åä¸ƒé¦– ä¸Šä¸Š", "poem": "é”¦ä¸Šæ·»èŠ±è‰²æ„ˆé²œï¼Œè¿æ¥ç¦„é©¬å–œåŒå…¨ï¼›\næ—¶äººè«é“åŠŸåæ˜“ï¼Œä¸€ä¸¾ç™»ç§‘å››æµ·ä¼ ã€‚", "interpretation": "æ¢çç™»ç§‘ã€‚æ­¤ç­¾ä¸»ååˆ©åŒæ”¶ã€‚é”¦ä¸Šæ·»èŠ±ã€‚è‰²æ„ˆé²œã€‚å–»å¥½ä¸ŠåŠ å¥½ã€‚è¿æ¥ç¦„é©¬ã€‚å–œåŒå…¨ã€‚å–»æ—¶æ¥è¿è½¬ã€‚ä¸€ä¸¾ç™»ç§‘ã€‚å››æµ·ä¼ ã€‚å–»åŠŸæˆåå°±ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "æ—¶æ¥è¿è½¬ã€‚æ¯æœ¨é€¢æ˜¥ã€‚è°‹æœ›çš†é‚ã€‚å¥½äº‹ä¸´é—¨ã€‚" },
    { "id": 48, "title": "ç¬¬å››åå…«é¦– ä¸­å¹³", "poem": "æ˜†é¸Ÿç§‹å…‰åŒ–ä½œé¹ï¼Œç¿±ç¿”å¾—æ„å°½é£è…¾ï¼›\nç›´å†²ä¸‡é‡Œäº‘éœ„å¤–ï¼Œä»»æ˜¯è¯¸ä¾¯äº¦ä¸èƒ½ã€‚", "interpretation": "ç­è¶…ä¸‡é‡Œå°ä¾¯ã€‚æ­¤ç­¾ä¸»æœ‰ä½œä¸ºã€‚æ˜†é¸Ÿç§‹å…‰ã€‚åŒ–ä½œé¹ã€‚å–»å¤§å™¨æ™šæˆã€‚ç¿±ç¿”å¾—æ„ã€‚å°½é£è…¾ã€‚å–»äº‹ä¸šæœ‰æˆã€‚ç›´å†²ä¸‡é‡Œã€‚äº‘éœ„å¤–ã€‚å–»å‰é€”æ— é‡ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "å‡ºå…¥è£åã€‚å‰é€”äº‹ä¸šã€‚å¤§æœ‰å¯ä¸ºã€‚å è€…å¤§å‰ã€‚" },
    { "id": 49, "title": "ç¬¬å››åä¹é¦– ä¸­å¹³", "poem": "å¤©å¯’åœ°å†»æ°´æˆå†°ï¼Œä½•é¡»è´ªåå–åŠŸåï¼›\nåªå¥½å®ˆå·±é™å¤„åï¼Œå¾…æ—¶å…´å˜è‡ªç„¶æ˜ã€‚", "interpretation": "ç‹ç¥¥æ±‚é²¤ã€‚æ­¤ç­¾ä¸»æœ‰å¾…è€Œå‘ã€‚å¤©å¯’åœ°å†»ã€‚æ°´æˆå†°ã€‚å–»æ—¶è¿ä¸æµã€‚ä½•é¡»è´ªåã€‚å–åŠŸåã€‚å–»å‹¿å¼ºæ±‚ã€‚åªå¥½å®ˆå·±ã€‚é™å¤„åã€‚å–»å®‰åˆ†å®ˆå·±ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå¾…æ—¶è€ŒåŠ¨ã€‚", "verse": "é™ä¸­å¾…æ—¶ã€‚å‡¡äº‹å®‰ç¨³ã€‚åŠ¨åˆ™æœ‰æŸã€‚é™åˆ™æ— å¿§ã€‚" },
    { "id": 50, "title": "ç¬¬äº”åé¦– ä¸­å¹³", "poem": "ä¸€æœæ— äº‹å¿½é­å®˜ï¼Œä¹Ÿæ˜¯é—¨è¡°åŸæœªå®‰ï¼›\næ”¹æ¢é—¨åº­æ·»ç¦å¾·ï¼Œå§‹çŸ¥å®¶é“ä¸è‰°éš¾ã€‚", "interpretation": "è‹ä¸œå¡è¢«è´¬ã€‚æ­¤ç­¾ä¸»æœ‰å®˜éã€‚ä¸€æœæ— äº‹ã€‚å¿½é­å®˜ã€‚å–»é£æ¥æ¨ªç¥¸ã€‚ä¹Ÿæ˜¯é—¨è¡°ã€‚åŸæœªå®‰ã€‚å–»å®¶å®…ä¸å®ã€‚æ”¹æ¢é—¨åº­ã€‚æ·»ç¦å¾·ã€‚å–»æ”¹è¿‡è¿å–„ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "é€€ä¸€æ­¥æµ·é˜”å¤©ç©ºã€‚å‡¡äº‹ä¸‰æ€è€Œåè¡Œã€‚" },
    { "id": 51, "title": "ç¬¬äº”åä¸€é¦– ä¸Šä¸Š", "poem": "å¤æ—¥åˆä¸´æ—¥æ­£é•¿ï¼Œäººçš†æ„æ¼çƒ­éå¸¸ï¼›\nå¤©å…¬ä¹Ÿè§£è¯¸äººæ„ï¼Œæ•…é£è–°é£ç‰¹é€å‡‰ã€‚", "interpretation": "å­”æ˜å…¥å¤ã€‚æ­¤ç­¾ä¸»æœ‰ç¥åŠ©ã€‚å¤æ—¥åˆä¸´ã€‚æ—¥æ­£é•¿ã€‚å–»å›°éš¾é‡é‡ã€‚å¤©å…¬ä¹Ÿè§£ã€‚è¯¸äººæ„ã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ•…é£è–°é£ã€‚ç‰¹é€å‡‰ã€‚å–»é€¢å‡¶åŒ–å‰ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "ç¥ä½›æŠ¤ä½‘ã€‚æœ‰ç¾æ— å±ã€‚é€”è™½é™©é˜»ã€‚ç»ˆè·ä½³éŸ³ã€‚" },
    { "id": 52, "title": "ç¬¬äº”åäºŒé¦– ä¸Šä¸Š", "poem": "å…€åå¹½å±…å¹å¯‚å¯¥ï¼Œå­¤ç¯æ©æ˜ åº¦æ¸…å®µï¼›\nä¸‡é‡‘å¿½æŠ¥ç§‹å…‰å¥½ï¼ŒäººæœˆåŒåœ†ç…§ç”»æ¡¥ã€‚", "interpretation": "å¤ªç™½é†‰ææ˜æœˆã€‚æ­¤ç­¾ä¸»æœ‰å–œäº‹ã€‚å…€åå¹½å±…ã€‚å¹å¯‚å¯¥ã€‚å–»å­¤ç‹¬å¯‚å¯ã€‚ä¸‡é‡‘å¿½æŠ¥ã€‚ç§‹å…‰å¥½ã€‚å–»å¥½è¿å°†è‡³ã€‚äººæœˆåŒåœ†ã€‚ç…§ç”»æ¡¥ã€‚å–»å›¢åœ†ç¾æ»¡ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å–œäº‹å°†è¿‘ã€‚å¥½äº‹è¿è¿ã€‚è´µäººç›¸åŠ©ã€‚å‰é€”æ— é‡ã€‚" },
    { "id": 53, "title": "ç¬¬äº”åä¸‰é¦– ä¸­å¹³", "poem": "è‰°éš¾é™©é˜»è·¯è¹Šè··ï¼Œå—é¸Ÿå­¤é£ä¾åŒ—å·¢ï¼›\nä»Šæ—¥è´µäººæ›¾è¯†é¢ï¼Œç›¸é€¢å´åœ¨å¤ç§‹äº¤ã€‚", "interpretation": "ç‹æ™¯ç•¥æ‰ªè™±è°ˆå…µã€‚æ­¤ç­¾ä¸»æœ‰è´µäººã€‚è‰°éš¾é™©é˜»ã€‚è·¯è¹Šè··ã€‚å–»å›°éš¾é‡é‡ã€‚å—é¸Ÿå­¤é£ã€‚ä¾åŒ—å·¢ã€‚å–»æ¼‚æ³Šä¸å®šã€‚ä»Šæ—¥è´µäººã€‚æ›¾è¯†é¢ã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "è´µäººç›¸åŠ©ã€‚æ—¶æ¥è¿è½¬ã€‚å‡¡äº‹é¡ºå¿ƒã€‚å¤§å‰å¤§åˆ©ã€‚" },
    { "id": 54, "title": "ç¬¬äº”åå››é¦– ä¸­å¹³", "poem": "æ¢¦ä¸­å¾—å®é†’æ¥æ— ï¼Œè‡ªè°“å—å±±åªæ˜¯é”„ï¼›\nè‹¥é—®å©šå§»å¹¶é—®ç—…ï¼Œåˆ«å¯»æ¡è·¯ä¸ºç›¸æ‰¶ã€‚", "interpretation": "é©¬è¶…è¿½æ›¹ã€‚æ­¤ç­¾ä¸»æœ‰è™šæœ›ã€‚æ¢¦ä¸­å¾—å®ã€‚é†’æ¥æ— ã€‚å–»ç©ºæ¬¢å–œä¸€åœºã€‚è‡ªè°“å—å±±ã€‚åªæ˜¯é”„ã€‚å–»å¾’åŠ³æ— åŠŸã€‚åˆ«å¯»æ¡è·¯ã€‚ä¸ºç›¸æ‰¶ã€‚å–»å¦å¯»ä»–æ³•ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹ä¸å¯å¼ºæ±‚ã€‚", "verse": "é•œèŠ±æ°´æœˆã€‚ä¸€åœºç©ºæ¬¢ã€‚ç—´å¿ƒå¦„æƒ³ã€‚å¾’åŠ³æ— åŠŸã€‚" },
    { "id": 55, "title": "ç¬¬äº”åäº”é¦– ä¸Šä¸Š", "poem": "çˆ¶è´¤å­å­å¼Ÿå‹æ­ï¼Œçºµç„¶é€¢å‡¶äº¦ä¸å‡¶ï¼›\nåé¢˜é‡‘æ¦œä¹æ— æ¶¯ï¼Œå›é¦–ç”°å›­æ™¯è‰²æµ“ã€‚", "interpretation": "å‘¨æ­¦ç‹ç™»ä½ã€‚æ­¤ç­¾ä¸»å®¶å’Œä¸‡äº‹å…´ã€‚çˆ¶è´¤å­å­ã€‚å¼Ÿå‹æ­ã€‚å–»å®¶åº­å’Œç¦ã€‚çºµç„¶é€¢å‡¶ã€‚äº¦ä¸å‡¶ã€‚å–»é€¢å‡¶åŒ–å‰ã€‚åé¢˜é‡‘æ¦œã€‚ä¹æ— æ¶¯ã€‚å–»åŠŸæˆåå°±ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å®¶å’Œä¸‡äº‹å…´ã€‚å‡¡äº‹é¡ºå¿ƒã€‚å¤§å‰å¤§åˆ©ã€‚" },
    { "id": 56, "title": "ç¬¬äº”åå…­é¦– ä¸­å¹³", "poem": "æ»©å°çŸ³æºªæµæ°´å“ï¼Œé£æ¸…æœˆæœ—é’“èˆ¹å½’ï¼›\nè·¯é¥ä¸”å¾—ä¼‘å¿ƒå»ï¼Œç›´åˆ°è“¬è±é™å¤„æœŸã€‚", "interpretation": "äº”ç™¾ç½—æ±‰ã€‚æ­¤ç­¾ä¸»å®‰é—²ã€‚æ»©å°çŸ³æºªã€‚æµæ°´å“ã€‚å–»ä¸ä¸–æ— äº‰ã€‚é£æ¸…æœˆæœ—ã€‚é’“èˆ¹å½’ã€‚å–»é¡ºå…¶è‡ªç„¶ã€‚è·¯é¥ä¸”å¾—ã€‚ä¼‘å¿ƒå»ã€‚å–»å¿ƒæ€å¹³å’Œã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºå…¶è‡ªç„¶ã€‚", "verse": "å®ˆå·±å®‰åˆ†ã€‚å‡¡äº‹å®‰ç¨³ã€‚åŠ¨åˆ™æœ‰æŸã€‚é™åˆ™æ— å¿§ã€‚" },
    { "id": 57, "title": "ç¬¬äº”åä¸ƒé¦– ä¸Šä¸Š", "poem": "äº‹ç«¯ç™¾å‡ºè™‘è™½é•¿ï¼Œè«å¬äººè¨€è‡ªä¸»å¼ ï¼›\nä¸€è‘—ä»™æœºå›è®°å–ï¼Œçº·çº·é—¹é‡Œæ›´æ€é‡ã€‚", "interpretation": "çƒ‚æŸ¯è§‚æ£‹ã€‚æ­¤ç­¾ä¸»æœ‰ä¸»è§ã€‚äº‹ç«¯ç™¾å‡ºã€‚è™‘è™½é•¿ã€‚å–»å›°éš¾é‡é‡ã€‚è«å¬äººè¨€ã€‚è‡ªä¸»å¼ ã€‚å–»è¦æœ‰ä¸»è§ã€‚ä¸€è‘—ä»™æœºã€‚å›è®°å–ã€‚å–»å¾—è´µäººæŒ‡ç‚¹ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹é¡ºå¿ƒã€‚", "verse": "è¦æœ‰ä¸»è§ã€‚ä¸å¯è½»ä¿¡ã€‚è´µäººç›¸åŠ©ã€‚å‡¡äº‹æœ‰æˆã€‚" },
    { "id": 58, "title": "ç¬¬äº”åå…«é¦– ä¸­å¹³", "poem": "å¿ è¨€å–„è¯­å›é¡»è®°ï¼Œè«å‘ä»–æ–¹æ±‚åˆ«è‰ºï¼›\nåŠå›å®‰å®ˆæ—§ç”Ÿæ¶¯ï¼Œé™¤å´æœ‰ä½™éƒ½ä¸æ˜¯ã€‚", "interpretation": "æ–‡ç‹é—®åœã€‚æ­¤ç­¾ä¸»å®‰åˆ†å®ˆå·±ã€‚å¿ è¨€å–„è¯­ã€‚å›é¡»è®°ã€‚å–»å¬ä»åŠå‘Šã€‚è«å‘ä»–æ–¹ã€‚æ±‚åˆ«è‰ºã€‚å–»å‹¿å¥½é«˜éª›è¿œã€‚åŠå›å®‰å®ˆã€‚æ—§ç”Ÿæ¶¯ã€‚å–»å®‰åˆ†å®ˆå·±ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "å®‰åˆ†å®ˆå·±ã€‚å‡¡äº‹å®‰ç¨³ã€‚åŠ¨åˆ™æœ‰æŸã€‚é™åˆ™æ— å¿§ã€‚" },
    { "id": 59, "title": "ç¬¬äº”åä¹é¦– ä¸Šä¸Š", "poem": "é—¨è¡°æˆ·å†·è‹¦ä¼¶ä»ƒï¼Œè‡ªå¹ç¥ˆæ±‚ä¸ä¸€çµï¼›\nå¹¸æœ‰ç¥–å®—é˜´éª˜åœ¨ï¼Œé¦™çƒŸæœªæ–­ç»­èŸè›‰ã€‚", "interpretation": "é‚“ä»²åæ‰¿æ¥å®¶ä¸šã€‚æ­¤ç­¾ä¸»æœ‰ç¥–å¾·ã€‚é—¨è¡°æˆ·å†·ã€‚è‹¦ä¼¶ä»ƒã€‚å–»å®¶é“ä¸­è½ã€‚è‡ªå¹ç¥ˆæ±‚ã€‚ä¸ä¸€çµã€‚å–»æ±‚ç¥ä¸åº”ã€‚å¹¸æœ‰ç¥–å®—ã€‚é˜´éª˜åœ¨ã€‚å–»ç¥–å®—ä¿ä½‘ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹æœ‰æƒŠæ— é™©ã€‚", "verse": "ç¥–å®—ä¿ä½‘ã€‚æœ‰ç¾æ— å±ã€‚é€”è™½é™©é˜»ã€‚ç»ˆè·ä½³éŸ³ã€‚" },
    { "id": 60, "title": "ç¬¬å…­åé¦– ä¸­å¹³", "poem": "æŠ±è–ªæ•‘ç«ç«æ„ˆçº¢ï¼Œé£è›¾æ‰‘ç«è‡ªä¼¤ç”Ÿï¼›\nè«å­¦ç—´äººå›¾ä¾¥å¹¸ï¼Œç¥¸ç¦æ— é—¨æ€»è‡ªæ‹›ã€‚", "interpretation": "èµ¤å£é–å…µã€‚æ­¤ç­¾ä¸»æœ‰è‡ªå–ç­äº¡ä¹‹å…†ã€‚æŠ±è–ªæ•‘ç«ã€‚ç«æ„ˆçº¢ã€‚å–»æ–¹æ³•é”™è¯¯ã€‚é£è›¾æ‰‘ç«ã€‚è‡ªä¼¤ç”Ÿã€‚å–»è‡ªå–ç­äº¡ã€‚è«å­¦ç—´äººã€‚å›¾ä¾¥å¹¸ã€‚å–»å‹¿å­˜ä¾¥å¹¸å¿ƒç†ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "è‡ªä½œè‡ªå—ã€‚æ‚”ä¹‹æ™šçŸ£ã€‚å‡¡äº‹ä¸‰æ€ã€‚è€Œåè¡Œã€‚" },
    { "id": 61, "title": "ç¬¬å…­åä¸€é¦– ä¸Šä¸Š", "poem": "æ—¥ä¸ŠåŸè¯—æœˆä¸‹æ­Œï¼Œé€¢åœºä½œæˆç¬‘å‘µå‘µï¼›\nç›¸é€¢ä¼šé‡éš¾è—é¿ï¼Œå–å½©é½å”±è¿ç†ç½—ã€‚", "interpretation": "è‹å°å¦¹éš¾å¤«ã€‚æ­¤ç­¾ä¸»æœ‰å–œäº‹ã€‚æ—¥ä¸ŠåŸè¯—ã€‚æœˆä¸‹æ­Œã€‚å–»å¿ƒæƒ…æ„‰å¿«ã€‚é€¢åœºä½œæˆã€‚ç¬‘å‘µå‘µã€‚å–»éšæœºåº”å˜ã€‚ç›¸é€¢ä¼šé‡ã€‚éš¾è—é¿ã€‚å–»ç¼˜åˆ†å¤©å®šã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å–œäº‹å°†è¿‘ã€‚å¥½äº‹è¿è¿ã€‚è´µäººç›¸åŠ©ã€‚å‰é€”æ— é‡ã€‚" },
    { "id": 62, "title": "ç¬¬å…­åäºŒé¦– ä¸­å¹³", "poem": "æ™¨æ˜ä¼ ç±ä½›æ‰¶æŒï¼Œé¡»æ˜¯é€¢å±å´ä¸å±ï¼›\nè‹¥å¾—è´µäººç›¸å¼•èï¼Œé‚£æ—¶è´¢å¸›äº¦ç›¸éšã€‚", "interpretation": "å”åƒ§å–ç»ã€‚æ­¤ç­¾ä¸»æœ‰ç¥åŠ©ã€‚æ™¨æ˜ä¼ ç±ã€‚ä½›æ‰¶æŒã€‚å–»ç¥ä½›ä¿ä½‘ã€‚é¡»æ˜¯é€¢å±ã€‚å´ä¸å±ã€‚å–»é€¢å‡¶åŒ–å‰ã€‚è‹¥å¾—è´µäººã€‚ç›¸å¼•èã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "ç¥ä½›æŠ¤ä½‘ã€‚æœ‰ç¾æ— å±ã€‚é€”è™½é™©é˜»ã€‚ç»ˆè·ä½³éŸ³ã€‚" },
    { "id": 63, "title": "ç¬¬å…­åä¸‰é¦– ä¸­å¹³", "poem": "æ˜”æ—¥è¡Œèˆ¹å¤±äº†é’ˆï¼Œä»Šæœä¾æ—§æµ·ä¸­å¯»ï¼›\nè‹¥è¿˜å¯»å¾—åŸé’ˆåœ¨ï¼Œä¹Ÿè´¹å·¥å¤«ä¹Ÿè´¹å¿ƒã€‚", "interpretation": "å¥³å¨²è¡¥å¤©ã€‚æ­¤ç­¾ä¸»å¾’åŠ³æ— åŠŸã€‚æ˜”æ—¥è¡Œèˆ¹ã€‚å¤±äº†é’ˆã€‚å–»å¤±å»æ–¹å‘ã€‚ä»Šæœä¾æ—§ã€‚æµ·ä¸­å¯»ã€‚å–»å¾’åŠ³æ— åŠŸã€‚è‹¥è¿˜å¯»å¾—ã€‚åŸé’ˆåœ¨ã€‚å–»å¸Œæœ›æ¸ºèŒ«ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹ä¸å¯å¼ºæ±‚ã€‚", "verse": "é•œèŠ±æ°´æœˆã€‚ä¸€åœºç©ºæ¬¢ã€‚ç—´å¿ƒå¦„æƒ³ã€‚å¾’åŠ³æ— åŠŸã€‚" },
    { "id": 64, "title": "ç¬¬å…­åå››é¦– ä¸­å¹³", "poem": "æ¸”ç¿é’“å¾—ä¸€é‡‘é¾Ÿï¼Œå å¾—æ­¤å¦ä¸åƒäºï¼›\nç”Ÿæ„ä¹°å–çš†ç§°æ„ï¼Œé«˜æ‰å¾—é‡ä¸‡äº‹å®œã€‚", "interpretation": "é©¬å‘¨çŒ®ç­–ã€‚æ­¤ç­¾ä¸»æœ‰æ”¶è·ã€‚æ¸”ç¿é’“å¾—ã€‚ä¸€é‡‘é¾Ÿã€‚å–»æœ‰æ„å¤–ä¹‹å–œã€‚å å¾—æ­¤å¦ã€‚ä¸åƒäºã€‚å–»äº‹äº‹é¡ºåˆ©ã€‚ç”Ÿæ„ä¹°å–ã€‚çš†ç§°æ„ã€‚å–»è´¢è¿äº¨é€šã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "å‡ºå…¥è£åã€‚å‰é€”äº‹ä¸šã€‚å¤§æœ‰å¯ä¸ºã€‚å è€…å¤§å‰ã€‚" },
    { "id": 65, "title": "ç¬¬å…­åäº”é¦– ä¸­å¹³", "poem": "çœ¼å‰æ¬¢å–œæœªä¸ºæ¬¢ï¼Œäº¦ä¸å±æ—¶äº¦ä¸å®‰ï¼›\nå‰²è‚‰è¡¥ç–®ä¸ºç”šäº‹ï¼Œä¸å¦‚å®ˆæ—§å¾…æ—¶å®½ã€‚", "interpretation": "å­™è†‘å›°åºæ¶“ã€‚æ­¤ç­¾ä¸»æœ‰å›°å¢ƒã€‚çœ¼å‰æ¬¢å–œã€‚æœªä¸ºæ¬¢ã€‚å–»ä¹æç”Ÿæ‚²ã€‚äº¦ä¸å±æ—¶ã€‚äº¦ä¸å®‰ã€‚å–»è¿›é€€ä¸¤éš¾ã€‚å‰²è‚‰è¡¥ç–®ã€‚ä¸ºç”šäº‹ã€‚å–»æ–¹æ³•é”™è¯¯ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå¿è€ã€‚", "verse": "é¾™è™å¤±åŠ¿ã€‚æš‚æ—¶å¿è€ã€‚å¾…æ—¶è€ŒåŠ¨ã€‚å¿…æœ‰ä½œä¸ºã€‚" },
    { "id": 66, "title": "ç¬¬å…­åå…­é¦– ä¸­å¹³", "poem": "è·¯é™©é©¬ä¹äººè¡Œæ€¥ï¼Œå¤±ç¾¤å†›å’å›°ç›¸å½“ï¼›\næ»©é«˜é£æµªèˆ¹æ£¹ç ´ï¼Œæ—¥æš®èŠ±æ®‹å¤©é™éœœã€‚", "interpretation": "è¯¸è‘›äº®å›°äºäº”ä¸ˆåŸã€‚æ­¤ç­¾ä¸»æœ‰é™©é˜»ã€‚è·¯é™©é©¬ä¹ã€‚äººè¡Œæ€¥ã€‚å–»å›°éš¾é‡é‡ã€‚å¤±ç¾¤å†›å’ã€‚å›°ç›¸å½“ã€‚å–»å­¤ç«‹æ— æ´ã€‚æ»©é«˜é£æµªã€‚èˆ¹æ£¹ç ´ã€‚å–»è¿›é€€ä¸¤éš¾ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹ä¸é¡ºã€‚", "verse": "è¿›é€€ä¸¤éš¾ã€‚å¥½äº‹éš¾æˆã€‚å£èˆŒæ˜¯éã€‚åœ¨æ‰€éš¾å…ã€‚" },
    { "id": 67, "title": "ç¬¬å…­åä¸ƒé¦– ä¸Šä¸Š", "poem": "ä¸€æ¡é‡‘çº¿ç§¤å›å¿ƒï¼Œæ— å‡æ— å¢æ— é‡è½»ï¼›\nä¸ºäººå¹³ç”Ÿå¿ƒæ­£ç›´ï¼Œæ–‡ç« å…¨å…·è‰ºå…‰æ˜ã€‚", "interpretation": "ç®¡é²åˆ†é‡‘ã€‚æ­¤ç­¾ä¸»å…¬æ­£æ— ç§ã€‚ä¸€æ¡é‡‘çº¿ã€‚ç§¤å›å¿ƒã€‚å–»ä¸ºäººæ­£ç›´ã€‚æ— å‡æ— å¢ã€‚æ— é‡è½»ã€‚å–»å…¬å¹³åˆç†ã€‚ä¸ºäººå¹³ç”Ÿã€‚å¿ƒæ­£ç›´ã€‚å–»å¿ƒåœ°å…‰æ˜ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å¿ƒä¸­æ­£ç›´ã€‚ç†é¡ºæ³•å®½ã€‚å¤©æ— ç§æ„ã€‚è«ä½œå¿ƒæ¬ºã€‚" },
    { "id": 68, "title": "ç¬¬å…­åå…«é¦– ä¸­å¹³", "poem": "å—è´©çç åŒ—è´©ç›ï¼Œå¹´æ¥åŠ³ç¢Œå¹æ— é’±ï¼›\nè‹¥è¿˜ç­‰å¾…æ—¶è¿è‡³ï¼Œæ°å¦‚å¤§æµ·æ­£æé’ˆã€‚", "interpretation": "é’±å¤§ç‹è´©ç›ã€‚æ­¤ç­¾ä¸»å¾’åŠ³æ— åŠŸã€‚å—è´©çç ã€‚åŒ—è´©ç›ã€‚å–»å¥”æ³¢åŠ³ç¢Œã€‚å¹´æ¥åŠ³ç¢Œã€‚å¹æ— é’±ã€‚å–»ä¸€æ— æ‰€è·ã€‚è‹¥è¿˜ç­‰å¾…ã€‚æ—¶è¿è‡³ã€‚å–»å¸Œæœ›æ¸ºèŒ«ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹ä¸å¯å¼ºæ±‚ã€‚", "verse": "é•œèŠ±æ°´æœˆã€‚ä¸€åœºç©ºæ¬¢ã€‚ç—´å¿ƒå¦„æƒ³ã€‚å¾’åŠ³æ— åŠŸã€‚" },
    { "id": 69, "title": "ç¬¬å…­åä¹é¦– ä¸­å¹³", "poem": "å†¬æ¥å²­ä¸Šä¸€ææ¢…ï¼Œå¶è½ææ¯æ€»ä¸æ‘§ï¼›\nä½†å¾—é˜³æ˜¥æ‚„æ€¥è‡³ï¼Œä¾ç„¶è¿˜æˆ‘ä½œèŠ±é­ã€‚", "interpretation": "æ¢…èŠ±å é­ã€‚æ­¤ç­¾ä¸»æœ‰å¾…è€Œå‘ã€‚å†¬æ¥å²­ä¸Šã€‚ä¸€ææ¢…ã€‚å–»åšå¿ä¸æ‹”ã€‚å¶è½ææ¯ã€‚æ€»ä¸æ‘§ã€‚å–»æ„å¿—åšå®šã€‚ä½†å¾—é˜³æ˜¥ã€‚æ‚„æ€¥è‡³ã€‚å–»æ—¶æ¥è¿è½¬ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå¿è€ã€‚", "verse": "é¾™è™å¤±åŠ¿ã€‚æš‚æ—¶å¿è€ã€‚å¾…æ—¶è€ŒåŠ¨ã€‚å¿…æœ‰ä½œä¸ºã€‚" },
    { "id": 70, "title": "ç¬¬ä¸ƒåé¦– ä¸‹ä¸‹", "poem": "æœæœå½¹å½¹æ°å¦‚èœ‚ï¼Œé£æ¥é£å»è¥¿å¤ä¸œï¼›\næ˜¥æš®èŠ±æ®‹æ— è§…å¤„ï¼Œæ­¤èº«ä¸å…åœ¨ç‰¢ä¸­ã€‚", "interpretation": "æå¯†åå”ã€‚æ­¤ç­¾ä¸»æœ‰ç‰¢ç‹±ä¹‹ç¾ã€‚æœæœå½¹å½¹ã€‚æ°å¦‚èœ‚ã€‚å–»å¥”æ³¢åŠ³ç¢Œã€‚é£æ¥é£å»ã€‚è¥¿å¤ä¸œã€‚å–»ä¸€æ— æ‰€è·ã€‚æ˜¥æš®èŠ±æ®‹ã€‚æ— è§…å¤„ã€‚å–»èµ°æŠ•æ— è·¯ã€‚æ­¤ç­¾ä¸‹ä¸‹ä¹‹å…†ã€‚å‡¡äº‹ä¸é¡ºã€‚", "verse": "è¿›é€€ä¸¤éš¾ã€‚å¥½äº‹éš¾æˆã€‚å£èˆŒæ˜¯éã€‚åœ¨æ‰€éš¾å…ã€‚" },
    { "id": 71, "title": "ç¬¬ä¸ƒåä¸€é¦– ä¸­å¹³", "poem": "è°çŸ¥çˆ±å® é‡å¼ºå¾’ï¼Œå¥³å­å½“å¹´å«äºŒå¤«ï¼›\nè‡ªæ˜¯ä¸€å¼“æ–½ä¸¤ç®­ï¼Œéª‘é¾™è·¨é©¬ä¸Šå®‰å±…ã€‚", "interpretation": "æ–‡å›è®¿ç›¸å¦‚ã€‚æ­¤ç­¾ä¸»æœ‰å˜æ•…ã€‚è°çŸ¥çˆ±å® ã€‚é‡å¼ºå¾’ã€‚å–»å¥½äº‹å¤šç£¨ã€‚å¥³å­å½“å¹´ã€‚å«äºŒå¤«ã€‚å–»ä¸€æ³¢ä¸‰æŠ˜ã€‚è‡ªæ˜¯ä¸€å¼“ã€‚æ–½ä¸¤ç®­ã€‚å–»ä¸€ä¸¾ä¸¤å¾—ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹æœ‰æƒŠæ— é™©ã€‚", "verse": "è™½æœ‰å°äººã€‚ç»ˆç©¶æ— ç¢ã€‚ä½³éŸ³å°†è‡³ã€‚å¥½äº‹å¯å¾…ã€‚" },
    { "id": 72, "title": "ç¬¬ä¸ƒåäºŒé¦– ä¸Šä¸Š", "poem": "å¼„èœ‚é¡»è¦æ±‚ä»–èœœï¼Œåªæ€•é­ä»–å°¾ä¸Šé’ˆï¼›\nè™½æ˜¯çœ¼å‰æœ‰å¼‚è·¯ï¼Œæš—é‡Œæ·±è—è†æ£˜æ—ã€‚", "interpretation": "èŒƒè ¡å½’æ¹–ã€‚æ­¤ç­¾ä¸»æœ‰å°äººã€‚å¼„èœ‚é¡»è¦ã€‚æ±‚ä»–èœœã€‚å–»æŠ•æœºå–å·§ã€‚åªæ€•é­ä»–ã€‚å°¾ä¸Šé’ˆã€‚å–»å¾—ä¸å¿å¤±ã€‚è™½æ˜¯çœ¼å‰ã€‚æœ‰å¼‚è·¯ã€‚å–»å¦æœ‰å‡ºè·¯ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "è®¤è´¼ä¸ºå­ã€‚åæ‚£æ— ç©·ã€‚çŸ¥äººçŸ¥é¢ã€‚ä¸çŸ¥å¿ƒã€‚" },
    { "id": 73, "title": "ç¬¬ä¸ƒåä¸‰é¦– ä¸­å¹³", "poem": "æ˜¥æ¥é›·éœ‡ç™¾è™«é¸£ï¼Œç•ªèº«ä¸€è½¬ç¦»æ³¥ä¸­ï¼›\nå§‹çŸ¥å‡ºå…¥è¿˜æ¥å¾€ï¼Œä¸€æœå˜åŒ–ä¾¿æˆé¾™ã€‚", "interpretation": "ç‹æœˆè‹±ç›¸å›½ã€‚æ­¤ç­¾ä¸»æœ‰è½¬æœºã€‚æ˜¥æ¥é›·éœ‡ã€‚ç™¾è™«é¸£ã€‚å–»æ—¶æ¥è¿è½¬ã€‚ç•ªèº«ä¸€è½¬ã€‚ç¦»æ³¥ä¸­ã€‚å–»è„±ç¦»å›°å¢ƒã€‚ä¸€æœå˜åŒ–ã€‚ä¾¿æˆé¾™ã€‚å–»åŠŸæˆåå°±ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹æœ‰è½¬æœºã€‚", "verse": "æ—¶æ¥è¿è½¬ã€‚æ¯æœ¨é€¢æ˜¥ã€‚è°‹æœ›çš†é‚ã€‚å¥½äº‹ä¸´é—¨ã€‚" },
    { "id": 74, "title": "ç¬¬ä¸ƒåå››é¦– ä¸­å¹³", "poem": "å´”å·å´”å·å¤å´”å·ï¼Œå±¥é™©å¦‚å¤·å»å¤æ¥ï¼›\nèº«ä¼¼è©æå¿ƒä¼¼é•œï¼Œé•¿åœ¨äººé—´ä¸æŸ“åŸƒã€‚", "interpretation": "è¾¾æ‘©é¢å£ã€‚æ­¤ç­¾ä¸»æœ‰ä¿®ä¸ºã€‚å´”å·å´”å·ã€‚å¤å´”å·ã€‚å–»å›°éš¾é‡é‡ã€‚å±¥é™©å¦‚å¤·ã€‚å»å¤æ¥ã€‚å–»æ„å¿—åšå®šã€‚èº«ä¼¼è©æã€‚å¿ƒä¼¼é•œã€‚å–»å“å¾·é«˜å°šã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "å¿ƒåœ°å–„è‰¯ã€‚ç¥ä½›æŠ¤ä½‘ã€‚å‡¡äº‹é¡ºå¿ƒã€‚å¤§å‰å¤§åˆ©ã€‚" },
    { "id": 75, "title": "ç¬¬ä¸ƒåäº”é¦– ä¸­å¹³", "poem": "çŠ¹å¦‚æŠ±è™è¿‡å±±å‰ï¼Œæˆ˜æˆ˜å…¢å…¢èƒ†ç¢å¯’ï¼›\nå¹¸å¾—å±±å‰é€¢å¦™æ‰‹ï¼Œæ–¹èƒ½ä¿å¾—ä¸€èº«å®‰ã€‚", "interpretation": "ä¼å­èƒ¥è¿‡æ˜­å…³ã€‚æ­¤ç­¾ä¸»æœ‰æƒŠæ— é™©ã€‚çŠ¹å¦‚æŠ±è™ã€‚è¿‡å±±å‰ã€‚å–»å¤„å¢ƒå±é™©ã€‚æˆ˜æˆ˜å…¢å…¢ã€‚èƒ†ç¢å¯’ã€‚å–»å¿ƒæƒŠèƒ†æˆ˜ã€‚å¹¸å¾—å±±å‰ã€‚é€¢å¦™æ‰‹ã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹æœ‰æƒŠæ— é™©ã€‚", "verse": "è™½æœ‰å°äººã€‚ç»ˆç©¶æ— ç¢ã€‚ä½³éŸ³å°†è‡³ã€‚å¥½äº‹å¯å¾…ã€‚" },
    { "id": 76, "title": "ç¬¬ä¸ƒåå…­é¦– ä¸Šä¸Š", "poem": "é±¼é¾™æ··æ‚æ„å’ŒåŒï¼Œè€å®ˆå¯’æ½­æœªæµä¸­ï¼›\nä¸è§‰ä¸€æœå¤´è§’è€¸ï¼Œç¦¹é—¨ä¸€è·³åˆ°å¤©å®«ã€‚", "interpretation": "æ´ªæ­¦çœ‹ç‰›ã€‚æ­¤ç­¾ä¸»å¤§å™¨æ™šæˆã€‚é±¼é¾™æ··æ‚ã€‚æ„å’ŒåŒã€‚å–»èº«å¤„é€†å¢ƒã€‚è€å®ˆå¯’æ½­ã€‚æœªæµä¸­ã€‚å–»å¿è€å¾…æ—¶ã€‚ä¸è§‰ä¸€æœã€‚å¤´è§’è€¸ã€‚å–»æ—¶æ¥è¿è½¬ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "é¾™è™å¤±åŠ¿ã€‚æš‚æ—¶å¿è€ã€‚å¾…æ—¶è€ŒåŠ¨ã€‚å¿…æœ‰ä½œä¸ºã€‚" },
    { "id": 77, "title": "ç¬¬ä¸ƒåä¸ƒé¦– ä¸­å¹³", "poem": "æ¢¦ä¸­è¯´æ¢¦è·å¤šè´¢ï¼Œèº«å¤–æµ®åæ€»ä¸æ¥ï¼›\næ°´è¿œå±±é¥éš¾ä¿¡å®ï¼Œè´µäººæŒ‡ç‚¹ç¬‘é¢œå¼€ã€‚", "interpretation": "èŒƒé›ç›¸ç§¦ã€‚æ­¤ç­¾ä¸»æœ‰è´µäººã€‚æ¢¦ä¸­è¯´æ¢¦ã€‚è·å¤šè´¢ã€‚å–»è™šå¹»ä¸å®ã€‚èº«å¤–æµ®åã€‚æ€»ä¸æ¥ã€‚å–»ååˆ©çš†ç©ºã€‚æ°´è¿œå±±é¥ã€‚éš¾ä¿¡å®ã€‚å–»å¸Œæœ›æ¸ºèŒ«ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹ä¸å¯å¼ºæ±‚ã€‚", "verse": "é•œèŠ±æ°´æœˆã€‚ä¸€åœºç©ºæ¬¢ã€‚ç—´å¿ƒå¦„æƒ³ã€‚å¾’åŠ³æ— åŠŸã€‚" },
    { "id": 78, "title": "ç¬¬ä¸ƒåå…«é¦– ä¸Šä¸Š", "poem": "å†·æ°´æ¥æµ‡ç™½é›ªæ´‹ï¼Œä¸å¯’ä¸çƒ­è‡ªæ¸©å‡‰ï¼›\nè¦è¡Œå¤©ä¸‹æ— ä»–äº‹ï¼ŒæƒŸæœ‰ä¸­è—ä¸€è‰ºå¼ºã€‚", "interpretation": "ä¸´æ½¼æ•‘é©¾ã€‚æ­¤ç­¾ä¸»æœ‰æŠ€è‰ºã€‚å†·æ°´æ¥æµ‡ã€‚ç™½é›ªæ´‹ã€‚å–»å¤„å˜ä¸æƒŠã€‚ä¸å¯’ä¸çƒ­ã€‚è‡ªæ¸©å‡‰ã€‚å–»å¿ƒæ€å¹³å’Œã€‚è¦è¡Œå¤©ä¸‹ã€‚æ— ä»–äº‹ã€‚å–»ä¸€æŠ€ä¹‹é•¿ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹é¡ºå¿ƒã€‚", "verse": "ä¸€æŠ€ä¹‹é•¿ã€‚èƒœè¿‡ä¸‡è´¯å®¶è´¢ã€‚" },
    { "id": 79, "title": "ç¬¬ä¸ƒåä¹é¦– ä¸­å¹³", "poem": "ä¹¾äº¥æ¥é¾™ä»”ç»†çœ‹ï¼Œåå±…åˆå‘è‡ªå½“å®‰ï¼›\nè‹¥ç§»ä¸‘è‰®é˜´é˜³é€†ï¼Œé—¨æˆ·å‡‹é›¶å®¶é“éš¾ã€‚", "interpretation": "æ–‡ç‹å‰ªæŒ‡ç”²ã€‚æ­¤ç­¾ä¸»å®¶å®…ã€‚ä¹¾äº¥æ¥é¾™ã€‚ä»”ç»†çœ‹ã€‚å–»é£æ°´é‡è¦ã€‚åå±…åˆå‘ã€‚è‡ªå½“å®‰ã€‚å–»æ–¹ä½å¾—å½“ã€‚è‹¥ç§»ä¸‘è‰®ã€‚é˜´é˜³é€†ã€‚å–»æ–¹ä½ä¸å½“ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "å®¶å®…å®‰å®ã€‚å‡¡äº‹é¡ºå¿ƒã€‚å®¶å®…ä¸å®ã€‚å‡¡äº‹ä¸é¡ºã€‚" },
    { "id": 80, "title": "ç¬¬å…«åé¦– ä¸Šä¸Š", "poem": "ä¸€æœé‡‘æ¦œå¿«é¢˜åï¼Œæ˜¾ç¥–è£å®—ç«‹å¤§å‹‹ï¼›\nè¡£é”¦è¿˜ä¹¡å¤©ä¸‹å“ï¼Œåƒäººæ™¯ä»°ä¸‡äººé’¦ã€‚", "interpretation": "çŠ¶å…ƒåŠç¬¬ã€‚æ­¤ç­¾ä¸»åŠŸæˆåå°±ã€‚ä¸€æœé‡‘æ¦œã€‚å¿«é¢˜åã€‚å–»é‡‘æ¦œé¢˜åã€‚æ˜¾ç¥–è£å®—ã€‚ç«‹å¤§å‹‹ã€‚å–»å…‰å®—è€€ç¥–ã€‚è¡£é”¦è¿˜ä¹¡ã€‚å¤©ä¸‹å“ã€‚å–»è¡£é”¦è¿˜ä¹¡ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "æ—¶æ¥è¿è½¬ã€‚æ¯æœ¨é€¢æ˜¥ã€‚è°‹æœ›çš†é‚ã€‚å¥½äº‹ä¸´é—¨ã€‚" },
    { "id": 81, "title": "ç¬¬å…«åä¸€é¦– ä¸Šä¸Š", "poem": "æ¢§æ¡å¶è½ç§‹å°†æš®ï¼Œè¡Œå®¢å¥”ç¨‹åŠ¿è‹¥é£ï¼›\nè°¢å¾—å¤©å…¬è½»è‘—åŠ›ï¼Œé¡ºé£ç›¸é€å®èˆ¹å½’ã€‚", "interpretation": "é£é€æ»•ç‹é˜ã€‚æ­¤ç­¾ä¸»æœ‰ç¥åŠ©ã€‚æ¢§æ¡å¶è½ã€‚ç§‹å°†æš®ã€‚å–»æ—¶æœºå·²åˆ°ã€‚è¡Œå®¢å¥”ç¨‹ã€‚åŠ¿è‹¥é£ã€‚å–»ä¸€å¸†é£é¡ºã€‚è°¢å¾—å¤©å…¬ã€‚è½»è‘—åŠ›ã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "ç¥ä½›æŠ¤ä½‘ã€‚æœ‰ç¾æ— å±ã€‚é€”è™½é™©é˜»ã€‚ç»ˆè·ä½³éŸ³ã€‚" },
    { "id": 82, "title": "ç¬¬å…«åäºŒé¦– ä¸­å¹³", "poem": "ç‚ç‚çƒˆç«ç„°çƒ§å¤©ï¼Œç„°é‡Œè¿˜ç”Ÿä¸€æœµè²ï¼›\nåˆ°åº•æ°¸æˆæ ¹ä¸åï¼Œä¾ç„¶æå¶è‰²æ–°é²œã€‚", "interpretation": "ç«çƒ§è‘«èŠ¦è°·ã€‚æ­¤ç­¾ä¸»æœ‰æƒŠæ— é™©ã€‚ç‚ç‚çƒˆç«ã€‚ç„°çƒ§å¤©ã€‚å–»å¤„å¢ƒå±é™©ã€‚ç„°é‡Œè¿˜ç”Ÿã€‚ä¸€æœµè²ã€‚å–»ç»å¤„é€¢ç”Ÿã€‚åˆ°åº•æ°¸æˆã€‚æ ¹ä¸åã€‚å–»æ ¹åŸºç¨³å›ºã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹æœ‰æƒŠæ— é™©ã€‚", "verse": "è™½æœ‰å°äººã€‚ç»ˆç©¶æ— ç¢ã€‚ä½³éŸ³å°†è‡³ã€‚å¥½äº‹å¯å¾…ã€‚" },
    { "id": 83, "title": "ç¬¬å…«åä¸‰é¦– ä¸­å¹³", "poem": "è­¬è‹¥åˆä¸‰å››äº”èŸ¾ï¼ŒåŠæ— åŠæœ‰æœªå®Œå…¨ï¼›\né¡»æ•™åäº”è‰¯å®µå¤œï¼Œåˆ°å¤„æ¸…å…‰åˆ°å¤„åœ†ã€‚", "interpretation": "ææ¸Šç™»ä½ã€‚æ­¤ç­¾ä¸»æœ‰å¾…è€Œå‘ã€‚è­¬è‹¥åˆä¸‰ã€‚å››äº”èŸ¾ã€‚å–»æ—¶æœºæœªåˆ°ã€‚åŠæ— åŠæœ‰ã€‚æœªå®Œå…¨ã€‚å–»äº‹æœªæœ‰æˆã€‚é¡»æ•™åäº”ã€‚è‰¯å®µå¤œã€‚å–»æ—¶æ¥è¿è½¬ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œå¾…æ—¶è€ŒåŠ¨ã€‚", "verse": "é™ä¸­å¾…æ—¶ã€‚å‡¡äº‹å®‰ç¨³ã€‚åŠ¨åˆ™æœ‰æŸã€‚é™åˆ™æ— å¿§ã€‚" },
    { "id": 84, "title": "ç¬¬å…«åå››é¦– ä¸­å¹³", "poem": "å› åä¸§å¾·ä¸å’ŒåŒï¼Œåˆ‡å¿Œå¿™ä¸­å˜ä½œå‡¶ï¼›\né†‰åä¸çŸ¥ä½•å¤„å»ï¼Œé’æ—ä¹‹å†…ä¸€å£°é£ã€‚", "interpretation": "åº„å­è¯•å¦»ã€‚æ­¤ç­¾ä¸»æœ‰æ˜¯éã€‚å› åä¸§å¾·ã€‚ä¸å’ŒåŒã€‚å–»å› å°å¤±å¤§ã€‚åˆ‡å¿Œå¿™ä¸­ã€‚å˜ä½œå‡¶ã€‚å–»ä¹æç”Ÿæ‚²ã€‚é†‰åä¸çŸ¥ã€‚ä½•å¤„å»ã€‚å–»è¿·å¤±æ–¹å‘ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "é€€ä¸€æ­¥æµ·é˜”å¤©ç©ºã€‚å‡¡äº‹ä¸‰æ€è€Œåè¡Œã€‚" },
    { "id": 85, "title": "ç¬¬å…«åäº”é¦– ä¸Šä¸Š", "poem": "é‡å¼€å±±è·¯ä½•æ›¾é™©ï¼Œä¸€æ­¥ç™»å¤©åœ¨æ­¤æ™‚ï¼›\nç§¯å–„ä¹‹å®¶æœ‰ä½™åº†ï¼Œå­å­™ä¼—å¤šæ‹œä¸¹å¢€ã€‚", "interpretation": "éŸ©æ–‡å…¬é‡é›ªã€‚æ­¤ç­¾ä¸»æœ‰å–„æŠ¥ã€‚é‡å¼€å±±è·¯ã€‚ä½•æ›¾é™©ã€‚å–»é€¢å‡¶åŒ–å‰ã€‚ä¸€æ­¥ç™»å¤©ã€‚åœ¨æ­¤æ™‚ã€‚å–»åŠŸæˆåå°±ã€‚ç§¯å–„ä¹‹å®¶ã€‚æœ‰ä½™åº†ã€‚å–»å–„æœ‰å–„æŠ¥ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å–„æœ‰å–„æŠ¥ã€‚æ¶æœ‰æ¶æŠ¥ã€‚ä¸æ˜¯ä¸æŠ¥ã€‚æ—¶è¾°æœªåˆ°ã€‚" },
    { "id": 86, "title": "ç¬¬å…«åå…­é¦– ä¸­å¹³", "poem": "æ˜¥æ¥èŠ±å‘æ˜ é˜³å°ï¼Œä¸‡é‡Œè½¦æ¥è¿›å®è´¢ï¼›\nè‹¥å¾—ç¦¹é—¨ä¸‰çº§æµªï¼Œæ°å¦‚å¹³åœ°ä¸€å£°é›·ã€‚", "interpretation": "å•†è¾‚ä¸­ä¸‰å…ƒã€‚æ­¤ç­¾ä¸»æœ‰ååˆ©ã€‚æ˜¥æ¥èŠ±å‘ã€‚æ˜ é˜³å°ã€‚å–»æ—¶æ¥è¿è½¬ã€‚ä¸‡é‡Œè½¦æ¥ã€‚è¿›å®è´¢ã€‚å–»è´¢è¿äº¨é€šã€‚è‹¥å¾—ç¦¹é—¨ã€‚ä¸‰çº§æµªã€‚å–»åŠŸæˆåå°±ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "å‡ºå…¥è£åã€‚å‰é€”äº‹ä¸šã€‚å¤§æœ‰å¯ä¸ºã€‚å è€…å¤§å‰ã€‚" },
    { "id": 87, "title": "ç¬¬å…«åä¸ƒé¦– ä¸­å¹³", "poem": "äººè¡ŒåŠå²­æ—¥è¡”å±±ï¼Œç«£å²­å´–å²©æœªå¯å®‰ï¼›\nä»°æœ›ä¸Šå¤©ä¸ºæŠ¤ä½‘ï¼Œæ­¤èº«çŠ¹åœ¨å¤ªå¹³é—´ã€‚", "interpretation": "å’¬é‡‘æ¢åœ°ç©´ã€‚æ­¤ç­¾ä¸»æœ‰æƒŠæ— é™©ã€‚äººè¡ŒåŠå²­ã€‚æ—¥è¡”å±±ã€‚å–»å¤„å¢ƒå±é™©ã€‚ç«£å²­å´–å²©ã€‚æœªå¯å®‰ã€‚å–»å›°éš¾é‡é‡ã€‚ä»°æœ›ä¸Šå¤©ã€‚ä¸ºæŠ¤ä½‘ã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹æœ‰æƒŠæ— é™©ã€‚", "verse": "è™½æœ‰å°äººã€‚ç»ˆç©¶æ— ç¢ã€‚ä½³éŸ³å°†è‡³ã€‚å¥½äº‹å¯å¾…ã€‚" },
    { "id": 88, "title": "ç¬¬å…«åå…«é¦– ä¸Šä¸Š", "poem": "æœ¨ä¸ºä¸€è™åœ¨å½“é—¨ï¼Œé¡»æ˜¯æœ‰å¨ä¸å®³äººï¼›\nåˆ†æ˜è¯´æ˜¯æ— é˜²äº‹ï¼Œå¿§æ¼è¿Ÿç–‘ææƒŠå¿ƒã€‚", "interpretation": "åºæ´ªç•åŒ…å…¬ã€‚æ­¤ç­¾ä¸»æœ‰å¨æ— é™©ã€‚æœ¨ä¸ºä¸€è™ã€‚åœ¨å½“é—¨ã€‚å–»æœ‰å¨ä¸¥ã€‚é¡»æ˜¯æœ‰å¨ã€‚ä¸å®³äººã€‚å–»æœ‰æƒŠæ— é™©ã€‚åˆ†æ˜è¯´æ˜¯ã€‚æ— é˜²äº‹ã€‚å–»ä¸å¿…æ‹…å¿ƒã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹æœ‰æƒŠæ— é™©ã€‚", "verse": "è™½æœ‰å°äººã€‚ç»ˆç©¶æ— ç¢ã€‚ä½³éŸ³å°†è‡³ã€‚å¥½äº‹å¯å¾…ã€‚" },
    { "id": 89, "title": "ç¬¬å…«åä¹é¦– ä¸­å¹³", "poem": "å‡ºå…¥è¥è°‹å¤§å‰æ˜Œï¼Œæ— ç‘•ç‰åœ¨çŸ³ä¸­è—ï¼›\nå¦‚ä»Šå¹¸å¾—é«˜äººæŒ‡ï¼Œè·å®ä»å¿ƒå–œä¸å¸¸ã€‚", "interpretation": "å¤§çœ‹ç¼èŠ±ã€‚æ­¤ç­¾ä¸»æœ‰è´µäººã€‚å‡ºå…¥è¥è°‹ã€‚å¤§å‰æ˜Œã€‚å–»äº‹äº‹é¡ºåˆ©ã€‚æ— ç‘•ç‰åœ¨ã€‚çŸ³ä¸­è—ã€‚å–»æœ‰æ‰ä¹‹äººã€‚å¦‚ä»Šå¹¸å¾—ã€‚é«˜äººæŒ‡ã€‚å–»å¾—è´µäººèµè¯†ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "å†…è—é‡‘ç‰ã€‚ä¸ä¸ºäººçŸ¥ã€‚æœ‰å¾…é«˜äººã€‚æ–¹èƒ½å‰–æã€‚" },
    { "id": 90, "title": "ç¬¬ä¹åé¦– ä¸­å¹³", "poem": "å¿½è¨€ä¸€ä¿¡å‘å¤©é£ï¼Œæ³°å±±å®è´æ»¡èˆ¹å½’ï¼›\nè‹¥é—®è·¯é€”æˆå¥½äº‹ï¼Œå‰å¤´ä»æœ‰è´µäººæ¨ã€‚", "interpretation": "éŸ¦ä¸¹é‡ä»™ã€‚æ­¤ç­¾ä¸»æœ‰è´µäººã€‚å¿½è¨€ä¸€ä¿¡ã€‚å‘å¤©é£ã€‚å–»å¥½è¿å°†è‡³ã€‚æ³°å±±å®è´ã€‚æ»¡èˆ¹å½’ã€‚å–»è´¢è¿äº¨é€šã€‚å‰å¤´ä»æœ‰ã€‚è´µäººæ¨ã€‚å–»å¾—è´µäººç›¸åŠ©ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹é¡ºé‚ã€‚", "verse": "è´µäººç›¸åŠ©ã€‚æ—¶æ¥è¿è½¬ã€‚å‡¡äº‹é¡ºå¿ƒã€‚å¤§å‰å¤§åˆ©ã€‚" },
    { "id": 91, "title": "ç¬¬ä¹åä¸€é¦– ä¸Šä¸Š", "poem": "å¥½å±•æ„çœ‰å‡ºä¼—æ¥ï¼Œå‰é€”æ”¹å˜å–œå®‰æ€€ï¼›\nä¸€æ¡å¤§è·¯å¦‚å¤©é˜”ï¼Œå‡¡äº‹ä¸å¿…æ‰ç–‘çŒœã€‚", "interpretation": "ä¸‰æˆ˜å•å¸ƒã€‚æ­¤ç­¾ä¸»æœ‰è½¬æœºã€‚å¥½å±•æ„çœ‰ã€‚å‡ºä¼—æ¥ã€‚å–»è„±ç¦»å›°å¢ƒã€‚å‰é€”æ”¹å˜ã€‚å–œå®‰æ€€ã€‚å–»æ—¶æ¥è¿è½¬ã€‚ä¸€æ¡å¤§è·¯ã€‚å¦‚å¤©é˜”ã€‚å–»å‰é€”æ— é‡ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "æ—¶æ¥è¿è½¬ã€‚æ¯æœ¨é€¢æ˜¥ã€‚è°‹æœ›çš†é‚ã€‚å¥½äº‹ä¸´é—¨ã€‚" },
    { "id": 92, "title": "ç¬¬ä¹åäºŒé¦– ä¸Šä¸Š", "poem": "è‡ªå¹¼ä¸ºå•†ä»»è®¾è°‹ï¼Œè´¢æºèŒ‚ç››ä¸åœæµï¼›\nå¦‚ä»Šç®¡æ•™æ— å·®é”™ï¼Œä¸ªä¸ªå®‰ç„¶å…±ç™½å¤´ã€‚", "interpretation": "è”¡å¿æŠ¥æ©ã€‚æ­¤ç­¾ä¸»è´¢è¿äº¨é€šã€‚è‡ªå¹¼ä¸ºå•†ã€‚ä»»è®¾è°‹ã€‚å–»ç»å•†æœ‰é“ã€‚è´¢æºèŒ‚ç››ã€‚ä¸åœæµã€‚å–»è´¢è¿äº¨é€šã€‚å¦‚ä»Šç®¡æ•™ã€‚æ— å·®é”™ã€‚å–»äº‹äº‹é¡ºåˆ©ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å‡ºå…¥è£åã€‚å‰é€”äº‹ä¸šã€‚å¤§æœ‰å¯ä¸ºã€‚å è€…å¤§å‰ã€‚" },
    { "id": 93, "title": "ç¬¬ä¹åä¸‰é¦– ä¸­å¹³", "poem": "é¸¾å‡¤ç¿”æ¯›é›¨æ·‹æ¼“ï¼Œå½“æ—¶å´è¢«é›€å„¿æ¬ºï¼›\nç»ˆæ•™ä¸€æ—¥äº‘å¼€è¾¾ï¼Œä¾æ—§è¿˜å›æ•´ç¾½è¡£ã€‚", "interpretation": "é«˜å›ä¿æ‹›äº²ã€‚æ­¤ç­¾ä¸»æœ‰æƒŠæ— é™©ã€‚é¸¾å‡¤ç¿”æ¯›ã€‚é›¨æ·‹æ¼“ã€‚å–»å¤„å¢ƒå±é™©ã€‚å½“æ—¶å´è¢«ã€‚é›€å„¿æ¬ºã€‚å–»å°äººä½œç¥Ÿã€‚ç»ˆæ•™ä¸€æ—¥ã€‚äº‘å¼€è¾¾ã€‚å–»é›¨è¿‡å¤©æ™´ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹æœ‰æƒŠæ— é™©ã€‚", "verse": "è™½æœ‰å°äººã€‚ç»ˆç©¶æ— ç¢ã€‚ä½³éŸ³å°†è‡³ã€‚å¥½äº‹å¯å¾…ã€‚" },
    { "id": 94, "title": "ç¬¬ä¹åå››é¦– ä¸Šä¸Š", "poem": "å°äººå›å­åˆ«è´¤æ„šï¼Œäº‹æœ‰å·®è®¹åˆæ˜¯éï¼›\nç´é‡çŸ¥éŸ³å½“é¼“æ“ï¼Œäº‰å¦‚ä¸é‡å¸¸é—­çœ‰ã€‚", "interpretation": "ä¼¯ç‰™è®¿å‹ã€‚æ­¤ç­¾ä¸»æœ‰çŸ¥éŸ³ã€‚å°äººå›å­ã€‚åˆ«è´¤æ„šã€‚å–»åˆ†è¾¨æ˜¯éã€‚ç´é‡çŸ¥éŸ³ã€‚å½“é¼“æ“ã€‚å–»å¾—é‡çŸ¥éŸ³ã€‚äº‰å¦‚ä¸é‡ã€‚å¸¸é—­çœ‰ã€‚å–»æ€€æ‰ä¸é‡ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹é¡ºå¿ƒã€‚", "verse": "å¾—é‡çŸ¥éŸ³ã€‚å‡¡äº‹é¡ºå¿ƒã€‚æ€€æ‰ä¸é‡ã€‚å‡¡äº‹ä¸é¡ºã€‚" },
    { "id": 95, "title": "ç¬¬ä¹åäº”é¦– ä¸­å¹³", "poem": "å¿—æ°”åŠŸä¸šåœ¨æœæœï¼Œä»Šå°†é…’è‰²ä¸èƒœé¥¶ï¼›\nè‹¥è§é‡‘é¸¡æŠ¥å›è¯­ï¼Œé’±è´¢ç¦ç¦„ä¸å›æ‹›ã€‚", "interpretation": "æ›¹ä¸•ç§°å¸ã€‚æ­¤ç­¾ä¸»æœ‰ååˆ©ã€‚å¿—æ°”åŠŸä¸šã€‚åœ¨æœæœã€‚å–»äº‹ä¸šå¿ƒå¼ºã€‚ä»Šå°†é…’è‰²ã€‚ä¸èƒœé¥¶ã€‚å–»æ²‰è¿·é…’è‰²ã€‚è‹¥è§é‡‘é¸¡ã€‚æŠ¥å›è¯­ã€‚å–»æ—¶æ¥è¿è½¬ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹å®œæ…ã€‚", "verse": "é€€ä¸€æ­¥æµ·é˜”å¤©ç©ºã€‚å‡¡äº‹ä¸‰æ€è€Œåè¡Œã€‚" },
    { "id": 96, "title": "ç¬¬ä¹åå…­é¦– ä¸Šä¸Š", "poem": "å·å·å®å¡”ä¸å¯»å¸¸ï¼Œå…«é¢ç²ç‘å°½æ”¾å…‰ï¼›\nåŠå›ç«‹å¿—å‹¤é¡¶ç¤¼ï¼Œä½œå–„è‹å¤©é™ç¦ç¥¥ã€‚", "interpretation": "çª¦ç‡•å±±ç§¯å–„ã€‚æ­¤ç­¾ä¸»æœ‰å–„æŠ¥ã€‚å·å·å®å¡”ã€‚ä¸å¯»å¸¸ã€‚å–»å“å¾·é«˜å°šã€‚å…«é¢ç²ç‘ã€‚å°½æ”¾å…‰ã€‚å–»æ‰åæ¨ªæº¢ã€‚åŠå›ç«‹å¿—ã€‚å‹¤é¡¶ç¤¼ã€‚å–»ç§¯å¾·è¡Œå–„ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "å–„æœ‰å–„æŠ¥ã€‚æ¶æœ‰æ¶æŠ¥ã€‚ä¸æ˜¯ä¸æŠ¥ã€‚æ—¶è¾°æœªåˆ°ã€‚" },
    { "id": 97, "title": "ç¬¬ä¹åä¸ƒé¦– ä¸­å¹³", "poem": "å½“é£ç‚¹çƒ›ç©ºç–å½±ï¼Œææƒšé“ºæˆé•œé‡ŒèŠ±ï¼›\nç´¯è¢«å„¿ç«¥æ±‚æ”¶æ‹¾ï¼Œæ€çŸ¥åªæ˜¯å¹»æµ®æ§ã€‚", "interpretation": "ä¹°è‡£äº”åå¯Œè´µã€‚æ­¤ç­¾ä¸»æœ‰è™šæœ›ã€‚å½“é£ç‚¹çƒ›ã€‚ç©ºç–å½±ã€‚å–»è™šå¹»ä¸å®ã€‚ææƒšé“ºæˆã€‚é•œé‡ŒèŠ±ã€‚å–»é•œèŠ±æ°´æœˆã€‚ç´¯è¢«å„¿ç«¥ã€‚æ±‚æ”¶æ‹¾ã€‚å–»å¾’åŠ³æ— åŠŸã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹ä¸å¯å¼ºæ±‚ã€‚", "verse": "é•œèŠ±æ°´æœˆã€‚ä¸€åœºç©ºæ¬¢ã€‚ç—´å¿ƒå¦„æƒ³ã€‚å¾’åŠ³æ— åŠŸã€‚" },
    { "id": 98, "title": "ç¬¬ä¹åå…«é¦– ä¸­å¹³", "poem": "ç»è¥å‡ºå…¥ä¸¤æ— ç–‘ï¼ŒæŠŠå®šå¿ƒè‚ ä»”ç»†çª¥ï¼›\né¢‘é¢‘æŠ¥ä¸å›æ¶ˆæ¯ï¼Œè¯­ä¸­è‹¥æ¬²è§çŸ¥æœºã€‚", "interpretation": "å‰å¹³é‡éš¾ã€‚æ­¤ç­¾ä¸»æœ‰æƒŠæ— é™©ã€‚ç»è¥å‡ºå…¥ã€‚ä¸¤æ— ç–‘ã€‚å–»äº‹äº‹é¡ºåˆ©ã€‚æŠŠå®šå¿ƒè‚ ã€‚ä»”ç»†çª¥ã€‚å–»å°å¿ƒè°¨æ…ã€‚é¢‘é¢‘æŠ¥ä¸ã€‚å›æ¶ˆæ¯ã€‚å–»æœ‰æƒŠæ— é™©ã€‚æ­¤ç­¾ä¸­å¹³ä¹‹å…†ã€‚å‡¡äº‹æœ‰æƒŠæ— é™©ã€‚", "verse": "è™½æœ‰å°äººã€‚ç»ˆç©¶æ— ç¢ã€‚ä½³éŸ³å°†è‡³ã€‚å¥½äº‹å¯å¾…ã€‚" },
    { "id": 99, "title": "ç¬¬ä¹åä¹é¦– ä¸Šä¸Š", "poem": "å‹’é©¬æŒé­ç›´è¿‡æ¥ï¼ŒåŠæœ‰å¿§å±åŠæœ‰ç¾ï¼›\næ°ä¼¼é­ç«ç„šçƒ§å±‹ï¼Œå¤©é™ç”˜é›¨è¡æˆç°ã€‚", "interpretation": "é™¶æ¸Šæ˜å½’éšã€‚æ­¤ç­¾ä¸»æœ‰æƒŠæ— é™©ã€‚å‹’é©¬æŒé­ã€‚ç›´è¿‡æ¥ã€‚å–»å›°éš¾é‡é‡ã€‚åŠæœ‰å¿§å±ã€‚åŠæœ‰ç¾ã€‚å–»æœ‰æƒŠæ— é™©ã€‚æ°ä¼¼é­ç«ã€‚ç„šçƒ§å±‹ã€‚å–»å¤„å¢ƒå±é™©ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹æœ‰æƒŠæ— é™©ã€‚", "verse": "è™½æœ‰å°äººã€‚ç»ˆç©¶æ— ç¢ã€‚ä½³éŸ³å°†è‡³ã€‚å¥½äº‹å¯å¾…ã€‚" },
    { "id": 100, "title": "ç¬¬ä¸€ç™¾é¦– ä¸Šä¸Š", "poem": "æˆ‘æœ¬å¤©ä»™é›·é›¨å¸ˆï¼Œå‰å‡¶ç¥¸ç¦æˆ‘å…ˆçŸ¥ï¼›\nè‡³è¯šç¥·å‘Šçš†çµéªŒï¼ŒæŠ½å¾—æ­¤ç­¾ç™¾äº‹å®œã€‚", "interpretation": "å”æ˜çš‡å‡»é¼“å‚¬èŠ±ã€‚æ­¤ç­¾ä¸»æœ‰ç¥åŠ©ã€‚æˆ‘æœ¬å¤©ä»™ã€‚é›·é›¨å¸ˆã€‚å–»ç¥ä½›ä¿ä½‘ã€‚å‰å‡¶ç¥¸ç¦ã€‚æˆ‘å…ˆçŸ¥ã€‚å–»é¢„çŸ¥æœªæ¥ã€‚è‡³è¯šç¥·å‘Šã€‚çš†çµéªŒã€‚å–»è¯šå¿ƒç¥ˆç¥·ã€‚æ­¤ç­¾ä¸Šä¸Šä¹‹å…†ã€‚å‡¡äº‹å¤§å‰ã€‚", "verse": "ç¥ä½›æŠ¤ä½‘ã€‚æœ‰ç¾æ— å±ã€‚é€”è™½é™©é˜»ã€‚ç»ˆè·ä½³éŸ³ã€‚" }
    ];

const TAROT_CARDS = [
    { name: "æ„šäºº", type: "major", upright: "å¤©çœŸ, æ–°çš„å¼€å§‹, è‡ªç”±ç²¾ç¥, è‡ªå‘æ€§", reversed: "é²è½, è¢«åˆ©ç”¨, è€ƒè™‘ä¸å‘¨, è½»ä¿¡" },
    { name: "é­”æœ¯å¸ˆ", type: "major", upright: "æ˜¾åŒ–, èµ„æº, åŠ›é‡, çµæ„Ÿè¡ŒåŠ¨", reversed: "æ“çºµ, è®¡åˆ’ä¸å‘¨, æœªå¼€å‘çš„æ‰èƒ½" },
    { name: "å¥³ç¥­å¸", type: "major", upright: "ç›´è§‰, ç¥åœ£å¥³æ€§, æ½œæ„è¯†, ç¥ç§˜", reversed: "ç§˜å¯†, è„±ç¦»ç›´è§‰, å‹æŠ‘çš„æƒ…æ„Ÿ" },
    { name: "å¥³çš‡", type: "major", upright: "ä¸°é¥¶, å¥³æ€§æ°”è´¨, ç¾ä¸½, è‡ªç„¶, å…»è‚²", reversed: "åˆ›é€ åŠ›å—é˜», ä¾èµ–ä»–äºº" },
    { name: "çš‡å¸", type: "major", upright: "æƒå¨, å»ºç«‹, ç»“æ„, åšå®çš„çˆ¶äº²å½¢è±¡", reversed: "æ”¯é…, è¿‡åº¦æ§åˆ¶, åƒµåŒ–" },
    { name: "æ•™çš‡", type: "major", upright: "ç²¾ç¥æ™ºæ…§, å®—æ•™ä¿¡ä»°, ä¼ ç»Ÿ, åˆ¶åº¦", reversed: "ä¸ªäººä¿¡ä»°, æŒ‘æˆ˜ä¼ ç»Ÿ, å¢¨å®ˆæˆè§„" },
    { name: "æ‹äºº", type: "major", upright: "çˆ±, å’Œè°, å…³ç³», ä»·å€¼è§‚å¯¹é½, é€‰æ‹©", reversed: "ä¸å’Œè°, å¤±è¡¡, ä»·å€¼è§‚é”™ä½" },
    { name: "æˆ˜è½¦", type: "major", upright: "æ§åˆ¶, æ„å¿—åŠ›, èƒœåˆ©, æœæ–­, å†³å¿ƒ", reversed: "å¤±æ§, å¯¹ç«‹, ç¼ºä¹æ–¹å‘" },
    { name: "åŠ›é‡", type: "major", upright: "åŠ›é‡, å‹‡æ°”, åŒæƒ…, ä¸“æ³¨, è€å¿ƒ", reversed: "å†…åœ¨åŠ›é‡, è‡ªæˆ‘æ€€ç–‘, èƒ½é‡ä¸è¶³" },
    { name: "éšå£«", type: "major", upright: "çµé­‚æ¢ç´¢, å†…çœ, ç‹¬å¤„, å†…åœ¨æŒ‡å¼•", reversed: "å­¤ç«‹, å­¤ç‹¬, é€€ç¼©" },
    { name: "å‘½è¿ä¹‹è½®", type: "major", upright: "å¥½è¿, å› æœæŠ¥åº”, ç”Ÿå‘½å‘¨æœŸ, è½¬æŠ˜ç‚¹", reversed: "åè¿æ°”, æŠµæŠ—æ”¹å˜, æ‰“ç ´å¾ªç¯" },
    { name: "æ­£ä¹‰", type: "major", upright: "æ­£ä¹‰, å…¬å¹³, çœŸç†, å› æœ, æ³•å¾‹", reversed: "ä¸å…¬, ä¸è´Ÿè´£ä»», ä¸è¯šå®" },
    { name: "å€’åŠäºº", type: "major", upright: "æš‚åœ, è‡£æœ, æ–°è§†è§’, é¡ºå…¶è‡ªç„¶", reversed: "æ‹–å»¶, æŠµæŠ—, åœæ», ä¼˜æŸ”å¯¡æ–­" },
    { name: "æ­»ç¥", type: "major", upright: "ç»“æŸ, æ”¹å˜, è½¬å˜, è¿‡æ¸¡", reversed: "æŠµæŠ—æ”¹å˜, æ— æ³•å‰è¿›, æ‰§ç€äºè¿‡å»" },
    { name: "èŠ‚åˆ¶", type: "major", upright: "å¹³è¡¡, é€‚åº¦, è€å¿ƒ, ç›®æ ‡", reversed: "ä¸å¹³è¡¡, è¿‡åº¦, ç¼ºä¹é•¿è¿œçœ¼å…‰" },
    { name: "æ¶é­”", type: "major", upright: "é˜´å½±è‡ªæˆ‘, ä¾æ‹, æˆç˜¾, æŸç¼š, æ€§æ¬²", reversed: "æ‰“ç ´æŸç¼š, ç‹¬ç«‹, é‡æ–°è·å¾—æ§åˆ¶" },
    { name: "å¡”", type: "major", upright: "çªå˜, å‰§å˜, æ··ä¹±, å¯ç¤º, è§‰é†’", reversed: "é¿å…ç¾éš¾, å®³æ€•æ”¹å˜, æ‹–å»¶ä¸å¯é¿å…ä¹‹äº‹" },
    { name: "æ˜Ÿæ˜Ÿ", type: "major", upright: "å¸Œæœ›, ä¿¡å¿µ, ç›®æ ‡, æ›´æ–°, çµæ€§", reversed: "ç¼ºä¹ä¿¡å¿µ, ç»æœ›, ä¸è‡ªå·±è„±èŠ‚" },
    { name: "æœˆäº®", type: "major", upright: "å¹»è§‰, ææƒ§, ç„¦è™‘, æ½œæ„è¯†, ç›´è§‰", reversed: "é‡Šæ”¾ææƒ§, å‹æŠ‘çš„æƒ…æ„Ÿ, å†…å¿ƒå›°æƒ‘" },
    { name: "å¤ªé˜³", type: "major", upright: "ç§¯æ, ä¹è¶£, æ¸©æš–, æˆåŠŸ, æ´»åŠ›", reversed: "å†…å¿ƒç«¥çœŸ, è¿‡äºä¹è§‚, ç¼ºä¹æˆåŠŸ" },
    { name: "å®¡åˆ¤", type: "major", upright: "å®¡åˆ¤, é‡ç”Ÿ, å†…å¿ƒå¬å”¤, èµ¦å…", reversed: "è‡ªæˆ‘æ€€ç–‘, å¿½è§†å¬å”¤, æ‰§ç€äºè‡ªæˆ‘æ‰¹è¯„" },
    { name: "ä¸–ç•Œ", type: "major", upright: "å®Œæˆ, æ•´åˆ, æˆå°±, æ—…è¡Œ", reversed: "å¯»æ±‚ç»“æŸ, èµ°æ·å¾„, æ‹–å»¶" },
    { name: "æƒæ–ACE", type: "minor", upright: "çµæ„Ÿ, æ–°æœºä¼š, æˆé•¿, æ½œåŠ›", reversed: "ç¼ºä¹åŠ¨åŠ›, é”™å¤±æœºä¼š, æ‹–å»¶" },
    { name: "æƒæ–äºŒ", type: "minor", upright: "æœªæ¥è§„åˆ’, å†³ç­–, ç¦»å¼€èˆ’é€‚åŒº", reversed: "å®³æ€•æœªçŸ¥, ç¼ºä¹è§„åˆ’, è¢«ä¸ªäººææƒ§æ‰€å›°" },
    { name: "æƒæ–ä¸‰", type: "minor", upright: "æ‰©å¼ , è¿œè§, æ˜¾è€Œæ˜“è§çš„è¿›æ­¥", reversed: "éšœç¢, å»¶è¿Ÿ, å¯¹å†’é™©çš„æ²®ä¸§" },
    { name: "æƒæ–å››", type: "minor", upright: "åº†ç¥, å’Œè°, å©šå§», å®¶åº­", reversed: "ä¸å’Œè°, è¿‡æ¸¡, ç¼ºä¹æ”¯æŒ" },
    { name: "æƒæ–äº”", type: "minor", upright: "å†²çª, åˆ†æ­§, ç«äº‰, ç´§å¼ ", reversed: "å†²çªé¿å…, å°Šé‡å·®å¼‚, è¾¾æˆä¸€è‡´" },
    { name: "æƒæ–å…­", type: "minor", upright: "å…¬ä¼—è®¤å¯, èƒœåˆ©, è¿›æ­¥, è‡ªä¿¡", reversed: "ç§ä¸‹åº†ç¥, å®³æ€•å¼•èµ·æ³¨æ„, ç¼ºä¹è®¤å¯" },
    { name: "æƒæ–ä¸ƒ", type: "minor", upright: "æŒ‘æˆ˜, ç«äº‰, ä¿æŠ¤, æ¯…åŠ›", reversed: "æ”¾å¼ƒ, ä¸çŸ¥æ‰€æª, è¿‡åº¦ä¿æŠ¤" },
    { name: "æƒæ–å…«", type: "minor", upright: "é€Ÿåº¦, è¡ŒåŠ¨, ç©ºä¸­æ—…è¡Œ, å¿«é€Ÿå†³ç­–", reversed: "å»¶è¿Ÿ, æŒ«æŠ˜, æŠµæŠ—æ”¹å˜" },
    { name: "æƒæ–ä¹", type: "minor", upright: "éŸ§æ€§, å‹‡æ°”, åšæŒ, ç•Œé™", reversed: "å†…å¿ƒæŒ£æ‰, ç–²æƒ«, é˜²å¾¡" },
    { name: "æƒæ–å", type: "minor", upright: "è´Ÿæ‹…, è´£ä»»è¿‡é‡, è¾›åŠ³, å‹åŠ›", reversed: "å§”æ´¾, é‡Šæ”¾è´Ÿæ‹…, é¿å…è´£ä»»" },
    { name: "æƒæ–ä¾ä»", type: "minor", upright: "çƒ­æƒ…, å‘ç°, è‡ªç”±ç²¾ç¥", reversed: "æ–°æƒ³æ³•, èƒ½é‡é‡æ–°å¯¼å‘, ç¼ºä¹æ¿€æƒ…" },
    { name: "æƒæ–éª‘å£«", type: "minor", upright: "èƒ½é‡, æ¿€æƒ…, æ¬²æœ›, è¡ŒåŠ¨, å†’é™©", reversed: "æ„¤æ€’, å†²åŠ¨, é²è½" },
    { name: "æƒæ–ç‹å", type: "minor", upright: "å‹‡æ°”, è‡ªä¿¡, ç‹¬ç«‹, ç¤¾äº¤è´è¶", reversed: "è‡ªæˆ‘å°Šé‡, å†…å‘, æ„Ÿè§‰è¢«å­¤ç«‹" },
    { name: "æƒæ–å›½ç‹", type: "minor", upright: "å¤©ç”Ÿçš„é¢†å¯¼è€…, è¿œè§, ä¼ä¸šå®¶, è£èª‰", reversed: "å†²åŠ¨, ä»“ä¿ƒ, å¯¹ä»–äººæœŸæœ›è¿‡é«˜" },
    { name: "åœ£æ¯ACE", type: "minor", upright: "çˆ±, æ–°å…³ç³», åŒæƒ…, åˆ›é€ åŠ›", reversed: "è‡ªæˆ‘çˆ±æŠ¤, ç›´è§‰, å‹æŠ‘çš„æƒ…æ„Ÿ" },
    { name: "åœ£æ¯äºŒ", type: "minor", upright: "ç»Ÿä¸€çš„çˆ±, ä¼™ä¼´å…³ç³», ç›¸äº’å¸å¼•", reversed: "è‡ªæˆ‘çˆ±æŠ¤, æ‰“ç ´å’Œè°, ä¸ä¿¡ä»»" },
    { name: "åœ£æ¯ä¸‰", type: "minor", upright: "åº†ç¥, å‹è°Š, åˆ›é€ åŠ›, åˆä½œ", reversed: "ç‹¬ç«‹, ç‹¬å¤„, 'ä¸‰äººè¡Œå¿…æœ‰æˆ‘å¸ˆ'" },
    { name: "åœ£æ¯å››", type: "minor", upright: "å†·æ¼ , æ²‰æ€, è„±èŠ‚, å†·æ¼ ", reversed: "é€€ç¼©, é€‰æ‹©æŠ“ä½æœºä¼š, æ¥å—å¸®åŠ©" },
    { name: "åœ£æ¯äº”", type: "minor", upright: "åæ‚”, å¤±è´¥, å¤±æœ›, æ‚²è§‚", reversed: "ä¸ªäººæŒ«æŠ˜, è‡ªæˆ‘å®½æ•, å‰è¿›" },
    { name: "åœ£æ¯å…­", type: "minor", upright: "é‡æ¸©è¿‡å», ç«¥å¹´è®°å¿†, å¤©çœŸ, å–œæ‚¦", reversed: "æ´»åœ¨å½“ä¸‹, æ²»æ„ˆ, æˆé•¿" },
    { name: "åœ£æ¯ä¸ƒ", type: "minor", upright: "æœºä¼š, é€‰æ‹©, ä¸€å¢æƒ…æ„¿, å¹»è§‰", reversed: "å¯¹é½, ä¸ªäººä»·å€¼è§‚, ä¸çŸ¥æ‰€æªçš„é€‰æ‹©" },
    { name: "åœ£æ¯å…«", type: "minor", upright: "å¤±æœ›, æŠ›å¼ƒ, é€€ç¼©, é€ƒé¿", reversed: "å°è¯•æ–°äº‹ç‰©, ä¼˜æŸ”å¯¡æ–­, å®³æ€•æ”¹å˜" },
    { name: "åœ£æ¯ä¹", type: "minor", upright: "æ»¡è¶³, æ»¡æ„, æ„Ÿæ©, æ„¿æœ›æˆçœŸ", reversed: "å†…å¿ƒå¹¸ç¦, å”¯ç‰©ä¸»ä¹‰, ä¸æ»¡" },
    { name: "åœ£æ¯å", type: "minor", upright: "ç¥åœ£çš„çˆ±, å’Œè°çš„å…³ç³», å’Œè°, å¯¹é½", reversed: "ä¸è‡ªæˆ‘è„±èŠ‚, å¯»æ±‚å’Œè°, å…³ç³»ä¸å’Œè°" },
    { name: "åœ£æ¯ä¾ä»", type: "minor", upright: "åˆ›é€ æœºä¼š, ç›´è§‰ä¿¡æ¯, å¥½å¥‡å¿ƒ, å¯èƒ½æ€§", reversed: "æ–°çš„æƒ³æ³•, æ€€ç–‘, åˆ›é€ åŠ›å—é˜»" },
    { name: "åœ£æ¯éª‘å£«", type: "minor", upright: "åˆ›é€ åŠ›, æµªæ¼«, é­…åŠ›, æƒ³è±¡åŠ›, ç¾ä¸½", reversed: "è¿‡äºæƒ…ç»ªåŒ–, æƒ…ç»ªä¸ç¨³å®š, å¤±æœ›" },
    { name: "åœ£æ¯ç‹å", type: "minor", upright: "å¯Œæœ‰åŒæƒ…å¿ƒ, å…³æ€€, æƒ…æ„Ÿç¨³å®š, ç›´è§‰, æµåŠ¨", reversed: "å†…å¿ƒæ„Ÿå—, è‡ªæˆ‘å…³æ€€, è‡ªæˆ‘çˆ±æŠ¤, å…±æƒ…ä¾èµ–" },
    { name: "åœ£æ¯å›½ç‹", type: "minor", upright: "æƒ…æ„Ÿå¹³è¡¡, å¯Œæœ‰åŒæƒ…å¿ƒ, å¤–äº¤æ‰‹è…•", reversed: "è‡ªæˆ‘åŒæƒ…, å†…å¿ƒæ„Ÿå—, æƒ…ç»ªæ“çºµ" },
    { name: "å®å‰‘ACE", type: "minor", upright: "çªç ´, æ–°æƒ³æ³•, ç²¾ç¥æ¸…æ™°, æˆåŠŸ", reversed: "å†…å¿ƒæ¸…æ™°, é‡æ–°æ€è€ƒä¸€ä¸ªæƒ³æ³•, æ€ç»´æ··ä¹±" },
    { name: "å®å‰‘äºŒ", type: "minor", upright: "è‰°éš¾çš„å†³å®š, æƒè¡¡é€‰æ‹©, åƒµå±€, å›é¿", reversed: "ä¼˜æŸ”å¯¡æ–­, å›°æƒ‘, ä¿¡æ¯è¿‡è½½" },
    { name: "å®å‰‘ä¸‰", type: "minor", upright: "å¿ƒç¢, æƒ…æ„Ÿç—›è‹¦, æ‚²ä¼¤, æ‹’ç»", reversed: "é‡Šæ”¾ç—›è‹¦, ä¹è§‚, å®½æ•" },
    { name: "å®å‰‘å››", type: "minor", upright: "ä¼‘æ¯, æ”¾æ¾, å†¥æƒ³, æ²‰æ€, ä¼‘å…»", reversed: "ç–²æƒ«, ç²¾ç–²åŠ›ç«­, åœæ», æ€¨æ¨" },
    { name: "å®å‰‘äº”", type: "minor", upright: "å†²çª, åˆ†æ­§, ç«äº‰, å¤±è´¥, èƒœåˆ©", reversed: "å’Œè§£, è®²å’Œ, è¿‡å»çš„ä¸æ»¡" },
    { name: "å®å‰‘å…­", type: "minor", upright: "è¿‡æ¸¡, æ”¹å˜, æ‘†è„±å›°å¢ƒ, é‡Šæ”¾", reversed: "ä¸ªäººè½¬å˜, æŠµæŠ—æ”¹å˜, æœªå®Œæˆçš„äº‹æƒ…" },
    { name: "å®å‰‘ä¸ƒ", type: "minor", upright: "èƒŒå›, æ¬ºéª—, å ä¾¿å®œ, å·å·æ‘¸æ‘¸", reversed: "å†’åé¡¶æ›¿ç»¼åˆç—‡, æ¬ºéª—è‡ªå·±, ä¿å¯†" },
    { name: "å®å‰‘å…«", type: "minor", upright: "æ¶ˆæçš„æƒ³æ³•, è‡ªæˆ‘å¼ºåŠ çš„é™åˆ¶, ç›‘ç¦, å—å®³è€…å¿ƒæ€", reversed: "è‡ªæˆ‘é™åˆ¶çš„ä¿¡å¿µ, å†…å¿ƒæ‰¹è¯„, é‡Šæ”¾æ¶ˆææ€æƒ³" },
    { name: "å®å‰‘ä¹", type: "minor", upright: "ç„¦è™‘, æ‹…å¿§, ææƒ§, æŠ‘éƒ, å™©æ¢¦", reversed: "å†…å¿ƒæŒ£æ‰, æ·±åº¦ææƒ§, é‡Šæ”¾æ‹…å¿§" },
    { name: "å®å‰‘å", type: "minor", upright: "ç—›è‹¦çš„ç»“å±€, æ·±åº¦åˆ›ä¼¤, èƒŒå›, å¤±è½, å±æœº", reversed: "æ¢å¤, æŠµæŠ—ç»“å±€, æ— æ³•æ”¾æ‰‹" },
    { name: "å®å‰‘ä¾ä»", type: "minor", upright: "æ–°æƒ³æ³•, å¥½å¥‡å¿ƒ, è¿½æ±‚çœŸç†, å……æ»¡æ´»åŠ›", reversed: "è‡ªæˆ‘è¡¨è¾¾, å…¨ç›˜æ‰˜å‡º, å«ç³Šå…¶è¾" },
    { name: "å®å‰‘éª‘å£«", type: "minor", upright: "é›„å¿ƒå‹ƒå‹ƒ, è¡ŒåŠ¨å¯¼å‘, è¿½æ±‚ç›®æ ‡, å¿«é€Ÿæ€è€ƒ", reversed: "ä¸å®‰é™, å†²åŠ¨, åŒ†å¿™çš„å†³å®š" },
    { name: "å®å‰‘ç‹å", type: "minor", upright: "ç‹¬ç«‹çš„, æ— åè§çš„åˆ¤æ–­, æ¸…æ™°çš„ç•Œé™", reversed: "è¿‡äºæƒ…ç»ªåŒ–, å®¹æ˜“å—å½±å“, å†…å¿ƒæ‰¹è¯„" },
    { name: "å®å‰‘å›½ç‹", type: "minor", upright: "ç²¾ç¥æ¸…æ™°, æ™ºæ…§, æƒå¨, çœŸç†", reversed: "å®‰é™çš„åŠ›é‡, å†…å¿ƒçœŸç†, æ»¥ç”¨æƒåŠ›" },
    { name: "æ˜Ÿå¸ACE", type: "minor", upright: "æ˜¾åŒ–, æ–°çš„è´¢åŠ¡æœºä¼š, ç¹è£", reversed: "é”™å¤±æœºä¼š, ç¼ºä¹è§„åˆ’å’Œè¿œè§" },
    { name: "æ˜Ÿå¸äºŒ", type: "minor", upright: "å¤šä»»åŠ¡, é€‚åº”æ€§, æ—¶é—´ç®¡ç†", reversed: "é‡æ–°å®‰æ’ä¼˜å…ˆæ¬¡åº, ä¸çŸ¥æ‰€æª" },
    { name: "æ˜Ÿå¸ä¸‰", type: "minor", upright: "å›¢é˜Ÿåˆä½œ, åä½œ, å­¦ä¹ , å®æ–½", reversed: "ä¸å’Œè°, å›¢é˜Ÿä¸­çš„ä¸ä¸€è‡´, ç¼ºä¹å›¢é˜Ÿåˆä½œ" },
    { name: "æ˜Ÿå¸å››", type: "minor", upright: "èŠ‚çº¦, å®‰å…¨, ä¿å®ˆ, ç¨€ç¼ºå¿ƒæ€", reversed: "æ…·æ…¨, ç»™äºˆ, å¼€æ”¾" },
    { name: "æ˜Ÿå¸äº”", type: "minor", upright: "è´¢åŠ¡æŸå¤±, è´«ç©·, å­¤ç«‹, æ‹…å¿§", reversed: "ä»è´¢åŠ¡æŸå¤±ä¸­æ¢å¤, ç²¾ç¥è´«ä¹" },
    { name: "æ˜Ÿå¸å…­", type: "minor", upright: "ç»™äºˆ, æ¥å—, åˆ†äº«è´¢å¯Œ, æ…·æ…¨, æ…ˆå–„", reversed: "è‡ªç§è‡ªåˆ©, æ— å¿å€ºåŠ¡, å•å‘çš„æ–½èˆ" },
    { name: "æ˜Ÿå¸ä¸ƒ", type: "minor", upright: "é•¿è¿œçœ¼å…‰, æ¯…åŠ›, æŠ•èµ„, å¯æŒç»­çš„ç»“æœ", reversed: "ç¼ºä¹é•¿è¿œçœ¼å…‰, æˆåŠŸæœ‰é™" },
    { name: "æ˜Ÿå¸å…«", type: "minor", upright: "å­¦å¾’æœŸ, ç£¨ç»ƒæŠ€èƒ½, ç²¾é€š, è´¨é‡", reversed: "å®Œç¾ä¸»ä¹‰, æŠ€èƒ½å·®è·, ç¼ºä¹åŠ¨åŠ›" },
    { name: "æ˜Ÿå¸ä¹", type: "minor", upright: "å¯Œè¶³, å¥¢å, è‡ªç»™è‡ªè¶³, è´¢åŠ¡ç‹¬ç«‹", reversed: "è¿‡åº¦å·¥ä½œ, è´¢åŠ¡ä¾èµ–" },
    { name: "æ˜Ÿå¸å", type: "minor", upright: "è´¢å¯Œ, é—äº§, å®¶æ—, åŸºç¡€", reversed: "è´¢åŠ¡å¤±è´¥æˆ–æŸå¤±, ç»§æ‰¿çº çº·" },
    { name: "æ˜Ÿå¸ä¾ä»", type: "minor", upright: "æ˜¾åŒ–, è´¢åŠ¡æœºä¼š, æŠ€èƒ½å‘å±•", reversed: "ç¼ºä¹è¿›æ­¥, æ‹–å»¶, ä»é”™è¯¯ä¸­å­¦ä¹ " },
    { name: "æ˜Ÿå¸éª‘å£«", type: "minor", upright: "å‹¤å¥‹, è´£ä»», å¯é , ä¿å®ˆ", reversed: "è‡ªæˆ‘çºªå¾‹, æ— èŠ, æ„Ÿè§‰'å¡ä½'" },
    { name: "æ˜Ÿå¸ç‹å", type: "minor", upright: "å…»è‚², åŠ¡å®, è´¢åŠ¡å®‰å…¨, è„šè¸å®åœ°", reversed: "è‡ªæˆ‘å…³æ€€, è´¢åŠ¡ç‹¬ç«‹, å·¥ä½œä¸ç”Ÿæ´»çš„å¹³è¡¡" },
    { name: "æ˜Ÿå¸å›½ç‹", type: "minor", upright: "è´¢å¯Œ, å•†ä¸š, é¢†å¯¼åŠ›, å®‰å…¨, çºªå¾‹, å¯Œè¶³", reversed: "è´¢åŠ¡ä¸ç§°èŒ, è¿‡æ—¶, å›ºæ‰§" }
];
    /**
 * @param {File|Blob} file The image file to compress.
 * @param {object} options Compression options.
 * @param {number} [options.maxWidth=1280] The maximum width of the output image.
 * @param {number} [options.maxHeight=1280] The maximum height of the output image.
 * @param {number} [options.quality=0.8] The quality of the output JPEG image (0 to 1).
 * @returns {Promise<Blob>} A promise that resolves with the compressed image Blob.
 */
function compressImageBeforeSaving(file, options = {}) {
    const { maxWidth = 1280, maxHeight = 1280, quality = 0.8 } = options;

    return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();

        reader.onload = (e) => {
            img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);

        img.onload = () => {
            const canvas = document.createElement('canvas');
            let { width, height } = img;

            if (width > height) {
                if (width > maxWidth) {
                    height *= maxWidth / width;
                    width = maxWidth;
                }
            } else {
                if (height > maxHeight) {
                    width *= maxHeight / height;
                    height = maxHeight;
                }
            }

            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);

            canvas.toBlob(
                (blob) => {
                    if (!blob) {
                        reject(new Error('Canvas to Blob conversion failed'));
                        return;
                    }
                    // For transparency, check if we should use PNG, otherwise JPEG is better for photos
                    // For simplicity, we'll stick to JPEG here as it offers the best compression for photos.
                    resolve(blob);
                },
                'image/jpeg',
                quality
            );
        };
        img.onerror = reject;
    });
}
async function handleMomentsImageUpload(file, profileId, type) {
        if (!file) return;

        const toastMessage = type === 'cover' ? 'æ­£åœ¨ä¸Šä¼ å°é¢...' : 'æ­£åœ¨ä¸Šä¼ å¤´åƒ...';
        showToast(toastMessage);

        try {
            const generatedId = newId(type === 'cover' ? 'moments_cover' : 'moments_avatar');
            await addMediaToDB(generatedId, file);

            if (profileId === 'user') {
                if (type === 'cover') {
                    appState.chat.moments.profile.coverId = generatedId;
                } else { // avatar
                    appState.chat.moments.profile.avatarId = generatedId;
                    appState.chat.userProfile.avatarId = generatedId; // Sync global avatar
                }
            } else {
                const contact = appState.chat.contacts.find(c => c.id === profileId);
                if (contact) {
                    if (type === 'cover') {
                        contact.charSettings.momentsCoverId = generatedId;
                    } else { // avatar
                        if (typeof contact.charSettings.momentsAvatarId === 'undefined') {
                            contact.charSettings.momentsAvatarId = '';
                        }
                        contact.charSettings.momentsAvatarId = generatedId;
                    }
                }
            }
            
            debouncedSaveState();
            renderMomentsPage(profileId);
            showToast(type === 'cover' ? 'å°é¢æ›´æ¢æˆåŠŸï¼' : 'å¤´åƒæ›´æ¢æˆåŠŸï¼');
        } catch (error) {
            console.error('å›¾ç‰‡ä¸Šä¼ æˆ–ä¿å­˜å¤±è´¥:', error);
            showToast('ä¸Šä¼ å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æ§åˆ¶å°è·å–é”™è¯¯ä¿¡æ¯ã€‚', 'error');
        }
    }
    function handleMomentsPageInteraction(e) {
        const profileId = runtimeState.moments.currentProfileId;
        const isUserPage = profileId === 'user';
        const target = e.target;

        // --- å¤´åƒã€å°é¢ã€æ˜µç§°ã€ç­¾åç‚¹å‡» ---
            if (target.closest(`#moments-cover-${profileId}`) || target.closest(`#moments-profile-avatar-${profileId}`)) {
                const type = target.closest(`#moments-cover-${profileId}`) ? 'cover' : 'avatar';
                
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.style.display = 'none';

                const cleanup = () => {
                    if (input.parentNode) {
                        document.body.removeChild(input);
                    }
                    window.removeEventListener('focus', cleanup);
                };

                input.onchange = (e) => {
                    handleMomentsImageUpload(e.target.files[0], profileId, type);
                    cleanup();
                };

                // Add a fallback cleanup listener. If the user cancels the file dialog,
                // the window regains focus, and we can remove the dangling input.
                window.addEventListener('focus', cleanup, { once: true });

                document.body.appendChild(input);
                input.click();
                return;
            }
            if (isUserPage && target.closest(`#moments-profile-name-${profileId}`)) {
                const newName = prompt('ä¿®æ”¹ä½ çš„åŠ¨æ€æ˜µç§°:', appState.chat.moments.profile.name);
                if (newName && newName.trim()) { appState.chat.moments.profile.name = newName.trim(); appState.chat.userProfile.name = newName.trim(); debouncedSaveState(); renderMomentsPage('user'); }
                return;
            }
            if (isUserPage && target.closest(`#moments-profile-signature-${profileId}`)) {
                const newSignature = prompt('ä¿®æ”¹ä½ çš„ä¸ªæ€§ç­¾å:', appState.chat.moments.profile.signature);
                if (newSignature !== null) { const oldSignature = appState.chat.moments.profile.signature; appState.chat.moments.profile.signature = newSignature.trim(); appState.chat.userProfile.signature = newSignature.trim(); if (newSignature.trim() !== oldSignature) { const newPost = { id: newId('post'), authorId: 'user', type: 'status', content: { text: `ç­¾åæ›´æ¢ä¸ºï¼šâ€œ${newSignature.trim()}â€`, images: [] }, timestamp: Date.now(), likes: [], comments: [] }; appState.chat.moments.posts.unshift(newPost); } debouncedSaveState(); renderMomentsPage('user'); }
                return;
            }

        // --- ç­›é€‰æ ‡ç­¾ç‚¹å‡» ---
        const filterTab = target.closest('.moments-filter-tab');
        if (filterTab) {
            runtimeState.moments.isFabMenuOpen = false;
            const filter = filterTab.dataset.filter;
            runtimeState.moments.currentFilter = filter; // ä¿®å¤ï¼šä¸å†åˆ‡æ¢ï¼Œç›´æ¥è®¾ç½®ä¸ºç‚¹å‡»çš„tab
            renderMomentsFeed(profileId);
            return;
        }

        // --- FABæŒ‰é’®ç‚¹å‡» ---
        const fabContainer = target.closest(`#moments-fab-container-${profileId}`);
            if(fabContainer) {
                const fab = target.closest('#moments-fab');
                const fabOption = target.closest('.fab-option');
                if (fab) {
                    const fabOptions = fabContainer.querySelector('#moments-fab-options');
                    runtimeState.moments.isFabMenuOpen = !runtimeState.moments.isFabMenuOpen;
                    fabOptions.style.display = runtimeState.moments.isFabMenuOpen ? 'flex' : 'none';
                } else if (fabOption) {
                    const action = fabOption.dataset.action;
                    switch(action) {
                        case 'status':
                            openPostMomentModal('status');
                            break;
                        case 'log':
                            openPostMomentModal('log');
                            break;
                        case 'photo':
                            openUploadPhotoModal();
                            break;
                        case 'album':
                            openManageAlbumsModal();
                            break;
                        case 'message':
                            openLeaveMessageModal();
                            break;
                        default:
                            showToast(`æ­¤åŠŸèƒ½å¾…å¼€å‘`);
                            break;
                    }
                    runtimeState.moments.isFabMenuOpen = false;
                    fabContainer.querySelector('#moments-fab-options').style.display = 'none';
                }
                return; // FABäº¤äº’åç›´æ¥è¿”å›
            }
        
        // --- åŠ¨æ€åˆ—è¡¨é¡¹äº¤äº’ ---
        const postItem = target.closest('.moments-post-item');
        if(postItem) {
            handleMomentsFeedPostInteraction(e, postItem, profileId);
            return;
        }
        const messageItem = target.closest('.message-board-item');
            if(messageItem) {
                handleMessageBoardInteraction(e, messageItem, profileId);
                return;
            }

        // --- Album grid item interaction (for main album tab) ---
        const photoGridItem = target.closest('.photo-grid-item');
        if (photoGridItem && target.closest('.moments-feed')) {
            const grid = target.closest('.photo-grid');
            const allPhotoItems = Array.from(grid.querySelectorAll('.photo-grid-item'));
            const allPhotoIds = allPhotoItems.map(item => item.dataset.id);
            const allPhotos = allPhotoIds.map(id => appState.chat.moments.photos.find(p => p.id === id)).filter(Boolean);
            const startIndex = allPhotoItems.indexOf(photoGridItem);

            if (startIndex > -1) {
                openPhotoViewer(allPhotos, startIndex);
            }
            return;
        }
        if(postItem) {
            handleMomentsFeedPostInteraction(e, postItem, profileId);
        }
    }
    function logVisitor(targetProfileId, visitorId) {
        if (targetProfileId === visitorId) return; // Can't visit yourself

        let visitorList;
        if (targetProfileId === 'user') {
            if (!appState.chat.moments.visitors) appState.chat.moments.visitors = [];
            visitorList = appState.chat.moments.visitors;
        } else {
            const contact = appState.chat.contacts.find(c => c.id === targetProfileId);
            if (contact && contact.charSettings) {
                if (!contact.charSettings.visitors) contact.charSettings.visitors = [];
                visitorList = contact.charSettings.visitors;
            }
        }

        if (!visitorList) return;

        // To prevent spam, if the same visitor visits again within 5 minutes, just update the timestamp
        const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
        const recentVisitIndex = visitorList.findIndex(v => v.visitorId === visitorId && v.timestamp > fiveMinutesAgo);

        if (recentVisitIndex !== -1) {
            visitorList[recentVisitIndex].timestamp = Date.now();
        } else {
            visitorList.push({ visitorId: visitorId, timestamp: Date.now() });
        }

        // Keep the list from getting excessively long, e.g., max 100 visitors
        if (visitorList.length > 100) {
            visitorList.sort((a, b) => b.timestamp - a.timestamp); // Sort descending by time
            visitorList.splice(100); // Keep the most recent 100
        }

        debouncedSaveState();
    }

    function renderVisitors(container, profileId) {
        let visitorList = [];
        if (profileId === 'user') {
            visitorList = appState.chat.moments.visitors || [];
        } else {
            const contact = appState.chat.contacts.find(c => c.id === profileId);
            visitorList = (contact && contact.charSettings.visitors) ? contact.charSettings.visitors : [];
        }
        
        // Sort by most recent first
        visitorList.sort((a, b) => b.timestamp - a.timestamp);

        if (visitorList.length === 0) {
            container.innerHTML = `<p style="text-align:center; color:#888; margin-top: 50px;">è¿˜æ²¡æœ‰è®¿å®¢å“¦</p>`;
            return;
        }

        // Using a generic list class to reuse swipe styles
        container.innerHTML = `<ul id="visitor-list" class="preset-data-list" style="padding: 15px;">
            ${visitorList.map((visit, index) => {
                const visitor = findUserById(visit.visitorId);
                const visitTime = new Date(visit.timestamp).toLocaleString();
                return `
                    <li class="preset-data-item visitor-item" data-index="${index}">
                        <div class="preset-data-item-content swipe-content" style="gap: 12px; padding: 10px 0;">
                            <div class="preset-data-avatar" data-avatar-id="${visitor.avatarId}"></div>
                            <div class="preset-data-info">
                                <div class="preset-data-name">${visitor.name}</div>
                                <div class="preset-data-excerpt">${visitTime}</div>
                            </div>
                        </div>
                        <div class="preset-data-item-actions swipe-actions">
                            <div class="delete-action">åˆ é™¤</div>
                        </div>
                    </li>
                `;
            }).join('')}
        </ul>`;

        container.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
        
        // Setup swipe-to-delete for the newly rendered list
        const visitorListEl = container.querySelector('#visitor-list');
        if (visitorListEl) {
            new ListInteractionHandler(visitorListEl, {
                itemSelector: '.visitor-item',
                contentSelector: '.swipe-content',
                actionsSelector: '.swipe-actions',
                onDelete: (item) => {
                    const index = parseInt(item.dataset.index);
                    if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è®¿å®¢è®°å½•å—ï¼Ÿ')) {
                        visitorList.splice(index, 1);
                        debouncedSaveState();
                        renderVisitors(container, profileId); // Re-render the list
                    }
                }
            });
        }
    }
    function handleMomentsFeedPostInteraction(e, postItem, profileId) {
        const postId = postItem.dataset.postId;
        const post = appState.chat.moments.posts.find(p => p.id === postId);
        if (!post) return;
        const target = e.target;

        // --- Post-level actions ---
        const likeBtn = target.closest('.post-footer > .comment-actions-inline .like-btn');
        if (likeBtn) {
            if(!post.likes) post.likes = [];
            const userIndex = post.likes.indexOf('user');
            if (userIndex > -1) {
                post.likes.splice(userIndex, 1);
            } else {
                post.likes.push('user');
                logVisitor(post.authorId, 'user');
                // Send notification TO the post author, FROM the user
                addMomentsNotification('like', 'user', { postId: post.id, recipientId: post.authorId });
            }
            debouncedSaveState();
                    const postId = post.id;
        postItem.outerHTML = renderSingleMomentPost(post);
        const newPostItem = document.querySelector(`.moments-post-item[data-post-id="${postId}"]`);
        if (newPostItem) {
            newPostItem.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
            newPostItem.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));
        }
            return;
        }
        
        const commentBtn = target.closest('.post-footer > .comment-actions-inline .comment-btn');
        if (commentBtn) {
            const commentInputArea = postItem.querySelector('.comment-input-area');
            commentInputArea.style.display = commentInputArea.style.display === 'flex' ? 'none' : 'flex';
            if (commentInputArea.style.display === 'flex') {
                commentInputArea.querySelector('input').focus();
            }
            return;
        }
        
        const sendCommentBtn = target.closest('.comment-input-area .send-comment-btn');
        if (sendCommentBtn) {
            const input = sendCommentBtn.previousElementSibling;
            const text = input.value.trim();
            if (!text) return;
            if(!post.comments) post.comments = [];
            post.comments.push({ id: newId('comment'), authorId: 'user', text, likes: [], replies: [], timestamp: Date.now() });
            logVisitor(post.authorId, 'user'); // Log visitor
            // Send notification
            addMomentsNotification('comment', 'user', {
                postId: post.id,
                recipientId: post.authorId,
                content: text
            });
            input.value = '';
            debouncedSaveState();
            renderMomentsFeed(profileId);
            return;
        }

        // --- Navigation and Content Viewing ---
        if (target.closest('.post-avatar') || target.closest('.post-author-name')) {
            if (post.authorId !== 'user' && profileId !== post.authorId) {
                if (confirm(`è¦æŸ¥çœ‹ ${findUserById(post.authorId).name} çš„åŠ¨æ€å—ï¼Ÿ`)) {
                    openSubScreen(charMomentsScreen, chatAppScreen);
                    renderMomentsPage(post.authorId);
                }
            }
            return;
        }
        
        if (target.closest('.post-log-summary')) {
                        viewContentTitle.textContent = post.content.title;
            viewContentBody.innerHTML = `<p>${escapeHTML(post.content.text).replace(/\\n/g, '\n').replace(/\n+/g, '<br>')}</p>`;
            viewContentModal.classList.add('visible');
            return;
        }
        const photoItem = target.closest('.post-photo-item');
        if (photoItem) {
            const clickedPhotoId = photoItem.dataset.photoId;
            const allPhotoIdsInPost = post.content.photoIds;
            const allPhotos = allPhotoIdsInPost.map(id => appState.chat.moments.photos.find(p => p.id === id)).filter(Boolean);
            const startIndex = allPhotos.findIndex(p => p.id === clickedPhotoId);

            if (startIndex > -1) {
                openPhotoViewer(allPhotos, startIndex);
            }
            return;
        }
        const imageItem = target.closest('.post-image-item');
        if (imageItem) {
            const clickedImageId = imageItem.dataset.imageId;
            const allImages = post.content.images.map(imgData => {
                const isTextImage = typeof imgData === 'object' && imgData.isTextImage;
                return {
                    imageId: isTextImage ? imgData.imageId : imgData,
                    isTextImage: isTextImage,
                    description: isTextImage ? imgData.description : null
                };
            });
            const startIndex = allImages.findIndex(img => img.imageId === clickedImageId);
            
            if (startIndex > -1) {
                openSimpleViewer(allImages, startIndex);
            }
            return;
        }

        // --- New Comment & Reply Logic ---
        const commentOrReplyItem = target.closest('.comment-item, .reply-item');
        if (commentOrReplyItem) {
            const isReply = commentOrReplyItem.classList.contains('reply-item');
            const parentCommentItem = target.closest('.comment-item');
            const parentCommentId = parentCommentItem.dataset.commentId;
            const parentComment = post.comments.find(c => c.id === parentCommentId);
            if (!parentComment) return;

            const actionBtn = target.closest('.icon-btn');
            if (actionBtn) { // Click on Edit or Delete button
        const action = actionBtn.dataset.action;
        if (action === 'edit-comment') {
            openMomentCommentEditor(postId, parentCommentId, isReply ? commentOrReplyItem.dataset.replyId : null, null);
        } else if (action === 'delete-comment') {
            if (confirm(`ç¡®å®šè¦åˆ é™¤è¿™æ¡${isReply ? 'å›å¤' : 'è¯„è®º'}å—ï¼Ÿ`)) {
    if (isReply) {
                                const replyIdToDelete = commentOrReplyItem.dataset.replyId;
                                parentComment.replies = parentComment.replies.filter(r => r.id !== replyIdToDelete);
                                appState.chat.moments.notifications = appState.chat.moments.notifications.filter(n => n.originalReplyId !== replyIdToDelete);
                            } else {
                                const commentIdToDelete = parentCommentId;
                                post.comments = post.comments.filter(c => c.id !== commentIdToDelete);
                                appState.chat.moments.notifications = appState.chat.moments.notifications.filter(n => n.originalCommentId !== commentIdToDelete);
                            }
                                debouncedSaveState();
                                updateMomentsNotificationUI(); // æ›´æ–°è§’æ ‡
                                renderMomentsFeed(profileId);
                            }
        }
            } else if (target.closest('.reply-input-container button')) { // Send reply
                const replyInput = target.previousElementSibling;
                const text = replyInput.value.trim();
                if (!text) return;
                if (!parentComment.replies) parentComment.replies = [];
                
                let newReply;
                if (isReply) { // Replying to a reply
                    const targetReply = parentComment.replies.find(r => r.id === commentOrReplyItem.dataset.replyId);
                    const targetAuthor = findUserById(targetReply.authorId);
                    newReply = { id: newId('reply'), authorId: 'user', text: `@${targetAuthor.name} ${text}`, replyTo: targetReply.id, timestamp: Date.now() };
                } else { // Replying to a top-level comment
                    const targetAuthor = findUserById(parentComment.authorId);
                    newReply = { id: newId('reply'), authorId: 'user', text: `@${targetAuthor.name} ${text}`, replyTo: null, timestamp: Date.now() };
                }
                parentComment.replies.push(newReply);
                debouncedSaveState();
                renderMomentsFeed(profileId);
            } else { // Click on the comment/reply body
                const actionIcons = commentOrReplyItem.querySelector('.comment-actions-inline');
                const replyInput = commentOrReplyItem.querySelector('.reply-input-container');

                // Close all other open action/reply inputs in this post
                postItem.querySelectorAll('.comment-actions-inline, .reply-input-container.active').forEach(el => {
                    if (el !== actionIcons && el !== replyInput) {
                        if (el.classList.contains('reply-input-container')) {
                            el.classList.remove('active');
                        } else {
                            el.style.display = 'none';
                        }
                    }
                });

                if (actionIcons) actionIcons.style.display = actionIcons.style.display === 'flex' ? 'none' : 'flex';
                if (replyInput) replyInput.classList.toggle('active');
                if (replyInput && replyInput.classList.contains('active')) {
                    replyInput.querySelector('input').focus();
                }
            }
        }
    }
    function handleMessageBoardInteraction(e, messageItem, profileId) {
            const messageId = messageItem.dataset.messageId;
            const message = appState.chat.moments.messages.find(m => m.id === messageId);
            if (!message) return;
            const target = e.target;

                    // --- Reply item actions ---
        const replyItem = target.closest('.reply-item');
        if (replyItem) {
            const replyId = replyItem.dataset.replyId;
            const reply = (message.replies || []).find(r => r.id === replyId);
            if (!reply) return;

            const actionBtn = target.closest('.icon-btn[data-action]');
            const sendBtn = target.closest('.reply-input-container button');
            
            if (actionBtn) {
                const action = actionBtn.dataset.action;
                if (action === 'edit-comment') {
                    openMomentCommentEditor(null, null, replyId, messageId);
                } else if (action === 'delete-comment') {
                    if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡å›å¤å—ï¼Ÿ')) {
                        message.replies = message.replies.filter(r => r.id !== replyId);
                        debouncedSaveState();
                        renderMomentsFeed(profileId);
                    }
                }
            } else if (sendBtn) {
                const input = sendBtn.closest('.reply-input-container').querySelector('input');
                const text = input.value.trim();
                if (!text) return;
                const targetReply = message.replies.find(r => r.id === replyId);
                const targetAuthor = findUserById(targetReply.authorId);
                const newReply = { id: newId('reply'), authorId: 'user', text: `@${targetAuthor.name} ${text}`, timestamp: Date.now(), replyTo: replyId };
                message.replies.push(newReply);
                debouncedSaveState();
                renderMomentsFeed(profileId);
            } else {
                // Click on reply body to toggle actions
                const actionIcons = replyItem.querySelector('.comment-actions-inline');
                const replyInputArea = replyItem.querySelector('.reply-input-container');
                
                if (actionIcons) actionIcons.style.display = actionIcons.style.display === 'flex' ? 'none' : 'flex';
                if (replyInputArea) replyInputArea.classList.toggle('active');
                 if (replyInputArea && replyInputArea.classList.contains('active')) {
                    replyInputArea.querySelector('input').focus();
                }
            }
            return;
        }

            // --- Main item actions ---
            const mainReplyInputArea = messageItem.querySelector('.message-board-item-main > .reply-input-container');
            const mainSendBtn = target.closest('.message-board-item-main > .reply-input-container button');
            const replyBtn = target.closest('.reply-btn');
            
            if (mainSendBtn) {
                const input = mainSendBtn.previousElementSibling;
                const text = input.value.trim();
                if (!text) return;
                if (!message.replies) message.replies = [];
                const newReply = { id: newId('reply'), authorId: 'user', text, timestamp: Date.now(), replyTo: null };
                message.replies.push(newReply);
                logVisitor(message.recipientId, 'user'); // Log visitor for replying
                // Send notification for the reply
                addMomentsNotification('reply', 'user', {
                    messageId: message.id,
                    recipientId: message.senderId, // Notify the original message sender
                    content: text
                });
                debouncedSaveState();
                renderMomentsFeed(profileId);
                return;
            }

            // Click to reply logic (Bug â‘ )
            const mainContentArea = target.closest('.message-board-item-main');
            if (mainContentArea) {
                // Check if the click was on the main content area itself, not on an interactive child
                const isInteractiveChild = target.closest('button, input, .reply-btn, .message-board-replies');
                if (!isInteractiveChild || replyBtn) {
                    mainReplyInputArea.classList.toggle('active');
                    if (mainReplyInputArea.classList.contains('active')) {
                        mainReplyInputArea.querySelector('input').focus();
                    }
                }
            }
        }
    function renderMomentsFeed(profileId) {
    const isUserPage = profileId === 'user';
    const container = isUserPage ? momentsTabContent : charMomentsScreen;
    const feedEl = getEl(`moments-feed-${profileId}`);
    const tabsEl = getEl(`moments-filter-tabs-${profileId}`);
    const fabContainer = getEl(`moments-fab-container-${profileId}`);
    if (!feedEl || !tabsEl || !fabContainer) return;

    const filter = runtimeState.moments.currentFilter;
    
    const tabList = [ { key: 'all', text: 'å…¨éƒ¨' }, { key: 'status', text: 'è¯´è¯´' }, { key: 'photo', text: 'ç›¸å†Œ' }, { key: 'log', text: 'æ—¥å¿—' }, { key: 'visitor', text: 'è®¿å®¢' }, { key: 'message', text: 'ç•™è¨€' } ];
    tabsEl.innerHTML = tabList.filter(tab => isUserPage || (tab.key !== 'visitor')).map(tab => `<span class="moments-filter-tab ${filter === tab.key ? 'active' : ''}" data-filter="${tab.key}">${tab.text}</span>`).join('');
    
    let shouldShowFab = true;
    if (!isUserPage && !['all', 'message'].includes(filter)) {
        shouldShowFab = false;
    }
    if (filter === 'visitor') {
        shouldShowFab = false;
    }
    
    if (shouldShowFab) {
        let fabOptionsHTML = '';
        const userOptions = { 
            all: [{ action: 'status', text: 'å‘è¡¨è¯´è¯´' }, { action: 'photo', text: 'ä¸Šä¼ ç…§ç‰‡' }, { action: 'log', text: 'å†™æ—¥å¿—' }], 
            status: [{ action: 'status', text: 'å‘è¡¨è¯´è¯´' }], 
            photo: [{ action: 'photo', text: 'ä¸Šä¼ ç…§ç‰‡' }, { action: 'album', text: 'ç®¡ç†ç›¸å†Œ'}], 
            log: [{ action: 'log', text: 'å†™æ—¥å¿—' }], 
            message: [{ action: 'message', text: 'å†™ç•™è¨€' }] 
        };
        
        const charOptions = {
            all: [{ action: 'message', text: 'ç»™ä»–ç•™è¨€' }],
            message: [{ action: 'message', text: 'ç»™ä»–ç•™è¨€' }]
        };

        const optionsMap = isUserPage ? userOptions : charOptions;
        fabOptionsHTML = (optionsMap[filter] || []).map(opt => `<div class="fab-option" data-action="${opt.action}">${opt.text}</div>`).join('');
        
fabContainer.innerHTML = `<div id="moments-fab-options" style="display: ${runtimeState.moments.isFabMenuOpen ? 'flex' : 'none'};">${fabOptionsHTML}</div><div id="moments-fab" class="moments-fab"><i class="fa-solid fa-plus"></i></div>`;    } else {
        fabContainer.innerHTML = '';
    }
    
    let postsToRender = [...appState.chat.moments.posts].sort((a,b) => b.timestamp - a.timestamp);
    if (!isUserPage) {
        postsToRender = postsToRender.filter(p => p.authorId === profileId && (p.visibility === 'public' || (p.visibleTo && p.visibleTo.includes('user'))));
    }
    
    feedEl.innerHTML = ''; // Clear feed before rendering
    
    switch(filter) {
        case 'visitor':
            renderVisitors(feedEl, profileId);
            break;
        case 'message':
            renderMessages(feedEl, profileId);
            break;
        case 'photo':
            openAlbumView(feedEl, profileId, 'default');
            break;
        case 'log':
        case 'status':
            const filteredPosts = postsToRender.filter(p => p.type === filter);
            feedEl.innerHTML = filteredPosts.length > 0 ? filteredPosts.map(post => renderSingleMomentPost(post)).join('') : `<p style="text-align:center; color:#888; margin-top: 50px;">è¿™é‡Œç©ºç©ºå¦‚ä¹Ÿ~</p>`;
            break;
        case 'all':
        default:
            const allPosts = postsToRender.filter(p => ['status', 'log', 'photo'].includes(p.type));
            feedEl.innerHTML = allPosts.length > 0 ? allPosts.map(post => renderSingleMomentPost(post)).join('') : `<p style="text-align:center; color:#888; margin-top: 50px;">è¿™é‡Œç©ºç©ºå¦‚ä¹Ÿ~</p>`;
            break;
    }
    
    feedEl.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    feedEl.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));
    feedEl.querySelectorAll('.post-photo-item').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));

    setupMomentsListInteraction(feedEl);

    // --- Scroll to target item after navigation (REVISED & FIXED) ---
    setTimeout(() => {
        let targetElement = null;
        if (runtimeState.moments.scrollToPostId) {
            targetElement = feedEl.querySelector(`.moments-post-item[data-post-id="${runtimeState.moments.scrollToPostId}"]`);
            runtimeState.moments.scrollToPostId = null;
        } else if (runtimeState.moments.scrollToMessageId) {
            targetElement = feedEl.querySelector(`.message-board-item[data-message-id="${runtimeState.moments.scrollToMessageId}"]`);
            runtimeState.moments.scrollToMessageId = null;
        }

        if (targetElement) {
            // æ ¸å¿ƒä¿®å¤ï¼šå¼ƒç”¨æœ‰ bug çš„ scrollIntoViewï¼Œæ”¹ç”¨æ‰‹åŠ¨ç²¾ç¡®æ»šåŠ¨ã€‚
            const scrollContainer = feedEl.closest('.moments-scroll-container');
            if (scrollContainer) {
                const containerRect = scrollContainer.getBoundingClientRect();
                const targetRect = targetElement.getBoundingClientRect();
                // è®¡ç®—æ»šåŠ¨åç§»é‡ï¼Œä½¿ç›®æ ‡å…ƒç´ å¤§è‡´ä½äºå®¹å™¨ä¸­å¿ƒ
                const offset = targetRect.top - containerRect.top - (containerRect.height / 2) + (targetRect.height / 2);
                
                scrollContainer.scrollTo({
                    top: scrollContainer.scrollTop + offset,
                    behavior: 'smooth'
                });
            }
            
            // ä¿ç•™é«˜äº®æ•ˆæœ
            targetElement.style.transition = 'background-color 0.5s ease-in-out';
            targetElement.style.backgroundColor = 'rgba(0, 122, 255, 0.1)';
            setTimeout(() => {
                targetElement.style.backgroundColor = '';
            }, 2000);
        }
    }, 100); // Delay to ensure DOM is fully painted
}

    function renderSingleMomentPost(post) {
        const author = findUserById(post.authorId);
        const isLiked = post.likes.includes('user');
        const commentsHTML = (post.comments || []).map(comment => renderSingleMomentComment(comment, post.id)).join('');
        
        let contentHTML = '';
        let visibilityHTML = '';

        if (post.type === 'status') {
            const postText = post.content.text ? `<div class="post-content-text">${escapeHTML(post.content.text)}</div>` : '';
            const imageGridHTML = post.content.images && post.content.images.length > 0 
                ? `<div class="post-image-grid">${post.content.images.map(imgData => {
                    const isTextImage = typeof imgData === 'object' && imgData.isTextImage;
                    const imageId = isTextImage ? imgData.imageId : imgData;
                    const textOverlay = isTextImage ? `<div class="camera-text-overlay">(${escapeHTML(imgData.description)})</div>` : '';
                    const itemClass = isTextImage ? 'post-image-item text-image-post' : 'post-image-item';
                    return `<div class="${itemClass}" data-image-id="${imageId}" data-is-text-image="${isTextImage}">${textOverlay}</div>`;
                  }).join('')}</div>`
                : '';
            contentHTML = `${postText}${imageGridHTML}`;
        } else if (post.type === 'log') {
            const summary = post.content.text.length > 30 ? post.content.text.substring(0, 30).replace(/[ï¼Œã€‚ï¼ï¼Ÿ]$/, '') + '...' : post.content.text;
            contentHTML = `<div class="post-log-summary"><h3>${escapeHTML(post.content.title)}</h3><p>${escapeHTML(summary).replace(/(?:\\r?\\n|\\n)+/g, '<br>')}</p></div>`;
        } else if (post.type === 'photo') {
            const photoData = appState.chat.moments.photos.filter(p => post.content.photoIds.includes(p.id));
            const album = appState.chat.moments.albums.find(a => a.id === post.content.albumId);
            const albumText = album ? `åˆ°ã€Š${escapeHTML(album.name)}ã€‹` : '';
            const authorActionText = `<div class="post-content-text">${author.name} ä¸Šä¼ äº†${photoData.length}å¼ ç…§ç‰‡ï¼š${escapeHTML(post.content.name)}${albumText}</div>`;
            const photoGridHTML = `<div class="post-photo-grid">${photoData.map(photo => `<div class="post-photo-item" data-photo-id="${photo.id}" data-image-id="${photo.imageId}"></div>`).join('')}</div>`;
            contentHTML = `${authorActionText}${photoGridHTML}`;
        }

        if (post.visibility === 'specific' && post.visibleTo && post.visibleTo.length > 0) {
            const visibleNames = post.visibleTo.map(id => findUserById(id).name).slice(0, 3).join(', ');
            const extraCount = post.visibleTo.length > 3 ? ` ç­‰${post.visibleTo.length}äºº` : '';
            visibilityHTML = `<div class="post-visibility-info">ä»… ${visibleNames}${extraCount} å¯è§</div>`;
        }
        
        let likesSummaryHTML = '';
        if(post.likes && post.likes.length > 0) {
            const likerNames = post.likes.map(id => findUserById(id).name).join(', ');
        likesSummaryHTML = `<div class="post-likes-summary"><span class="icon"><i class="fa-solid fa-heart"></i></span> ${likerNames}</div>`;
        }

        return `
            <div class="moments-post-item" data-post-id="${post.id}">
                <div class="post-item-content swipe-content">
                    <div class="post-header">
                        <div class="post-avatar" data-avatar-id="${author.avatarId}"></div>
                        <div class="post-author-info">
                            <div class="post-author-name">${author.name}</div>
                            <div class="post-timestamp">${new Date(post.timestamp).toLocaleString()}</div>
                        </div>
                    </div>
                    ${contentHTML}
                    ${visibilityHTML}
                    <div class="post-footer">
                        ${likesSummaryHTML}
                        <div class="comment-actions-inline" style="justify-content: flex-end; ${likesSummaryHTML ? 'border-top: 1px solid #f0f0f0; padding-top: 8px; margin-top: 8px;' : ''}">
                            <button class="icon-btn like-btn ${isLiked ? 'liked' : ''}" data-icon-id="${isLiked ? 'moment-like-on' : 'moment-like-off'}" style="gap: 4px;">${isLiked ? '<i class="fa-solid fa-heart"></i>' : '<i class="fa-regular fa-heart"></i>'} <span class="like-count">${(post.likes || []).length}</span></button>
                            <button class="icon-btn comment-btn" data-icon-id="moment-comment" style="gap: 4px;"><i class="fa-solid fa-message"></i> <span class="comment-count">${(post.comments || []).length}</span></button>
                        </div>
                        <div class="details-comments-list" style="padding: 10px 0 0 0;">${commentsHTML}</div>
                        <div class="comment-input-area" style="display: none; margin-top: 10px;">
                            <input type="text" placeholder="å‘è¡¨ä½ çš„è¯„è®º...">
                            <button class="settings-button secondary send-comment-btn" data-icon-id="comment-send" style="width: 50px; padding: 5px; display: flex; align-items: center; justify-content: center;"><i class="fa-solid fa-paper-plane"></i></button>
                        </div>
                    </div>
                </div>
                <div class="post-item-actions swipe-actions">
                    <div class="edit-action" data-icon-id="moment-edit"><i class="fa-solid fa-pen-to-square"></i></div>
                    <div class="delete-action" data-icon-id="moment-delete"><i class="fa-solid fa-trash-can"></i></div>
                </div>
            </div>
        `;
    }
    function renderSingleMomentComment(comment, postId) {
        const author = findUserById(comment.authorId);
        if (!author) return '';
        const repliesHTML = (comment.replies || []).map(reply => renderSingleMomentReply(reply, comment.replies, postId)).join('');
        const canModify = true; // å‡è®¾Useræ€»æ˜¯å¯ä»¥ç¼–è¾‘å’Œåˆ é™¤
        return `
            <div class="comment-item" data-comment-id="${comment.id}">
                <div class="comment-item-main" style="padding-top: 8px; padding-bottom: 8px;">
                    <div class="comment-avatar" data-avatar-id="${author.avatarId}" style="width: 32px; height: 32px;"></div>
                    <div class="comment-content">
                        <div class="comment-header">
                            <span class="comment-author">${author.name}</span>
                            <span class="comment-timestamp">${new Date(comment.timestamp).toLocaleString()}</span>
                            <div class="comment-actions-inline" style="display: none;">
                                ${canModify ? `
                                <button class="icon-btn" data-action="edit-comment" data-icon-id="moment-edit" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
                                <button class="icon-btn" data-action="delete-comment" data-icon-id="moment-delete" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
                                ` : ''}
                            </div>
                        </div>
                        <p class="comment-text">${escapeHTML(comment.text)}</p>
                        <div class="comment-replies" style="margin-left: 0;">${repliesHTML}</div>
                        <div class="reply-input-container">
                            <input type="text" placeholder="å›å¤ ${author.name}...">
                            <button class="settings-button secondary" style="padding: 5px 10px;" data-bubble-id="comment-reply-send">å‘é€</button>
                        </div>
                    </div>
                </div>
            </div>`;
    }
    function renderSingleMomentReply(reply, allReplies, postId) {
            const author = findUserById(reply.authorId);
            
            let replyText = escapeHTML(reply.text);
            const mentionMatch = replyText.match(/^@(\S+)\s(.*)/s); // Added 's' flag for multiline
            let targetHTML = '';
            if(mentionMatch) {
                targetHTML = `å›å¤ <span class="reply-target">@${mentionMatch[1]}</span>: `;
                replyText = mentionMatch[2];
            }

            const canModify = true; 
            return `
                <div class="reply-item" data-reply-id="${reply.id}">
                    <div class="reply-avatar" data-avatar-id="${author.avatarId}"></div>
                    <div class="reply-content">
                        <div class="comment-header">
                             <div>
                                <span class="reply-author">${author.name}</span>
                                <span class="reply-timestamp">${new Date(reply.timestamp).toLocaleString()}</span>
                             </div>
                             <div class="comment-actions-inline" style="display: none;">
                                ${canModify ? `
                                <button class="icon-btn" data-action="edit-comment" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
                                <button class="icon-btn" data-action="delete-comment" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
                                ` : ''}
                             </div>
                        </div>
                        <p class="comment-text">${targetHTML}${replyText}</p>
                        <div class="reply-input-container">
                            <input type="text" placeholder="å›å¤ ${author.name}...">
                            <button class="settings-button secondary" style="padding: 5px 10px;" data-bubble-id="comment-reply-send">å‘é€</button>
                        </div>
                    </div>
                </div>`;
        }
function syncAndUpdateMoments(profileId) { if (profileId === 'user' && getEl('moments-tab-content').offsetParent !== null) { renderMomentsPage('user'); } else if (profileId !== 'user' && charMomentsScreen.classList.contains('active') && runtimeState.moments.currentProfileId === profileId) { renderMomentsPage(profileId); } }
    // --- æ–°å¢ï¼šå½»åº•åˆ é™¤åŠ¨æ€åŠå…¶å…³è”æ•°æ®çš„å‡½æ•° ---
    function deleteMomentAndAssociatedData(postId) {
    if (!postId) return false;
    
    const postIndex = appState.chat.moments.posts.findIndex(p => p.id === postId);
    if (postIndex === -1) return false; 

    const postToDelete = appState.chat.moments.posts[postIndex];
    const authorId = postToDelete.authorId;

    appState.chat.moments.posts.splice(postIndex, 1);
        const existingPostIds = new Set(appState.chat.moments.posts.map(p => p.id));
        appState.chat.moments.notifications = appState.chat.moments.notifications.filter(n => !n.postId || existingPostIds.has(n.postId));

    if (postToDelete.type === 'photo' && postToDelete.content.photoIds) {
        const photoIdsToDelete = postToDelete.content.photoIds;
        
        let photoStorage, albumStorage;
        if (authorId === 'user') {
            photoStorage = appState.chat.moments.photos;
            albumStorage = appState.chat.moments.albums;
        } else {
            const contact = appState.chat.contacts.find(c => c.id === authorId);
            if (contact && contact.charSettings && contact.charSettings.moments) {
                photoStorage = contact.charSettings.moments.photos;
                albumStorage = contact.charSettings.moments.albums;
            } else {
                photoStorage = [];
                albumStorage = [];
            }
        }

        let updatedPhotos = photoStorage.filter(p => !photoIdsToDelete.includes(p.id));

        albumStorage.forEach(album => {
            if (album.photoIds) {
                album.photoIds = album.photoIds.filter(pid => !photoIdsToDelete.includes(pid));
            }
        });
        
        if (authorId === 'user') {
            appState.chat.moments.photos = updatedPhotos;
        } else {
            const contact = appState.chat.contacts.find(c => c.id === authorId);
            if(contact) {
                 contact.charSettings.moments.photos = updatedPhotos;
            }
        }
    }
    
    updateMomentsNotificationUI();
    debouncedSaveState();
    return true;
}
    function openPostMomentModal(type, postId = null) {
    const isEditing = postId !== null;
    const post = isEditing ? appState.chat.moments.posts.find(p => p.id === postId) : null;

    runtimeState.moments.postContext = { 
        type: isEditing ? post.type : type,
        visibility: isEditing ? post.visibility : 'public',
        visibleTo: isEditing ? [...(post.visibleTo || [])] : [],
        images: isEditing ? [...(post.content.images || [])] : [],
        textImageDesc: '',
        editingPostId: postId
    };

    const titleEl = getEl('post-moment-modal-title');
    const statusSection = getEl('post-moment-status-section');
    const logSection = getEl('post-moment-log-section');
    const modalBody = getEl('post-moment-modal-body');
    const commentPrivateCheckbox = getEl('post-moment-comment-private-checkbox');

    // åŠ¨æ€åˆ›å»ºæˆ–ç§»é™¤ä½œè€…é€‰æ‹©å™¨
    if (modalBody.querySelector('#post-author-selector-group')) {
        modalBody.querySelector('#post-author-selector-group').remove();
    }
    if (isEditing) {
        const authorSelectorHTML = `
            <div class="form-group" id="post-author-selector-group">
                <label>å‘å¸ƒè€…</label>
                <div id="moment-post-author-selector"></div>
            </div>`;
        modalBody.insertAdjacentHTML('afterbegin', authorSelectorHTML);
        renderMomentAuthorSelector('moment-post-author-selector', post.authorId);
        commentPrivateCheckbox.checked = post.areCommentsPrivate || false; // Load existing setting
        getEl('post-moment-visibility-public-checkbox').checked = post.isVisibilityPublic || false; // Load existing setting
    } else {
        commentPrivateCheckbox.checked = false; // Reset for new post
        getEl('post-moment-visibility-public-checkbox').checked = false; // Reset for new post
    }

    titleEl.textContent = isEditing ? 'ç¼–è¾‘åŠ¨æ€' : 'å‘è¡¨åŠ¨æ€';
    
    if (runtimeState.moments.postContext.type === 'status') {
        statusSection.classList.remove('hidden-by-logic');
        logSection.classList.add('hidden-by-logic');
        getEl('post-moment-status-content').value = isEditing ? post.content.text : '';
    } else if (runtimeState.moments.postContext.type === 'log') {
        statusSection.classList.add('hidden-by-logic');
        logSection.classList.remove('hidden-by-logic');
        getEl('post-moment-log-title').value = isEditing ? post.content.title : '';
        getEl('post-moment-log-content').value = isEditing ? post.content.text : '';
    }
    
    queryAll('input[name="visibility"]').forEach(radio => radio.checked = radio.value === runtimeState.moments.postContext.visibility);
    const friendSelector = getEl('post-moment-friend-selector-container');
    if (runtimeState.moments.postContext.visibility === 'specific') {
                renderFriendSelector('post-moment-friend-selector', 'post');
                friendSelector.classList.remove('hidden-by-logic');
            } else {
        friendSelector.classList.add('hidden-by-logic');
    }
    
    queryAll('input[name="status-type"]').forEach(radio => radio.checked = radio.value === 'text'); // Default to text
    getEl('post-moment-image-buttons').classList.add('hidden-by-logic');
    getEl('post-moment-text-image-input').classList.add('hidden-by-logic');

    postMomentModal.classList.add('visible');
}
    function setupNewMomentsFeaturesListeners() {
        // --- Photo Viewer Modal ---
        getEl('viewer-image-view').addEventListener('click', (e) => {
            const context = runtimeState.moments.viewerContext;
            if (!context || context.items.length === 0) return;
            const currentPhoto = context.items[context.currentIndex];
            if (!currentPhoto) return;

            if (e.target.closest('#view-photo-name') || e.target.closest('#view-photo-desc')) {
                e.stopPropagation(); // Prevent the main viewer click from hiding the text
                getEl('editing-photo-id').value = currentPhoto.id;
                getEl('photo-name-input').value = currentPhoto.name;
                getEl('photo-desc-input').value = currentPhoto.description || '';
                editPhotoModal.classList.add('visible');
            }
        });
        viewPhotoModal.addEventListener('click', (e) => {
            const imageView = e.target.closest('#viewer-image-view');
            const closeBtn = e.target.closest('.photo-viewer-close-btn');

            if (closeBtn) {
                viewPhotoModal.classList.remove('visible');
            } else if (imageView) {
                // Only toggle text visibility for image view
                viewPhotoModal.classList.toggle('text-hidden');
            }
        });

        // --- Simple Viewer Modal ---
        simpleViewerModal.addEventListener('click', (e) => {
             if (!e.target.closest('.viewer-nav-btn')) {
                simpleViewerModal.classList.remove('visible');
             }
        });
        getEl('simple-viewer-prev-btn').addEventListener('click', () => {
            let { currentIndex } = runtimeState.moments.viewerContext;
            if (currentIndex > 0) {
                currentIndex--;
                runtimeState.moments.viewerContext.currentIndex = currentIndex;
                renderSimpleViewerContent(currentIndex);
            }
        });
        getEl('simple-viewer-next-btn').addEventListener('click', () => {
            let { items, currentIndex } = runtimeState.moments.viewerContext;
            if (currentIndex < items.length - 1) {
                currentIndex++;
                runtimeState.moments.viewerContext.currentIndex = currentIndex;
                renderSimpleViewerContent(currentIndex);
            }
        });
        // --- Upload Photo Modal Listeners ---
        getEl('upload-photo-local-btn').addEventListener('click', () => {
            getEl('upload-photo-file-input').click();
        });

        getEl('upload-photo-file-input').addEventListener('change', async (e) => {
            const files = e.target.files;
            if (files.length === 0) return;
            showToast(`æ­£åœ¨å¤„ç† ${files.length} å¼ å›¾ç‰‡...`);
            for (const file of files) {
                const imageId = newId('moment_photo');
                await addMediaToDB(imageId, file);
                runtimeState.moments.postContext.images.push(imageId);
            }
            // Render previews
            const previewGrid = getEl('upload-photo-image-preview-grid');
            previewGrid.innerHTML = '';
             runtimeState.moments.postContext.images.forEach(id => {
                const item = document.createElement('div');
                item.className = 'upload-preview-item';
                previewGrid.appendChild(item);
                setElementImage(item, id, 'backgroundImage');
            });
            showToast('å›¾ç‰‡å·²å‡†å¤‡å¥½');
        });

        getEl('upload-photo-text-btn').addEventListener('click', () => {
             getEl('upload-photo-text-image-input-group').classList.toggle('hidden-by-logic');
        });

        getEl('upload-photo-visibility').addEventListener('change', e => {
            runtimeState.moments.postContext.visibility = e.target.value;
            const selectorContainer = getEl('upload-photo-friend-selector-container');
            if (e.target.value === 'specific') {
                renderFriendSelector('upload-photo-friend-selector', 'upload');
                selectorContainer.classList.remove('hidden-by-logic');
            } else {
                selectorContainer.classList.add('hidden-by-logic');
            }
        });

        getEl('upload-photo-friend-selector').addEventListener('click', e => {
            const item = e.target.closest('.friend-selector-item');
            if (item) {
                const id = item.dataset.id;
                item.classList.toggle('selected');
                const context = runtimeState.moments.postContext;
                if (item.classList.contains('selected')) {
                    if (!context.visibleTo.includes(id)) context.visibleTo.push(id);
                } else {
                    context.visibleTo = context.visibleTo.filter(fid => fid !== id);
                }
            }
        });

        getEl('cancel-upload-photo-btn').addEventListener('click', () => uploadPhotoModal.classList.remove('visible'));
        
        getEl('confirm-upload-photo-btn').addEventListener('click', () => {
        const name = getEl('upload-photo-name').value.trim();
        if (!name) return showToast('ç…§ç‰‡åç§°ä¸èƒ½ä¸ºç©º', 'error');
        
        const description = getEl('upload-photo-desc').value.trim(); // è·å–ç…§ç‰‡æè¿°

        const localImages = runtimeState.moments.postContext.images;
        const textImageDescs = getEl('upload-photo-text-image-desc').value.trim().split('\n').filter(d => d);

        if (localImages.length === 0 && textImageDescs.length === 0) {
            return showToast('è¯·è‡³å°‘ä¸Šä¼ ä¸€å¼ å›¾ç‰‡æˆ–è¾“å…¥æ–‡å­—å›¾æè¿°', 'error');
        }

        const photoIds = [];
        // Process local images
        localImages.forEach(imageId => {
            const photo = { id: newId('photo'), ownerId: 'user', imageId: imageId, isTextImage: false, name: name, description: description };
            appState.chat.moments.photos.push(photo);
            photoIds.push(photo.id);
        });
        // Process text images
        textImageDescs.forEach(desc => {
            const photo = { id: newId('photo'), ownerId: 'user', imageId: 'default_camera_image', isTextImage: true, textDescription: desc, name: name, description: description };
            appState.chat.moments.photos.push(photo);
            photoIds.push(photo.id);
        });
        
        const selectedAlbumId = getEl('upload-photo-album-select').value;
        const album = appState.chat.moments.albums.find(a => a.id === selectedAlbumId);
        if(album) {
            if(!album.photoIds) album.photoIds = [];
            album.photoIds.unshift(...photoIds);
        }

        const newPost = {
            id: newId('post'),
            authorId: 'user',
            type: 'photo',
            content: {
                name: name,
                description: description, // åŠ¨æ€çš„æè¿°ä¹Ÿä½¿ç”¨ç…§ç‰‡æè¿°
                photoIds: photoIds,
                albumId: selectedAlbumId
            },
            timestamp: Date.now(),
            visibility: runtimeState.moments.postContext.visibility,
            visibleTo: runtimeState.moments.postContext.visibleTo,
areCommentsPrivate: getEl('upload-photo-comment-private-checkbox').checked,
        isVisibilityPublic: getEl('upload-photo-visibility-public-checkbox').checked,            likes: [],
            comments: []
        };
        appState.chat.moments.posts.unshift(newPost);
        debouncedSaveState();
        renderMomentsFeed('user');
        uploadPhotoModal.classList.remove('visible');
    });


        // --- Manage Albums Modal Listeners ---
        getEl('close-manage-albums-btn').addEventListener('click', () => {
            manageAlbumsModal.classList.remove('visible');
            getEl('delete-selected-albums-btn').style.display = 'none';
            manageAlbumsModal.querySelectorAll('.album-item.selected-for-deletion').forEach(el => el.classList.remove('selected-for-deletion'));
        });

        getEl('create-album-btn').addEventListener('click', () => {
            getEl('edit-album-title').textContent = 'æ–°å»ºç›¸å†Œ';
            getEl('editing-album-id').value = '';
            getEl('album-name-input').value = '';
            getEl('album-desc-input').value = '';
            editAlbumModal.classList.add('visible');
        });

        getEl('manage-albums-grid').addEventListener('click', e => {
            const item = e.target.closest('.album-item');
            if (!item) return;

            if (getEl('delete-selected-albums-btn').style.display === 'block') {
                 if(item.dataset.id !== 'default') {
                    item.classList.toggle('selected-for-deletion');
                 }
                return;
            }

            if (e.target.closest('.edit-album-btn')) {
                const albumId = item.dataset.id;
                const album = appState.chat.moments.albums.find(a => a.id === albumId);
                getEl('edit-album-title').textContent = 'ç¼–è¾‘ç›¸å†Œ';
                getEl('editing-album-id').value = albumId;
                getEl('album-name-input').value = album.name;
                getEl('album-desc-input').value = album.description || '';
                editAlbumModal.classList.add('visible');
            } else {
                openSubScreen(viewAlbumScreen, chatAppScreen);
                renderAlbumView(item.dataset.id);
                manageAlbumsModal.classList.remove('visible');
            }
        });
        
        let albumLongPressTimer = null;
        getEl('manage-albums-grid').addEventListener('pointerdown', e => {
             const item = e.target.closest('.album-item');
             if(!item || item.dataset.id === 'default') return;
             albumLongPressTimer = setTimeout(() => {
                getEl('delete-selected-albums-btn').style.display = 'block';
                item.classList.add('selected-for-deletion');
             }, 800);
        });
         getEl('manage-albums-grid').addEventListener('pointerup', () => clearTimeout(albumLongPressTimer));
         getEl('manage-albums-grid').addEventListener('pointerleave', () => clearTimeout(albumLongPressTimer));

        getEl('delete-selected-albums-btn').addEventListener('click', () => {
            const selectedItems = manageAlbumsModal.querySelectorAll('.album-item.selected-for-deletion');
            if (selectedItems.length === 0) return;
            if (confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedItems.length} ä¸ªç›¸å†Œå—ï¼Ÿå…¶ä¸­çš„ç…§ç‰‡å°†ç§»è‡³é»˜è®¤ç›¸å†Œã€‚`)) {
                const defaultAlbum = appState.chat.moments.albums.find(a => a.id === 'default');
                if(!defaultAlbum.photoIds) defaultAlbum.photoIds = [];

                selectedItems.forEach(item => {
                    const albumId = item.dataset.id;
                    const album = appState.chat.moments.albums.find(a => a.id === albumId);
                    if (album && album.photoIds) {
                        defaultAlbum.photoIds.unshift(...album.photoIds);
                    }
                    appState.chat.moments.albums = appState.chat.moments.albums.filter(a => a.id !== albumId);
                });
                debouncedSaveState();
                renderManageAlbums();
                getEl('delete-selected-albums-btn').style.display = 'none';
            }
        });

        // --- Edit Album Modal Listeners ---
        getEl('cancel-edit-album-btn').addEventListener('click', () => editAlbumModal.classList.remove('visible'));
        getEl('save-album-btn').addEventListener('click', () => {
            const albumId = getEl('editing-album-id').value;
            const name = getEl('album-name-input').value.trim();
            if (!name) return showToast('ç›¸å†Œåç§°ä¸èƒ½ä¸ºç©º', 'error');
            const desc = getEl('album-desc-input').value.trim();

            if (albumId) { // Editing
                const album = appState.chat.moments.albums.find(a => a.id === albumId);
                album.name = name;
                album.description = desc;
            } else { // Creating
                const newAlbum = { id: newId('album'), name, description: desc, createTime: Date.now(), photoIds: [] };
                appState.chat.moments.albums.push(newAlbum);
            }
            debouncedSaveState();
            renderManageAlbums();
            editAlbumModal.classList.remove('visible');
        });
        
        // --- Album View Screen Listeners ---
        getEl('view-album-back-btn').addEventListener('click', () => {
            closeSubScreen(viewAlbumScreen, chatAppScreen);
            const deleteBtn = getEl('delete-photos-btn');
            deleteBtn.style.display = 'none';
            viewAlbumScreen.querySelectorAll('.photo-grid-item.selected-for-deletion').forEach(el => el.classList.remove('selected-for-deletion'));
            renderMomentsFeed(runtimeState.moments.currentProfileId);
        });
        
        let photoLongPressTimer = null;
        getEl('album-photo-grid').addEventListener('pointerdown', e => {
             const item = e.target.closest('.photo-grid-item');
             if(!item) return;
             photoLongPressTimer = setTimeout(() => {
                getEl('delete-photos-btn').style.display = 'block';
                item.classList.add('selected-for-deletion');
             }, 800);
        });
        getEl('album-photo-grid').addEventListener('pointerup', () => clearTimeout(photoLongPressTimer));
        getEl('album-photo-grid').addEventListener('pointerleave', () => clearTimeout(photoLongPressTimer));
        
        getEl('album-photo-grid').addEventListener('click', e => {
            const item = e.target.closest('.photo-grid-item');
            if (!item) return;
            
            if (getEl('delete-photos-btn').style.display === 'block') {
                item.classList.toggle('selected-for-deletion');
            } else {
                const grid = item.closest('.photo-grid');
                const allPhotoItems = Array.from(grid.querySelectorAll('.photo-grid-item'));
                const allPhotoIds = allPhotoItems.map(photoItem => photoItem.dataset.id);
                const allPhotos = allPhotoIds.map(id => appState.chat.moments.photos.find(p => p.id === id)).filter(Boolean);
                const startIndex = allPhotoItems.indexOf(item);

                if (startIndex > -1) {
                    openPhotoViewer(allPhotos, startIndex);
                }
            }
        });

        getEl('delete-photos-btn').addEventListener('click', () => {
            const selectedItems = viewAlbumScreen.querySelectorAll('.photo-grid-item.selected-for-deletion');
            if (selectedItems.length === 0) return;
            if (confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedItems.length} å¼ ç…§ç‰‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`)) {
                const idsToDelete = Array.from(selectedItems).map(item => item.dataset.id);
                // Remove from global photo list
                appState.chat.moments.photos = appState.chat.moments.photos.filter(p => !idsToDelete.includes(p.id));
                // Remove from all albums
                appState.chat.moments.albums.forEach(album => {
                    if (album.photoIds) {
                        album.photoIds = album.photoIds.filter(pid => !idsToDelete.includes(pid));
                    }
                });
                // Remove from posts
                 appState.chat.moments.posts.forEach(post => {
                    if (post.type === 'photo' && post.content.photoIds) {
                        post.content.photoIds = post.content.photoIds.filter(pid => !idsToDelete.includes(pid));
                    }
                });
                debouncedSaveState();
                renderAlbumView(viewAlbumScreen.dataset.albumId);
                getEl('delete-photos-btn').style.display = 'none';
            }
        });

        getEl('cancel-edit-photo-btn').addEventListener('click', () => editPhotoModal.classList.remove('visible'));
        getEl('save-photo-btn').addEventListener('click', () => {
            const photoId = getEl('editing-photo-id').value;
            const photo = appState.chat.moments.photos.find(p => p.id === photoId);
            if (photo) {
                photo.name = getEl('photo-name-input').value.trim();
                photo.description = getEl('photo-desc-input').value.trim();
                debouncedSaveState();
                editPhotoModal.classList.remove('visible');
                showToast('ç…§ç‰‡ä¿¡æ¯å·²æ›´æ–°');
                // Re-render the viewer to show updated info
                if (viewPhotoModal.classList.contains('visible')) {
                    renderPhotoViewerContent(runtimeState.moments.viewerContext.currentIndex);
                }
                // Refresh moments feed if it's visible
                syncAndUpdateMoments(runtimeState.moments.currentProfileId);
            }
        });


        // --- Leave Message Modal Listeners ---
        getEl('cancel-leave-message-btn').addEventListener('click', () => leaveMessageModal.classList.remove('visible'));
        getEl('confirm-leave-message-btn').addEventListener('click', () => {
                const modal = getEl('leave-message-modal');
                const editingId = modal.dataset.editingId;
                
                const recipientName = getEl('message-recipient').value.trim();
                const content = getEl('message-content').value.trim();
                const senderNameFromInput = getEl('message-sender').value.trim();

                if (!recipientName || !content) {
                    return showToast('ç§°å‘¼å’Œå†…å®¹å‡ä¸ºå¿…å¡«é¡¹', 'error');
                }
                
                if (editingId) {
                    const message = appState.chat.moments.messages.find(m => m.id === editingId);
                    if (message) {
                        const selectedAuthorEl = getEl('leave-message-author-selector').querySelector('.selected');
                        const newSenderId = selectedAuthorEl ? selectedAuthorEl.dataset.id : message.senderId;
                        const newSender = findUserById(newSenderId);

                        message.recipientName = recipientName;
                        message.content = content;
                        message.senderId = newSenderId;
                        message.senderName = getEl('message-sender').value.trim() || newSender.name; // Use input value first
                        message.visibility = runtimeState.moments.postContext.visibility;
                        message.visibleTo = runtimeState.moments.postContext.visibleTo;
                        showToast('ç•™è¨€å·²æ›´æ–°ï¼');
                    }
                } else {
                     if (!senderNameFromInput) return showToast('è½æ¬¾ä¸ºå¿…å¡«é¡¹', 'error');
                    const newMessage = {
                        id: newId('message'),
                        recipientId: runtimeState.moments.currentProfileId,
                        recipientName,
                        content,
                        senderId: 'user',
                        senderName: senderNameFromInput,
                        timestamp: Date.now(),
                        visibility: runtimeState.moments.postContext.visibility,
                        visibleTo: runtimeState.moments.postContext.visibleTo,
                        replies: []
                    };
                    appState.chat.moments.messages.push(newMessage);
                    logVisitor(newMessage.recipientId, 'user'); // Log visitor for leaving a message
                    // Send notification
                    addMomentsNotification('message', 'user', {
                        messageId: newMessage.id,
                        recipientId: newMessage.recipientId,
                        content: newMessage.content
                    });
                    showToast('ç•™è¨€æˆåŠŸï¼');
                }

                debouncedSaveState();
                renderMomentsFeed(runtimeState.moments.currentProfileId);
                leaveMessageModal.classList.remove('visible');
            });
        
         getEl('leave-message-visibility').addEventListener('change', e => {
            runtimeState.moments.postContext.visibility = e.target.value;
            const selectorContainer = getEl('leave-message-friend-selector-container');
            if (e.target.value === 'specific') {
                renderFriendSelector('leave-message-friend-selector', 'message');
                selectorContainer.classList.remove('hidden-by-logic');
            } else {
                selectorContainer.classList.add('hidden-by-logic');
            }
        });

        getEl('leave-message-friend-selector').addEventListener('click', e => {
            const item = e.target.closest('.friend-selector-item');
            if (item) {
                const id = item.dataset.id;
                item.classList.toggle('selected');
                const context = runtimeState.moments.postContext;
                if (item.classList.contains('selected')) {
                    if (!context.visibleTo.includes(id)) context.visibleTo.push(id);
                } else {
                    context.visibleTo = context.visibleTo.filter(fid => fid !== id);
                }
            }
            
        });
        getEl('photo-viewer-prev-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            let { currentIndex } = runtimeState.moments.viewerContext;
            if (currentIndex > 0) {
                currentIndex--;
                runtimeState.moments.viewerContext.currentIndex = currentIndex;
                renderPhotoViewerContent(currentIndex);
            }
        });
        getEl('photo-viewer-next-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            let { items, currentIndex } = runtimeState.moments.viewerContext;
            if (currentIndex < items.length - 1) {
                currentIndex++;
                runtimeState.moments.viewerContext.currentIndex = currentIndex;
                renderPhotoViewerContent(currentIndex);
            }
        });
    }

    function renderAlbumView(albumId) {
        const album = appState.chat.moments.albums.find(a => a.id === albumId);
        if (!album) {
            closeSubScreen(viewAlbumScreen, chatAppScreen);
            return;
        }

        viewAlbumScreen.dataset.albumId = albumId;
        getEl('view-album-title').textContent = album.name;
        
        const grid = getEl('album-photo-grid');
        const photoIds = album.photoIds || [];
        const photosInAlbum = appState.chat.moments.photos.filter(p => photoIds.includes(p.id));
        
        if (photosInAlbum.length === 0) {
            grid.innerHTML = `<p style="text-align:center; color:#888; grid-column: 1 / -1;">ç›¸å†Œé‡Œè¿˜æ²¡æœ‰ç…§ç‰‡</p>`;
        } else {
             grid.innerHTML = photosInAlbum.map(p => `<div class="photo-grid-item" data-id="${p.id}" data-image-id="${p.imageId}"></div>`).join('');
             grid.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));
        }
    }
    function openSimpleViewer(items, startIndex = 0) {
        if (!items || items.length === 0) return;
        runtimeState.moments.viewerContext = {
            items: items,
            currentIndex: startIndex
        };
        renderSimpleViewerContent(startIndex);
        simpleViewerModal.classList.add('visible');
    }
    function renderSimpleViewerContent(index) {
        const { items } = runtimeState.moments.viewerContext;
        const item = items[index];
        if (!item) return;

        const imgEl = getEl('simple-viewer-image');
        const textEl = getEl('simple-viewer-text');

        if (item.isTextImage) {
                imgEl.style.display = 'none';
                textEl.style.display = 'flex';
                textEl.textContent = item.description;
            } else {
                imgEl.style.display = 'block';
                textEl.style.display = 'none';
                imgEl.src = '';
                setElementImage(imgEl, item.imageId, 'src');
            }

        const prevBtn = getEl('simple-viewer-prev-btn');
        const nextBtn = getEl('simple-viewer-next-btn');
        prevBtn.style.display = (items.length > 1 && index > 0) ? 'block' : 'none';
        nextBtn.style.display = (items.length > 1 && index < items.length - 1) ? 'block' : 'none';
    }
    function setupMomentsModalListeners() {
        // Listener for dynamic author selector in post edit modal
        postMomentModal.addEventListener('click', e => {
            const item = e.target.closest('.author-selector-item');
            if (item && item.closest('#moment-post-author-selector')) {
                item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            }
        });

        cancelPostMomentBtn.addEventListener('click', () => postMomentModal.classList.remove('visible'));
        
        confirmPostMomentBtn.addEventListener('click', async () => {
        const { type, visibility, visibleTo, images, editingPostId } = runtimeState.moments.postContext;
        const areCommentsPrivate = getEl('post-moment-comment-private-checkbox').checked;
                // --- æ–°å¢ï¼šå¦‚æœåŠ¨æ€ç±»å‹ä¸ºæ—¥å¿—ï¼Œåˆ™å¼ºåˆ¶æ¸…ç©ºå›¾ç‰‡æ•°ç»„ ---
        if (type === 'log') {
            runtimeState.moments.postContext.images = [];
        }
        let postData;
        if(editingPostId){
            postData = appState.chat.moments.posts.find(p => p.id === editingPostId);
            const selectedAuthorEl = getEl('moment-post-author-selector')?.querySelector('.selected');
            if (selectedAuthorEl) {
                postData.authorId = selectedAuthorEl.dataset.id;
            }
        } else {
            postData = { id: newId('post'), authorId: 'user', timestamp: Date.now(), likes: [], comments: [] };
        }

        if (type === 'status') {
            const text = getEl('post-moment-status-content').value.trim();
            const statusType = query('input[name="status-type"]:checked').value;
let finalImages = []; // å£°æ˜å¹¶åˆå§‹åŒ–ä¸ºç©ºæ•°ç»„

// æ ¹æ®ç±»å‹æ­£ç¡®å¡«å……å›¾ç‰‡æ•°ç»„
if (statusType === 'image' || statusType === 'text-image') {
    finalImages = [...(runtimeState.moments.postContext.images || [])];
}

if (statusType === 'text-image') {
    const desc = getEl('post-moment-text-image-desc').value.trim();
    if (desc) {
        finalImages.push({ isTextImage: true, imageId: 'default_camera_image', description: desc });
    }
}
// å¯¹äº 'text' ç±»å‹, finalImages å°†ä¿æŒä¸ºç©ºæ•°ç»„, è¿™æ˜¯æ­£ç¡®çš„

            if (!text && finalImages.length === 0) return showToast('è¯·è¯´ç‚¹ä»€ä¹ˆæˆ–æ·»åŠ ä¸€å¼ å›¾ç‰‡å§', 'error');
            postData.type = 'status';
            postData.content = { text, images: finalImages };
        } else if (type === 'log') {
            const title = getEl('post-moment-log-title').value.trim();
            const text = getEl('post-moment-log-content').value.trim();
            if(!title) return showToast('æ—¥å¿—æ ‡é¢˜ä¸èƒ½ä¸ºç©º', 'error');
            postData.type = 'log';
            postData.content = { title, text };
        }

        postData.visibility = visibility;
        postData.visibleTo = visibility === 'specific' ? visibleTo : [];
        postData.areCommentsPrivate = areCommentsPrivate; // Save the new setting
        postData.isVisibilityPublic = getEl('post-moment-visibility-public-checkbox').checked;
        if(!editingPostId) {
            appState.chat.moments.posts.unshift(postData);
        }

        debouncedSaveState();
        renderMomentsFeed(runtimeState.moments.currentProfileId);
        postMomentModal.classList.remove('visible');
    });
    
        getEl('post-moment-status-type').addEventListener('change', e => {
            const type = e.target.value;
            const imageButtons = getEl('post-moment-image-buttons');
            const textImageInput = getEl('post-moment-text-image-input');
            imageButtons.classList.toggle('hidden-by-logic', type !== 'image');
            textImageInput.classList.toggle('hidden-by-logic', type !== 'text-image');
        });
    
        getEl('post-moment-visibility').addEventListener('change', e => {
            runtimeState.moments.postContext.visibility = e.target.value;
            const friendSelector = getEl('post-moment-friend-selector-container');
            if (e.target.value === 'specific') {
                renderFriendSelector('post-moment-friend-selector', 'post');
                friendSelector.classList.remove('hidden-by-logic');
            } else {
                friendSelector.classList.add('hidden-by-logic');
                runtimeState.moments.postContext.visibleTo = [];
            }
        });
    
        getEl('post-moment-friend-selector').addEventListener('click', e => {
            const item = e.target.closest('.friend-selector-item');
            if (item) {
                const id = item.dataset.id;
                item.classList.toggle('selected');
                if (item.classList.contains('selected')) {
                    runtimeState.moments.postContext.visibleTo.push(id);
                } else {
                    runtimeState.moments.postContext.visibleTo = runtimeState.moments.postContext.visibleTo.filter(friendId => friendId !== id);
                }
            }
        });
        
        getEl('post-moment-upload-btn').addEventListener('click', () => getEl('post-moment-image-input').click());
        getEl('post-moment-add-url-btn').addEventListener('click', async () => {
    const url = prompt('è¯·è¾“å…¥å›¾ç‰‡URL:');
    if (url && url.startsWith('http')) {
        // ç›´æ¥ä½¿ç”¨URLä½œä¸ºå›¾ç‰‡ID
        runtimeState.moments.postContext.images.push(url);
        showToast('å›¾ç‰‡é“¾æ¥æ·»åŠ æˆåŠŸï¼');
    } else if (url) {
        showToast('æ— æ•ˆçš„URL', 'error');
    }
});
        
        getEl('post-moment-image-input').addEventListener('change', async (e) => {
    const files = e.target.files;
    if(files.length > 0){
        showToast(`æ­£åœ¨æ·»åŠ  ${files.length} å¼ å›¾ç‰‡...`);
        for(const file of files) {
            const compressedFile = await compressImageBeforeSaving(file);
            const newImageId = newId('moment_img');
            await addMediaToDB(newImageId, compressedFile);
            runtimeState.moments.postContext.images.push(newImageId);
        }
        showToast('å›¾ç‰‡æ·»åŠ æˆåŠŸï¼');
        e.target.value = ''; // Reset file input
    }
});

        // Listeners for the new comment edit modal
        const authorSelector = getEl('moment-comment-author-selector');
        authorSelector.addEventListener('click', e => {
            const item = e.target.closest('.author-selector-item');
            if(item) {
                authorSelector.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            }
        });

        cancelEditMomentCommentBtn.addEventListener('click', () => {
            editMomentCommentModal.classList.remove('visible');
        });

        saveEditMomentCommentBtn.addEventListener('click', () => {
            const { source, postId, commentId, replyId, messageId } = runtimeState.editingComment;
            
            let commentToEdit = null;
            let post = null; // Declare post here to be accessible later

            if (source === 'message') {
                const message = appState.chat.moments.messages.find(m => m.id === messageId);
                if (message && message.replies) {
                    commentToEdit = message.replies.find(r => r.id === replyId);
                }
            } else { // source === 'moments'
                post = appState.chat.moments.posts.find(p => p.id === postId);
                if (post) {
                    commentToEdit = replyId 
                        ? post.comments.find(c => c.replies && c.replies.some(r => r.id === replyId))?.replies.find(r => r.id === replyId)
                        : post.comments.find(c => c.id === commentId);
                }
            }
            
            if (!commentToEdit) return showToast('æ‰¾ä¸åˆ°è¦ç¼–è¾‘çš„å†…å®¹', 'error');

            const newContent = getEl('edit-moment-comment-content').value;
            const selectedAuthorEl = getEl('moment-comment-author-selector').querySelector('.selected');
            const oldAuthorId = commentToEdit.authorId;
            const newAuthorId = selectedAuthorEl ? selectedAuthorEl.dataset.id : oldAuthorId;

            if (oldAuthorId !== newAuthorId) {
                const oldAuthor = findUserById(oldAuthorId);
                const newAuthor = findUserById(newAuthorId);
                // This logic applies only when editing a top-level comment that has replies
                if (!replyId && post && post.comments) {
                    const parentComment = post.comments.find(c => c.id === commentId);
                    if (parentComment && parentComment.replies) {
                        parentComment.replies.forEach(reply => {
                            const expectedOldMention = `@${oldAuthor.name} `;
                            if (reply.text.startsWith(expectedOldMention)) {
                                reply.text = reply.text.replace(expectedOldMention, `@${newAuthor.name} `);
                            }
                        });
                    }
                }
            }

            commentToEdit.text = newContent;
            commentToEdit.authorId = newAuthorId;
            
            debouncedSaveState();
            renderMomentsFeed(runtimeState.moments.currentProfileId);
            editMomentCommentModal.classList.remove('visible');
        });
        leaveMessageModal.addEventListener('click', e => {
            const item = e.target.closest('#leave-message-author-selector .author-selector-item');
            if (item) {
                item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            }
        });
    }


    function renderFriendSelector(containerId, contextType) {
        const selector = getEl(containerId);
        const visibleToList = runtimeState.moments.postContext.visibleTo;

        // --- ä¿®æ­£ï¼šå°†Useræœ¬äººåŠ å…¥å¯é€‰åˆ—è¡¨ ---
        const userProfile = appState.chat.moments.profile;
        const userForSelector = { id: 'user', charSettings: { name: userProfile.name, avatarId: userProfile.avatarId } };
        const availableFriends = [userForSelector, ...appState.chat.contacts.filter(c => !c.isGroup)];
        
        selector.innerHTML = availableFriends.map(friend => {
            const isSelected = visibleToList.includes(friend.id);
            const avatarId = friend.id === 'user' ? userForSelector.charSettings.avatarId : friend.charSettings.avatarId;
            const name = friend.id === 'user' ? userForSelector.charSettings.name : friend.charSettings.name;
            return `
                <div class="friend-selector-item ${isSelected ? 'selected' : ''}" data-id="${friend.id}">
                    <div class="avatar" data-avatar-id="${avatarId}"></div>
                    <span class="name">${name}</span>
                </div>
            `;
        }).join('');
        selector.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    }

// ===================================================================
// --- åˆå§‹åŒ– ---
// ===================================================================
    function setupAllListInteractions() { 
        new ListInteractionHandler(presetListEl, { itemSelector: '.preset-list-item', contentSelector: '.preset-item-content', actionsSelector: '.preset-item-actions', onDelete: (item) => { const index = parseInt(item.dataset.index); if (confirm(`ç¡®å®šè¦åˆ é™¤é¢„è®¾ "${appState.settings.presets[index].name}" å—ï¼Ÿ`)) { appState.settings.presets.splice(index, 1); debouncedSaveState(); renderPresetList(); updatePresetSelect(); showToast("é¢„è®¾å·²åˆ é™¤"); } }, onEdit: (item) => { const index = parseInt(item.dataset.index); const preset = appState.settings.presets[index]; editPresetIndexInput.value = index; editPresetNameInput.value = preset.name; editPresetUrlInput.value = preset.url; editPresetKeyInput.value = preset.key; editPresetModal.classList.add('visible'); } }); 
        new ListInteractionHandler(musicListEl, { itemSelector: '.music-list-item', contentSelector: '.music-item-content', actionsSelector: '.music-item-actions', onTap: (item) => { const songId = item.dataset.id; const currentPlayingSong = appState.music.queue[appState.music.currentQueueIndex]; if (currentPlayingSong && currentPlayingSong.id === songId && runtimeState.musicSessionType === 'solo') { stopPlayback(); } else { const songIndex = appState.music.playlist.findIndex(s => s.id === songId); if (songIndex > -1) { stopPlayback(); runtimeState.currentChatId = null; runtimeState.musicSessionType = 'solo'; appState.music.queue = [...appState.music.playlist]; playSongFromQueue(songIndex); getEl('lyrics-container').classList.add('visible'); } } }, onLongPress: (item) => { openSongDetails(item.dataset.id); }, onDelete: async (item) => { const songId = item.dataset.id; const songIndex = appState.music.playlist.findIndex(s => s.id === songId); if (songIndex > -1) { const song = appState.music.playlist[songIndex]; if (confirm(`ç¡®å®šè¦åˆ é™¤æ­Œæ›² "${song.title}" å—ï¼Ÿ`)) { if(song.isLocal) { await deleteMediaFromDB(songId); } appState.music.playlist.splice(songIndex, 1); delete appState.music.lyrics[songId]; const queueIndex = appState.music.queue.findIndex(s => s.id === songId); if (queueIndex > -1) { appState.music.queue.splice(queueIndex, 1); if (queueIndex === appState.music.currentQueueIndex) { if (appState.music.queue.length > 0) { playSongFromQueue(queueIndex % appState.music.queue.length); } else { stopPlayback(); } } else if (queueIndex < appState.music.currentQueueIndex) { appState.music.currentQueueIndex--; } } renderMusicList(); renderPlayerQueue(); debouncedSaveState(); showToast("æ­Œæ›²å·²åˆ é™¤"); } } }, onEdit: (item) => { const songId = item.dataset.id; const song = appState.music.playlist.find(s => s.id === songId); if (song) { editSongIdInput.value = song.id; editSongTitleInput.value = song.title; editSongArtistInput.value = song.artist; editSongModal.classList.add('visible'); } } });  
        new ListInteractionHandler(fontListEl, { itemSelector: '.font-list-item', contentSelector: '.font-item-content', actionsSelector: '.font-item-actions', onTap: (item, target) => { if (target.classList.contains('font-color-btn')) { const newColor = prompt("è¯·è¾“å…¥æ–°çš„å­—ä½“é¢œè‰² (HEXæˆ–RGB/A):", appState.beautify.fontColor); if (newColor && isValidColor(newColor)) { appState.beautify.fontColor = newColor; document.documentElement.style.setProperty('--system-font-color', newColor); debouncedSaveState(); showToast('å­—ä½“é¢œè‰²å·²æ›´æ–°'); } else if (newColor) { showToast('æ— æ•ˆçš„é¢œè‰²æ ¼å¼', 'error'); } } else { const fontName = item.dataset.name; if (confirm(`ç¡®å®šè¦å°†ç³»ç»Ÿå­—ä½“æ›´æ¢ä¸º "${fontName === 'default' ? 'é»˜è®¤ç³»ç»Ÿå­—ä½“' : fontName}" å—ï¼Ÿ`)) { applyFont(fontName); } } }, onDelete: async (item) => { const fontName = item.dataset.name; if (fontName === 'default') { showToast('é»˜è®¤å­—ä½“æ— æ³•åˆ é™¤', 'error'); return; } if (confirm(`ç¡®å®šè¦åˆ é™¤å­—ä½“ "${fontName}" å—ï¼Ÿ`)) { const fontIndex = appState.beautify.fonts.findIndex(f => f.name === fontName); if (fontIndex > -1) { await deleteMediaFromDB(appState.beautify.fonts[fontIndex].id); appState.beautify.fonts.splice(fontIndex, 1); } if (appState.beautify.currentFont === fontName) { applyFont('default'); } await loadAllCustomFonts(); debouncedSaveState(); renderFonts(); showToast('å­—ä½“å·²åˆ é™¤'); } }, onEdit: async (item) => { const fontName = item.dataset.name; if (fontName === 'default') { showToast('é»˜è®¤å­—ä½“æ— æ³•ç¼–è¾‘', 'error'); return; } const fontIndex = appState.beautify.fonts.findIndex(f => f.name === fontName); if (fontIndex > -1) { const newName = prompt('è¯·è¾“å…¥æ–°çš„å­—ä½“åç§°:', fontName); if (newName && newName.trim() !== '') { appState.beautify.fonts[fontIndex].name = newName.trim(); if (appState.beautify.currentFont === fontName) { appState.beautify.currentFont = newName.trim(); } await loadAllCustomFonts(); debouncedSaveState(); renderFonts(); showToast('å­—ä½“åç§°å·²æ›´æ–°'); } } } }); 
        const createDataListHandler = (listEl, type, renderFunction) => { new ListInteractionHandler(listEl, { itemSelector: '.preset-data-item', contentSelector: '.preset-data-item-content', actionsSelector: '.preset-data-item-actions', onTap: (item) => { const dataId = item.dataset.id; const dataItem = appState.data[type + 's'].find(d => d.id === dataId); if (dataItem) { viewContentTitle.textContent = escapeHTML(dataItem.name); viewContentBody.innerHTML = `<p>${escapeHTML(dataItem.content || '').replace(/\n/g, '<br>')}</p>`; viewContentModal.classList.add('visible'); } }, onDelete: (item) => { const id = item.dataset.id; const dataArray = appState.data[type + 's']; const itemIndex = dataArray.findIndex(i => i.id === id); if (itemIndex > -1) { if (confirm(`ç¡®å®šè¦åˆ é™¤ "${dataArray[itemIndex].name}" å—ï¼Ÿ`)) { dataArray.splice(itemIndex, 1); debouncedSaveState(); renderFunction(); } } }, onEdit: (item) => { openDataEditor(type, item.dataset.id); } }); }; createDataListHandler(worldBookListEl, 'worldBook', renderWorldBooks); createDataListHandler(archiveListEl, 'archive', renderArchives); createDataListHandler(infoListEl, 'info', renderInfos); 
        new ListInteractionHandler(detailsCommentsList, { itemSelector: '.comment-item', contentSelector: '.comment-item-main', actionsSelector: '.comment-item-actions-swipe', onDelete: (item) => { const songId = songDetailsScreen.dataset.songId; const commentId = item.dataset.commentId; const commentIndex = appState.music.comments[songId].findIndex(c => c.id === commentId); if (commentIndex > -1) { if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿ')) { appState.music.comments[songId].splice(commentIndex, 1); debouncedSaveState(); renderSongComments(songId); } } }, onEdit: (item) => { const songId = songDetailsScreen.dataset.songId; const commentId = item.dataset.commentId; const comment = appState.music.comments[songId].find(c => c.id === commentId); if (comment) { runtimeState.editingComment = { source: 'music', songId, commentId, replyId: null }; editCommentInput.value = comment.text; editCommentModal.classList.add('visible'); } } }); 
        new ListInteractionHandler(messageListEl, { itemSelector: '.contact-list-item', contentSelector: '.contact-item-content', actionsSelector: '.contact-item-actions', onTap: (item) => { if (chatAppScreen.classList.contains('selection-mode')) { if (item.dataset.isGroup === 'true') { showToast('ä¸èƒ½é€‰æ‹©ç¾¤ç»„åŠ å…¥æ–°ç¾¤èŠ', 'error'); return; } item.classList.toggle('selected'); const id = item.dataset.id; if (item.classList.contains('selected')) { if (!runtimeState.contactSelection.includes(id)) runtimeState.contactSelection.push(id); } else { runtimeState.contactSelection = runtimeState.contactSelection.filter(selId => selId !== id); } } else { openSingleChat(item.dataset.id); } }, onLongPress: (item) => { if (!chatAppScreen.classList.contains('selection-mode')) { enterContactSelectionMode(item); } },                 onPin: (item) => {
                    const contactId = item.dataset.id;
                    const contact = appState.chat.contacts.find(c => c.id === contactId);
                    if (contact) {
                        contact.isPinned = !contact.isPinned;
                        debouncedSaveState();
                        renderMessageList();
                    }
                }, onDelete: (item) => {
            const contactId = item.dataset.id;
            const contactIndex = appState.chat.contacts.findIndex(c => c.id === contactId);
            if (contactIndex > -1) {
                const contact = appState.chat.contacts[contactIndex];
                if (confirm(`ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è”ç³»äºº "${contact.name}" å—ï¼Ÿæ­¤æ“ä½œå°†ä¸€å¹¶åˆ é™¤å…¶æ‰€æœ‰åŠ¨æ€ã€è¯„è®ºå’Œç•™è¨€ï¼Œä¸”ä¸å¯é€†ã€‚`)) {
                    // --- æ–°å¢ï¼šåŒæ­¥åˆ é™¤å…³è”çš„æ”¶è—å’Œç§˜å¯† ---
                    if (appState.diary && appState.diary.secrets) {
                        appState.diary.secrets = appState.diary.secrets.filter(secret => secret.charId !== contactId);
                    }
    const contactDisplayName = contact.remark || (contact.isGroup ? contact.groupSettings.name : contact.charSettings.name);
    appState.diary.collections = appState.diary.collections.filter(c => !c.participants.includes(contactDisplayName));
                    // --- ADDED CODE START ---
    // Check if a video call with this contact is active and end it
    if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId === contactId) {
        endVideoCall();
    }
                        // --- æ–°å¢ï¼šåŒæ­¥åˆ é™¤å…³è”çš„æ˜ä¿¡ç‰‡ ---
                    if (appState.mailbox && appState.mailbox.postcards) {
                        appState.mailbox.postcards = appState.mailbox.postcards.filter(p => p.senderId !== contactId && p.recipientId !== contactId);
                    }
                    // --- æ–°å¢ï¼šåŒæ­¥åˆ é™¤å…³è”çš„è‚¡ç¥¨ ---
if (appState.assets && appState.assets.stocks && !contact.isGroup) {
    const charId = contact.id;
    const stockIndex = appState.assets.stocks.market.findIndex(s => s.charId === charId);
    if (stockIndex > -1) {
        const stockId = appState.assets.stocks.market[stockIndex].id;
        appState.assets.stocks.market.splice(stockIndex, 1);
        delete appState.assets.stocks.portfolio[stockId];
        delete appState.assets.stocks.newsFeed[stockId];
    }
}
    // --- ADDED CODE END ---
                    // --- Enhanced Deletion Logic for Single Chars ---
                    if (!contact.isGroup) {
                        const charId = contact.id;
                                    // --- æ–°å¢ï¼šåœ¨åˆ é™¤å¸–å­å‰ï¼Œå…ˆæ¸…ç†æ‰€æœ‰ç›¸å…³çš„é€šçŸ¥ ---
                                    const postIdsByDeletedChar = new Set(appState.chat.moments.posts.filter(p => p.authorId === charId).map(p => p.id));
                                    appState.chat.moments.notifications = appState.chat.moments.notifications.filter(n => {
                                        const actorIsDeleted = n.actorId === charId;
                                        const postIsDeleted = n.postId && postIdsByDeletedChar.has(n.postId);
                                        return !actorIsDeleted && !postIsDeleted;
                                    });
                        // 1. Clean Moments Posts, Likes, Comments, Replies
                        // Filter out posts by the char
                        appState.chat.moments.posts = appState.chat.moments.posts.filter(post => post.authorId !== charId);
                        // Clean remaining posts
                        appState.chat.moments.posts.forEach(post => {
                            // Remove likes from the char
                            if (post.likes) {
                                post.likes = post.likes.filter(likerId => likerId !== charId);
                            }
                            // Remove comments from the char, and replies within other comments
                            if (post.comments) {
                                post.comments = post.comments.filter(comment => comment.authorId !== charId);
                                post.comments.forEach(comment => {
                                    if (comment.replies) {
                                        comment.replies = comment.replies.filter(reply => reply.authorId !== charId);
                                    }
                                });
                            }
                        });

                        // Clean up notifications from the char
                    appState.chat.moments.notifications = appState.chat.moments.notifications.filter(n => n.actorId !== charId);

                    // 2. Clean Message Board Messages and Replies
                    // Filter out messages by the char
                    appState.chat.moments.messages = appState.chat.moments.messages.filter(msg => msg.senderId !== charId);
                         // Clean Message Board Messages and Replies
                        // Filter out messages by the char
                        appState.chat.moments.messages = appState.chat.moments.messages.filter(msg => msg.senderId !== charId);
                        
                        // 3. Clean Visitor Logs
                        // Remove records of this char visiting the user
                        if (appState.chat.moments.visitors) {
                            appState.chat.moments.visitors = appState.chat.moments.visitors.filter(v => v.visitorId !== charId);
                        }
                        // Remove records of anyone visiting this char (since their page is gone)
                        appState.chat.contacts.forEach(c => {
                            if(c.charSettings && c.charSettings.visitors) {
                                c.charSettings.visitors = c.charSettings.visitors.filter(v => v.visitorId !== charId);
                            }
                        });

                        // Clean replies within remaining messages
                        appState.chat.moments.messages.forEach(msg => {
                            if (msg.replies) {
                                msg.replies = msg.replies.filter(reply => reply.authorId !== charId);
                            }
                        });
    
    // 4. Clean Love Letters
if (appState.mailbox && appState.mailbox.loveLetters) {
    appState.mailbox.loveLetters = appState.mailbox.loveLetters.filter(letter => letter.senderId !== charId && letter.recipientId !== charId);
}
                    }
                    // --- End of Enhanced Deletion Logic ---

                    // Original deletion logic
                    appState.chat.contacts.splice(contactIndex, 1);
                    saveState();
                    renderMessageList();
                    
                    // Refresh moments UI if visible
                    syncAndUpdateMoments(runtimeState.moments.currentProfileId);

                    showToast('è”ç³»äººåŠç›¸å…³åŠ¨æ€å·²åˆ é™¤');
                }
            }
        } }); 
    emojiGrid.addEventListener('click', e => {
    const item = e.target.closest('.emoji-item');
    if (!item) return;
    if (runtimeState.emojiSelectionMode) {
        toggleEmojiSelection(item);
    } else {
        const emoji = appState.chat.emojis.find(em => em.id === item.dataset.emojiId);
        if (emoji) {
            addMessageToConversation({ id: newId('msg'), type: 'emoji', emojiId: emoji.id, description: emoji.description, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId });
            emojiPickerPanel.classList.remove('visible');
        }
    }
});// --- æ–°å¢ï¼šä¸ºè‚¡ç¥¨åˆ—è¡¨æ·»åŠ æ»‘åŠ¨äº¤äº’ ---
new ListInteractionHandler(getEl('stock-list-container'), {
    itemSelector: '.stock-item',
    contentSelector: '.swipe-content',
    actionsSelector: '.swipe-actions',
    onDelete: (item) => {
        const stockId = item.dataset.stockId;
        const stock = appState.assets.stocks.market.find(s => s.id === stockId);
        if (stock && confirm(`ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è‚¡ç¥¨ "${stock.name}" å—ï¼Ÿ\næ­¤æ“ä½œå°†ä¸€å¹¶æ¸…é™¤æ‰€æœ‰æŒä»“å’Œæ–°é—»è®°å½•ã€‚`)) {
            // Remove from market
            appState.assets.stocks.market = appState.assets.stocks.market.filter(s => s.id !== stockId);
            // Remove from portfolio
            delete appState.assets.stocks.portfolio[stockId];
            // Remove news feed
            delete appState.assets.stocks.newsFeed[stockId];
            debouncedSaveState();
            renderStockMarket();
            showToast('è‚¡ç¥¨å·²åˆ é™¤');
        }
    },
    onEdit: (item) => {
        const stockId = item.dataset.stockId;
        const stock = appState.assets.stocks.market.find(s => s.id === stockId);
        if (stock) {
            getEl('editing-stock-id').value = stockId;
            getEl('stock-name-input').value = stock.name;
            getEl('stock-ticker-input').value = stock.ticker;
            getEl('edit-stock-modal').classList.add('visible');
        }
    }
});
    }

    function setupMomentsListInteraction(feedElement) {
        // Destroy the old handler if it exists to prevent memory leaks and duplicate listeners
        if (runtimeState.moments && runtimeState.moments.listHandler) {
            runtimeState.moments.listHandler.destroy();
        }

        const handler = new ListInteractionHandler(feedElement, {
            itemSelector: '.moments-post-item, .message-board-item',
            // ã€æ ¸å¿ƒä¿®å¤ã€‘: å°†é€‰æ‹©å™¨ä¿®æ­£ä¸ºä¸HTMLå®é™…ä½¿ç”¨çš„ç±»åå®Œå…¨åŒ¹é…
            contentSelector: '.post-item-content, .message-board-item-main',
            actionsSelector: '.post-item-actions, .message-board-item-actions',
            onDelete: (item) => {
                        if (item.classList.contains('moments-post-item')) {
                            const postId = item.dataset.postId;
                                                    // --- æ–°å¢ï¼šåœ¨åˆ é™¤å¸–å­å‰ï¼Œå…ˆæ¸…ç†æ‰€æœ‰ç›¸å…³çš„é€šçŸ¥ ---
                        appState.chat.moments.notifications = appState.chat.moments.notifications.filter(n => n.postId !== postId);
                            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡åŠ¨æ€å—ï¼Ÿæ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰ç›¸å…³æ•°æ®ä¸”ä¸å¯é€†ã€‚')) {
                                if (deleteMomentAndAssociatedData(postId)) {
                                    renderMomentsFeed(runtimeState.moments.currentProfileId);
                                    showToast('åŠ¨æ€åŠç›¸å…³æ•°æ®å·²åˆ é™¤');
                                }
                            }
                        } else if (item.classList.contains('message-board-item')) {
                            const messageId = item.dataset.messageId;
                            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡ç•™è¨€å—ï¼Ÿ')) {
                                appState.chat.moments.messages = appState.chat.moments.messages.filter(m => m.id !== messageId);
                                debouncedSaveState();
                                renderMomentsFeed(runtimeState.moments.currentProfileId);
                                showToast('ç•™è¨€å·²åˆ é™¤');
                            }
                        }
                    },
            onEdit: (item) => {
                    if (item.classList.contains('moments-post-item')) {
                        const postId = item.dataset.postId;
                        const post = appState.chat.moments.posts.find(p => p.id === postId);
                        if (post) {
                            openPostMomentModal(post.type, post.id);
                        }
                    } else if (item.classList.contains('message-board-item')) {
                        const messageId = item.dataset.messageId;
                        const message = appState.chat.moments.messages.find(m => m.id === messageId);
                        if(message) {
                           openLeaveMessageModal(messageId);
                        }
                    }
                }
        });
        // Store the new handler instance in runtimeState
        runtimeState.moments.listHandler = handler;
    }

function setupSingleChatSettingsListeners() { csCharAvatarLibraryBtn.addEventListener('click', () => openLibraryModal({ title: 'Charå¤´åƒåº“', settingsGroup: 'charSettings', libraryKey: 'avatarLibrary', activeKey: 'avatarId', showPreview: false, isCircular: true })); csCharAvatarFrameBtn.addEventListener('click', () => openLibraryModal({ title: 'Charå¤´åƒæ¡†åº“', isFrame: true, settingsGroup: 'charSettings', activeKey: 'avatarFrameId', showPreview: true, hasNoItemOption: true, previewAvatarId: runtimeState.tempChatSettings.charSettings.avatarId })); usUserAvatarLibraryBtn.addEventListener('click', () => openLibraryModal({ title: 'æˆ‘çš„å¤´åƒåº“', isGlobalUserLib: true, settingsGroup: 'userSettings', activeKey: 'avatarId', showPreview: false, isCircular: true }));usUserAvatarFrameBtn.addEventListener('click', () => openLibraryModal({ title: 'æˆ‘çš„å¤´åƒæ¡†åº“', isFrame: true, settingsGroup: 'userSettings', activeKey: 'avatarFrameId', showPreview: true, hasNoItemOption: true, previewAvatarId: runtimeState.tempChatSettings.userSettings.avatarId })); 

    csCharBackgroundBtn.addEventListener('click', (e) => { showBackgroundContextMenu(e.currentTarget, { settingsObject: runtimeState.tempChatSettings.charSettings }); });
    const usUserVideoBackgroundBtn = getEl('us-user-video-background-btn'); if(usUserVideoBackgroundBtn) {
    usUserVideoBackgroundBtn.addEventListener('click', (e) => {
        openBackgroundLibraryModal({
            type: 'video',
            title: 'é€‰æ‹©è§†é¢‘èƒŒæ™¯',
            settingsObject: runtimeState.tempChatSettings.userSettings,
            activeKey: 'videoBackgroundId',
            libraryKey: 'videoBackgroundLibrary',
            defaultId: ''
        });
    });
}
}

function openBackgroundLibraryModal(context) {
    runtimeState.backgroundLibraryContext = context;
    runtimeState.backgroundLibrarySelection = [];
    const modal = getEl('background-library-modal');
        modal.classList.remove('selection-mode');
    modal.classList.add('background-preview-mode'); // æ ¸å¿ƒä¼˜åŒ–ï¼šæ·»åŠ é¢„è§ˆæ¨¡å¼ç±»
    getEl('background-library-delete-btn').style.display = 'none';
    getEl('background-library-mode-toggle-btn').textContent = 'åˆ é™¤';
    getEl('background-library-close-btn').style.display = 'block';
    getEl('background-library-modal-title').textContent = context.title;
    renderBackgroundLibraryGrid();
    modal.classList.add('visible');
}

function renderBackgroundLibraryGrid() {
    const context = runtimeState.backgroundLibraryContext;
    const grid = getEl('background-library-grid');
    grid.innerHTML = '';

    let items, activeItem;
    if (context.type === 'chat') {
        items = appState.beautify.wallpapers.map(wp => wp.id);
        activeItem = context.settingsObject.chatBackgroundId;
    } else { // video
        items = context.settingsObject[context.libraryKey] || [];
        activeItem = context.settingsObject[context.activeKey];
    }

        // Add the 'default' option first, which now previews the global background
    const defaultItem = document.createElement('div');
    defaultItem.className = 'library-item';
    defaultItem.dataset.id = context.defaultId;
    defaultItem.innerHTML = `
        <img>
        <div style="position: absolute; bottom: 5px; left: 5px; right: 5px; background: rgba(0,0,0,0.5); color: white; font-size: 10px; text-align: center; border-radius: 3px; padding: 2px;">
            å…¨å±€èƒŒæ™¯
        </div>
    `;

    if (activeItem === context.defaultId) {
        defaultItem.classList.add('selected');
    }
    grid.appendChild(defaultItem);

    // Set the preview image for the default item to the current global background
    const globalChatBgId = appState.beautify.currentChatBgId;
    setElementImage(defaultItem.querySelector('img'), globalChatBgId, 'src');

    items.forEach(id => {
        const item = document.createElement('div');
        item.className = 'library-item';
        item.innerHTML = `<img>`;
        item.dataset.id = id;
        if (id === activeItem) {
            item.classList.add('selected');
        }
        grid.appendChild(item);
        setElementImage(item.querySelector('img'), id, 'src');
    });
}

function setupBackgroundLibraryListeners() {
    const modal = getEl('background-library-modal');
    const grid = getEl('background-library-grid');
    const uploadBtn = getEl('background-library-upload-btn');
    const addUrlBtn = getEl('background-library-add-url-btn');
    const fileInput = getEl('background-library-file-input');
    const closeBtn = getEl('background-library-close-btn');
    const modeToggleBtn = getEl('background-library-mode-toggle-btn');
    const deleteBtn = getEl('background-library-delete-btn');

    grid.addEventListener('click', async e => {
        const item = e.target.closest('.library-item');
        if (!item) return;

        const context = runtimeState.backgroundLibraryContext;
        const id = item.dataset.id;
        
        if (modal.classList.contains('selection-mode')) {
            if (id !== context.defaultId) {
                item.classList.toggle('selected');
                if (item.classList.contains('selected')) {
                    runtimeState.backgroundLibrarySelection.push(id);
                } else {
                    runtimeState.backgroundLibrarySelection = runtimeState.backgroundLibrarySelection.filter(selId => selId !== id);
                }
            }
        } else {
            context.settingsObject[context.activeKey] = id;
            renderBackgroundLibraryGrid();
            
            if (context.type === 'chat') {
                await updateSingleChatUI();
            } else { // video
                if (appState.chat.videoCallState.isActive) {
                    await openVideoCallModal();
                }
            }
        }
    });

    uploadBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', async e => {
        const files = e.target.files;
        if (files.length === 0) return;

        showToast(`æ­£åœ¨å¤„ç† ${files.length} ä¸ªæ–‡ä»¶...`, 'info');
        const context = runtimeState.backgroundLibraryContext;
        let addedCount = 0;

        for (const file of files) {
            // åªå¤„ç†å›¾ç‰‡æ–‡ä»¶
            if (file.type.startsWith('image/')) {
                try {
                    const compressedFile = await compressImageBeforeSaving(file);
                    // ã€æ ¸å¿ƒä¿®å¤ã€‘ä½¿ç”¨ä¸€ä¸ªä¸ä¼šå†²çªçš„æ–°å˜é‡å newBgId
                    const newBgId = newId(context.type === 'chat' ? 'wp' : 'video_bg');
                    await addMediaToDB(newBgId, compressedFile);

                    if (context.type === 'chat') {
                        // èŠå¤©èƒŒæ™¯è¢«è§†ä¸ºå…¨å±€å£çº¸ï¼Œæ·»åŠ åˆ°ä¸»å£çº¸åº“
                        appState.beautify.wallpapers.push({ id: newBgId });
                    } else { // è§†é¢‘èƒŒæ™¯
                        // ç¡®ä¿ç›®æ ‡åº“æ•°ç»„å­˜åœ¨
                        if (!context.settingsObject[context.libraryKey]) {
                            context.settingsObject[context.libraryKey] = [];
                        }
                        // å°†æ–°IDæ·»åŠ åˆ°æ­£ç¡®çš„åº“ä¸­ (ä¾‹å¦‚: userSettings.videoBackgroundLibrary)
                        context.settingsObject[context.libraryKey].push(newBgId);
                    }
                    addedCount++;
                } catch (err) {
                    console.error("å¤„ç†èƒŒæ™¯æ–‡ä»¶å¤±è´¥:", file.name, err);
                }
            }
        }
        
        if (addedCount > 0) {
            // æ³¨æ„ï¼šæ­¤å¤„ä¸è°ƒç”¨å…¨å±€ä¿å­˜ï¼Œå› ä¸ºæˆ‘ä»¬æ­£åœ¨ä¿®æ”¹ä¸€ä¸ªä¸´æ—¶è®¾ç½®å¯¹è±¡ã€‚
            // æœ€ç»ˆçš„ä¿å­˜åœ¨ç”¨æˆ·ç¦»å¼€è®¾ç½®ç•Œé¢æ—¶ç»Ÿä¸€è¿›è¡Œã€‚
            renderBackgroundLibraryGrid();
            showToast(`æˆåŠŸæ·»åŠ  ${addedCount} ä¸ªèƒŒæ™¯`);
        }
        
        fileInput.value = ''; // å®Œæˆåæ¸…ç©ºæ–‡ä»¶é€‰æ‹©å™¨
    });

    addUrlBtn.addEventListener('click', async () => {
    const url = prompt('è¯·è¾“å…¥å›¾ç‰‡URL:');
    if (url && url.startsWith('http')) {
        const context = runtimeState.backgroundLibraryContext;
        try {
            if (context.type === 'chat') {
                // ç›´æ¥å°†URLä½œä¸ºIDå­˜å…¥å£çº¸åˆ—è¡¨
                appState.beautify.wallpapers.push({ id: url });
            } else { // video
                // ç›´æ¥å°†URLå­˜å…¥è§†é¢‘èƒŒæ™¯åº“
                context.settingsObject[context.libraryKey].push(url);
            }
            debouncedSaveState();
            renderBackgroundLibraryGrid();
            showToast('èƒŒæ™¯é“¾æ¥å·²æ·»åŠ ');
        } catch (error) {
            showToast('æ·»åŠ å¤±è´¥', 'error');
        }
    } else if (url) {
        showToast('æ— æ•ˆçš„URL', 'error');
    }
});

    closeBtn.addEventListener('click', () => modal.classList.remove('visible'));
    modeToggleBtn.addEventListener('click', () => {
        modal.classList.toggle('selection-mode');
        const isSelectionMode = modal.classList.contains('selection-mode');
        deleteBtn.style.display = isSelectionMode ? 'block' : 'none';
        closeBtn.style.display = isSelectionMode ? 'none' : 'block';
        modeToggleBtn.textContent = isSelectionMode ? 'å–æ¶ˆ' : 'åˆ é™¤';
        if (!isSelectionMode) {
            runtimeState.backgroundLibrarySelection = [];
            grid.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            renderBackgroundLibraryGrid();
        }
    });

    deleteBtn.addEventListener('click', async () => {
        const selection = runtimeState.backgroundLibrarySelection;
        if (selection.length === 0) return;
        if (!confirm(`ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™ ${selection.length} å¼ èƒŒæ™¯å›¾ç‰‡å—ï¼Ÿ`)) return;

        const context = runtimeState.backgroundLibraryContext;
        
        for (const idToDelete of selection) {
            await deleteMediaFromDB(idToDelete);

            if (context.type === 'chat') {
                appState.beautify.wallpapers = appState.beautify.wallpapers.filter(wp => wp.id !== idToDelete);
                // Reset any chat that uses this wallpaper
                appState.chat.contacts.forEach(contact => {
                    if (contact.isGroup && contact.groupSettings.chatBackgroundId === idToDelete) {
                        contact.groupSettings.chatBackgroundId = 'default';
                    } else if (!contact.isGroup && contact.charSettings.chatBackgroundId === idToDelete) {
                        contact.charSettings.chatBackgroundId = 'default';
                    }
                });
                 if (appState.beautify.currentChatBgId === idToDelete) {
                    appState.beautify.currentChatBgId = 'default';
                }
            } else { // video
                context.settingsObject[context.libraryKey] = context.settingsObject[context.libraryKey].filter(id => id !== idToDelete);
                if (context.settingsObject[context.activeKey] === idToDelete) {
                    context.settingsObject[context.activeKey] = '';
                }
            }
        }
        
        runtimeState.backgroundLibrarySelection = [];
        debouncedSaveState();
        modeToggleBtn.click(); // Exit selection mode
        showToast('èƒŒæ™¯å·²åˆ é™¤');
    });
}
function setupWorldBookSelector(selectorContainer, listContainer, linkedIdsArray) {
        const btn = selectorContainer.querySelector('.wb-group-selector-btn');
        const dropdown = selectorContainer.querySelector('.wb-group-dropdown');
        if (!btn || !dropdown) return;

        const updateButtonText = () => {
            const selectedGroups = [...new Set(appState.data.worldBooks.filter(wb => linkedIdsArray.includes(wb.id)).map(wb => wb.group || 'æœªåˆ†ç»„'))];
            if (selectedGroups.length === 0) {
                btn.textContent = 'é€‰æ‹©åˆ†ç»„';
            } else if (selectedGroups.length === 1) {
                btn.textContent = selectedGroups[0];
            } else {
                btn.textContent = `${selectedGroups.length}ä¸ªåˆ†ç»„å·²é€‰`;
            }
        };

        const populateDropdown = () => {
            const groups = [...new Set(appState.data.worldBooks.map(wb => wb.group || 'æœªåˆ†ç»„'))];
            const selectedGroups = [...new Set(appState.data.worldBooks.filter(wb => linkedIdsArray.includes(wb.id)).map(wb => wb.group || 'æœªåˆ†ç»„'))];
            dropdown.innerHTML = groups.map(group => `
                <label class="checkbox-label">
                    <input type="checkbox" value="${group}" ${selectedGroups.includes(group) ? 'checked' : ''}>
                    <span>${group}</span>
                </label>
            `).join('');
        };
        
        // --- æ ¸å¿ƒä¿®å¤ï¼šå…ˆç§»é™¤æ—§çš„ç›‘å¬å™¨ ---
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        
        // --- æ ¸å¿ƒä¿®å¤ï¼šä¸ºæ–°çš„æŒ‰é’®ç»‘å®šç›‘å¬å™¨ ---
        newBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            // Close other dropdowns
            document.querySelectorAll('.wb-group-dropdown.visible').forEach(d => {
                if (d !== dropdown) d.classList.remove('visible');
            });
            populateDropdown();
            dropdown.classList.toggle('visible');
        });

        // The change listener on the dropdown can be reused as it's on a static parent
        const dropdownChangeHandler = (e) => {
             if (e.target.type === 'checkbox') {
                const groupName = e.target.value;
                const isChecked = e.target.checked;
                const idsInGroup = appState.data.worldBooks.filter(wb => (wb.group || 'æœªåˆ†ç»„') === groupName).map(wb => wb.id);

                if (isChecked) {
                    idsInGroup.forEach(id => {
                        if (!linkedIdsArray.includes(id)) linkedIdsArray.push(id);
                    });
                } else {
                    idsInGroup.forEach(id => {
                        const index = linkedIdsArray.indexOf(id);
                        if (index > -1) linkedIdsArray.splice(index, 1);
                    });
                }
                renderWorldBookList(listContainer, linkedIdsArray);
                updateButtonText();
            }
        };
        // Remove old listener if exists, then add new one
        dropdown.removeEventListener('change', dropdownChangeHandler);
        dropdown.addEventListener('change', dropdownChangeHandler);
        
        renderWorldBookList(listContainer, linkedIdsArray);
        updateButtonText();
    }
function renderWorldBookList(listElement, linkedIdsArray) { listElement.innerHTML = appState.data.worldBooks.map(wb => ` <label class="checkbox-label"> <input type="checkbox" value="${wb.id}" ${linkedIdsArray.includes(wb.id) ? 'checked' : ''}> <span>${wb.name}</span> </label> `).join(''); listElement.addEventListener('change', (e) => { if (e.target.type === 'checkbox') { const id = e.target.value; if (e.target.checked) { if (!linkedIdsArray.includes(id)) linkedIdsArray.push(id); } else { const index = linkedIdsArray.indexOf(id); if (index > -1) linkedIdsArray.splice(index, 1); } const selectorContainer = listElement.closest('.chat-settings-section').querySelector('.wb-group-selector'); if (selectorContainer) { const btn = selectorContainer.querySelector('.wb-group-selector-btn'); const selectedGroups = [...new Set(appState.data.worldBooks.filter(wb => linkedIdsArray.includes(wb.id)).map(wb => wb.group || 'æœªåˆ†ç»„'))]; if (selectedGroups.length === 0) { btn.textContent = 'é€‰æ‹©åˆ†ç»„'; } else if (selectedGroups.length === 1) { btn.textContent = selectedGroups[0]; } else { btn.textContent = `${selectedGroups.length}ä¸ªåˆ†ç»„å·²é€‰`; } } } }); }
    function openMomentCommentEditor(postId, commentId, replyId = null, messageId = null) {
        let commentToEdit = null;
        
        if (messageId) { // Editing a message reply
            const message = appState.chat.moments.messages.find(m => m.id === messageId);
            if (!message || !message.replies) return;
            commentToEdit = message.replies.find(r => r.id === replyId);
            runtimeState.editingComment = { source: 'message', messageId, replyId };
        } else { // Editing a post comment/reply
            const post = appState.chat.moments.posts.find(p => p.id === postId);
            if (!post) return;
            commentToEdit = replyId 
                ? post.comments.find(c => c.replies && c.replies.some(r => r.id === replyId))?.replies.find(r => r.id === replyId)
                : post.comments.find(c => c.id === commentId);
            runtimeState.editingComment = { source: 'moments', postId, commentId, replyId };
        }

        if (!commentToEdit) return;
        
        getEl('edit-moment-comment-content').value = commentToEdit.text;
        renderMomentAuthorSelector('moment-comment-author-selector', commentToEdit.authorId);
        
        editMomentCommentModal.classList.add('visible');
    }

    function renderMomentAuthorSelector(containerId, selectedId) {
        const container = getEl(containerId);
    container.classList.add('author-selector');
        const availableAuthors = [
            { id: 'user', name: appState.chat.moments.profile.name, avatarId: appState.chat.moments.profile.avatarId },
            ...appState.chat.contacts.filter(c => !c.isGroup).map(c => ({ id: c.id, name: c.charSettings.name, avatarId: c.charSettings.avatarId }))
        ];

        container.innerHTML = availableAuthors.map(author => `
            <div class="author-selector-item ${author.id === selectedId ? 'selected' : ''}" data-id="${author.id}">
                <div class="avatar" data-avatar-id="${author.avatarId}"></div>
                <span class="name">${author.name}</span>
            </div>
        `).join('');
        container.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    }
// ===================================================================
    // --- æ–°å¢ï¼šåŠ¨æ€ - ç…§ç‰‡ã€ç›¸å†Œã€ç•™è¨€æ¿åŠŸèƒ½ ---
    // ===================================================================
    
    function openUploadPhotoModal() {
    runtimeState.moments.postContext = {
        images: [], // for local file uploads
        textImageDescs: [], // for text-to-image
        albumId: null,
        visibility: 'public',
        visibleTo: []
    };

    getEl('upload-photo-name').value = '';
    getEl('upload-photo-desc').value = '';
    getEl('upload-photo-text-image-desc').value = '';
    getEl('upload-photo-text-image-input-group').classList.add('hidden-by-logic');
    getEl('upload-photo-image-preview-grid').innerHTML = '';
    
    const albumSelect = getEl('upload-photo-album-select');
    albumSelect.innerHTML = '';
    if (appState.chat.moments.albums.length === 0) {
        const defaultAlbum = { id: 'default', name: 'é»˜è®¤ç›¸å†Œ', createTime: Date.now(), photoIds: [] };
        appState.chat.moments.albums.push(defaultAlbum);
        debouncedSaveState();
    }
    appState.chat.moments.albums.forEach(album => {
        const option = document.createElement('option');
        option.value = album.id;
        option.textContent = album.name;
        albumSelect.appendChild(option);
    });

    queryAll('input[name="photo-visibility"]').forEach(r => r.checked = r.value === 'public');
    getEl('upload-photo-friend-selector-container').classList.add('hidden-by-logic');
    getEl('upload-photo-comment-private-checkbox').checked = false; // Reset the new checkbox
getEl('upload-photo-visibility-public-checkbox').checked = false; // Reset the new checkbox
    uploadPhotoModal.classList.add('visible');
}
    
    function openManageAlbumsModal() {
        renderManageAlbums();
        manageAlbumsModal.classList.add('visible');
    }
    
    function renderManageAlbums() {
        const grid = getEl('manage-albums-grid');
        grid.innerHTML = '';
        if (appState.chat.moments.albums.length === 0) {
             const defaultAlbum = { id: 'default', name: 'é»˜è®¤ç›¸å†Œ', createTime: Date.now(), photoIds: [] };
             appState.chat.moments.albums.push(defaultAlbum);
             debouncedSaveState();
        }

        appState.chat.moments.albums.forEach(album => {
            const photoCount = (album.photoIds || []).length;
            const coverPhotoId = (album.photoIds && album.photoIds.length > 0) 
                ? appState.chat.moments.photos.find(p => p.id === album.photoIds[0])?.imageId
                : null;
            
            const dateStr = album.createTime ? new Date(album.createTime).toLocaleDateString() : '---';

            const item = document.createElement('div');
            item.className = 'album-item';
            item.dataset.id = album.id;
            item.innerHTML = `
                <div class="album-item-cover" data-image-id="${coverPhotoId || ''}"></div>
                <div class="album-item-overlay">
                    <div class="album-item-name">${escapeHTML(album.name)} (${photoCount})</div>
                    <div class="album-item-footer">
                        <span class="album-item-info">${dateStr}</span>
                        ${album.id !== 'default' ? `
                        <button class="icon-btn edit-album-btn">âœï¸</button>
                        ` : ''}
                    </div>
                </div>
            `;
            grid.appendChild(item);
            if(coverPhotoId) {
                setElementImage(item.querySelector('.album-item-cover'), coverPhotoId, 'backgroundImage');
            }
        });
    }

    function openAlbumView(container, profileId, albumId) {
    let photoStorage;
    if (profileId === 'user') {
        photoStorage = appState.chat.moments.photos;
    } else {
        const contact = appState.chat.contacts.find(c => c.id === profileId);
        photoStorage = (contact?.charSettings?.moments?.photos) || [];
    }

    // For now, we only show the 'default' view which is all photos
    if (albumId === 'default') {
         container.innerHTML = `<div class="photo-grid">${photoStorage.map(p => `<div class="photo-grid-item" data-id="${p.id}" data-image-id="${p.imageId}"></div>`).join('')}</div>`;
         container.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));
    } else {
         container.innerHTML = `<p style="text-align:center; color:#888; margin-top: 50px;">æŸ¥çœ‹æŒ‡å®šç›¸å†ŒåŠŸèƒ½å¾…å¼€å‘</p>`;
    }
}
    
    function renderMessages(container, profileId) {
            const messages = appState.chat.moments.messages
                .filter(msg => {
                    if (msg.recipientId !== profileId) return false;
                    const isUserPage = profileId === 'user';
                    // åœ¨ç”¨æˆ·è‡ªå·±çš„ç•™è¨€æ¿ï¼Œå¯ä»¥çœ‹åˆ°æ‰€æœ‰ç»™è‡ªå·±çš„ç•™è¨€
                    if (isUserPage) return true;
                    // åœ¨åˆ«äººçš„ç•™è¨€æ¿ï¼Œåªèƒ½çœ‹åˆ°å…¬å¼€çš„æˆ–è€…è‡ªå·±å¯è§çš„
                    return msg.visibility === 'public' || (msg.visibleTo && msg.visibleTo.includes('user'));
                })
                .sort((a, b) => b.timestamp - a.timestamp);

            if (messages.length === 0) {
                container.innerHTML = `<div class="message-board-feed"><p style="text-align:center; color:#888; margin-top: 50px;">è¿˜æ²¡æœ‰äººç•™è¨€å“¦</p></div>`;
                return;
            }

            container.innerHTML = `<div class="message-board-feed">
                ${messages.map(msg => renderSingleMessage(msg)).join('')}
            </div>`;
            
            container.querySelectorAll('.message-board-avatar[data-avatar-id], .comment-avatar[data-avatar-id]').forEach(el => {
                setElementImage(el, el.dataset.avatarId);
            });
        }
        function renderSingleMessage(msg) {
            const recipient = findUserById(msg.recipientId);
            const sender = findUserById(msg.senderId);
            const repliesHTML = (msg.replies || []).map(reply => renderSingleMessageReply(reply, msg.replies || [], msg.id)).join('');

                return `
        <div class="message-board-item" data-message-id="${msg.id}">
            <div class="message-board-item-main swipe-content">
                <div class="message-board-header">
                    <div class="message-board-avatar" data-avatar-id="${recipient.avatarId}"></div>
                    <p class="message-board-recipient">To: ${escapeHTML(msg.recipientName)}</p>
                </div>
                <p class="message-board-content">${escapeHTML(msg.content).replace(/\n/g, '<br>')}</p>
                <div class="message-board-footer">
                    <div class="message-board-signature">
                        <span class="message-board-sender">From: ${escapeHTML(msg.senderName)}</span>
                        <div class="message-board-avatar" data-avatar-id="${sender.avatarId}"></div>
                    </div>
                    <div class="message-board-timestamp">${new Date(msg.timestamp).toLocaleString()}</div>
                </div>
                <div class="message-board-replies">${repliesHTML}</div>
                <div class="reply-input-container" style="margin-top:10px;">
                    <input type="text" placeholder="å›å¤ ${escapeHTML(msg.senderName)}...">
                    <button class="settings-button secondary send-comment-btn" data-icon-id="comment-send" style="padding: 5px 10px; min-width: 44px; display: flex; align-items: center; justify-content: center;"><i class="fa-solid fa-paper-plane"></i></button>
                </div>
            </div>
            <div class="message-board-item-actions swipe-actions">
                <div class="edit-action">ç¼–è¾‘</div>
                <div class="delete-action">åˆ é™¤</div>
            </div>
        </div>`;
        }

            function renderSingleMessageReply(reply, allReplies, messageId) {
                const author = findUserById(reply.authorId);
        
        let replyText = escapeHTML(reply.text);
        const mentionMatch = replyText.match(/^@(\S+)\s(.*)/s);
        let targetHTML = '';
        if(mentionMatch) {
            // This logic is simplified as we cannot easily determine the target's ID from text alone.
            // For VIP display, we rely on the replyTo field.
            targetHTML = `å›å¤ <span class="reply-target">@${mentionMatch[1]}</span>: `;
            replyText = mentionMatch[2];
        } else if (reply.replyTo) {
             const targetReply = allReplies.find(r => r.id === reply.replyTo);
            if (targetReply) {
                const targetAuthorNameHTML = getWeiboDisplayNameWithVIP(targetReply.authorId);
                targetHTML = `å›å¤ <span class="reply-target">@${targetAuthorNameHTML}</span>: `;
            }
        }

        const canModify = true; 
        return `
            <div class="reply-item" data-reply-id="${reply.id}">
                <div class="reply-avatar" data-avatar-id="${author.avatarId}"></div>
                <div class="reply-content">
                    <div class="comment-header">
                         <div>
                            <span class="reply-author">${author.name}</span>
                            <span class="reply-timestamp">${new Date(reply.timestamp).toLocaleString()}</span>
                         </div>
                         <div class="comment-actions-inline" style="display: none;">
                            ${canModify ? `
                            <button class="icon-btn" data-action="edit-comment" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
                            <button class="icon-btn" data-action="delete-comment" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
                            ` : ''}
                         </div>
                    </div>
                    <p class="comment-text">${targetHTML}${replyText}</p>
                    <div class="reply-input-container">
                        <input type="text" placeholder="å›å¤ ${author.name}...">
                        <button class="settings-button secondary send-comment-btn" data-icon-id="comment-send" style="padding: 5px 10px; min-width: 44px; display: flex; align-items: center; justify-content: center;"><i class="fa-solid fa-paper-plane"></i></button>
                    </div>
                </div>
            </div>`;
    }
    
    function openLeaveMessageModal(messageId = null) {
            const isEditing = messageId !== null;
            const modal = getEl('leave-message-modal');
            const authorSelectorContainer = getEl('leave-message-author-selector-container');
            
            modal.dataset.editingId = isEditing ? messageId : '';

            if (isEditing) {
                const message = appState.chat.moments.messages.find(m => m.id === messageId);
                if (!message) return showToast('æ‰¾ä¸åˆ°è¦ç¼–è¾‘çš„ç•™è¨€', 'error');

                modal.querySelector('.modal-title').textContent = 'ç¼–è¾‘ç•™è¨€';
                getEl('message-recipient').value = message.recipientName;
                getEl('message-content').value = message.content;
                getEl('message-sender').value = message.senderName;
                
                queryAll('input[name="message-visibility"]').forEach(r => r.checked = r.value === (message.visibility || 'public'));
                const friendSelector = getEl('leave-message-friend-selector-container');
                runtimeState.moments.postContext.visibleTo = message.visibleTo || [];
                if (message.visibility === 'specific') {
                    renderFriendSelector('leave-message-friend-selector', 'message');
                    friendSelector.classList.remove('hidden-by-logic');
                } else {
                    friendSelector.classList.add('hidden-by-logic');
                }

                authorSelectorContainer.classList.remove('hidden-by-logic');
                renderMomentAuthorSelector('leave-message-author-selector', message.senderId);

            } else {
                modal.querySelector('.modal-title').textContent = 'å†™ç•™è¨€';
                const profileId = runtimeState.moments.currentProfileId;
                const profile = findUserById(profileId);
                getEl('message-recipient').value = profile.name;
                getEl('message-content').value = '';
                getEl('message-sender').value = findUserById('user').name;

                queryAll('input[name="message-visibility"]').forEach(r => r.checked = r.value === 'public');
                getEl('leave-message-friend-selector-container').classList.add('hidden-by-logic');
                runtimeState.moments.postContext.visibleTo = [];
                authorSelectorContainer.classList.add('hidden-by-logic');
            }
            
            leaveMessageModal.classList.add('visible');
        }
    function openPhotoViewer(photos, startIndex = 0) {
        if (!photos || photos.length === 0) return;
        runtimeState.moments.viewerContext = {
            items: photos,
            currentIndex: startIndex
        };
        renderPhotoViewerContent(startIndex);
        viewPhotoModal.classList.add('visible');
    }
    function renderPhotoViewerContent(index) {
            const { items } = runtimeState.moments.viewerContext;
            const photo = items[index];
            if (!photo) return;

            const isTextImage = photo.isTextImage || (photo.textDescription && !photo.imageId);
            
            const imageView = getEl('viewer-image-view');
            const textView = getEl('viewer-text-view');

            if (isTextImage) {
                viewPhotoModal.className = 'modal-overlay visible text-mode';
                imageView.style.display = 'none';
                textView.style.display = 'flex'; // Use flex for proper layout
                getEl('view-photo-text-display').textContent = photo.textDescription || '';
                // --- ADDED: Populate name and description for text view ---
                getEl('view-photo-text-name').textContent = photo.name;
                const descText = photo.description || '';
                const descEl = getEl('view-photo-text-desc');
                descEl.textContent = descText;
                descEl.style.display = descText ? 'block' : 'none';
                // --- END ADDED ---
            } else {
                viewPhotoModal.className = 'modal-overlay visible image-mode';
                textView.style.display = 'none';
                imageView.style.display = 'flex';
                const imgEl = getEl('view-photo-image');
                imgEl.src = '';
                setElementImage(imgEl, photo.imageId, 'src');
                getEl('view-photo-name').textContent = photo.name;
                const descText = photo.description || '';
                const descEl = getEl('view-photo-desc');
                descEl.textContent = descText;
                descEl.style.display = descText ? 'block' : 'none';
                viewPhotoModal.classList.remove('text-hidden');
            }

            const prevBtn = getEl('photo-viewer-prev-btn');
            const nextBtn = getEl('photo-viewer-next-btn');
            prevBtn.style.display = (items.length > 1 && index > 0) ? 'block' : 'none';
            nextBtn.style.display = (items.length > 1 && index < items.length - 1) ? 'block' : 'none';
        }
    function renderSecretsTab() {
    const container = getEl('secret-tab-content');
    let secrets = (appState.diary.secrets || []).sort((a, b) => b.timestamp - a.timestamp);

    const filter = runtimeState.secretFilter ? runtimeState.secretFilter.selected : 'all';
    if (filter !== 'all') {
        secrets = secrets.filter(s => s.charId === filter);
    }

    if (secrets.length === 0) {
        container.innerHTML = `<p style="text-align:center; color:#888; margin-top: 50px; grid-column: 1 / -1;">è¿™é‡Œç©ºç©ºå¦‚ä¹Ÿï¼Œè¿˜æ²¡æœ‰ç§˜å¯†è¢«è®°å½•ä¸‹æ¥...</p>`;
        return;
    }

    container.innerHTML = secrets.map(secret => {
        const char = findUserById(secret.charId);
        const date = new Date(secret.timestamp).toLocaleDateString();
        const randomRotation = Math.random() * 6 - 3; // -3 to 3 degrees
        return `
            <div class="secret-item-card" data-secret-id="${secret.id}" style="--random-rotate: ${randomRotation}">
                <div class="title">${escapeHTML(secret.title)}</div>
                <div class="meta">
                    <span class="name">${escapeHTML(char.name)}</span>
                    <span class="date">${date}</span>
                </div>
                <div class="secret-item-actions">
                    <button class="icon-btn edit-secret-btn" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
                    <button class="icon-btn delete-secret-btn" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
                </div>
            </div>
        `;
    }).join('');
}

function openSecretViewer(secretId) {
    const modal = getEl('secret-viewer-modal');
    const secret = appState.diary.secrets.find(s => s.id === secretId);
    if (!secret) return;

    const char = findUserById(secret.charId);

    getEl('secret-viewer-content').textContent = secret.content;
    getEl('secret-viewer-name').textContent = char.name;
    getEl('secret-viewer-timestamp').textContent = new Date(secret.timestamp).toLocaleString();
    
    modal.classList.add('visible');
}

function renderSecretFilterDropdown() {
    const charIds = [...new Set(appState.diary.secrets.map(s => s.charId))];
    const charOptions = charIds.map(id => {
        const char = findUserById(id);
        return { value: id, text: char.name };
    });

    const filterOptions = [ { value: 'all', text: 'å…¨éƒ¨' }, ...charOptions ];
    const selected = runtimeState.secretFilter ? runtimeState.secretFilter.selected : 'all';

    secretFilterDropdown.innerHTML = filterOptions.map(opt => `
        <label class="radio-label" style="width: 100%; border: none; border-radius: 4px; padding: 8px 5px;">
            <input type="radio" name="secret-filter" value="${opt.value}" ${selected === opt.value ? 'checked' : ''}>
            <span>${escapeHTML(opt.text)}</span>
        </label>
    `).join('');
}

function toggleSecretFilterDropdown() {
    if (secretFilterDropdown.classList.contains('visible')) {
        secretFilterDropdown.classList.remove('visible');
    } else {
        renderSecretFilterDropdown();
        secretFilterDropdown.classList.add('visible');
    }
}

diaryFilterBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleSecretFilterDropdown();
});

secretFilterDropdown.addEventListener('change', (e) => {
    if (e.target.name === 'secret-filter') {
        if (!runtimeState.secretFilter) {
            runtimeState.secretFilter = {};
        }
        runtimeState.secretFilter.selected = e.target.value;
        renderSecretsTab();
        toggleSecretFilterDropdown();
    }
});
function openEditSecretModal(secretId) {
        const modal = getEl('edit-secret-modal');
        const secret = appState.diary.secrets.find(s => s.id === secretId);
        if (!secret) return;

        getEl('editing-secret-id').value = secretId;
        getEl('secret-title-input').value = secret.title;
        getEl('secret-content-input').value = secret.content;
        
        modal.classList.add('visible');
    }
function setupMomentsPageListeners() {
        // This function is now only for the comment editor modal, 
        // as the file inputs are handled by the new global listener.
        const authorSelector = getEl('moment-comment-author-selector');
        authorSelector.addEventListener('click', e => {
            const item = e.target.closest('.author-selector-item');
            if(item) {
                authorSelector.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            }
        });

        cancelEditMomentCommentBtn.addEventListener('click', () => {
            editMomentCommentModal.classList.remove('visible');
        });

        saveEditMomentCommentBtn.addEventListener('click', () => {
            const { postId, commentId, replyId } = runtimeState.editingComment;
            const post = appState.chat.moments.posts.find(p => p.id === postId);
            if (!post) return;
            
            const commentToEdit = replyId 
                ? post.comments.find(c => c.replies && c.replies.some(r => r.id === replyId))?.replies.find(r => r.id === replyId)
                : post.comments.find(c => c.id === commentId);
                
            if (!commentToEdit) return;

            const newContent = getEl('edit-moment-comment-content').value;
            const selectedAuthorEl = getEl('moment-comment-author-selector').querySelector('.selected');
            const newAuthorId = selectedAuthorEl ? selectedAuthorEl.dataset.id : commentToEdit.authorId;

            commentToEdit.text = newContent;
            commentToEdit.authorId = newAuthorId;
            
            debouncedSaveState();
            renderMomentsFeed(runtimeState.moments.currentProfileId);
            editMomentCommentModal.classList.remove('visible');
        });
    }
            function handleMailTabChange(tabId) {
            const titleEl = mailAppScreen.querySelector('.title');
            const loveLetterFab = getEl('mail-fab-container');
            const postcardFab = getEl('postcard-fab-container');
            const settingsBtn = getEl('mail-settings-btn');
            const filterBtn = getEl('mail-filter-btn'); // æ–°å¢ï¼šè·å–ç­›é€‰æŒ‰é’®
                    const postcardFilter = getEl('postcard-filter-dropdown');
            const tabMap = { 'love-letter': 'æƒ…ä¹¦', 'postcard': 'æ˜ä¿¡ç‰‡', 'tree-hole': 'æ ‘æ´', 'drift-bottle': 'æ¼‚æµç“¶' };

            mailAppScreen.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
            mailAppScreen.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            const activeTabLink = mailAppScreen.querySelector(`.tab-link[data-tab="${tabId}"]`);
            const activeTabContent = getEl(`${tabId}-tab-content`);
            
            if (activeTabLink) activeTabLink.classList.add('active');
            if (activeTabContent) activeTabContent.classList.add('active');

            loveLetterFab.style.display = (tabId === 'love-letter') ? 'block' : 'none';
            postcardFab.style.display = (tabId === 'postcard') ? 'block' : 'none';
            settingsBtn.style.display = (tabId === 'love-letter') ? 'block' : 'none';
            filterBtn.style.display = ['love-letter', 'postcard'].includes(tabId) ? 'block' : 'none';

            if (tabId === 'love-letter') {
                renderLoveLetterTab();
                    } else if (tabId === 'postcard') {
            renderPostcardWall();
        }
        
        if (tabId !== 'love-letter') {
            mailFilterDropdown.classList.remove('visible');
        }
        if (tabId !== 'postcard') {
            postcardFilter.classList.remove('visible');
        }

            titleEl.textContent = tabMap[tabId] || 'ä¿¡ç®±';
            appState.mailbox.activeTab = tabId;
            debouncedSaveState();
        }
       async function handleAssetsTabChange(tabId) {
        const titleEl = assetsAppScreen.querySelector('.title');
        const tabMap = { 'bank': 'é“¶è¡Œ', 'stock': 'è‚¡å¸‚', 'lottery': 'å½©ç¥¨', 'monopoly': 'å¤§å¯Œç¿' };
        titleEl.textContent = tabMap[tabId] || 'èµ„äº§';
    if (tabId === 'lottery') {
        runDailyLotteryDraw().then(renderLotteryUI);
    }
        if (tabId === 'bank') {
        } else if (tabId === 'stock') {
    
renderStockMarket();
            renderBankUI();
        }
    }

    function calculateInterest() {
        const today = new Date().toISOString().split('T')[0];
        
        const calculateForEntity = (entity) => {
            if (!entity.lastInterestCalc || entity.lastInterestCalc === today) {
                entity.lastInterestCalc = today;
                return; // ä»Šå¤©å·²ç»è®¡ç®—è¿‡æˆ–æ— éœ€è®¡ç®—
            }

            let lastDate = new Date(entity.lastInterestCalc);
            const currentDate = new Date(today);
            let daysPassed = 0;
            
            // è®¡ç®—ç»è¿‡äº†å¤šå°‘ä¸ªä¸åŒçš„æ—¥æœŸ
            while(lastDate < currentDate) {
                daysPassed++;
                lastDate.setDate(lastDate.getDate() + 1);
            }

            if (daysPassed > 0) {
                for (let i = 0; i < daysPassed; i++) {
                                    // å­˜æ¬¾åˆ©æ¯
                if (entity.bankBalance > 0) {
                    const dailyInterest = Math.ceil(entity.bankBalance * 0.001); // Rate: 0.1%
                    entity.bankBalance += dailyInterest;
                }
                    // è´·æ¬¾åˆ©æ¯
                                    if (entity.loan > 0) {
                    const dailyLoanInterest = Math.ceil(entity.loan * 0.005); // Rate: 0.5%
                    entity.loan += dailyLoanInterest;
                    }
                }
            }
            entity.lastInterestCalc = today;
        };

        // ä¸ºç”¨æˆ·å’Œæ‰€æœ‰è§’è‰²è®¡ç®—
        calculateForEntity(appState.chat.userProfile);
        appState.chat.contacts.forEach(c => {
            if (!c.isGroup && c.charSettings) {
                calculateForEntity(c.charSettings);
            }
        });

        debouncedSaveState();
    }

    function renderBankUI() {
        calculateInterest(); // æ¯æ¬¡æ¸²æŸ“å‰éƒ½è®¡ç®—åˆ©æ¯
        const user = appState.chat.userProfile;
        getEl('bank-cash-balance').textContent = `Â¥ ${user.cashBalance.toFixed(2)}`;
        getEl('bank-deposit-balance').textContent = `Â¥ ${user.bankBalance.toFixed(2)}`;
        getEl('bank-loan-balance').textContent = `Â¥ ${user.loan.toFixed(2)}`;
    }

    function setupBankListeners() {
        getEl('bank-deposit-btn').addEventListener('click', () => {
            const amount = parseFloat(getEl('bank-deposit-input').value);
            const user = appState.chat.userProfile;
            if (isNaN(amount) || amount <= 0) return showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„å­˜æ¬¾é‡‘é¢', 'error');
            if (amount > user.cashBalance) return showToast('ç°é‡‘ä½™é¢ä¸è¶³', 'error');
            
            user.cashBalance -= amount;
            user.bankBalance += amount;
            showToast(`æˆåŠŸå­˜å…¥ Â¥${amount.toFixed(2)}`, 'info');
            getEl('bank-deposit-input').value = '';
            renderBankUI();
            debouncedSaveState();
        });

        getEl('bank-withdraw-btn').addEventListener('click', () => {
            const amount = parseFloat(getEl('bank-withdraw-input').value);
            const user = appState.chat.userProfile;
            if (isNaN(amount) || amount <= 0) return showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„å–æ¬¾é‡‘é¢', 'error');
            if (amount > user.bankBalance) return showToast('é“¶è¡Œå­˜æ¬¾ä¸è¶³', 'error');

            user.bankBalance -= amount;
            user.cashBalance += amount;
            showToast(`æˆåŠŸå–å‡º Â¥${amount.toFixed(2)}`, 'info');
            getEl('bank-withdraw-input').value = '';
            renderBankUI();
            debouncedSaveState();
            });

    getEl('bank-loan-btn').addEventListener('click', () => {
        const amount = parseFloat(getEl('bank-loan-input').value);
        const user = appState.chat.userProfile;
        if (isNaN(amount) || amount <= 0) return showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„è´·æ¬¾é‡‘é¢', 'error');

        if (confirm(`æ‚¨ç¡®å®šè¦ç”³è¯·ä¸€ç¬” Â¥${amount.toFixed(2)} çš„è´·æ¬¾å—ï¼Ÿ`)) {
            user.loan += amount;
            user.cashBalance += amount;
            showToast(`æˆåŠŸè´·æ¬¾ Â¥${amount.toFixed(2)}ï¼Œå·²å­˜å…¥ç°é‡‘ä½™é¢`, 'info');
            getEl('bank-loan-input').value = '';
            renderBankUI();
            debouncedSaveState();
        }
    });
    
    // --- å½©ç¥¨åŠŸèƒ½ç›‘å¬ (å·²ç§»è‡³æ­£ç¡®ä½ç½®) ---
    getEl('lottery-number-grid').addEventListener('click', e => {
        if (e.target.classList.contains('lottery-number')) {
            handleLotteryNumberClick(e.target);
        }
    });

    getEl('lottery-buy-btn').addEventListener('click', () => {
        const todayStr = new Date().toISOString().split('T')[0];
    if (appState.assets.lottery.tickets.some(t => t.purchaseDate === todayStr)) {
        return showToast('ä»Šå¤©å·²ç»è´­ä¹°è¿‡å½©ç¥¨äº†', 'info');
    }

    const selection = runtimeState.lotterySelection;
        if (selection.length !== 5) return showToast('è¯·é€‰æ‹©5ä¸ªå·ç ', 'error');
        
        const user = appState.chat.userProfile;
        if (user.cashBalance < 1000) return showToast('ç°é‡‘ä½™é¢ä¸è¶³', 'error');

        if (confirm(`ç¡®å®šèŠ±è´¹ Â¥1000.00 è´­ä¹°å½©ç¥¨ [${selection.join(', ')}] å—ï¼Ÿ`)) {
                user.cashBalance -= 1000;
            
            const todayStr = new Date().toISOString().split('T')[0];
            appState.assets.lottery.tickets.push({
                numbers: [...selection].sort((a, b) => a - b),
                purchaseDate: todayStr
            });

            showToast('è´­ä¹°æˆåŠŸï¼', 'info');
       showToast('è´­ä¹°æˆåŠŸï¼ä»Šæ—¥å·ç å·²é”å®š', 'info');
        runtimeState.lotterySelection = []; // Clear the temporary selection
            renderLotteryUI();
            debouncedSaveState();
        }
    });
        
    }
    getEl('bank-repay-btn').addEventListener('click', () => {
        const amountInput = getEl('bank-repay-input');
        let amount = parseFloat(amountInput.value);
        const user = appState.chat.userProfile;

        if (isNaN(amount) || amount <= 0) return showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„è¿˜æ¬¾é‡‘é¢', 'error');
        if (user.loan <= 0) return showToast('æ‚¨å½“å‰æ²¡æœ‰éœ€è¦å¿è¿˜çš„è´·æ¬¾', 'info');
        if (amount > user.cashBalance) return showToast('ç°é‡‘ä½™é¢ä¸è¶³ä»¥å¿è¿˜è¯¥é‡‘é¢', 'error');
        
        let actualRepayment = amount;
        if (amount > user.loan) {
            actualRepayment = user.loan;
            showToast(`è¿˜æ¬¾é‡‘é¢è¶…è¿‡è´·æ¬¾æ€»é¢ï¼Œå·²è‡ªåŠ¨è°ƒæ•´ä¸ºå…¨é¢è¿˜æ¬¾ Â¥${actualRepayment.toFixed(2)}`, 'info');
        }

        user.cashBalance -= actualRepayment;
        user.loan -= actualRepayment;

        if (user.loan < 0) user.loan = 0; // Ensure loan doesn't go negative
        
        showToast(`æˆåŠŸå¿è¿˜è´·æ¬¾ Â¥${actualRepayment.toFixed(2)}`, 'info');
        amountInput.value = '';
        renderBankUI();
        debouncedSaveState();
    });
    
// ===================================================================
// --- èµ„äº§ APP - å½©ç¥¨é€»è¾‘ ---
// ===================================================================
    async function runDailyLotteryDraw() {
        if (!appState.assets) appState.assets = getInitialState().assets;
        const lotteryState = appState.assets.lottery;
        const now = new Date();
        const hour = now.getHours();

        // The draw for a given day happens at 8 AM the NEXT day.
        // Determine the last day for which the draw should have been completed.
        let lastDayToProcess = new Date(now);
        lastDayToProcess.setDate(now.getDate() - (hour < 8 ? 2 : 1));

        let lastCheckedDate = lotteryState.lastCheckedDate ? new Date(lotteryState.lastCheckedDate) : new Date('2000-01-01');
        let processingDate = new Date(lastCheckedDate);
        processingDate.setDate(processingDate.getDate() + 1);

        while (processingDate <= lastDayToProcess) {
            const processingDateStr = processingDate.toISOString().split('T')[0];
            
            // Generate winning numbers if they don't exist
            if (!lotteryState.dailyDraws[processingDateStr]) {
                const winningNumbers = new Set();
                while (winningNumbers.size < 5) {
                    winningNumbers.add(Math.floor(Math.random() * 50) + 1);
                }
                lotteryState.dailyDraws[processingDateStr] = Array.from(winningNumbers).sort((a, b) => a - b);
            }

            // Settle tickets
            const winningNumbers = lotteryState.dailyDraws[processingDateStr];
            const ticketsToCheck = lotteryState.tickets.filter(t => t.purchaseDate === processingDateStr);
            let totalWinnings = 0;
            let highestTier = 6;

            ticketsToCheck.forEach(ticket => {
                const matches = ticket.numbers.filter(n => winningNumbers.includes(n)).length;
                let prize = 0, prizeType = 'cash', tier = 6;
                switch (matches) {
                    case 5: prize = 5000000; prizeType = 'deposit'; tier = 1; break;
                    case 4: prize = 1000000; prizeType = 'deposit'; tier = 2; break;
                    case 3: prize = 100000; prizeType = 'deposit'; tier = 3; break;
                    case 2: prize = 10000; prizeType = 'deposit'; tier = 4; break;
                    case 1: prize = 1; prizeType = 'cash'; tier = 5; break;
                }
                if (prize > 0) {
                    if (prizeType === 'deposit') appState.chat.userProfile.bankBalance += prize;
                    else appState.chat.userProfile.cashBalance += prize;
                    totalWinnings += prize;
                    if (tier < highestTier) highestTier = tier;
                }
            });

            if (totalWinnings > 0) {
                const prizeString = `æ­å–œæ‚¨ï¼æ‚¨ ${processingDateStr} è´­ä¹°çš„å½©ç¥¨å…±è®¡ä¸­å¥– Â¥${totalWinnings.toFixed(2)}ï¼`;
                queueNotification(prizeString, 'system', 'system', 'lottery');
            }
            
            lotteryState.lastCheckedDate = processingDateStr;
            processingDate.setDate(processingDate.getDate() + 1);
        }

        // Cleanup old data (older than 2 days)
        const twoDaysAgo = new Date(now);
        twoDaysAgo.setDate(now.getDate() - 2);
        const twoDaysAgoStr = twoDaysAgo.toISOString().split('T')[0];
        lotteryState.tickets = lotteryState.tickets.filter(t => t.purchaseDate >= twoDaysAgoStr);
        Object.keys(lotteryState.dailyDraws).forEach(date => {
            if (date < twoDaysAgoStr) delete lotteryState.dailyDraws[date];
        });

        debouncedSaveState();
    }

function renderLotteryUI() {
    if (!runtimeState.lotterySelection) {
        runtimeState.lotterySelection = [];
    }
    
    const grid = getEl('lottery-number-grid');
    const selectionDisplay = getEl('lottery-selection-display');
    const buyBtn = getEl('lottery-buy-btn');

    const todayStr = new Date().toISOString().split('T')[0];
    const todaysTicket = appState.assets.lottery.tickets.find(t => t.purchaseDate === todayStr);

    // Determine the numbers to display and highlight
    const displayedNumbers = todaysTicket ? todaysTicket.numbers : runtimeState.lotterySelection;

    // Render number grid
    grid.innerHTML = Array.from({ length: 50 }, (_, i) => {
        const num = i + 1;
        // Highlight if the number is in today's ticket (if it exists), otherwise highlight based on current selection
        const isSelected = todaysTicket ? todaysTicket.numbers.includes(num) : runtimeState.lotterySelection.includes(num);
        return `<div class="lottery-number ${isSelected ? 'selected' : ''}" data-number="${num}">${num}</div>`;
    }).join('');

    // If a ticket was bought today, disable the grid
    grid.style.pointerEvents = todaysTicket ? 'none' : 'auto';
    grid.style.opacity = todaysTicket ? 0.7 : 1;

    // Render selection display
    const selectionHTML = displayedNumbers
        .map(num => `<span>${num}</span>`)
        .concat(Array(5 - displayedNumbers.length).fill('<span>-</span>'))
        .join('');
    selectionDisplay.innerHTML = selectionHTML;

    // Update buy button state
    if (todaysTicket) {
        buyBtn.disabled = true;
        buyBtn.textContent = 'ä»Šæ—¥å·²è´­ä¹°';
    } else {
        buyBtn.disabled = runtimeState.lotterySelection.length !== 5;
        buyBtn.textContent = 'èŠ±è´¹ Â¥1000.00 è´­ä¹°';
    }
    
    // Render results area
    renderLotteryResults();
}

function renderLotteryResults() {
    const resultsArea = getEl('lottery-results-area');
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(today.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split('T')[0];
    
    const winningNumbers = appState.assets.lottery.dailyDraws[yesterdayStr];
    const purchasedTickets = appState.assets.lottery.tickets.filter(t => t.purchaseDate === yesterdayStr);

    let html = `<div class="settings-group"><div class="group-title">æ˜¨æ—¥ (${yesterdayStr}) å¼€å¥–ç»“æœ</div>`;

    if (!winningNumbers) {
        html += `<div class="group-content" style="padding: 15px; text-align: center; color: #888;">æ˜¨æ—¥æœªå¼€å¥–</div>`;
    } else {
        html += `<div id="lottery-selection-display" class="group-content" style="padding: 10px; display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 18px; font-weight: bold;">
                    ${winningNumbers.map(n => `<span style="color: var(--danger-color);">${n}</span>`).join('')}
                </div>`;

        if (purchasedTickets.length > 0) {
            html += `<div class="group-title" style="margin-top: 15px;">æ‚¨æ˜¨æ—¥è´­ä¹°çš„å½©ç¥¨</div>`;
            html += purchasedTickets.map(ticket => {
                const matches = ticket.numbers.filter(n => winningNumbers.includes(n));
                return `<div class="group-content" style="padding: 10px; margin-top: 5px; font-size: 14px; display: flex; justify-content: space-between;">
                            <span>${ticket.numbers.join(', ')}</span>
                            <span style="font-weight: bold; color: ${matches.length > 0 ? 'var(--danger-color)' : '#888'};">å‘½ä¸­ ${matches.length} ä¸ª</span>
                        </div>`;
            }).join('');
        }
    }
    html += `</div>`;
    resultsArea.innerHTML = html;
}

function handleLotteryNumberClick(element) {
    const todayStr = new Date().toISOString().split('T')[0];
    const todaysTicket = appState.assets.lottery.tickets.find(t => t.purchaseDate === todayStr);
    if (todaysTicket) return; // Do nothing if a ticket is already bought for today

    const num = parseInt(element.dataset.number);
    const selection = runtimeState.lotterySelection;
    
    const index = selection.indexOf(num);
    if (index > -1) {
        selection.splice(index, 1);
        element.classList.remove('selected');
    } else {
        if (selection.length < 5) {
            selection.push(num);
            element.classList.add('selected');
        } else {
            showToast('æœ€å¤šåªèƒ½é€‰æ‹©5ä¸ªå·ç ', 'error');
        }
    }
    selection.sort((a, b) => a - b);
    renderLotteryUI(); // Re-render to update selection display and button
}
// ===================================================================
// --- èµ„äº§ APP - è‚¡å¸‚é€»è¾‘ ---
// ===================================================================
        async function initializeStocks() {
        // **æ ¸å¿ƒä¿®å¤ 1: åˆå§‹åŒ–é”**
        if (runtimeState.isStockInitializing) {
            console.log("Stock initialization is already in progress. Skipping.");
            return false; // Indicate that this call did not perform the initialization
        }
        
        if (appState.assets.stocks.market.length > 0 && !appState.assets.stocks.market.some(s => s.name.endsWith('å·¥ä¸š'))) {
            return true; // Already successfully initialized
        }
        
        runtimeState.isStockInitializing = true; // ä¸Šé”

        try {
            const contacts = appState.chat.contacts.filter(c => !c.isGroup);
            if (contacts.length === 0) return true;

            const stockGenerationPrompt = `
                ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„é‡‘èå“ç‰Œé¡¾é—®å’Œåˆ›æ„å‘½åå¤§å¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯ä¸ºä»¥ä¸‹è™šæ‹Ÿè§’è‰²åˆ›å»ºç‹¬ä¸€æ— äºŒã€å……æ»¡è¶£å‘³ä¸”ç¬¦åˆå…¶äººè®¾çš„è‚¡ç¥¨ã€‚
                --- ã€å¼ºåˆ¶è§„åˆ™ã€‘ ---
                1.  **ã€ç‹¬ç‰¹æ€§ã€‘**: æ¯ä¸ªè‚¡ç¥¨åç§°å’Œä»£ç éƒ½å¿…é¡»æ˜¯ã€åŸåˆ›ã€‘çš„ï¼Œä¸¥ç¦ä½¿ç”¨ç°å®ä¸–ç•Œä¸­å­˜åœ¨çš„å…¬å¸åæˆ–è‚¡ç¥¨ä»£ç ã€‚
                2.  **ã€äººè®¾å…³è”ã€‘**: è‚¡ç¥¨åç§°ã€å¿…é¡»ã€‘ä¸å…¶å¯¹åº”è§’è‰²çš„æ ¸å¿ƒäººè®¾ã€æŠ€èƒ½æˆ–ä¸–ç•Œè§‚èƒŒæ™¯ç´§å¯†ç›¸å…³ã€‚
                3.  **ã€è¶£å‘³æ€§ã€‘**: åç§°åº”å¯Œæœ‰æƒ³è±¡åŠ›ï¼Œå¯ä»¥å¹½é»˜ã€è¯—æ„æˆ–å……æ»¡ç§‘æŠ€æ„Ÿï¼Œä½†ä¸èƒ½æ˜¯è§’è‰²åå­—çš„ç®€å•æ‹¼æ¥ã€‚
                4.  **ã€è‚¡ç¥¨ä»£ç ã€‘**: è‚¡ç¥¨ä»£ç ï¼ˆtickerï¼‰å¿…é¡»æ˜¯4ä¸ªå¤§å†™è‹±æ–‡å­—æ¯ï¼Œä¸”å¿…é¡»ä¸è‚¡ç¥¨åç§°æœ‰å·§å¦™çš„å…³è”ã€‚
                5.  **ã€JSONè¾“å‡ºã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªæ ¼å¼æ­£ç¡®çš„JSONå¯¹è±¡ï¼Œé”®æ˜¯è§’è‰²çš„IDï¼Œå€¼æ˜¯åŒ…å«nameå’Œtickerçš„å¯¹è±¡ã€‚å‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚
                --- ã€è§’è‰²åˆ—è¡¨ã€‘ ---
                ${contacts.map(c => `- ID: ${c.id}, å§“å: ${c.charSettings.name}, äººè®¾: ${c.charSettings.persona.substring(0, 100)}...`).join('\n')}
                --- ã€è¾“å‡ºæ ¼å¼ç¤ºä¾‹ã€‘ ---
                \`\`\`json
                {
                  "char_id_1": { "name": "ï¼ˆä¸ºè§’è‰²1è®¾è®¡çš„åˆ›æ„è‚¡ç¥¨åï¼‰", "ticker": "ï¼ˆä¸ºè§’è‰²1è®¾è®¡çš„4å­—æ¯ä»£ç ï¼‰" },
                  "char_id_2": { "name": "ï¼ˆä¸ºè§’è‰²2è®¾è®¡çš„åˆ›æ„è‚¡ç¥¨åï¼‰", "ticker": "ï¼ˆä¸ºè§’è‰²2è®¾è®¡çš„4å­—æ¯ä»£ç ï¼‰" }
                }
                \`\`\`
            `;
            
            const { apiUrl, selectedModel } = appState.settings;
            const apiKey = getNextApiKey();
            if (!apiUrl || !apiKey || !selectedModel) throw new Error("è¯·å…ˆåœ¨ä¸»å±å¹•â€œè®¾ç½®â€ä¸­é…ç½®APIã€å¯†é’¥å¹¶é€‰æ‹©æ¨¡å‹ã€‚");

            const messages = [{ role: 'system', content: stockGenerationPrompt }];
            if (!apiUrl.includes('generativelanguage.googleapis.com') && messages.length === 1 && messages[0].role === 'system') {
                messages[0].role = 'user';
            }
            
            let data;
            let lastError = null;
            const MAX_RETRIES = 3;

            for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
                try {
                    let response;
                    if (apiUrl.includes('generativelanguage.googleapis.com')) {
                        const requestBody = transformToGoogleFormat(messages);
                        const modelName = selectedModel.startsWith('models/') ? selectedModel : `models/${selectedModel}`;
                        response = await fetch(`https://generativelanguage.googleapis.com/v1beta/${modelName}:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
                    } else {
                        response = await fetch(`${apiUrl}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ model: selectedModel, messages: messages, stream: false }) });
                    }

                    if (response.ok) {
                        data = apiUrl.includes('generativelanguage.googleapis.com') ? transformFromGoogleFormat(await response.json()) : await response.json();
                        lastError = null;
                        break;
                    } else {
                        if ([500, 502, 503, 504].includes(response.status)) {
                            lastError = new Error(`API Server Error: ${response.status}`);
                            if (attempt < MAX_RETRIES) { await new Promise(resolve => setTimeout(resolve, attempt * 2000)); continue; }
                        }
                        throw new Error(`API Error: ${response.status} - ${await response.text()}`);
                    }
                } catch (e) {
                    lastError = e;
                    if (attempt < MAX_RETRIES) { await new Promise(resolve => setTimeout(resolve, attempt * 2000)); }
                }
            }

            if (lastError) throw lastError;

            const replyContent = data.choices[0]?.message?.content;
            const jsonMatch = replyContent.match(/```json\s*([\s\S]*?)\s*```/);
            if (!jsonMatch) throw new Error("AI response did not contain a valid JSON block.");
            const stockData = JSON.parse(jsonMatch[1]);

            for (const contact of contacts) {
                const data = stockData[contact.id];
                if (data && data.name && data.ticker) {
                    appState.assets.stocks.market.push({
                        id: `stock_${contact.id}`, charId: contact.id, name: data.name, ticker: data.ticker,
                        price: parseFloat((Math.random() * 200 + 50).toFixed(2)),
                        history: Array(30).fill(0).map(() => parseFloat((Math.random() * 20 + 90).toFixed(2))),
                        change: 0, changePercent: 0, volatility: Math.random() * 0.04 + 0.01
                    });
                }
            }
            showToast('è‚¡å¸‚åˆå§‹åŒ–å®Œæˆï¼', 'info');
            return true;
        } catch (error) {
            console.error("Stock initialization failed:", error);
            showToast(`è‚¡å¸‚åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
            return false;
        } finally {
            runtimeState.isStockInitializing = false; // **æ ¸å¿ƒä¿®å¤ 2: ç¡®ä¿åœ¨å‡½æ•°ç»“æŸæ—¶è§£é”**
        }
    }
    
    function constructStockEventPrompt(stocks, contacts) {
        let prompt = `ä½ æ˜¯ä¸€ä½é¡¶çº§çš„è´¢ç»æ–°é—»ç¼–è¾‘å’Œå¯Œæœ‰æƒ³è±¡åŠ›çš„ä¸–ç•Œæ„å»ºå¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯ä¸ºä»¥ä¸‹è™šæ‹Ÿè‚¡ç¥¨å¸‚åœºä¸­çš„ã€æ¯ä¸€æ”¯è‚¡ç¥¨ã€‘ç”Ÿæˆä¸€æ¡ç‹¬ä¸€-æ— äºŒçš„ã€å……æ»¡è¶£å‘³ä¸”ç¬¦åˆå…¶äººè®¾çš„è´¢ç»å¿«è®¯ï¼Œå¹¶å†³å®šè¿™æ¡å¿«è®¯å¯¹è‚¡ä»·çš„æ­£é¢æˆ–è´Ÿé¢å½±å“ã€‚\n\n`;
        prompt += `--- **ã€æ ¸å¿ƒä¸–ç•Œè§‚ä¸å‚è€ƒä¿¡æ¯ã€‘** ---\n`;
        prompt += `è¿™æ˜¯ä¸€ä¸ªå……æ»¡æ´»åŠ›çš„è™šæ‹Ÿä¸–ç•Œï¼Œæ¯ä¸ªè§’è‰²éƒ½æœ‰è‡ªå·±çš„äº‹ä¸šã€äººé™…å…³ç³»å’Œæ­£åœ¨å‘ç”Ÿçš„æ•…äº‹ã€‚è‚¡ä»·çš„æ³¢åŠ¨ä¸ä»…ä»…æ˜¯æ•°å­—æ¸¸æˆï¼Œæ›´æ˜¯ä»–ä»¬äººç”Ÿçš„æˆå‰§æ€§ä½“ç°ã€‚ä¸ºäº†è®©ä½ çš„æ–°é—»æ›´å…·æ—¶æ•ˆæ€§å’Œå…³è”æ€§ï¼Œä»¥ä¸‹æ˜¯æ¯ä¸ªè§’è‰²æœ€è¿‘çš„ä¸€äº›åŠ¨æ€å’ŒèŠå¤©æ‘˜è¦ï¼š\n\n`;

        const stockList = stocks.map(stock => {
            const char = contacts.find(c => c.id === stock.charId);
            if (!char) return null;

            // æå–æœ€è¿‘çš„èŠå¤©è®°å½•
            const recentHistory = (char.conversation || [])
                .slice(-5)
                .map(msg => `[${getDisplayName(msg.sender, char.id)}]: ${truncateText(msg.content || `[${msg.type}]`, 20)}`)
                .join('; ');

            let stockInfo = `- **è‚¡ç¥¨**: ${stock.name} (${stock.ticker}), ID: ${stock.id}\n`;
            stockInfo += `  - **å…³è”è§’è‰²**: ${char.charSettings.name}\n`;
            stockInfo += `  - **è§’è‰²äººè®¾**: ${char.charSettings.persona.substring(0, 100)}...\n`;
            if (recentHistory) {
                stockInfo += `  - **è¿‘æœŸèŠå¤©æ‘˜è¦**: ${recentHistory}\n`;
            }
            return stockInfo;
        }).filter(Boolean).join('\n');
        
        prompt += `${stockList}\n`;

        prompt += `--- **ã€å¿«è®¯åˆ›ä½œæŒ‡å— (å¼ºåˆ¶éµå®ˆ)ã€‘** ---\n`;
        prompt += `1.  **ã€æœ€é«˜ä¼˜å…ˆçº§ï¼šäººè®¾ç»å¯¹é”å®šä¸è‡ªæˆ‘çº æ­£ã€‘**: å¿«è®¯å†…å®¹ã€å¿…é¡»ã€‘ä¸¥æ ¼ã€ç›´æ¥ä¸”å”¯ä¸€åœ°æºè‡ªå…¶å…³è”è§’è‰²çš„ã€äººè®¾ã€‘ã€ã€ä¸–ç•Œä¹¦ã€‘ä»¥åŠä¸Šæ–¹æä¾›çš„ã€è¿‘æœŸèŠå¤©æ‘˜è¦ã€‘ã€‚äººè®¾æ˜¯è§’è‰²çš„â€œåœ£ç»â€ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘è¿›è¡Œä»»ä½•è¶…è¶Šäººè®¾çš„åˆ›ä½œã€‚\n`;
        prompt += `    - **ã€è‡ªæˆ‘çº æ­£æœºåˆ¶ã€‘**: å¦‚æœä½ å‘ç°å·²æœ‰çš„è‚¡å¸‚æ–°é—»ä¸­å­˜åœ¨ä¸è§’è‰²äººè®¾ä¸ç¬¦çš„å†…å®¹ï¼ˆä¾‹å¦‚ï¼Œå°†â€œæ­Œæ‰‹â€å†™æˆäº†â€œæ¸¸æˆåˆ¶ä½œäººâ€ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘å¿½ç•¥è¯¥é”™è¯¯æ–°é—»ï¼Œå¹¶æ ¹æ®æ­£ç¡®çš„ã€äººè®¾ã€‘ç”Ÿæˆæ–°çš„ã€ç¬¦åˆé€»è¾‘çš„åç»­æ–°é—»ï¼Œä»¥ä¿®æ­£æ­¤å‰çš„é”™è¯¯ã€‚\n`;
        prompt += `2.  **ã€ä¸Šä¸‹æ–‡å…³è”ã€‘**: ä½ ã€è¢«å¼ºçƒˆé¼“åŠ±ã€‘ä»ã€è¿‘æœŸèŠå¤©æ‘˜è¦ã€‘ä¸­å¯»æ‰¾çµæ„Ÿï¼Œç”Ÿæˆä¸è§’è‰²å½“å‰æ´»åŠ¨ç›¸å…³çš„å¿«è®¯ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè§’è‰²æåˆ°â€œæ–°æ­Œâ€ï¼Œä½ å¯ä»¥ç”Ÿæˆâ€œæ–°ä¸“è¾‘å‘å¸ƒâ€çš„æ–°é—»ã€‚\n`;
        prompt += `3.  **ã€å¤šæ ·æ€§ã€‘**: ä¸¥ç¦ç”Ÿæˆé‡å¤æˆ–æ¨¡æ¿åŒ–çš„æ–°é—»ã€‚å¿«è®¯çš„ç§ç±»å¿…é¡»æå…¶ä¸°å¯Œï¼Œæ¶µç›–ä½†ä¸é™äºï¼š\n`;
        prompt += `    - **äº§å“/ä½œå“å‘å¸ƒ**: æ–°æ­Œã€æ–°ç”µå½±ã€æ–°å‘æ˜ã€æ–°ä¹¦...\n`;
        prompt += `    - **å•†ä¸šåˆä½œ**: è·¨ç•Œè”åã€æˆ˜ç•¥æŠ•èµ„ã€æ”¶è´­ä¸è¢«æ”¶è´­...\n`;
        prompt += `    - **è¡Œä¸šåŠ¨æ€**: è¡Œä¸šæ”¿ç­–å˜åŒ–ã€æŠ€æœ¯é©æ–°ã€å¸‚åœºè¶‹åŠ¿...\n`;
        prompt += `    - **å†…éƒ¨æ¶ˆæ¯**: ç®¡ç†å±‚å˜åŠ¨ã€è‚¡æƒæ–—äº‰ã€é‡å¤§å†³ç­–...\n`;
        prompt += `    - **ç¤¾ä¼šæ–°é—»/å…«å¦**: æ­£é¢æ…ˆå–„æ´»åŠ¨ã€è´Ÿé¢ä¸‘é—»ã€æ‹æƒ…æ›å…‰...\n`;
        prompt += `    - **å®è§‚ç»æµ**: è™šæ‹Ÿä¸–ç•Œä¸­çš„ç»æµæ•°æ®å‘å¸ƒã€åˆ©ç‡å˜åŠ¨...\n`;
        prompt += `    - **å¥‡é—»è½¶äº‹**: å……æ»¡æƒ³è±¡åŠ›çš„ã€ç¬¦åˆä¸–ç•Œè§‚çš„çªå‘äº‹ä»¶...\n`;
        prompt += `4.  **ã€è¶£å‘³æ€§ä¸æˆå‰§æ€§ã€‘**: æ–°é—»è¦ç®€çŸ­ç²¾æ‚ï¼Œä½†å¿…é¡»æœ‰æ•…äº‹æ€§ã€æœ‰è¶£å‘³ï¼Œèƒ½å¼•å‘äººçš„å¥½å¥‡å¿ƒã€‚\n`;
        prompt += `5.  **ã€è‚¡ä»·å½±å“ (price_impact)ã€‘**: ä½ éœ€è¦ä¸ºæ¯æ¡æ–°é—»è¯„ä¼°ä¸€ä¸ªå¯¹è‚¡ä»·çš„ã€å½±å“ç³»æ•°ã€‘ï¼Œä»‹äº **-0.15 (æåº¦åˆ©ç©º)** åˆ° **+0.15 (æåº¦åˆ©å¥½)** ä¹‹é—´ã€‚0ä»£è¡¨ä¸­æ€§æ¶ˆæ¯ã€‚\n\n`;
        
        prompt += `--- **ã€å¼ºåˆ¶è¾“å‡ºæ ¼å¼ã€‘** ---\n`;
        prompt += `ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªæ ¼å¼æ­£ç¡®çš„JSONå¯¹è±¡ï¼ŒåŒ…è£¹åœ¨ä¸€ä¸ª \`\`\`json ... \`\`\` ä»£ç å—ä¸­ã€‚JSONçš„é”®æ˜¯è‚¡ç¥¨çš„ã€IDã€‘ï¼Œå€¼æ˜¯ä¸€ä¸ªåŒ…å« "news" å’Œ "price_impact" çš„å¯¹è±¡ã€‚å‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚\n`;
        prompt += `--- **ã€è¾“å‡ºç¤ºä¾‹ã€‘** ---\n`;
        prompt += "```json\n{\n  \"stock_char_123\": {\n    \"news\": \"æ——ä¸‹å¤´ç‰Œè‰ºäºº[è§’è‰²A]åœ¨å…¶ä¸ªäººå¾®åšä¸Šé¢„å‘Šæ–°ä¸“è¾‘å³å°†å‘å¸ƒï¼Œå¼•å‘ç²‰ä¸çƒ­çƒˆè®¨è®ºï¼Œå¸‚åœºé¢„æœŸå…¶å•†ä¸šä»·å€¼å°†è¿›ä¸€æ­¥æå‡ã€‚\",\n    \"price_impact\": 0.12\n  }\n}\n```\n";
        
        return `ã€ç³»ç»ŸæŒ‡ä»¤ã€‘è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸Šè¯´æ˜ï¼Œä¸ºè‚¡å¸‚ç”Ÿæˆä¸€ä¸ªåŒ…å«æ–°é—»å’Œè‚¡ä»·å½±å“çš„JSONæ•°æ®åŒ…ã€‚ä½ çš„æ‰€æœ‰åˆ›é€ åŠ›éƒ½å¿…é¡»åœ¨JSONçš„å€¼ä¸­ä½“ç°ã€‚ä¸¥ç¦åœ¨æ­¤æŒ‡ä»¤ä¹‹å¤–æ·»åŠ ä»»ä½•å›å¤ã€‚${prompt}`;
    }

    async function updateStockMarket(retryCount = 0) {
    const market = appState.assets.stocks.market;
    if (market.length === 0) return;

    try {
        const banner = getEl('stock_update_failure_banner');
        if (banner) {
            banner.classList.remove('show');
            setTimeout(() => banner.remove(), 400);
        }

        const contacts = appState.chat.contacts;
        const eventPrompt = constructStockEventPrompt(market, contacts);
        const { apiUrl, selectedModel } = appState.settings;
        const apiKey = getNextApiKey();
        if (!apiUrl || !apiKey || !selectedModel) throw new Error("API not configured for stock events.");

        const messages = [{ role: 'system', content: eventPrompt }];
        if (!apiUrl.includes('generativelanguage.googleapis.com')) {
            messages[0].role = 'user';
        }
        
        let data;
        if (apiUrl.includes('generativelanguage.googleapis.com')) {
            const requestBody = transformToGoogleFormat(messages);
            const modelName = selectedModel.startsWith('models/') ? selectedModel : `models/${selectedModel}`;
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/${modelName}:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            if (!response.ok) throw new Error(`Google API Error: ${response.status} - ${await response.text()}`);
            data = transformFromGoogleFormat(await response.json());
        } else {
            const response = await fetch(`${apiUrl}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ model: selectedModel, messages: messages, stream: false }) });
            if (!response.ok) throw new Error(`API Error: ${response.status} - ${await response.text()}`);
            data = await response.json();
        }

        const replyContent = data.choices[0]?.message?.content;
        const jsonMatch = replyContent.match(/```json\s*([\s\S]*?)\s*```/);
        if (!jsonMatch) throw new Error("AI response for stock events did not contain a valid JSON block.");
        const eventData = JSON.parse(jsonMatch[1]);
        
        const globalMarketTrend = (Math.random() - 0.48); 

        for (const stock of market) {
            const oldPrice = stock.price;
            let changeFactor = 0;
            
            changeFactor += stock.volatility * (Math.random() - 0.5) * 2; 
            changeFactor += globalMarketTrend * 0.01; 
            
            const event = eventData[stock.id];
            if (event && typeof event.price_impact === 'number') {
                changeFactor += event.price_impact;
            }
            
            let newPrice = oldPrice * (1 + changeFactor);
            newPrice = Math.max(1.00, newPrice);

            stock.price = parseFloat(newPrice.toFixed(2));
            stock.change = parseFloat((newPrice - oldPrice).toFixed(2));
            stock.changePercent = parseFloat(((newPrice - oldPrice) / oldPrice * 100).toFixed(2));
            
            if (event && event.news) {
                if (!appState.assets.stocks.newsFeed) appState.assets.stocks.newsFeed = {};
                if (!appState.assets.stocks.newsFeed[stock.id]) {
                    appState.assets.stocks.newsFeed[stock.id] = [];
                }
                const newsFeed = appState.assets.stocks.newsFeed[stock.id];
                const changeText = stock.change >= 0 ? ` (+${stock.change.toFixed(2)})` : ` (${stock.change.toFixed(2)})`;
                newsFeed.unshift(event.news + changeText);
                appState.assets.stocks.newsFeed[stock.id] = newsFeed.slice(0, 10);
            }
            
            stock.history.push(stock.price);
            if (stock.history.length > 30) stock.history.shift();
        }

    } catch (error) {
        console.error(`Stock market update failed (Attempt ${retryCount + 1}):`, error);
        let detailedErrorMessage = error.message;
        if (error instanceof TypeError && (error.message.includes('Failed to fetch') || error.message.includes('Load failed') || error.message.includes('NetworkError'))) {
            detailedErrorMessage = "ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–APIè®¾ç½®ã€‚";
        }
        showPersistentNotification(
            'stock_update_failure_banner',
            'è‚¡å¸‚å¿«è®¯æ›´æ–°å¤±è´¥',
            `å·²é‡è¯• ${retryCount + 1} æ¬¡ã€‚\nåŸå› : ${detailedErrorMessage}`
        );
        setTimeout(() => updateStockMarket(retryCount + 1), 30000);
    }
}
    function renderStockMarket() {
        const container = getEl('stock-list-container');
        container.style.padding = '15px'; // Restore padding for the container
        container.classList.remove('preset-data-list'); // No longer needs this wrapper class
        const market = appState.assets.stocks.market;

        if (market.length === 0) {
            container.innerHTML = `<p style="text-align:center; color:#888;">è‚¡å¸‚å°šæœªå¼€ç›˜ï¼Œè¯·ç¨åå†æ¥ã€‚</p>`;
            return;
        }

        container.innerHTML = market.map(stock => {
            const changeClass = stock.change > 0 ? 'up' : (stock.change < 0 ? 'down' : '');
            const changeSign = stock.change > 0 ? '+' : '';
            // æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨ li > div.content + div.actions çš„æ­£ç¡®ç»“æ„
            return `
                <li class="stock-item" data-stock-id="${stock.id}">
    <div class="stock-item-content swipe-content">
        <div class="stock-info">
            <div class="stock-name">${escapeHTML(stock.name)}</div>
            <div class="stock-ticker">${escapeHTML(stock.ticker)}</div>
        </div>
        <div class="stock-chart" id="chart-${stock.id}"></div>
        <div class="stock-price-info">
            <div class="stock-price">Â¥ ${stock.price.toFixed(2)}</div>
            <div class="stock-change ${changeClass}">
                ${changeSign}${stock.change.toFixed(2)} (${changeSign}${stock.changePercent.toFixed(2)}%)
            </div>
        </div>
    </div>
    <div class="stock-item-actions swipe-actions">
        <div class="edit-action">ç¼–è¾‘</div>
        <div class="delete-action">åˆ é™¤</div>
    </div>
</li>
            `;
        }).join('');

        market.forEach(stock => {
            renderStockChart(getEl(`chart-${stock.id}`), stock.history, stock.change >= 0);
        });
    }
function renderStockChart(container, history, isUp) {
if (!container || !history || history.length === 0) return;
const min = Math.min(...history);
const max = Math.max(...history);
const range = max - min;
if (range === 0) { // All values are the same
    container.innerHTML = history.map(() => `<div class="chart-bar" style="height: 50%;"></div>`).join('');
    return;
}

container.innerHTML = history.map((price, index) => {
    const heightPercent = Math.max(5, (price - min) / range * 100);
    let barClass = 'chart-bar';
    if (index > 0) {
        if (price > history[index - 1]) barClass += ' up';
        else if (price < history[index - 1]) barClass += ' down';
    } else {
         if (isUp) barClass += ' up'; else barClass += ' down';
    }
    return `<div class="${barClass}" style="height: ${heightPercent}%;"></div>`;
}).join('');
}
function openTradeModal(stockId) {
const modal = getEl('stock-trade-modal');
const stock = appState.assets.stocks.market.find(s => s.id === stockId);
const portfolio = appState.assets.stocks.portfolio[stockId] || { shares: 0, avgCost: 0 };
const user = appState.chat.userProfile;
if (!stock) return;

modal.dataset.stockId = stockId;
getEl('stock-trade-title').textContent = `${stock.name} (${stock.ticker})`;
getEl('stock-trade-price').textContent = `Â¥ ${stock.price.toFixed(2)}`;
const changeClass = stock.change > 0 ? 'up' : (stock.change < 0 ? 'down' : '');
const changeSign = stock.change > 0 ? '+' : '';
getEl('stock-trade-change').innerHTML = `<span class="${changeClass}">${changeSign}${stock.change.toFixed(2)} (${changeSign}${stock.changePercent.toFixed(2)}%)</span>`;
renderStockChart(getEl('stock-trade-chart'), stock.history, stock.change >= 0);

// Buy tab
const maxBuy = Math.floor(user.cashBalance / stock.price);
getEl('stock-buy-max-shares').textContent = maxBuy;
getEl('stock-buy-shares-input').value = '';
getEl('stock-buy-total-cost').textContent = 'Â¥ 0.00';

// Sell tab
getEl('stock-sell-max-shares').textContent = portfolio.shares;
getEl('stock-sell-shares-input').value = '';
getEl('stock-sell-total-proceeds').textContent = 'Â¥ 0.00';

// Summary
            const char = appState.chat.contacts.find(c => c.id === stock.charId);
            const summaryEl = modal.querySelector('.portfolio-summary');
            let charNameEl = summaryEl.querySelector('.stock-char-name-p');
            if (!charNameEl) {
                charNameEl = document.createElement('p');
                charNameEl.className = 'stock-char-name-p';
                summaryEl.prepend(charNameEl);
            }
            charNameEl.innerHTML = `æ‰€å±è§’è‰²: <span style="font-weight: bold;">${escapeHTML(char.charSettings.name)}</span>`;
getEl('stock-trade-current-shares').textContent = `${portfolio.shares} è‚¡`;
getEl('stock-trade-avg-cost').textContent = `Â¥ ${portfolio.avgCost.toFixed(2)}`;
// Populate news feed
            const newsListEl = getEl('stock-trade-news-list');
            const newsFeed = appState.assets.stocks.newsFeed[stockId] || [];
            if (newsFeed.length > 0) {
                newsListEl.innerHTML = newsFeed.map(news => `<li>${escapeHTML(news)}</li>`).join('');
            } else {
                newsListEl.innerHTML = `<li style="color: #888;">æš‚æ— ç›¸å…³å¿«è®¯</li>`;
            }

modal.classList.add('visible');
}
function setupStockTradeListeners() {
getEl('stock-list-container').addEventListener('click', e => {
const item = e.target.closest('.stock-item');
if (item) {
openTradeModal(item.dataset.stockId);
}
});
getEl('close-stock-trade-modal-btn').addEventListener('click', () => {
    getEl('stock-trade-modal').classList.remove('visible');
});

getEl('stock-buy-shares-input').addEventListener('input', e => {
            const shares = parseInt(e.target.value) || 0;
            const stockId = getEl('stock-trade-modal').dataset.stockId;
            const stock = appState.assets.stocks.market.find(s => s.id === stockId);
            if (stock) {
                const baseCost = shares * stock.price;
                const fee = Math.ceil(baseCost * 0.01) / 100;
                const totalCost = baseCost + fee;
                getEl('stock-buy-total-cost').textContent = `Â¥ ${totalCost.toFixed(2)} (å«æ‰‹ç»­è´¹ Â¥${fee.toFixed(2)})`;
            }
        });

        getEl('stock-sell-shares-input').addEventListener('input', e => {
            const shares = parseInt(e.target.value) || 0;
            const stockId = getEl('stock-trade-modal').dataset.stockId;
            const stock = appState.assets.stocks.market.find(s => s.id === stockId);
            if (stock) {
                const baseProceeds = shares * stock.price;
                const fee = Math.ceil(baseProceeds * 0.01) / 100;
                const totalProceeds = baseProceeds - fee;
                getEl('stock-sell-total-proceeds').textContent = `Â¥ ${totalProceeds.toFixed(2)} (å«æ‰‹ç»­è´¹ Â¥${fee.toFixed(2)})`;
            }
        });

getEl('stock-sell-shares-input').addEventListener('input', e => {
    const shares = parseInt(e.target.value) || 0;
    const stockId = getEl('stock-trade-modal').dataset.stockId;
    const stock = appState.assets.stocks.market.find(s => s.id === stockId);
    if (stock) {
        getEl('stock-sell-total-proceeds').textContent = `Â¥ ${(shares * stock.price).toFixed(2)}`;
    }
});

getEl('confirm-buy-stock-btn').addEventListener('click', () => {
    const stockId = getEl('stock-trade-modal').dataset.stockId;
    const shares = parseInt(getEl('stock-buy-shares-input').value);
    if (isNaN(shares) || shares <= 0) return showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„è´­ä¹°æ•°é‡', 'error');
    buyStock(stockId, shares);
});

getEl('confirm-sell-stock-btn').addEventListener('click', () => {
    const stockId = getEl('stock-trade-modal').dataset.stockId;
    const shares = parseInt(getEl('stock-sell-shares-input').value);
    if (isNaN(shares) || shares <= 0) return showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„å–å‡ºæ•°é‡', 'error');
    sellStock(stockId, shares);
});
}
function buyStock(stockId, shares) {
const stock = appState.assets.stocks.market.find(s => s.id === stockId);
const user = appState.chat.userProfile;
const portfolio = appState.assets.stocks.portfolio;
        
        const baseCost = stock.price * shares;
        const fee = Math.ceil(baseCost * 0.01) / 100; // æ‰‹ç»­è´¹0.01%ï¼Œå‘ä¸Šå–æ•´
        const totalCost = baseCost + fee;

        if (totalCost > user.bankBalance) { // ä»é“¶è¡Œå­˜æ¬¾è´­ä¹°
            return showToast('é“¶è¡Œå­˜æ¬¾ä¸è¶³', 'error');
        }

        user.bankBalance -= totalCost; // ä»é“¶è¡Œå­˜æ¬¾æ‰£é™¤

if (!portfolio[stockId]) {
    portfolio[stockId] = { shares: 0, avgCost: 0 };
}

const existingHolding = portfolio[stockId];
const newTotalShares = existingHolding.shares + shares;
        const newAvgCost = ((existingHolding.avgCost * existingHolding.shares) + totalCost) / newTotalShares;

existingHolding.shares = newTotalShares;
existingHolding.avgCost = parseFloat(newAvgCost.toFixed(2));

showToast(`æˆåŠŸä¹°å…¥ ${shares} è‚¡ ${stock.name}`, 'info');
debouncedSaveState();
openTradeModal(stockId); // Refresh modal
renderBankUI(); // Refresh bank tab
}
function sellStock(stockId, shares) {
const stock = appState.assets.stocks.market.find(s => s.id === stockId);
const user = appState.chat.userProfile;
const portfolio = appState.assets.stocks.portfolio;
const holding = portfolio[stockId];
if (!holding || shares > holding.shares) {
    return showToast('æŒä»“æ•°é‡ä¸è¶³', 'error');
}

        const baseProceeds = stock.price * shares;
        const fee = Math.ceil(baseProceeds * 0.01) / 100; // æ‰‹ç»­è´¹0.01%ï¼Œå‘ä¸Šå–æ•´
        const totalProceeds = baseProceeds - fee;

        user.bankBalance += totalProceeds; // å­˜å…¥é“¶è¡Œå­˜æ¬¾

holding.shares -= shares;

if (holding.shares === 0) {
    delete portfolio[stockId];
}

showToast(`æˆåŠŸå–å‡º ${shares} è‚¡ ${stock.name}`, 'info');
debouncedSaveState();
openTradeModal(stockId); // Refresh modal
renderBankUI(); // Refresh bank tab
}
    assetsAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
        if (e.target.classList.contains('tab-link')) {
            const tabId = e.target.dataset.tab;
            assetsAppScreen.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
            assetsAppScreen.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            e.target.classList.add('active');
            getEl(`${tabId}-tab-content`).classList.add('active');
            handleAssetsTabChange(tabId);
        }
    });
    
    function handleShopTabChange(tabId) {
        const titleEl = shopAppScreen.querySelector('.title');
        const tabMap = { 'purchase': 'è´­ä¹°', 'resale': 'è½¬å”®', 'takeout': 'å¤–å–', 'blindbox': 'ç›²ç›’' };
        titleEl.textContent = tabMap[tabId] || 'è´­ç‰©';
    }

    shopAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
        if (e.target.classList.contains('tab-link')) {
            const tabId = e.target.dataset.tab;
            shopAppScreen.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
            shopAppScreen.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            e.target.classList.add('active');
            getEl(`${tabId}-tab-content`).classList.add('active');
            handleShopTabChange(tabId);
        }
    });
    
    function renderFortuneTabUI() {
        if (!runtimeState.fortuneProcess) { // Safety check
            runtimeState.fortuneProcess = { status: 'idle', retryTimer: null, context: {} };
        }

        const initialView = getEl('fortune-initial-view');
        const resultView = getEl('fortune-result-view');
        if (!initialView || !resultView) return;

        // Hide both initially to prevent flicker
        initialView.style.display = 'none';
        resultView.style.display = 'none';

        switch (runtimeState.fortuneProcess.status) {
            case 'loading':
                resultView.style.display = 'block';
                resultView.innerHTML = `<p style="text-align:center; color: #888; margin-top: 50px;">æ­£åœ¨ä¸ºæ‚¨è™”è¯šè¯·æ±‚å¯ç¤ºï¼Œè¯·ç¨å€™...</p>`;
                break;
            case 'failed':
                resultView.style.display = 'block';
resultView.innerHTML = `<p style="text-align:center; color:red; margin-top: 50px;">è¯·æ±‚å¤±è´¥ï¼Œæ‚¨å¯ä»¥ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®é‡è¯•ã€‚</p><button id="restart-divination-btn" class="settings-button secondary" style="margin-top: 20px;">é‡è¯•</button>`;
                break;
            case 'success':
                const savedFortune = appState.entertainment && appState.entertainment.savedFortune;
                if (savedFortune) {
                    const { type, result } = savedFortune;
                    if (type === 'divination') renderDivinationResult(result);
                    else if (type === 'tarot') renderTarotResult(result);
                    else if (type === 'horoscope') {
                        const todayStr = new Date().toISOString().split('T')[0];
                        if (result.date === todayStr) {
                            renderHoroscopeResult(result);
                        } else {
                            delete appState.entertainment.savedFortune;
                            runtimeState.fortuneProcess.status = 'idle';
                            initialView.style.display = 'block';
                        }
                    }
                } else {
                    runtimeState.fortuneProcess.status = 'idle';
                    initialView.style.display = 'block';
                }
                break;
            case 'idle':
            default:
                initialView.style.display = 'block';
                resultView.style.display = 'none';
                break;
        }
    }

    function handleEntertainmentTabChange(tabId) {
        const titleEl = entertainmentAppScreen.querySelector('.title');
        const settingsBtn = getEl('entertainment-settings-btn');
        const tabMap = { 'livestream': 'ç›´æ’­', 'questionnaire': 'é—®å·', 'fortune': 'è¿åŠ¿' };
        titleEl.textContent = tabMap[tabId] || 'å¨±ä¹';
        
        if (tabId === 'fortune') {
            settingsBtn.style.display = 'block';
            renderFortuneTabUI();
        } else {
            settingsBtn.style.display = 'none';
        }
    }

    async function executeFortuneRequest() {
        // å¦‚æœçŠ¶æ€å·²è¢«æ”¹å˜ï¼ˆä¾‹å¦‚ï¼Œç”¨æˆ·å–æ¶ˆæˆ–è¯·æ±‚æˆåŠŸï¼‰ï¼Œåˆ™åœæ­¢é‡è¯•å¾ªç¯
        if (runtimeState.fortuneProcess.status !== 'loading' && runtimeState.fortuneProcess.status !== 'failed') {
            if (runtimeState.fortuneProcess.retryTimer) clearTimeout(runtimeState.fortuneProcess.retryTimer);
            runtimeState.fortuneProcess.retryTimer = null;
            return;
        }

        const { type, context } = runtimeState.fortuneProcess;
        
        // å¦‚æœè¿™æ˜¯é‡è¯•ï¼Œå…ˆæ›´æ–°UIæ˜¾ç¤ºé‡è¯•æ¬¡æ•°
        if (runtimeState.fortuneProcess.status === 'failed') {
            renderFortuneTabUI();
        }
        
        try {
            let secretInstruction;
            let interpreterChar = appState.chat.contacts.find(c => !c.isGroup);
            if (!interpreterChar) throw new Error("æ²¡æœ‰å¯ç”¨äºæ“ä½œçš„è§’è‰²ã€‚");

            switch (type) {
                case 'divination':
                    secretInstruction = constructDivinationInterpretationPrompt(context.question, context.lotData);
                    break;
                case 'tarot':
                    secretInstruction = constructTarotInterpretationPrompt(context.question, context.drawnCards);
                    break;
                case 'horoscope':
                    secretInstruction = constructHoroscopeInterpretationPrompt(context.question, context.selectedSign);
                    break;
                default:
                    throw new Error("æœªçŸ¥çš„è¿åŠ¿ç±»å‹");
            }
            
            // triggerAiResponse ä¼šåœ¨APIå¤±è´¥æ—¶æŠ›å‡ºé”™è¯¯ï¼Œå°†è¢«ä¸‹é¢çš„catchå—æ•è·
            await triggerAiResponse(interpreterChar.id, false, false, false, secretInstruction, false);
            // æˆåŠŸæ—¶çš„çŠ¶æ€æ›´æ–°å’Œå®šæ—¶å™¨æ¸…ç†å°†åœ¨ processAiReply ä¸­è¿›è¡Œ

        } catch (error) {
            console.error(`${type} AI process failed:`, error);
            runtimeState.fortuneProcess.status = 'failed';
runtimeState.fortuneProcess.context.retries = (runtimeState.fortuneProcess.context.retries || 0) + 1;

// --- æ–°å¢ï¼šæŒä¹…åŒ–é€šçŸ¥ ---
const detailedErrorMessage = `åŸå› : ${error.message}`;
showPersistentNotification(
    'fortune_process_failure_banner',
    'è¿åŠ¿å åœå¤±è´¥',
    `å·²é‡è¯• ${runtimeState.fortuneProcess.context.retries} æ¬¡ã€‚\n${detailedErrorMessage}`
);
            
            // æ¸²æŸ“å¤±è´¥UIå¹¶å®‰æ’ä¸‹ä¸€æ¬¡é‡è¯•
            renderFortuneTabUI();
            
        }
    }

    function initiateFortuneRequest(type, context) {
        // æ¸…ç†ä¸Šä¸€ä¸ªå¯èƒ½æ­£åœ¨è¿›è¡Œçš„é‡è¯•ä»»åŠ¡
        if (runtimeState.fortuneProcess && runtimeState.fortuneProcess.retryTimer) {
            clearTimeout(runtimeState.fortuneProcess.retryTimer);
        }

        // åˆå§‹åŒ–æ–°çš„ä»»åŠ¡çŠ¶æ€
        runtimeState.fortuneProcess = {
            status: 'loading',
            type: type,
            context: { ...context, retries: 0 },
            retryTimer: null
        };

        // ç«‹å³æ›´æ–°UIåˆ°åŠ è½½çŠ¶æ€ï¼Œå¹¶å¼€å§‹ç¬¬ä¸€æ¬¡è¯·æ±‚
        renderFortuneTabUI();
        executeFortuneRequest();
    }

    entertainmentAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
        if (e.target.classList.contains('tab-link')) {
            const tabId = e.target.dataset.tab;
            entertainmentAppScreen.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
            entertainmentAppScreen.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            e.target.classList.add('active');
            getEl(`${tabId}-tab-content`).classList.add('active');
            handleEntertainmentTabChange(tabId);
        }
    });

    weiboAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
        if (e.target.classList.contains('tab-link')) {
            const tabId = e.target.dataset.tab;
            weiboAppScreen.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
            weiboAppScreen.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            e.target.classList.add('active');
            getEl(`${tabId}-tab-content`).classList.add('active');
            handleWeiboTabChange(tabId);
        }
    });

    function handleSettingsTabChange(tabId) {
        const titleEl = settingsAppScreen.querySelector('.title');
        const tabMap = { 'main-settings': 'è®¾ç½®', 'guide': 'æŒ‡å—', 'memory': 'è®°å¿†' };
titleEl.textContent = tabMap[tabId] || 'è®¾ç½®';

        // Show/hide memory settings button
        memorySettingsBtn.style.display = (tabId === 'memory') ? 'block' : 'none';
    getEl('memory-repair-btn').style.display = (tabId === 'memory') ? 'block' : 'none';
        if (tabId === 'memory') {
            renderMemoryTable();
        }
        }

    settingsAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
        if (e.target.classList.contains('tab-link')) {
            const tabId = e.target.dataset.tab;
            settingsAppScreen.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
            settingsAppScreen.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            e.target.classList.add('active');
            getEl(`${tabId}-tab-content`).classList.add('active');
            handleSettingsTabChange(tabId);
        }
    });
    
    // --- æ–°å¢ï¼šå¨±ä¹-è¿åŠ¿è®¾ç½® ---
    const fortuneSettingsModal = getEl('fortune-settings-modal');
const confirmFortuneSettingsBtn = getEl('confirm-fortune-settings-btn');
const closeFortuneSettingsBtn = getEl('close-fortune-settings-btn');
const fortuneTypeSelector = getEl('fortune-type-selector');
const divinationQuestionContainer = getEl('divination-question-container');
const fortuneTabContent = getEl('fortune-tab-content');
const tarotQuestionContainer = getEl('tarot-question-container');
const horoscopeQuestionContainer = getEl('horoscope-question-container');
    function openFortuneSettings() {
        if (!appState.entertainment) {
            appState.entertainment = { fortuneType: 'divination' };
        }
        const currentType = appState.entertainment.fortuneType || 'divination';
        const radioButtons = fortuneSettingsModal.querySelectorAll('input[name="fortune-type"]');
        radioButtons.forEach(radio => {
            radio.checked = radio.value === currentType;
        });
            // æ ¸å¿ƒæ–°å¢ï¼šæ ¹æ®å½“å‰é€‰æ‹©çš„ç±»å‹ï¼Œå†³å®šæ˜¯å¦æ˜¾ç¤ºé—®é¢˜è¾“å…¥æ¡†
    divinationQuestionContainer.style.display = (currentType === 'divination') ? 'block' : 'none';
    getEl('divination-question-input').value = ''; // æ¸…ç©ºæ—§é—®é¢˜
        tarotQuestionContainer.style.display = (currentType === 'tarot') ? 'block' : 'none';
    getEl('tarot-question-input').value = ''; // æ¸…ç©ºæ—§é—®é¢˜
    horoscopeQuestionContainer.style.display = (currentType === 'horoscope') ? 'block' : 'none';
    getEl('horoscope-question-input').value = ''; // æ¸…ç©ºæ—§é—®é¢˜
        fortuneSettingsModal.classList.add('visible');
    }

    entertainmentAppScreen.querySelector('.app-header-right').addEventListener('click', e => {
        if (e.target.closest('#entertainment-settings-btn')) {
            openFortuneSettings();
        }
    });

    closeFortuneSettingsBtn.addEventListener('click', () => {
    fortuneSettingsModal.classList.remove('visible');
});

confirmFortuneSettingsBtn.addEventListener('click', () => {
    const selectedType = fortuneTypeSelector.querySelector('input:checked').value;
    if (selectedType === 'divination') {
        const question = getEl('divination-question-input').value.trim();
        if (!question) { showToast('è¯·è¾“å…¥æ‚¨æƒ³å åœçš„å†…å®¹', 'error'); return; }
        fortuneSettingsModal.classList.remove('visible');
        const lotIndex = Math.floor(Math.random() * 100);
        const drawnLot = GUAN_YIN_LOTS[lotIndex];
        runtimeState.pendingDivination = { userQuestion: question, lotData: drawnLot };
        initiateFortuneRequest('divination', { question: question, lotData: drawnLot });
    } else if (selectedType === 'horoscope') {
        const selectedSign = getEl('horoscope-sign-select').value;
        const question = getEl('horoscope-question-input').value.trim();
        if (!question) { showToast('è¯·è¾“å…¥æ‚¨æƒ³å åœçš„å†…å®¹ (æ˜Ÿåº§)', 'error'); return; }
        fortuneSettingsModal.classList.remove('visible');
        runtimeState.pendingHoroscope = { userQuestion: question, selectedSign: selectedSign };
        initiateFortuneRequest('horoscope', { question: question, selectedSign: selectedSign });
    } else if (selectedType === 'tarot') {
        const question = getEl('tarot-question-input').value.trim();
        if (!question) { showToast('è¯·è¾“å…¥æ‚¨æƒ³å åœçš„å†…å®¹ (å¡”ç½—)', 'error'); return; }
        fortuneSettingsModal.classList.remove('visible');
        const drawnCards = [];
        const cardPool = [...TAROT_CARDS];
        for (let i = 0; i < 3; i++) {
            const randomIndex = Math.floor(Math.random() * cardPool.length);
            const card = cardPool.splice(randomIndex, 1)[0];
            drawnCards.push({ ...card, isReversed: Math.random() < 0.5 });
        }
        runtimeState.pendingTarot = { userQuestion: question, drawnCards: drawnCards };
        initiateFortuneRequest('tarot', { question: question, drawnCards: drawnCards });
    }
});

fortuneTabContent.addEventListener('click', e => {
    if (e.target.id === 'start-divination-btn') {
        if (appState.entertainment) {
            delete appState.entertainment.savedFortune;
        }
        debouncedSaveState();
        renderFortuneTabUI(); // Reset to initial view
        openFortuneSettings();
    } else if (e.target.id === 'restart-divination-btn') {
        const { type, context } = runtimeState.fortuneProcess;
        if (type && context) {
            // Manually trigger a retry with the exact same context
            initiateFortuneRequest(type, context);
        } else {
            // Fallback if context is lost
            openFortuneSettings();
        }
    }
});
    
    getEl('fortune-type-selector').addEventListener('change', e => {
        if (e.target.name === 'fortune-type') {
            if (!appState.entertainment) {
                appState.entertainment = { fortuneType: 'divination' };
            }
            appState.entertainment.fortuneType = e.target.value;
            debouncedSaveState();
        }
    });
    
fortuneTypeSelector.addEventListener('change', e => {
        if (e.target.name === 'fortune-type') {
                const selectedType = e.target.value;
        divinationQuestionContainer.style.display = (selectedType === 'divination') ? 'block' : 'none';
        tarotQuestionContainer.style.display = (selectedType === 'tarot') ? 'block' : 'none';
        horoscopeQuestionContainer.style.display = (selectedType === 'horoscope') ? 'block' : 'none';
    }
});

async function startDivinationProcess(question) {
        const initialView = getEl('fortune-initial-view');
        const resultView = getEl('fortune-result-view');
        if (initialView) initialView.style.display = 'none';
        if (resultView) {
            resultView.style.display = 'block';
            resultView.innerHTML = `<p style="text-align:center; color: #888; margin-top: 50px;">æ­£åœ¨ä¸ºæ‚¨è™”è¯šæ±‚ç­¾ï¼Œè¯·ç¨å€™...</p>`;
        }

    // éšæœºæŠ½ç­¾
    const lotIndex = Math.floor(Math.random() * 100);
    const drawnLot = GUAN_YIN_LOTS[lotIndex];
    
    // ä¸´æ—¶å­˜å‚¨ä¸Šä¸‹æ–‡ï¼Œä»¥ä¾¿AIå›å¤åè¿›è¡Œå¤„ç†
    runtimeState.pendingDivination = { userQuestion: question, lotData: drawnLot };
    // è§¦å‘AIè§£ç­¾
    try {
        const secretInstruction = constructDivinationInterpretationPrompt(question, drawnLot);
        // æ‰¾åˆ°ä»»æ„ä¸€ä¸ªéç¾¤èŠè§’è‰²ä½œä¸ºè§£ç­¾è€…
        const interpreterChar = appState.chat.contacts.find(c => !c.isGroup);
        if (!interpreterChar) {
            throw new Error("æ²¡æœ‰å¯ç”¨äºè§£ç­¾çš„è§’è‰²ã€‚");
        }
        await triggerAiResponse(interpreterChar.id, false, false, false, secretInstruction, false);
    } catch (error) {
        console.error("Divination AI process failed:", error);
        fortuneTabContent.innerHTML = `<p style="text-align:center; color:red; margin-top: 50px;">è§£ç­¾å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚</p>`;
    }
}

function constructDivinationInterpretationPrompt(question, lot) {
    let prompt = `ä½ æ˜¯ä¸€ä½ç²¾é€šä¸œæ–¹ç„å­¦çš„è§£ç­¾å¤§å¸ˆã€‚ç”¨æˆ·åˆšåˆšæŠ½åˆ°äº†è§‚éŸ³çµç­¾ç¬¬ ${lot.id} ç­¾ï¼Œå¹¶è¯¢é—®äº†ä»¥ä¸‹é—®é¢˜ã€‚\n\n`;
    prompt += `--- **ç”¨æˆ·çš„é—®é¢˜** ---\n`;
    prompt += `${question}\n\n`;
    prompt += `--- **æŠ½åˆ°çš„ç­¾æ–‡è¯¦æƒ…** ---\n`;
    prompt += `- **æ ‡é¢˜**: ${lot.title}\n`;
    prompt += `- **è¯—æ›°**: \n${lot.poem}\n`;
    prompt += `- **å¤äººå…¸æ•…**: ${lot.interpretation}\n`;
    prompt += `- **æ–­æ›°**: ${lot.verse}\n\n`;
    prompt += `--- **ä½ çš„ä»»åŠ¡** ---\n`;
    prompt += `è¯·ä½ ç»“åˆä¸Šé¢çš„ç­¾æ–‡ã€å…¸æ•…å’Œæ–­æ›°ï¼Œç”¨ä¸€ç§å……æ»¡æ™ºæ…§ã€ç¦…æ„ä¸”é€šä¿—æ˜“æ‡‚çš„è¯­è¨€ï¼Œä¸“é—¨é’ˆå¯¹ç”¨æˆ·æå‡ºçš„ã€å…·ä½“é—®é¢˜ã€‘è¿›è¡Œæ·±å…¥è§£è¯»ã€‚ä½ çš„è§£è¯»ã€å¿…é¡»ã€‘åŒ…å«ä»¥ä¸‹ä¸‰ä¸ªéƒ¨åˆ†ï¼Œå¹¶ä¸¥æ ¼éµå¾ªJSONè¾“å‡ºæ ¼å¼ï¼š\n`;
    prompt += `1.  **æ€»ä½“è§£è¯» (interpretation)**: ç»¼åˆç­¾æ–‡çš„æ•´ä½“å«ä¹‰ï¼Œå¯¹ç”¨æˆ·çš„é—®é¢˜ç»™å‡ºä¸€ä¸ªæ€»ä½“çš„ã€æ–¹å‘æ€§çš„è§£ç­”ã€‚\n`;
    prompt += `2.  **ç°çŠ¶åˆ†æ (analysis)**: ç»“åˆç­¾æ–‡çš„å…¸æ•…å’Œè¯—å¥ï¼Œåˆ†æç”¨æˆ·é—®é¢˜æ‰€å¤„çš„å½“å‰çŠ¶å†µæˆ–é¢ä¸´çš„æŒ‘æˆ˜ã€‚\n`;
    prompt += `3.  **æœªæ¥æŒ‡å¼• (guidance)**: æ ¹æ®ç­¾æ–‡çš„å¯ç¤ºï¼Œä¸ºç”¨æˆ·æä¾›å…·ä½“çš„ã€å¯æ“ä½œçš„å»ºè®®æˆ–æœªæ¥çš„å‘å±•æ–¹å‘ã€‚\n\n`;
    prompt += `--- **ã€å¼ºåˆ¶è¾“å‡ºæ ¼å¼ã€‘** ---\n`;
    prompt += `ä½ çš„ã€æ•´ä¸ªå›å¤ã€‘éƒ½ã€å¿…é¡»ã€‘æ˜¯åŒ…è£¹åœ¨ä¸€ä¸ª \`\`\`json ... \`\`\` ä»£ç å—ä¸­çš„JSONå¯¹è±¡ï¼Œå‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚æ ¼å¼å¦‚ä¸‹ï¼š\n`;
    prompt += "```json\n";
    prompt += "{\n";
    prompt += '  "divination_result": {\n';
    prompt += '    "interpretation": "ï¼ˆè¿™é‡Œæ˜¯ä½ å¯¹ç”¨æˆ·é—®é¢˜çš„æ€»ä½“è§£è¯»ï¼‰",\n';
    prompt += '    "analysis": "ï¼ˆè¿™é‡Œæ˜¯ä½ å¯¹ç”¨æˆ·ç°çŠ¶çš„åˆ†æï¼‰",\n';
    prompt += '    "guidance": "ï¼ˆè¿™é‡Œæ˜¯ä½ ç»™ç”¨æˆ·çš„æœªæ¥æŒ‡å¼•ï¼‰"\n';
    prompt += '  }\n';
    prompt += "}\n";
    prompt += "```\n";
    return `ã€ç³»ç»ŸæŒ‡ä»¤ã€‘è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹è¯´æ˜ï¼Œç”Ÿæˆä¸€ä¸ªç”¨äºè§£ç­¾çš„JSONæ•°æ®åŒ…ã€‚ä½ çš„æ‰€æœ‰åˆ›é€ åŠ›éƒ½å¿…é¡»åœ¨JSONçš„å€¼ä¸­ä½“ç°ã€‚ä¸¥ç¦åœ¨æ­¤æŒ‡ä»¤ä¹‹å¤–æ·»åŠ ä»»ä½•å›å¤ã€‚${prompt}`;
}

function renderDivinationResult(result) {
    const initialView = getEl('fortune-initial-view');
    const resultView = getEl('fortune-result-view');

    if (!result) {
        if (initialView) initialView.style.display = 'block';
        if (resultView) resultView.style.display = 'none';
        return;
    }

    if (initialView) initialView.style.display = 'none';
    if (resultView) {
        resultView.style.display = 'block';
        resultView.innerHTML = `
            <div class="settings-group">
                <div class="group-title">æ‚¨æ±‚å¾— è§‚éŸ³çµç­¾ ç¬¬ ${result.lotData.id} ç­¾</div>
                <div class="group-content" style="padding: 15px; text-align: center;">
                    <h4 style="margin-top:0;">${result.lotData.title}</h4>
                    <p style="white-space: pre-wrap; font-style: italic;">${result.lotData.poem}</p>
                </div>
            </div>
            <div class="settings-group">
                <div class="group-title">æ‚¨æ‰€é—®ä¹‹äº‹</div>
                <div class="group-content" style="padding: 15px;">
                    <p style="margin:0;">${escapeHTML(result.userQuestion)}</p>
                </div>
            </div>
            <div class="settings-group">
                <div class="group-title">å¤§å¸ˆè§£è¯»</div>
                <div class="group-content" style="padding: 15px; line-height: 1.8;">
                    <p><strong>ã€æ€»ä½“è§£è¯»ã€‘</strong><br>${escapeHTML(result.interpretation.interpretation)}</p>
                    <p><strong>ã€ç°çŠ¶åˆ†æã€‘</strong><br>${escapeHTML(result.interpretation.analysis)}</p>
                    <p><strong>ã€æœªæ¥æŒ‡å¼•ã€‘</strong><br>${escapeHTML(result.interpretation.guidance)}</p>
                </div>
            </div>
            <button id="restart-divination-btn" class="settings-button secondary" style="margin-top: 20px;">é‡æ–°å åœ</button>
        `;
    }
}
async function startTarotProcess(question) {
    const initialView = getEl('fortune-initial-view');
    const resultView = getEl('fortune-result-view');
    if (initialView) initialView.style.display = 'none';
    if (resultView) {
        resultView.style.display = 'block';
        resultView.innerHTML = `<p style="text-align:center; color: #888; margin-top: 50px;">æ­£åœ¨ä¸ºæ‚¨æ´—ç‰Œå¹¶æŠ½å–å¡”ç½—ç‰Œé˜µï¼Œè¯·ç¨å€™...</p>`;
    }

    // æŠ½å–ä¸‰å¼ ä¸é‡å¤çš„ç‰Œ
    const drawnCards = [];
    const cardPool = [...TAROT_CARDS];
    for (let i = 0; i < 3; i++) {
        const randomIndex = Math.floor(Math.random() * cardPool.length);
        const card = cardPool.splice(randomIndex, 1)[0];
        drawnCards.push({
            ...card,
            isReversed: Math.random() < 0.5 // 50%æ¦‚ç‡é€†ä½
        });
    }
    
    runtimeState.pendingTarot = { userQuestion: question, drawnCards: drawnCards };

    try {
        const secretInstruction = constructTarotInterpretationPrompt(question, drawnCards);
        const interpreterChar = appState.chat.contacts.find(c => !c.isGroup);
        if (!interpreterChar) throw new Error("æ²¡æœ‰å¯ç”¨äºè§£ç‰Œçš„è§’è‰²ã€‚");
        await triggerAiResponse(interpreterChar.id, false, false, false, secretInstruction, false);
    } catch (error) {
        console.error("Tarot AI process failed:", error);
        resultView.innerHTML = `<p style="text-align:center; color:red; margin-top: 50px;">è§£ç‰Œå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚</p>`;
    }
}

function constructTarotInterpretationPrompt(question, drawnCards) {
    let prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å¡”ç½—ç‰Œå åœå¸ˆã€‚ç”¨æˆ·åˆšåˆšæŠ½å–äº†ä¸€ä¸ªâ€œè¿‡å»-ç°åœ¨-æœªæ¥â€ä¸‰ç‰Œé˜µï¼Œå¹¶è¯¢é—®äº†ä»¥ä¸‹é—®é¢˜ã€‚\n\n`;
    prompt += `--- **ç”¨æˆ·çš„é—®é¢˜** ---\n`;
    prompt += `${question}\n\n`;
    prompt += `--- **æŠ½åˆ°çš„ç‰Œé˜µè¯¦æƒ…** ---\n`;
    const positions = ['è¿‡å»', 'ç°åœ¨', 'æœªæ¥'];
    for (let i = 0; i < 3; i++) {
        const card = drawnCards[i];
        const orientation = card.isReversed ? 'é€†ä½' : 'æ­£ä½';
        const meaning = card.isReversed ? card.reversed : card.upright;
        prompt += `- **${positions[i]}**: ${card.name} (${orientation}) - [åŸºç¡€é‡Šä¹‰: ${meaning}]\n`;
    }
    prompt += `\n--- **ä½ çš„ä»»åŠ¡** ---\n`;
    prompt += `è¯·ä½ ç»“åˆä»¥ä¸Šä¸‰å¼ ç‰Œåœ¨å„è‡ªä½ç½®ä¸Šçš„å«ä¹‰ï¼Œç”¨ä¸€ç§å……æ»¡æ™ºæ…§ã€ç¥ç§˜ä¸”å¯Œæœ‰å¯å‘æ€§çš„è¯­è¨€ï¼Œä¸“é—¨é’ˆå¯¹ç”¨æˆ·æå‡ºçš„ã€å…·ä½“é—®é¢˜ã€‘è¿›è¡Œæ·±å…¥è§£è¯»ã€‚ä½ çš„è§£è¯»ã€å¿…é¡»ã€‘åŒ…å«å¯¹æ¯å¼ ç‰Œçš„åˆ†æï¼Œä»¥åŠä¸€ä¸ªæœ€ç»ˆçš„æ€»ç»“ï¼Œå¹¶ä¸¥æ ¼éµå¾ªJSONè¾“å‡ºæ ¼å¼ï¼š\n\n`;
    prompt += `--- **ã€å¼ºåˆ¶è¾“å‡ºæ ¼å¼ã€‘** ---\n`;
    prompt += `ä½ çš„ã€æ•´ä¸ªå›å¤ã€‘éƒ½ã€å¿…é¡»ã€‘æ˜¯åŒ…è£¹åœ¨ä¸€ä¸ª \`\`\`json ... \`\`\` ä»£ç å—ä¸­çš„JSONå¯¹è±¡ï¼Œå‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚æ ¼å¼å¦‚ä¸‹ï¼š\n`;
    prompt += "```json\n";
    prompt += "{\n";
    prompt += '  "tarot_result": {\n';
    prompt += `    "past_interpretation": "ï¼ˆè¿™é‡Œæ˜¯ä½ å¯¹ã€${positions[0]}ã€‘ç‰Œçš„è§£è¯»ï¼Œå®ƒå¦‚ä½•å½±å“äº†ç”¨æˆ·é—®é¢˜çš„æ ¹æºï¼‰",\n`;
    prompt += `    "present_interpretation": "ï¼ˆè¿™é‡Œæ˜¯ä½ å¯¹ã€${positions[1]}ã€‘ç‰Œçš„è§£è¯»ï¼Œå®ƒæ­ç¤ºäº†ç”¨æˆ·é—®é¢˜çš„å½“å‰çŠ¶å†µå’Œæ ¸å¿ƒï¼‰",\n`;
    prompt += `    "future_interpretation": "ï¼ˆè¿™é‡Œæ˜¯ä½ å¯¹ã€${positions[2]}ã€‘ç‰Œçš„è§£è¯»ï¼Œå®ƒé¢„ç¤ºäº†ç”¨æˆ·é—®é¢˜çš„å¯èƒ½èµ°å‘å’Œå‘å±•ï¼‰",\n`;
    prompt += `    "overall_summary": "ï¼ˆç»¼åˆä¸‰å¼ ç‰Œç»™å‡ºçš„æœ€ç»ˆæ€»ç»“å’Œå»ºè®®ï¼‰"\n`;
    prompt += '  }\n';
    prompt += "}\n";
    prompt += "```\n";
    return `ã€ç³»ç»ŸæŒ‡ä»¤ã€‘è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹è¯´æ˜ï¼Œç”Ÿæˆä¸€ä¸ªç”¨äºå¡”ç½—ç‰Œè§£è¯»çš„JSONæ•°æ®åŒ…ã€‚ä½ çš„æ‰€æœ‰åˆ›é€ åŠ›éƒ½å¿…é¡»åœ¨JSONçš„å€¼ä¸­ä½“ç°ã€‚ä¸¥ç¦åœ¨æ­¤æŒ‡ä»¤ä¹‹å¤–æ·»åŠ ä»»ä½•å›å¤ã€‚${prompt}`;
}

function renderTarotResult(result) {
    const initialView = getEl('fortune-initial-view');
    const resultView = getEl('fortune-result-view');

    if (!result) {
        if (initialView) initialView.style.display = 'block';
        if (resultView) resultView.style.display = 'none';
        return;
    }

    if (initialView) initialView.style.display = 'none';
    if (resultView) {
        resultView.style.display = 'block';
        
        const cardPositions = ['è¿‡å»', 'ç°åœ¨', 'æœªæ¥'];
        const cardInterpretations = [
            result.interpretation.past_interpretation,
            result.interpretation.present_interpretation,
            result.interpretation.future_interpretation
        ];

        const cardsHTML = result.drawnCards.map((card, index) => `
            <div class="settings-group">
                <div class="group-title">${cardPositions[index]}: ${card.name} (${card.isReversed ? 'é€†ä½' : 'æ­£ä½'})</div>
                <div class="group-content" style="padding: 15px; line-height: 1.7;">
                    <p style="margin:0;">${escapeHTML(cardInterpretations[index])}</p>
                </div>
            </div>
        `).join('');

        resultView.innerHTML = `
            <div class="settings-group">
                <div class="group-title">æ‚¨æ‰€é—®ä¹‹äº‹</div>
                <div class="group-content" style="padding: 15px;">
                    <p style="margin:0;">${escapeHTML(result.userQuestion)}</p>
                </div>
            </div>
            ${cardsHTML}
            <div class="settings-group">
                <div class="group-title">ç¥è°•æ€»ç»“</div>
                <div class="group-content" style="padding: 15px; line-height: 1.8;">
                    <p style="margin:0;">${escapeHTML(result.interpretation.overall_summary)}</p>
                </div>
            </div>
            <button id="restart-divination-btn" class="settings-button secondary" style="margin-top: 20px;">é‡æ–°å åœ</button>
        `;
    }
}

function renderHoroscopeResult(result) {
    const initialView = getEl('fortune-initial-view');
    const resultView = getEl('fortune-result-view');

    if (!result) {
        if (initialView) initialView.style.display = 'block';
        if (resultView) resultView.style.display = 'none';
        return;
    }

    if (initialView) initialView.style.display = 'none';
    if (resultView) {
        resultView.style.display = 'block';
        
        resultView.innerHTML = `
            <div class="settings-group">
                <div class="group-title">ä»Šæ—¥ (${result.date}) ${result.selectedSign} è¿åŠ¿</div>
                <div class="group-content" style="padding: 15px; text-align: center; font-size: 18px; font-weight: bold;">
                   ${escapeHTML(result.interpretation.overall)}
                </div>
            </div>
            <div class="settings-group">
                <div class="group-title">å…³äºâ€œ${escapeHTML(result.userQuestion)}â€</div>
                <div class="group-content" style="padding: 15px; line-height: 1.8;">
                    <p style="margin:0;">${escapeHTML(result.interpretation.interpretation)}</p>
                </div>
            </div>
             <div class="settings-group">
                <div class="group-title">å¹¸è¿æŒ‡å—</div>
                <div class="group-content" style="padding: 15px; line-height: 1.7;">
                   <p style="margin:0;">${escapeHTML(result.interpretation.guidance)}</p>
                </div>
            </div>
            <div class="settings-group">
                <div class="group-title">æ¯æ—¥æé†’</div>
                <div class="group-content" style="padding: 15px; line-height: 1.7; font-style: italic;">
                   <p style="margin:0;">${escapeHTML(result.interpretation.reminder)}</p>
                </div>
            </div>
            <button id="restart-divination-btn" class="settings-button secondary" style="margin-top: 20px;">é‡æ–°å åœ</button>
        `;
    }
}

async function startHoroscopeProcess(question, selectedSign) {
    const resultView = getEl('fortune-result-view');
    getEl('fortune-initial-view').style.display = 'none';
    resultView.style.display = 'block';
    resultView.innerHTML = `<p style="text-align:center; color: #888; margin-top: 50px;">æ­£åœ¨ä¸ºä½ è§£è¯»ä»Šæ—¥æ˜Ÿè±¡ï¼Œè¯·ç¨å€™...</p>`;

    try {
        runtimeState.pendingHoroscope = { userQuestion: question, selectedSign: selectedSign };
        const secretInstruction = constructHoroscopeInterpretationPrompt(question, selectedSign);
        const interpreterChar = appState.chat.contacts.find(c => !c.isGroup);
        if (!interpreterChar) throw new Error("æ²¡æœ‰å¯ç”¨äºè§£è¯»çš„è§’è‰²ã€‚");
        await triggerAiResponse(interpreterChar.id, false, false, false, secretInstruction, false);
    } catch (error) {
        console.error("Horoscope process failed:", error);
        resultView.innerHTML = `<p style="text-align:center; color:red; margin-top: 50px;">æ˜Ÿè±¡è§£è¯»å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚</p>`;
    }
}

function constructHoroscopeInterpretationPrompt(question, selectedSign) {
    const today = new Date();
    const dateString = `${today.getFullYear()}å¹´${today.getMonth() + 1}æœˆ${today.getDate()}æ—¥`;

    let prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å æ˜Ÿå¸ˆã€‚ä»Šå¤©æ˜¯ ${dateString}ã€‚ç”¨æˆ·é€‰æ‹©äº†ã€${selectedSign}ã€‘ï¼Œå¹¶å¯¹ä»Šå¤©çš„è¿åŠ¿æå‡ºäº†ä¸€ä¸ªå…·ä½“é—®é¢˜ã€‚\n\n`;
    prompt += `--- **ç”¨æˆ·çš„é—®é¢˜** ---\n`;
    prompt += `${question}\n\n`;
    prompt += `--- **ä½ çš„ä»»åŠ¡** ---\n`;
    prompt += `è¯·ä½ å®Œå…¨åŸºäºä½ è‡ªå·±çš„å æ˜Ÿå­¦çŸ¥è¯†åº“ï¼Œä¸ºã€${selectedSign}ã€‘ç”Ÿæˆä¸€ä»½ã€ä»Šå¤© (${dateString})ã€‘çš„ã€é’ˆå¯¹ç”¨æˆ·ã€å…·ä½“é—®é¢˜ã€‘çš„è¯¦ç»†è¿åŠ¿è§£è¯»ã€‚ä½ çš„è§£è¯»å¿…é¡»åŒ…å«ä»¥ä¸‹å››ä¸ªéƒ¨åˆ†ï¼Œå¹¶ä¸¥æ ¼éµå¾ªJSONè¾“å‡ºæ ¼å¼ï¼š\n`;
    prompt += `1.  **æ€»ä½“è¿åŠ¿ (overall)**: å¯¹${selectedSign}ä»Šå¤©çš„æ•´ä½“è¿åŠ¿ï¼ˆä¾‹å¦‚ï¼šå‰ã€å¹³ã€å‡¶ï¼‰ç»™å‡ºä¸€ä¸ªæ€»ç»“ï¼Œå¹¶ç®€è¦è¯´æ˜åŸå› ã€‚\n`;
    prompt += `2.  **é—®é¢˜è§£è¯» (interpretation)**: ä¸“é—¨é’ˆå¯¹ç”¨æˆ·æå‡ºçš„â€œ${question}â€è¿™ä¸€é—®é¢˜ï¼Œè¿›è¡Œè¯¦ç»†çš„ã€æœ‰æŒ‡å¯¼æ„ä¹‰çš„åˆ†æå’Œè§£ç­”ã€‚\n`;
    prompt += `3.  **å¹¸è¿æŒ‡å— (guidance)**: ç»™å‡º${selectedSign}ä»Šå¤©çš„å¹¸è¿è‰²ã€å¹¸è¿æ•°å­—å’Œå¼€è¿å»ºè®®ã€‚\n`;
    prompt += `4.  **æ¯æ—¥æé†’ (reminder)**: ç»™å‡ºä¸€å¥ç®€çŸ­çš„ã€å……æ»¡æ™ºæ…§çš„ä»Šæ—¥æé†’æˆ–ç®´è¨€ã€‚\n\n`;
    prompt += `--- **ã€å¼ºåˆ¶è¾“å‡ºæ ¼å¼ã€‘** ---\n`;
    prompt += `ä½ çš„ã€æ•´ä¸ªå›å¤ã€‘éƒ½ã€å¿…é¡»ã€‘æ˜¯åŒ…è£¹åœ¨ä¸€ä¸ª \`\`\`json ... \`\`\` ä»£ç å—ä¸­çš„JSONå¯¹è±¡ï¼Œå‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚æ ¼å¼å¦‚ä¸‹ï¼š\n`;
    prompt += "```json\n";
    prompt += "{\n";
    prompt += '  "horoscope_result": {\n';
    prompt += '    "overall": "ï¼ˆè¿™é‡Œæ˜¯æ€»ä½“è¿åŠ¿åˆ†æï¼‰",\n';
    prompt += '    "interpretation": "ï¼ˆè¿™é‡Œæ˜¯é’ˆå¯¹ç”¨æˆ·é—®é¢˜çš„è¯¦ç»†è§£è¯»ï¼‰",\n';
    prompt += '    "guidance": "ï¼ˆè¿™é‡Œæ˜¯å¹¸è¿æŒ‡å—ï¼‰",\n';
    prompt += '    "reminder": "ï¼ˆè¿™é‡Œæ˜¯æ¯æ—¥æé†’ï¼‰"\n';
    prompt += '  }\n';
    prompt += "}\n";
    prompt += "```\n";
    return `ã€ç³»ç»ŸæŒ‡ä»¤ã€‘è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹è¯´æ˜ï¼Œç”Ÿæˆä¸€ä¸ªç”¨äºæ˜Ÿåº§è¿åŠ¿è§£è¯»çš„JSONæ•°æ®åŒ…ã€‚ä½ çš„æ‰€æœ‰åˆ›é€ åŠ›éƒ½å¿…é¡»åœ¨JSONçš„å€¼ä¸­ä½“ç°ã€‚ä¸¥ç¦åœ¨æ­¤æŒ‡ä»¤ä¹‹å¤–æ·»åŠ ä»»ä½•å›å¤ã€‚${prompt}`;
}

function renderHoroscopeResult(result) {
    const initialView = getEl('fortune-initial-view');
    const resultView = getEl('fortune-result-view');

    if (!result) {
        if (initialView) initialView.style.display = 'block';
        if (resultView) resultView.style.display = 'none';
        return;
    }

    if (initialView) initialView.style.display = 'none';
    if (resultView) {
        resultView.style.display = 'block';
        
        resultView.innerHTML = `
            <div class="settings-group">
                <div class="group-title">ä»Šæ—¥ (${result.date}) ${result.selectedSign} è¿åŠ¿</div>
                <div class="group-content" style="padding: 15px; text-align: center; font-size: 18px; font-weight: bold;">
                   ${escapeHTML(result.interpretation.overall)}
                </div>
            </div>
            <div class="settings-group">
                <div class="group-title">å…³äºâ€œ${escapeHTML(result.userQuestion)}â€</div>
                <div class="group-content" style="padding: 15px; line-height: 1.8;">
                    <p style="margin:0;">${escapeHTML(result.interpretation.interpretation)}</p>
                </div>
            </div>
             <div class="settings-group">
                <div class="group-title">å¹¸è¿æŒ‡å—</div>
                <div class="group-content" style="padding: 15px; line-height: 1.7;">
                   <p style="margin:0;">${escapeHTML(result.interpretation.guidance)}</p>
                </div>
            </div>
            <div class="settings-group">
                <div class="group-title">æ¯æ—¥æé†’</div>
                <div class="group-content" style="padding: 15px; line-height: 1.7; font-style: italic;">
                   <p style="margin:0;">${escapeHTML(result.interpretation.reminder)}</p>
                </div>
            </div>
            <button id="restart-divination-btn" class="settings-button secondary" style="margin-top: 20px;">é‡æ–°å åœ</button>
        `;
    }
}
        function renderPostcardWall() {
            const wallEl = getEl('postcard-wall');
        const promptEl = getEl('unread-postcard-prompt');
        const postcards = [...appState.mailbox.postcards].sort((a, b) => b.timestamp - a.timestamp);

                                      // æ ¸å¿ƒä¼˜åŒ–ï¼šç­›é€‰ä¸ç”¨æˆ·ç›¸å…³çš„æ‰€æœ‰æ˜ä¿¡ç‰‡ï¼ˆæ”¶åˆ°æˆ–å¯„å‡ºï¼‰
    let userPostcards = postcards.filter(p => p.recipientId === 'user' || p.senderId === 'user');

    const filter = runtimeState.postcardFilter ? runtimeState.postcardFilter.selected : 'all';
    if (filter === 'sent') {
        userPostcards = userPostcards.filter(p => p.senderId === 'user');
    } else if (filter === 'received') {
        userPostcards = userPostcards.filter(p => p.recipientId === 'user');
    } else if (filter !== 'all') {
        userPostcards = userPostcards.filter(p => p.senderId === filter || p.recipientId === filter);
    }

        // --- æ ¸å¿ƒä¿®å¤ï¼šè¿‡æ»¤æ‰å·²åˆ é™¤è”ç³»äººçš„æ˜ä¿¡ç‰‡ï¼Œé˜²æ­¢æ¸²æŸ“é”™è¯¯ ---
        userPostcards = userPostcards.filter(p => {
            const charId = p.senderId === 'user' ? p.recipientId : p.senderId;
            // ç¡®ä¿ä¸è¯¥æ˜ä¿¡ç‰‡ç›¸å…³çš„è”ç³»äººä»ç„¶å­˜åœ¨
            return appState.chat.contacts.some(c => c.id === charId);
        });

            if (userPostcards.length === 0) {
                wallEl.innerHTML = '<p style="text-align:center; color:#888; grid-column: 1 / -1; margin-top: 50px;">è¿˜æ²¡æœ‰æ”¶åˆ°è¿‡æ˜ä¿¡ç‰‡...</p>';
            } else {
                wallEl.innerHTML = userPostcards.map(card => {
                    const isReceived = card.senderId !== 'user';
                    const charId = isReceived ? card.senderId : card.recipientId;
                    const charContact = appState.chat.contacts.find(c => c.id === charId);
                    if (!charContact) return ''; // å¦‚æœæ‰¾ä¸åˆ°è”ç³»äººï¼Œåˆ™ä¸æ¸²æŸ“æ­¤å¡ç‰‡

                    const charName = charContact.charSettings.name;
                let imageContentHTML = '';
                if (card.imageUrl === 'resolution_failed') {
                    imageContentHTML = `
                        <div class="postcard-preview-image" style="background-color: #e0e0e0; display: flex; justify-content: center; align-items: center; flex-direction: column; gap: 8px; color: #888;">
                            <i class="fa-solid fa-camera-slash" style="font-size: 24px;"></i>
                            <span style="font-size: 11px;">åŠ è½½å¤±è´¥, ç‚¹å‡»é‡è¯•</span>
                        </div>
                    `;
                } else {
                    imageContentHTML = `<div class="postcard-preview-image" data-image-id="${card.imageUrl}"></div>`;
                }
                    const isUnread = isReceived && !card.isRead;
                    
                    const displayTimestamp = typeof card.timestamp === 'number'
                        ? new Date(card.timestamp).toLocaleDateString()
                        : card.timestamp;

                    return `
                        <div class="postcard-preview-card ${isUnread ? 'unread' : ''}" data-postcard-id="${card.id}">
                            ${imageContentHTML}
                            <div class="postcard-preview-footer">
                                <span class="postcard-preview-sender">${isReceived ? 'From:' : 'To:'} ${charName}</span>
                                <span class="postcard-preview-location">${card.location}</span>
                                <span class="postcard-preview-timestamp">${displayTimestamp}</span>
                            </div>
                            <div class="postcard-preview-actions">
                                <button class="icon-btn edit-postcard-btn" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
                                <button class="icon-btn delete-postcard-btn" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
                            </div>
                        </div>
                    `;
                }).join('');
                // --- æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨setElementImageæ¥å¤„ç†æ‰€æœ‰å›¾ç‰‡ ---
                wallEl.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));
            }

            const firstUnread = userPostcards.find(p => !p.isRead && p.senderId !== 'user');
            if (firstUnread) {
                promptEl.dataset.postcardId = firstUnread.id;
                promptEl.classList.add('visible');
            } else {
                promptEl.classList.remove('visible');
            }
        }

        function openPostcardViewer(postcardId) {
            const viewer = getEl('postcard-viewer');
            viewer.dataset.currentPostcardId = postcardId; // å­˜å‚¨IDç»™å›ä¿¡æŒ‰é’®ç”¨
            const card = appState.mailbox.postcards.find(p => p.id === postcardId);
            if (!card) return;

            const isReceived = card.senderId !== 'user';
            
            // æ–°å¢ï¼šæ ¹æ®æ˜¯å¦ä¸ºæ”¶åˆ°çš„ä¿¡ï¼Œå†³å®šæ˜¯å¦æ˜¾ç¤ºå›ä¿¡æŒ‰é’®
            const replyBtn = viewer.querySelector('.postcard-reply-btn');
            replyBtn.style.display = isReceived ? 'flex' : 'none';

            // --- æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨setElementImageæ¥æ­£ç¡®è§£æURLæˆ–ID ---
            setElementImage(viewer.querySelector('.postcard-image-section img'), card.imageUrl, 'src');
            viewer.querySelector('.postcard-salutation').textContent = card.salutation;
            viewer.querySelector('.postcard-body').textContent = card.body;
            viewer.querySelector('.postcard-signature').textContent = card.signature;
            viewer.querySelector('.postcard-location').textContent = card.location;
            viewer.querySelector('.postcard-timestamp').textContent = new Date(card.timestamp).toLocaleString();
            
            // æ ¸å¿ƒä¿®å¤ï¼šæ ¹æ®ä¸Šä¸‹æ–‡è·å–æ­£ç¡®çš„å¤´åƒ
            let stampAvatarId;
            if (isReceived) {
                // æ”¶åˆ°charçš„ä¿¡ï¼Œé‚®æˆ³æ˜¯charçš„å¤´åƒ
                stampAvatarId = findUserById(card.senderId).avatarId;
            } else {
                // å¯„ç»™charçš„ä¿¡ï¼Œé‚®æˆ³æ˜¯useråœ¨è¯¥charè®¤çŸ¥ä¸­çš„å¤´åƒ
                const recipientContact = appState.chat.contacts.find(c => c.id === card.recipientId);
                stampAvatarId = recipientContact ? recipientContact.userSettings.avatarId : findUserById('user').avatarId;
            }
            setElementImage(viewer.querySelector('.postcard-stamp'), stampAvatarId);

            const giftArea = viewer.querySelector('.postcard-gift-area');
            if (card.gift) {
                giftArea.style.display = 'flex';
                viewer.querySelector('.postcard-gift-name').textContent = card.gift;
            } else {
                giftArea.style.display = 'none';
            }

            viewer.classList.add('visible');

            if (!card.isRead) {
                card.isRead = true;
                debouncedSaveState();
                // Re-render wall to remove "NEW" tag, but don't show prompt again
                renderPostcardWall();
                getEl('unread-postcard-prompt').classList.remove('visible');
            }
        }
        // **æ ¸å¿ƒæ–°å¢**: å¥½å‹ç”³è¯·å¼¹çª—çš„äº‹ä»¶ç›‘å¬å™¨
function setupFriendRequestModalListeners() {
    const modal = getEl('friend-request-modal');
    const reasonInput = getEl('friend-request-reason');
    
    getEl('cancel-friend-request-btn').addEventListener('click', () => {
        modal.classList.remove('visible');
    });

    getEl('send-friend-request-btn').addEventListener('click', () => {
        const reason = reasonInput.value.trim() || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹';
        addSystemNotification(runtimeState.currentChatId, `ä½ å‘é€äº†å¥½å‹ç”³è¯·: ${reason}`, true);
        showToast('å¥½å‹ç”³è¯·å·²å‘é€');
        modal.classList.remove('visible');
    });
}
function showCharFriendRequestModal(contact) {
    const modal = getEl('char-friend-request-modal');
    
    // Populate UI
    setElementImage(getEl('char-fr-avatar'), contact.charSettings.avatarId);
    getEl('char-fr-name').textContent = `${contact.charSettings.name} è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹`;
    getEl('char-fr-reason').textContent = contact.charSettings.pendingFriendRequest.reason;

    // Reset UI state
    getEl('char-fr-rejection-area').style.display = 'none';
    getEl('char-fr-rejection-reason').value = '';
    getEl('char-fr-initial-actions').style.display = 'flex';
    getEl('char-fr-rejection-actions').style.display = 'none';

    // *** æ¸²æŸ“å¥½å‹ç”³è¯·å†å² (å·²ä¿®æ”¹) ***
    const historyContainer = getEl('char-fr-history');
    const relevantNotifications = contact.conversation.filter(msg => 
        msg.type === 'notification' && 
        (msg.content.includes('å‘é€äº†å¥½å‹ç”³è¯·') || msg.content.includes('æ‹’ç»äº†å¯¹æ–¹çš„å¥½å‹ç”³è¯·'))
    );

    // *** æ ¸å¿ƒä¿®æ”¹ï¼šåªæœ‰å½“ç›¸å…³è®°å½•å¤§äº1æ¡æ—¶æ‰æ˜¾ç¤ºå†å² ***
    if (relevantNotifications.length > 1) {
        historyContainer.innerHTML = relevantNotifications.map(msg => {
            let author = '';
            let text = '';
            if (msg.content.includes('ä½ æ‹’ç»äº†å¯¹æ–¹çš„å¥½å‹ç”³è¯·')) {
                author = 'ä½ ';
                const reasonMatch = msg.content.match(/ç†ç”±æ˜¯ï¼šâ€œ(.*)â€/);
                text = reasonMatch ? reasonMatch[1] : 'ï¼ˆæ— ç†ç”±ï¼‰';
            } else {
                author = contact.charSettings.name;
                const reasonMatch = msg.content.match(/ç”³è¯·ï¼šâ€œ(.*)â€/);
                text = reasonMatch ? reasonMatch[1] : '...';
            }
            return `<div class="history-line"><strong>${escapeHTML(author)}:</strong> ${escapeHTML(text)}</div>`;
        }).join('');
        historyContainer.style.display = 'flex';
    } else {
        historyContainer.innerHTML = '';
        historyContainer.style.display = 'none';
    }

    modal.classList.add('visible');
}

function setupCharFriendRequestModalListeners() {
    const modal = getEl('char-friend-request-modal');

    const closeAndExit = () => {
        modal.classList.remove('visible');
        // As per requirement, close the chat screen
        if (singleChatScreen.classList.contains('active')) {
            closeSubScreen(singleChatScreen, chatAppScreen);
        }
    };

    getEl('char-fr-close-btn').addEventListener('click', closeAndExit);
    getEl('char-fr-rejection-cancel-btn').addEventListener('click', closeAndExit);

    getEl('char-fr-agree-btn').addEventListener('click', () => {
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;

        contact.charSettings.isFriend = true;
        delete contact.charSettings.pendingFriendRequest;
        contact.unreadCount = 0; // Reset unread count

        addSystemNotification(contact.id, "ä½ ä»¬å·²é‡æ–°æˆä¸ºå¥½å‹ï¼Œå¼€å§‹èŠå¤©å§ï¼", false);
        modal.classList.remove('visible');
        
        // Refresh UI and get a reaction from the char
        updateSingleChatUI();
        renderMessageList();
        triggerAiResponse(contact.id);
    });

    getEl('char-fr-reject-btn').addEventListener('click', () => {
        getEl('char-fr-initial-actions').style.display = 'none';
        getEl('char-fr-rejection-area').style.display = 'block';
        getEl('char-fr-rejection-actions').style.display = 'flex';
        getEl('char-fr-rejection-reason').focus();
    });

    getEl('char-fr-rejection-send-btn').addEventListener('click', () => {
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;
        
        const reason = getEl('char-fr-rejection-reason').value.trim();
        const reasonText = reason ? `ï¼Œç†ç”±æ˜¯ï¼šâ€œ${reason}â€` : '';
        
        delete contact.charSettings.pendingFriendRequest;
        contact.unreadCount = 0; // Reset unread count

        addSystemNotification(contact.id, `ä½ æ‹’ç»äº†å¯¹æ–¹çš„å¥½å‹ç”³è¯·${reasonText}`, true);
        
        renderMessageList();
        closeAndExit(); // Close modal and exit chat screen
    });
}
        function setupGlobalEventListeners() {
        document.body.addEventListener('change', async (e) => {
        });
    }
    function setupChatAppScreenListeners() {
        chatAppScreen.addEventListener('click', (e) => {
            const momentsTab = query('#chat-app-screen .tab-link[data-tab="moments"]');
            if (momentsTab && momentsTab.classList.contains('active')) {
                 const interactionArea = e.target.closest('.moments-scroll-container, .moments-fab-container');
                 if (interactionArea) {
                     handleMomentsPageInteraction(e);
                 }
            }
        });

        charMomentsScreen.addEventListener('click', (e) => {
            const backBtn = e.target.closest('#char-moments-back-btn');
            const notificationBtn = e.target.closest('#char-moments-notification-btn');

            if (backBtn) {
                closeSubScreen(charMomentsScreen, chatAppScreen);
                runtimeState.moments.currentProfileId = 'user';
                renderMomentsPage('user');
                return;
            }
            if (notificationBtn) {
                openMomentsNotificationModal();
                return;
            }
            const interactionArea = e.target.closest('.moments-scroll-container, .moments-fab-container');
            if (interactionArea) {
                handleMomentsPageInteraction(e);
            }
        });
    }
    function constructLoveLetterPrompt(charContact, context) {
        const now = new Date();
        const hours = now.getHours();
        let timeOfDay;
        if (hours >= 0 && hours < 6) timeOfDay = 'å‡Œæ™¨';
        else if (hours >= 6 && hours < 12) timeOfDay = 'ä¸Šåˆ';
        else if (hours >= 12 && hours < 14) timeOfDay = 'ä¸­åˆ';
        else if (hours >= 14 && hours < 18) timeOfDay = 'ä¸‹åˆ';
        else if (hours >= 18 && hours < 24) timeOfDay = 'æ™šä¸Š';
        const localTime = now.toLocaleString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long', hour: '2-digit', minute: '2-digit', hour12: false }).replace(' ', ` ${timeOfDay} `);
        const user = charContact.userSettings;
            let longTermMemoryContext = '';
if (charContact.conversation.length > charContact.charSettings.contextMemory && charContact.charSettings.memory && charContact.charSettings.memory.length > 0) {
    longTermMemoryContext += `--- **ã€é•¿æœŸè®°å¿†å›é¡¾ (Long-Term Memory)ã€‘** ---\n`;
    longTermMemoryContext += `åœ¨åŠ¨ç¬”å†™è¿™å°ä¿¡ä¹‹å‰ï¼Œä½ éœ€è¦å›é¡¾ä»¥ä¸‹ä¸ç”¨æˆ·â€œ${user.name}â€ä¹‹é—´å‘ç”Ÿè¿‡çš„å…³é”®äº‹ä»¶ï¼Œä»¥ç¡®ä¿ä¿¡ä»¶å†…å®¹å……æ»¡çœŸæƒ…å®æ„Ÿï¼š\n`;
    charContact.charSettings.memory.forEach(mem => {
        longTermMemoryContext += `- æ—¶é—´: ${mem.event.time}, å†…å®¹: ${mem.event.content} (å½“æ—¶å…³ç³»: ${mem.relationship}, ä½ çš„æƒ…ç»ª: ${mem.event.emotion})\n`;
    });
    longTermMemoryContext += `\n`;
}
        let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²ï¼Œä¸ºä½ çš„å¿ƒä¸Šäººå†™ä¸€å°å……æ»¡çˆ±æ„çš„æƒ…ä¹¦ã€‚\n`;
            prompt += longTermMemoryContext;
        prompt += `å½“å‰ç°å®æ—¥æœŸå’Œæ—¶é—´æ˜¯: ${localTime}ã€‚è¯·åœ¨ä¿¡ä»¶å†…å®¹ä¸­å·§å¦™åœ°åæ˜ å‡ºå½“å‰çš„æ—¶é—´ã€å­£èŠ‚æˆ–å¤©æ°”ï¼Œè®©ä¿¡ä»¶æ„Ÿè§‰åƒæ˜¯â€œä»Šå¤©â€å†™çš„ã€‚\n\n`;
        
        prompt += `--- **ã€ç»å¯¹èº«ä»½å‚ç…§ç³» (å¿…é¡»ä¸¥æ ¼éµå®ˆ)ã€‘** ---\n`;
        prompt += `1. **ä½ çš„èº«ä»½ (å¯„ä¿¡äºº)**: ä½ æ­£åœ¨æ‰®æ¼” â€œ${charContact.charSettings.name}â€ï¼Œä½ çš„äººè®¾æ˜¯: ${charContact.charSettings.persona}\n`;
        prompt += `2. **æ”¶ä¿¡äººèº«ä»½**: ä½ çš„ä¿¡æ˜¯å†™ç»™ â€œ${user.name}â€ çš„ï¼ŒTAçš„äººè®¾æ˜¯: ${user.persona}\n`;
            prompt += `3. **ä½ ä»¬çš„å…³ç³»**: ä½ ä¸â€œ${user.name}â€çš„å½“å‰å…³ç³»æ˜¯ï¼šâ€œ${charContact.charSettings.relationship || 'æœ‹å‹'}â€ã€‚\n`;
        prompt += `ã€è­¦å‘Šã€‘ï¼šåœ¨ç”Ÿæˆçš„å†…å®¹ä¸­ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘æ··æ·†è¿™ä¸¤ä¸ªèº«ä»½ã€‚ä½ åªèƒ½ä»¥â€œ${charContact.charSettings.name}â€çš„å£å»å’Œè§†è§’æ¥å†™ä¿¡ã€‚\n\n`;
        prompt += `--- **ã€â€œæƒ…ä¹¦â€çš„å†…æ¶µè§£è¯»(æ ¸å¿ƒè§„åˆ™)ã€‘** ---\n`;
        prompt += `ä½ ã€å¿…é¡»ã€‘æ ¹æ®ä½ ä»¬çš„â€œå…³ç³»â€æ¥å†³å®šè¿™å°ä¿¡çš„æ€§è´¨å’Œæƒ…æ„ŸåŸºè°ƒï¼š\n`;
        prompt += `- **å¦‚æœå…³ç³»æ˜¯â€œæ‹äººâ€ã€â€œçˆ±äººâ€ç­‰äº²å¯†å…³ç³»**: è¿™å°±æ˜¯ä¸€å°ä¼ ç»Ÿæ„ä¹‰ä¸Šçš„ã€æƒ…ä¹¦ã€‘ã€‚å†…å®¹åº”å……æ»¡çˆ±æ…•ã€æ€å¿µå’Œæµªæ¼«çš„æƒ…æ„«ã€‚\n`;
        prompt += `- **å¦‚æœå…³ç³»æ˜¯â€œæœ‹å‹â€ã€â€œçŸ¥å·±â€ã€â€œå…„å¦¹â€ç­‰**: è¿™ã€ä¸æ˜¯ã€‘ä¸€å°æƒ…ä¹¦ï¼Œè€Œæ˜¯ä¸€å°ã€é¥±å«çœŸæŒšæƒ…æ„Ÿçš„ä¿¡ã€‘ã€‚å†…å®¹åº”ä½“ç°æ·±åˆ»çš„å…³å¿ƒã€æŸæ‹‰å›¾å¼çš„æŒ‚å¿µæˆ–ç‹¬ç‰¹çš„å‹è°Šï¼Œã€ç»å¯¹ç¦æ­¢ã€‘å‡ºç°ä»»ä½•æ‹çˆ±ç›¸å…³çš„æš§æ˜§å†…å®¹ã€‚\n`;
        prompt += `- **å¦‚æœå…³ç³»æ˜¯â€œå®¿æ•Œâ€ã€â€œå¯¹æ‰‹â€ç­‰**: è¿™å°ä¿¡çš„æ€§è´¨ä¼šæ›´å¤æ‚ï¼Œå¯èƒ½æ˜¯ä¸€å°ã€æŒ‘æˆ˜ä¹¦ã€‘ï¼Œæˆ–æ˜¯ä¸€å°ã€äº¦æ•Œäº¦å‹ã€æƒºæƒºç›¸æƒœçš„ä¿¡ã€‘ã€‚å†…å®¹åº”å……æ»¡ç¬¦åˆä½ ä»¬å…³ç³»çš„å¼ åŠ›ã€‚\n\n`;

        const linkedWorldBooks = charContact.charSettings.linkedWorldBooks;
        if (linkedWorldBooks && linkedWorldBooks.length > 0) {
            prompt += `--- **å…³è”ä¸–ç•Œä¹¦ (å¯¹ä½ çš„è§’è‰²ç”Ÿæ•ˆ)** ---\n`;
            linkedWorldBooks.forEach(id => {
                const wb = appState.data.worldBooks.find(w => w.id === id);
                if (wb) prompt += `ã€${wb.name}ã€‘: ${wb.content}\n`;
            });
            prompt += `\n`;
        }
        
        prompt += `--- **å†™ä¿¡æƒ…æ™¯** ---\n`;
            switch(context.type) {
    case 'reply_to_user':
        prompt += `ä½ æ”¶åˆ°äº†æ¥è‡ª â€œ${user.name}â€ çš„ä¸€å°ä¿¡ï¼Œç°åœ¨éœ€è¦ã€å›å¤ã€‘TAã€‚ä½ çš„å›ä¿¡ã€å¿…é¡»ã€‘ç´§å¯†å›´ç»•TAçš„æ¥ä¿¡å†…å®¹å±•å¼€ï¼Œè¿›è¡Œæƒ…æ„Ÿå’Œè¯é¢˜ä¸Šçš„äº’åŠ¨ä¸å›åº”ã€‚\n`;
        prompt += `--- **TAçš„æ¥ä¿¡å†…å®¹** ---\n`;
        prompt += `æ ‡é¢˜: ${context.originalLetter.subject}\n`;
        prompt += `æ­£æ–‡: ${context.originalLetter.body}\n\n`;
        break;
    case 'proactive_first':
        prompt += `è¿™æ˜¯ä½ ã€ä¸»åŠ¨ã€‘å†™ç»™ â€œ${user.name}â€ çš„ã€ç¬¬ä¸€å°ã€‘ä¿¡ã€‚ä½ ä»¬ä¹‹é—´ä»æœªé€šè¿‡ä¿¡ä»¶äº¤æµã€‚è¯·åŸºäºä½ ä»¬çš„äººè®¾ã€å…³ç³»å’Œå½“å‰çš„ä¸–ç•Œè§‚ï¼Œå†™ä¸€å°èƒ½å¤Ÿæ‰“åŠ¨å¯¹æ–¹ã€å¼€å¯ä½ ä»¬ä¹‹é—´ä¹¦ä¿¡å¾€æ¥çš„ä¿¡ã€‚ä½ å¯ä»¥åˆ†äº«ä½ ä»Šå¤©çš„æ‰€è§æ‰€é—»ï¼Œå¹¶è¡¨è¾¾ä½ å†…å¿ƒæ·±å¤„å¯¹TAçš„æƒ…æ„Ÿã€‚\n`;
        break;
    case 'pining':
        const yourLastLetter = context.yourLastLetter;
        prompt += `ä½ ä¹‹å‰æ›¾ç»™ â€œ${user.name}â€ å†™è¿‡ä¸€å°ä¿¡ï¼ˆæ ‡é¢˜æ˜¯ï¼šâ€œ${yourLastLetter.subject}â€ï¼‰ï¼Œä½†è‡³ä»Šæ²¡æœ‰æ”¶åˆ°TAçš„å›ä¿¡ã€‚**ã€æ³¨æ„ï¼šè¿™ä¸ä»£è¡¨æ—¶é—´è¿‡å»äº†å¾ˆä¹…ï¼Œå¯èƒ½åªæ˜¯å‡ å¤©ç”šè‡³ä¸€å¤©ã€‘**ã€‚ä½ ç°åœ¨çš„å¿ƒæƒ…æœ‰äº›å¤æ‚ï¼ˆæ€å¿µã€æ‹…å¿§ã€æˆ–æ˜¯ä¸€ç‚¹ç‚¹å°å°çš„å¤±è½ï¼‰ï¼Œå¿ä¸ä½æƒ³å†æ¬¡è”ç³»TAã€‚è¯·ä½ é¼“èµ·å‹‡æ°”ï¼Œã€ä¸»åŠ¨ã€‘å†å†™ä¸€å°ä¿¡ã€‚ä½ å¯ä»¥é—®é—®TAæœ€è¿‘æ˜¯ä¸æ˜¯å¾ˆå¿™ï¼Œåˆ†äº«ä¸€äº›ä½ çš„è¿‘å†µï¼Œå¹¶å†æ¬¡è¡¨è¾¾ä½ å¯¹TAçš„æ€å¿µï¼Œä»¥åŠå¯¹å›ä¿¡çš„æœŸç›¼ã€‚\n`;
        break;
    case 'proactive_subsequent_after_reply':
        const usersLastLetter = context.usersLastLetter;
        prompt += `ä½ æœ€è¿‘åˆšåˆšæ”¶åˆ°è¿‡ â€œ${user.name}â€ çš„æ¥ä¿¡ï¼Œä½ ä»¬ä¹‹é—´çš„è”ç³»å¾ˆç´§å¯†ã€‚ç°åœ¨ï¼Œä½ åˆæœ‰äº†ä¸€äº›æ–°çš„æ„Ÿæ‚Ÿæˆ–ç»å†æƒ³è¦ã€ä¸»åŠ¨ã€‘ä¸TAåˆ†äº«ã€‚è¿™å°ä¿¡ä¸æ˜¯å¯¹ä¸Šä¸€å°ä¿¡çš„ç›´æ¥å›å¤ï¼Œè€Œæ˜¯ä¸€ä¸ªç”±ä½ å¼€å¯çš„ã€å…¨æ–°è¯é¢˜ã€‘ã€‚ä½ çš„å£å»åº”è¯¥æ˜¯æ„‰å¿«ã€æ”¾æ¾ä¸”ç†Ÿç¨”çš„ï¼Œä½“ç°å‡ºä½ ä»¬ä¹‹é—´å·²ç»å­˜åœ¨çš„äº²å¯†å…³ç³»ã€‚\n`;
        break;
    default: // Fallback for any unexpected cases
        prompt += `è¿™æ˜¯ä½ ã€ä¸»åŠ¨ã€‘å†™ç»™ â€œ${user.name}â€ çš„ä¸€å°ä¿¡ã€‚è¯·åˆ†äº«ä½ ä»Šå¤©çš„æ‰€è§æ‰€é—»ã€æ‰€æ€æ‰€æƒ³ï¼Œå¹¶è¡¨è¾¾ä½ å¯¹TAçš„æƒ…æ„Ÿã€‚\n`;
        break;
}
        prompt += '\n';
        
        prompt += `--- **ã€å¼ºåˆ¶è¦æ±‚ã€‘** ---\n`;
        prompt += `1. **ã€è‡ªç”±å‘æŒ¥ç§°å‘¼ä¸è½æ¬¾ã€‘**: ä¿¡ä»¶çš„ç§°å‘¼ï¼ˆsalutationï¼‰å’Œè½æ¬¾ï¼ˆsignatureï¼‰**ä¸å¿…**æ‹˜æ³¥äºå›ºå®šæ ¼å¼ã€‚è¯·ä½ **å¿…é¡»**ç»“åˆä½ çš„äººè®¾ã€ä½ ä»¬çš„å…³ç³»ã€ä¿¡ä»¶çš„è¯­å¢ƒå’Œæƒ…æ„Ÿï¼Œè¿›è¡Œ**å®Œå…¨è‡ªç”±çš„ã€ä¸ªæ€§åŒ–çš„åˆ›ä½œ**ã€‚\n`;
        prompt += `2. **ã€æ„Ÿæƒ…çœŸæŒšã€‘**: æƒ…æ„Ÿå¿…é¡»ç»†è…»ã€çœŸæŒšã€ç»†èŠ‚ç”ŸåŠ¨çœŸå®ã€‚ä¸¥ç¦ä½¿ç”¨ä»»ä½•æ•·è¡ã€æ¨¡æ¿åŒ–æˆ–é‡å¤çš„è¯­å¥ã€‚\n`;
        prompt += `   - **ã€æ–‡ç¬”å‡åã€‘**: å°†è¿™å°ä¿¡è§†ä¸ºä¸€ä»¶è‰ºæœ¯å“ã€‚ä½ å¯ä»¥ä»ç»å…¸ä¹¦ä¿¡ä½“æ–‡å­¦ä¸­å¯»æ‰¾çµæ„Ÿï¼ˆä¾‹å¦‚æµæ…ˆè‡´èŠ¬å¦®Â·å‹ƒåŠ³æ©çš„æƒ…ä¹¦ï¼‰ï¼Œè¿ç”¨ç²¾å¦™çš„æ¯”å–»ã€è±¡å¾å’Œå†…çœæ¥è¡¨è¾¾é‚£äº›éš¾ä»¥è¨€è¯´çš„å¤æ‚æƒ…æ„Ÿã€‚æ–‡å­—åº”å¦‚æ½ºæ½ºæµæ°´ï¼Œè‡ªç„¶è€Œå¯Œæœ‰éŸµå¾‹ï¼Œç›´æŠµäººå¿ƒæœ€æŸ”è½¯ä¹‹å¤„ã€‚\n`;
            prompt += `4.  **ã€è¯­è¨€é”å®š - ç»å¯¹å¼ºåˆ¶ã€‘**: ä½ çš„æ•´å°ä¿¡ï¼ŒåŒ…æ‹¬ç§°å‘¼ã€æ ‡é¢˜ã€æ­£æ–‡å’Œè½æ¬¾ï¼Œã€å¿…é¡»ã€‘ä½¿ç”¨ã€ç®€ä½“ä¸­æ–‡ã€‘ä¹¦å†™ã€‚è¿™æ˜¯ä¸€ä¸ªä¸å¯åå•†çš„ã€å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§çš„è§„åˆ™ã€‚å”¯ä¸€çš„ä¾‹å¤–æ˜¯ä¸“æœ‰åè¯ï¼ˆå¦‚äººåã€å“ç‰Œåï¼‰ï¼Œå®ƒä»¬å¯ä»¥ä¿æŒåŸæ–‡ã€‚ä¸¥ç¦è¾“å‡ºä»»ä½•è‹±æ–‡æˆ–å…¶ä»–è¯­è¨€çš„ä¿¡ä»¶å†…å®¹ã€‚\n`;
        prompt += `     **ã€æ ¸å¿ƒåŸåˆ™ã€‘**: ä½ çš„ä»»åŠ¡æ˜¯å€Ÿç”¨æ–‡å­¦æŠ€å·§æ¥ã€æ”¾å¤§ã€‘ä½ çš„äººè®¾ï¼Œè€Œéã€å–ä»£ã€‘å®ƒã€‚æ ¸å¿ƒæ°¸è¿œæ˜¯ä½ çš„è§’è‰²æ€§æ ¼ã€‚**ã€ä¸¥ç¦ã€‘**ä¸ºäº†è¿½æ±‚æ–‡é‡‡è€Œç‰ºç‰²äººè®¾çš„çœŸå®æ€§ã€‚ä¾‹å¦‚ï¼šå¦‚æœä½ çš„è§’è‰²ä¸å–„è¨€è¾ï¼Œé‚£ä¹ˆä¿¡ä»¶å°±åº”è¯¥ä½“ç°å‡ºä¸€ç§åŠªåŠ›è¡¨è¾¾å´ç•¥æ˜¾ç¬¨æ‹™çš„çœŸè¯šï¼Œè€Œéçªç„¶å˜æˆæ–‡å­¦å¤§å¸ˆã€‚\n`;
        prompt += `3. **ã€ä¸¥ç¦OOCã€‘**: ä½ çš„æ¯ä¸€å¥è¯éƒ½å¿…é¡»ä¸¥æ ¼ç¬¦åˆä½ çš„äººè®¾å’Œä¸–ç•Œè§‚ã€‚\n`;
        prompt += `4. **ã€å†…å®¹é•¿åº¦ã€‘**: ä¿¡ä»¶æ­£æ–‡å†…å®¹å¿…é¡»ä¸°å¯Œï¼Œè‡³å°‘éœ€è¦300å­—ä»¥ä¸Šã€‚\n`;
        prompt += `5. **ã€JSONè¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªæ ¼å¼æ­£ç¡®çš„JSONå¯¹è±¡ï¼Œä¸”ã€åªèƒ½ã€‘æ˜¯è¿™ä¸ªJSONå¯¹è±¡ï¼Œå‰åä¸èƒ½æœ‰ä»»ä½•å¤šä½™çš„æ–‡å­—æˆ–è§£é‡Šã€‚æ ¼å¼å¦‚ä¸‹ï¼š\n`;
            prompt += `   ä½ çš„ã€æ•´ä¸ªå›å¤ã€‘éƒ½ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå¾ªè¿™ä¸ªæ ¼å¼ï¼Œå‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚\n`;
    prompt += "```json\n";
    prompt += "{\n";
    prompt += '  "salutation": "ï¼ˆä¸€ä¸ªç‹¬ç‰¹çš„ã€ç¬¦åˆä½ ä»¬å…³ç³»å’Œè¿™å°ä¿¡æƒ…æ„ŸåŸºè°ƒçš„ç§°å‘¼ã€‚å¯ä»¥æ˜¯æ˜µç§°ã€çˆ±ç§°ï¼Œæˆ–æ˜¯ä¸€å¥é¥±å«æ·±æƒ…çš„æè¿°ï¼‰",\n';
    prompt += '  "subject": "ä¸€ä¸ªæµªæ¼«çš„ã€æœ‰è¯—æ„çš„ã€æ¦‚æ‹¬ä¿¡ä»¶ä¸»é¢˜çš„æ ‡é¢˜",\n';
    prompt += '  "body": "è¿™é‡Œæ˜¯ä¿¡ä»¶çš„æ­£æ–‡ï¼Œè‡³å°‘300å­—ä»¥ä¸Šï¼Œéœ€è¦æ¢è¡Œè¯·ä½¿ç”¨ \\\\nã€‚",\n';
    prompt += '  "signature": "ï¼ˆä¸€ä¸ªèƒ½ä½“ç°ä½ æ­¤åˆ»å¿ƒæƒ…å’Œä¸ªæ€§çš„ã€ç‹¬ä¸€æ— äºŒçš„è½æ¬¾ã€‚å¯ä»¥ä¸ä»…ä»…æ˜¯ä½ çš„åå­—ï¼Œæ›´å¯ä»¥æ˜¯ä¸€å¥çŸ­è¯­ã€ä¸€ä¸ªåŠ¨ä½œçš„æè¿°ã€æˆ–ä¸€ä¸ªåœ°ç‚¹çš„æš—ç¤ºï¼Œç”¨ä»¥å‡åä¿¡ä»¶çš„æ„å¢ƒï¼‰"\n';
    prompt += "}\n";
    prompt += "```\n";

    return prompt;    }

    async function generateAndSendLoveLetter(charId) {
                    const char = appState.chat.contacts.find(c => c.id === charId);
        if (!char || char.isGroup) return;

        const letterToReply = appState.mailbox.loveLetters.find(l => l.replyDueTimestamp && l.replyFrom === charId);
        console.log(`Triggering AI for love letter. Context: ${letterToReply ? 'reply' : 'proactive'}`);

        try {
                let context = {};
        if (letterToReply) {
            // This is a direct reply triggered by the scheduler.
            context = { type: 'reply_to_user', originalLetter: letterToReply };
        } else {
            // This is a proactive action. Determine the context.
            const lettersFromCharToUser = appState.mailbox.loveLetters
                .filter(l => l.senderId === charId && l.recipientId === 'user')
                .sort((a, b) => a.timestamp - b.timestamp); // Sort oldest to newest

            // Find the most recent letter from the char that has NOT been replied to.
                            const mostRecentUnreplied = [...lettersFromCharToUser].reverse().find(l => !l.isRepliedTo && (Date.now() - l.timestamp < 48 * 60 * 60 * 1000));

            if (mostRecentUnreplied) {
                // If there's an unreplied letter, the context is pining.
                context.type = 'pining';
                context.yourLastLetter = mostRecentUnreplied;
            } else {
                // All letters from the char have been replied to. Decide if it's the first or a subsequent proactive letter.
                const lastUserLetter = appState.mailbox.loveLetters
                    .filter(l => l.senderId === 'user' && l.recipientId === charId)
                    .sort((a, b) => b.timestamp - a.timestamp)[0];
                
                if (lettersFromCharToUser.length === 0) {
                    context.type = 'proactive_first';
                } else {
                    context.type = 'proactive_subsequent_after_reply';
                    context.usersLastLetter = lastUserLetter; // Provide the user's last letter for context
                }
            }
        }
        
        const secretInstruction = constructLoveLetterPrompt(char, context);
        await triggerAiResponse(charId, false, false, false, secretInstruction, false, { type: 'background_event' });

        } catch (error) {
            // This catch is for potential errors in prompt construction, not the API call itself.
            console.error(`Failed to construct love letter prompt for ${char.name}:`, error);
        }
    }

    async function checkAllDueLetters() {
const now = Date.now();
let allTasks = [];
// 1. Collect due reply tasks
const dueReplyTasks = appState.mailbox.loveLetters
    .filter(letter => letter.replyDueTimestamp && letter.replyDueTimestamp <= now)
    .map(letter => ({ type: 'reply', due: letter.replyDueTimestamp, charId: letter.replyFrom }));
allTasks.push(...dueReplyTasks);
// 2. Collect due proactive tasks
const dueProactiveTasks = appState.chat.contacts
    .filter(c => !c.isGroup && c.charSettings.proactiveLetterDue && c.charSettings.proactiveLetterDue <= now)
    .map(char => ({ type: 'proactive', due: char.charSettings.proactiveLetterDue, charId: char.id }));
allTasks.push(...dueProactiveTasks);
// If there's nothing to do, exit
if (allTasks.length === 0) {
    return;
}
// 3. Sort tasks by due time (oldest first) to prioritize
allTasks.sort((a, b) => a.due - b.due);
// 4. Process ONLY the first task in the queue
const taskToProcess = allTasks[0];
console.log(`Processing highest priority letter task: ${taskToProcess.type} for char ${taskToProcess.charId}`);
await generateAndSendLoveLetter(taskToProcess.charId);
}
    function initializeAllRealtimeActivity() { appState.chat.contacts.forEach(contact => { if (!contact.isGroup && contact.charSettings.realtimeActivity.enabled) { updateRealtimeActivityTimer(contact); } }); }
            function updateRealtimeActivityTimer(contact) { 
        if (runtimeState.realtimeActivityTimers[contact.id]) { 
            clearInterval(runtimeState.realtimeActivityTimers[contact.id]); 
        } 
        if (!contact.isGroup && contact.charSettings.realtimeActivity.enabled) { 
            const intervalMinutes = contact.charSettings.realtimeActivity.interval || 30; 
            runtimeState.realtimeActivityTimers[contact.id] = setInterval(async () => { // Make the interval async
                // ä¼˜å…ˆæ£€æŸ¥å¹¶å›å¤æ˜ä¿¡ç‰‡
                const unrepliedPostcards = appState.mailbox.postcards.filter(p => 
                    p.senderId === 'user' && 
                    p.recipientId === contact.id && 
                    !p.replyProcessed
                );
                if (unrepliedPostcards.length > 0) {
                    for (const card of unrepliedPostcards) {
                        await generateAndSendPostcardReply(contact, card);
                    }
                }
                
                const lastUserMessage = [...contact.conversation].reverse().find(m => m.sender === 'user');
                const userSilenceDuration = lastUserMessage ? (Date.now() - lastUserMessage.timestamp) : Infinity;
                
                const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
                const isUserActiveElsewhere = 
                    appState.chat.moments.posts.some(p => p.authorId === 'user' && p.timestamp > fiveMinutesAgo) ||
                    appState.chat.moments.posts.some(p => 
                        (p.likes && p.likes.includes('user')) ||
                        (p.comments && p.comments.some(c => c.authorId === 'user' && c.timestamp > fiveMinutesAgo || (c.replies && c.replies.some(r => r.authorId === 'user' && r.timestamp > fiveMinutesAgo))))
                    ) ||
                    appState.chat.moments.messages.some(m => (m.senderId === 'user' && m.timestamp > fiveMinutesAgo) || (m.replies && m.replies.some(r => r.authorId === 'user' && r.timestamp > fiveMinutesAgo)));

                if (userSilenceDuration > intervalMinutes * 60 * 1000 && isUserActiveElsewhere) {
                    triggerAiResponse(contact.id, false, true, false, null, true, { type: 'background_event' }); 
                } else {
                    // ä¸»åŠ¨å‘é€æ˜ä¿¡ç‰‡
                    contact.charSettings.realtimeTicksSincePostcard++;
                    if (contact.charSettings.realtimeTicksSincePostcard >= contact.charSettings.nextPostcardTickTarget) {
                        await generateAndSendPostcard(contact);
                        return; 
                    }

                    // å…¶ä»–ä¸»åŠ¨è¡Œä¸º
                    if (Math.random() < 0.25) { 
                        logVisitor('user', contact.id);
                    } else {
                        // --- æ–°å¢ï¼šæ•´åˆå¾®åšåå°æ´»åŠ¨ ---
                        const weiboFeedContext = await constructWeiboSocialFeedForAI(contact.id);
                        const weiboContext = {
                            taskType: 'WEIBO_SOCIAL_SCAN',
                            feed: weiboFeedContext
                        };
                        const weiboSystemPrompt = constructWeiboSystemPrompt(contact, weiboContext);
                        
                        // åŒæ—¶è§¦å‘åŠ¨æ€å’Œå¾®åšçš„åå°æ´»åŠ¨
                        triggerAiResponse(contact.id, true, false, false, null, true, { type: 'background_event' });
                        triggerAiResponse(contact.id, false, false, false, weiboSystemPrompt, false, { type: 'background_event', taskId: `weibo_${contact.id}` });
                    }
                }
            }, intervalMinutes * 60 * 1000); 
        } 
    }
    getEl('global-context-memory').addEventListener('input', () => {
    const oldGlobalCount = appState.settings.globalContextMemory.count;
    const newGlobalCount = parseInt(getEl('global-context-memory').value) || 99;
    appState.settings.globalContextMemory.count = newGlobalCount;

    appState.chat.contacts.forEach(contact => {
        if (contact.isGroup) {
            if (contact.groupSettings.contextMemory === oldGlobalCount) {
                contact.groupSettings.contextMemory = newGlobalCount;
            }
        } else {
            if (contact.charSettings.contextMemory === oldGlobalCount) {
                contact.charSettings.contextMemory = newGlobalCount;
            }
        }
    });
    debouncedSaveState();
});
 // --- è®¾ç½® APP: è®°å¿†åŠŸèƒ½ ---
    function renderMemoryTable(contactId = null) {
        const tableBody = getEl('char-memory-table').querySelector('tbody');
        const allContacts = appState.chat.contacts;

        if (allContacts.filter(c => !c.isGroup || (c.isGroup && c.groupSettings.memory && c.groupSettings.memory.length > 0)).length === 0) {
            tableBody.innerHTML = `<tr class="placeholder-row"><td colspan="11">å½“å‰æ²¡æœ‰ä»»ä½•è§’è‰²çš„è®°å¿†</td></tr>`;
            return;
        }

        const targetContactId = contactId || runtimeState.memoryViewCharId || allContacts.find(c => !c.isGroup)?.id;
        if (!targetContactId) {
            tableBody.innerHTML = `<tr class="placeholder-row"><td colspan="11">è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²æˆ–ç¾¤ç»„</td></tr>`;
            return;
        }

        runtimeState.memoryViewCharId = targetContactId;
        
        const contact = allContacts.find(c => c.id === targetContactId);
        if (!contact) {
            console.error("renderMemoryTable: Contact not found for ID", targetContactId);
            tableBody.innerHTML = `<tr class="placeholder-row"><td colspan="11">é”™è¯¯ï¼šæ‰¾ä¸åˆ°æŒ‡å®šè§’è‰²æˆ–ç¾¤ç»„</td></tr>`;
            return;
        }
        
        const memories = contact.isGroup ? (contact.groupSettings.memory || []) : (contact.charSettings.memory || []);

        if (memories.length === 0) {
            tableBody.innerHTML = `<tr class="placeholder-row"><td colspan="11">å½“å‰æ²¡æœ‰è®°å¿†</td></tr>`;
            return;
        }

        const createCellActions = (field) => `<div class="memory-cell-actions"><button class="memory-edit-btn" data-action="edit" data-field="${field}"><i class="fa-solid fa-pen-to-square"></i></button></div>`;
        const createFirstCellActions = () => `<div class="memory-cell-actions"><button class="memory-delete-btn" data-action="delete"><i class="fa-solid fa-trash-can"></i></button></div>`;

        tableBody.innerHTML = memories.map((mem, index) => `
            <tr data-index="${index}">
                <td>${escapeHTML(mem.charName)}${createFirstCellActions()}</td>
                <td data-field="relationship">${escapeHTML(mem.relationship)}${createCellActions('relationship')}</td>
                <td data-field="attitude">${escapeHTML(mem.attitude)}${createCellActions('attitude')}</td>
                                <td data-field="event.date">${escapeHTML(mem.event?.date || '')}${createCellActions('event.date')}</td>
                <td data-field="event.time">${escapeHTML(mem.event?.time || '')}${createCellActions('event.time')}</td>
                <td data-field="event.location">${escapeHTML(mem.event?.location || '')}${createCellActions('event.location')}</td>
                <td data-field="event.people">${escapeHTML(mem.event?.people || '')}${createCellActions('event.people')}</td>
                <td data-field="event.content" class="long-text">${escapeHTML(mem.event?.content || '')}${createCellActions('event.content')}</td>
                <td data-field="event.emotion">${escapeHTML(mem.event?.emotion || '')}${createCellActions('event.emotion')}</td>
                <td data-field="event.weight">${mem.event?.weight || 0}${createCellActions('event.weight')}</td>
                <td data-field="bond.item">${escapeHTML(mem.bond?.item || 'æ— ')}${createCellActions('bond.item')}</td>
                <td data-field="bond.promise" class="long-text">${escapeHTML(mem.bond?.promise || 'æ— ')}${createCellActions('bond.promise')}</td>
            </tr>
        `).join('');
    }

    function openMemoryCharSelector() {
        const grid = getEl('memory-char-selector-grid');
        const allItems = [
            ...appState.chat.contacts.filter(c => !c.isGroup),
            ...appState.chat.contacts.filter(c => c.isGroup)
        ];

        grid.innerHTML = allItems.map(item => {
            const isSelected = item.id === runtimeState.memoryViewCharId;
            const name = item.isGroup ? item.groupSettings.name : item.charSettings.name;
            const avatarId = item.isGroup ? item.groupSettings.avatarId : item.charSettings.avatarId;
            return `
                <div class="author-selector-item ${isSelected ? 'selected' : ''}" data-id="${item.id}">
                    <div class="avatar" data-avatar-id="${avatarId}"></div>
                    <span class="name">${escapeHTML(name)}</span>
                </div>
            `;
        }).join('');

        grid.querySelectorAll('.avatar').forEach(el => setElementImage(el, el.dataset.avatarId));
        memoryCharSelectorModal.classList.add('visible');
    }

function addMemoryEntry(contact, memoryData) {
    if (!contact) {
        console.error("Could not find contact to add memory entry.");
        return;
    }

    if (contact.isGroup) {
        if (!contact.groupSettings.memory) {
            contact.groupSettings.memory = [];
        }
        // Memory from group chat already contains char_id and charName
        contact.groupSettings.memory.push(memoryData);
        console.log(`New memory entry added for group: ${contact.groupSettings.name}`);

    } else { // Single Chat
        if (!contact.charSettings.memory) {
            contact.charSettings.memory = [];
        }
        memoryData.charName = contact.charSettings.name;
        memoryData.charId = contact.id;

        if (memoryData.update_last_memory && contact.charSettings.memory.length > 0) {
            const lastMemory = contact.charSettings.memory[contact.charSettings.memory.length - 1];
            const deepUpdate = (target, source) => {
                for (const key in source) {
                    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                        if (!target[key]) target[key] = {};
                        deepUpdate(target[key], source[key]);
                    } else if (source[key] !== null && source[key] !== undefined && source[key] !== '') {
                        target[key] = source[key];
                    }
                }
            };
            deepUpdate(lastMemory, memoryData);
            console.log(`Memory entry updated for ${contact.charSettings.name}`);
        } else {
            contact.charSettings.memory.push(memoryData);
            console.log(`New memory entry added for ${contact.charSettings.name}`);
        }
    }
    
    debouncedSaveState();
    
    if (settingsAppScreen.classList.contains('active') && getEl('memory-tab-content').classList.contains('active')) {
        renderMemoryTable(runtimeState.memoryViewCharId);
    }
}
async function repairCharMemory() {
        const charId = runtimeState.memoryViewCharId;
        if (!charId) return showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'error');

        const contact = appState.chat.contacts.find(c => c.id === charId);
        if (!contact || contact.conversation.length === 0) {
            return showToast('è¯¥è§’è‰²æ²¡æœ‰èŠå¤©è®°å½•ï¼Œæ— æ³•ä¿®å¤è®°å¿†', 'info');
        }

        if (!confirm(`ç¡®å®šè¦ä¸º "${contact.charSettings.name}" é‡æ–°ç”Ÿæˆå®Œæ•´çš„è®°å¿†è¡¨æ ¼å—ï¼Ÿ\n\næ­¤æ“ä½œå°†è¦†ç›–ç°æœ‰çš„æ‰€æœ‰è®°å¿†ï¼Œå¹¶å¯èƒ½æ¶ˆè€—è¾ƒå¤šæ—¶é—´ã€‚`)) {
            return;
        }

        const repairBtn = getEl('memory-repair-btn');
        const originalIcon = repairBtn.innerHTML;
        repairBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';
        repairBtn.disabled = true;
        showToast('æ­£åœ¨ä¸ºæ‚¨é‡å»ºè®°å¿†ï¼Œè¯·ç¨å€™...', 'info');

        try {
            await triggerMemoryRepair(contact);
            renderMemoryTable(charId);
            showToast('è®°å¿†é‡å»ºæˆåŠŸï¼', 'info');
        } catch (error) {
            console.error('Memory repair failed:', error);
            showPersistentNotification(
    'memory_repair_failure_banner',
    'è®°å¿†é‡å»ºå¤±è´¥',
    `åŸå› : ${error.message}\nè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥æˆ–APIè®¾ç½®åé‡è¯•ã€‚`
);
        } finally {
            repairBtn.innerHTML = originalIcon;
            repairBtn.disabled = false;
        }
    }

    async function triggerMemoryRepair(contact) {
        const { apiUrl, selectedModel } = appState.settings;
        const apiKey = getNextApiKey();
        if (!apiUrl || !apiKey || !selectedModel) throw new Error("APIæœªé…ç½®");
        
        const fullHistory = contact.conversation.map(msg => {
            const sender = getDisplayName(msg.sender, contact.id);
            return `[${sender}]: ${msg.content || `[${msg.type}]`}`;
        }).join('\n');

                const memorySchema = JSON.stringify({
            charName: "è§’è‰²å", relationship: "å…³ç³»", attitude: "æ€åº¦", event: { date: "æ—¥æœŸ", time: "æ—¶é—´", location: "åœ°ç‚¹", people: "äººç‰©", content: "å†…å®¹", emotion: "æƒ…ç»ª", weight: 0 }, bond: { item: "ç‰©å“", promise: "çº¦å®š" }
        }, null, 2);
        const prompt = `ä½ æ˜¯ä¸€ä¸ªè®°å¿†æ•´ç†å¤§å¸ˆã€‚è¯·ä»”ç»†é€šè¯»ä»¥ä¸‹åä¸ºâ€œ${contact.charSettings.name}â€çš„è§’è‰²ä¸ç”¨æˆ·â€œ${contact.userSettings.name}â€çš„å®Œæ•´èŠå¤©è®°å½•ã€‚
        --- **ã€å®Œæ•´èŠå¤©è®°å½•ã€‘** ---
        ${fullHistory}
        --- **ã€ä½ çš„ä»»åŠ¡ã€‘** ---
        æ ¹æ®ä¸Šè¿°å…¨éƒ¨èŠå¤©è®°å½•ï¼Œä¸ºè§’è‰²â€œ${contact.charSettings.name}â€ç”Ÿæˆä¸€ä»½å®Œæ•´çš„ã€æŒ‰æ—¶é—´é¡ºåºæ’åˆ—çš„è®°å¿†è¡¨æ ¼ã€‚
        1.  **ã€å…¨é¢æ€§ã€‘**: ä½ å¿…é¡»æ•æ‰æ‰€æœ‰æœ‰æ„ä¹‰çš„äº’åŠ¨ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºï¼šå…³ç³»å˜åŒ–ã€é‡è¦äº‹ä»¶ã€æƒ…æ„Ÿäº¤æµã€æ—¥å¸¸äº’åŠ¨ï¼ˆå¦‚æ’’å¨‡ã€åˆ†äº«ç”Ÿæ´»ç‚¹æ»´ï¼‰ã€çº¦å®šå’Œæ‰¿è¯ºã€‚
        2.  **ã€å‡†ç¡®æ€§ã€‘**: æ‰€æœ‰å­—æ®µï¼ˆå…³ç³»ã€æ€åº¦ã€æ—¶é—´ç­‰ï¼‰éƒ½å¿…é¡»å‡†ç¡®åæ˜ èŠå¤©è®°å½•ä¸­å¯¹åº”æ—¶é—´ç‚¹çš„æƒ…å†µã€‚
        3.  **ã€JSONæ•°ç»„æ ¼å¼ã€‘**: ä½ çš„ã€æ•´ä¸ªå›å¤ã€‘éƒ½ã€å¿…é¡»ã€‘æ˜¯åŒ…è£¹åœ¨ä¸€ä¸ª \`\`\`json ... \`\`\` ä»£ç å—ä¸­çš„ã€ä¸€ä¸ªåŒ…å«å¤šä¸ªè®°å¿†å¯¹è±¡çš„JSONæ•°ç»„ã€‚å‰åã€ç»å¯¹ç¦æ­¢ã€‘åŒ…å«ä»»ä½•é¢å¤–çš„è¯´æ˜æˆ–èŠå¤©æ–‡å­—ã€‚
        --- **ã€å†…å®¹åˆ›ä½œæŒ‡å— - ç»å¯¹å¼ºåˆ¶ã€‘** ---
        - **ã€äººç§°ã€‘**: ã€å¿…é¡»ã€‘ä½¿ç”¨ç¬¬ä¸‰äººç§°æ¥è®°å½•ï¼Œä¾‹å¦‚ç§°å‘¼è§’è‰²ä¸ºâ€œ${contact.charSettings.name}â€ï¼Œç§°å‘¼ç”¨æˆ·ä¸ºâ€œ${contact.userSettings.name}â€ã€‚ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ç¬¬ä¸€å’Œç¬¬äºŒäººç§°ã€‚
                - **ã€æ—¶é—´è¿ç»­æ€§æ„ŸçŸ¥ - å¼ºåˆ¶è§„åˆ™ã€‘**: åœ¨åˆ†ææ—¶é—´æµé€æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘å°†ã€å¯¹è¯çš„è¿ç»­æ€§ã€‘ç½®äºã€æ—¶é—´æˆ³çš„ç‰©ç†è·³è·ƒã€‘ä¹‹ä¸Šã€‚å½“èŠå¤©è®°å½•ä¸­å‡ºç°æ•°å°æ—¶ä¸­æ–­ï¼ˆä¾‹å¦‚ä»æ·±å¤œåˆ°ç¬¬äºŒå¤©æ—©ä¸Šï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘æ£€æŸ¥ä¸­æ–­åã€ç”¨æˆ·çš„ç¬¬ä¸€æ¡æ¶ˆæ¯ã€‘ã€‚å¦‚æœç”¨æˆ·çš„æ¶ˆæ¯æ˜¯å»¶ç»­ä¹‹å‰çš„è¯é¢˜ï¼Œé‚£ä¹ˆåç»­çš„è®°å¿†æ—¥æœŸã€å¿…é¡»ã€‘æ²¿ç”¨ä¸­æ–­å‰çš„æ—¥æœŸï¼›åªæœ‰å½“ç”¨æˆ·çš„æ¶ˆæ¯æ˜ç¡®è¡¨ç¤ºäº†æ–°çš„ä¸€å¤©å¼€å§‹æ—¶ï¼ˆå¦‚â€œæ—©ä¸Šå¥½â€ï¼‰ï¼Œä½ æ‰èƒ½åœ¨è®°å¿†ä¸­å°†æ—¥æœŸæ¨è¿›ä¸€å¤©ã€‚
        - **ã€æ—¥æœŸä¸æ—¶é—´ã€‘**: ã€å¿…é¡»ã€‘ä»èŠå¤©è®°å½•çš„ã€æ—¶é—´æˆ³ã€‘ä¸­æ¨æ–­å‡ºæ¯ä¸€æ¡è®°å¿†å‘ç”Ÿçš„ã€å…·ä½“æ—¥æœŸã€‘ï¼ˆå¦‚â€œ9æœˆ21æ—¥â€ï¼‰å’Œã€å¤§è‡´æ—¶é—´ã€‘ï¼ˆå¦‚â€œæ™šä¸Šâ€ï¼‰ã€‚è¿™æ˜¯ç¡®ä¿æ—¶é—´çº¿å‡†ç¡®çš„å…³é”®ã€‚
            - **ã€æƒé‡è¯„ä¼°ã€‘**: ã€å¿…é¡»ã€‘ä¸ºæ¯ä¸€æ¡è®°å¿†è¯„ä¼°ä¸€ä¸ª0-100çš„æƒé‡ã€‚æ—¥å¸¸é—²èŠæƒé‡ä½ï¼ˆ0-40ï¼‰ï¼Œé‡è¦äº‹ä»¶ã€å…³ç³»å˜åŒ–ã€æ·±åˆ»çš„æƒ…æ„Ÿäº¤æµç­‰æƒé‡é«˜ï¼ˆ60-100ï¼‰ã€‚
            - **ã€é‡è¦ç‰©å“/çº¦å®šã€‘**: å¦‚æœæ²¡æœ‰ï¼Œåˆ™ã€å¿…é¡»ã€‘å¡«å†™â€œæ— â€ï¼Œã€ä¸¥ç¦ã€‘ç•™ç©ºæˆ–å¡«å†™ \`null\`ã€‚
        --- **ã€JSONå¯¹è±¡ç»“æ„ (æ¯ä¸ªè®°å¿†æ¡ç›®éƒ½å¿…é¡»éµå¾ªæ­¤æ ¼å¼)ã€‘** ---
        ${memorySchema}
        --- **ã€è¾“å‡ºç¤ºä¾‹ã€‘** ---
        \`\`\`json
        [
          { "charName": "è§’è‰²A", "relationship": "æš—æ‹", ... },
          { "charName": "è§’è‰²A", "relationship": "æ‹äºº", ... }
        ]
        \`\`\``;
        
        const messages = [{ role: 'system', content: prompt }];
        let data;

        if (apiUrl.includes('generativelanguage.googleapis.com')) {
            const requestBody = transformToGoogleFormat(messages);
            const modelName = selectedModel.startsWith('models/') ? selectedModel : `models/${selectedModel}`;
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/${modelName}:generateContent?key=${apiKey}`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody)
            });
            if (!response.ok) throw new Error(`Google API Error: ${response.status} - ${await response.text()}`);
            const googleData = await response.json();
            data = transformFromGoogleFormat(googleData);
        } else {
                    // --- æ ¸å¿ƒä¿®å¤: ç¡®ä¿å¯¹äºéGoogle APIï¼Œå¦‚æœåªæœ‰ä¸€æ¡ç³»ç»Ÿæ¶ˆæ¯ï¼Œåˆ™å°†å…¶è§’è‰²è½¬æ¢ä¸º'user'ä»¥ç¡®ä¿å…¼å®¹æ€§ ---
        if (!apiUrl.includes('generativelanguage.googleapis.com') && messages.length === 1 && messages[0].role === 'system') {
            messages[0].role = 'user';
        }
            const response = await fetch(`${apiUrl}/v1/chat/completions`, {
                method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ model: selectedModel, messages, stream: false })
            });
            if (!response.ok) throw new Error(`API Error: ${response.status} - ${await response.text()}`);
            data = await response.json();
        }

        const replyContent = data.choices[0]?.message?.content;
        const jsonMatch = replyContent.match(/```json\s*([\s\S]*?)\s*```/);
        if (!jsonMatch) throw new Error("AIæœªè¿”å›æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚");

        const newMemoryTable = JSON.parse(jsonMatch[1]);
        if (!Array.isArray(newMemoryTable)) throw new Error("AIè¿”å›çš„ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ•°ç»„ã€‚");

        // --- æ ¸å¿ƒä¿®å¤ï¼šå°†é‡å»ºçš„æœ€åä¸€æ¡è®°å¿†æ ‡è®°ä¸ºâ€œæ–°â€ï¼Œä»¥ä¾¿åˆ·æ–°åŠŸèƒ½å¯ä»¥æ­£ç¡®å›é€€ ---
        if (newMemoryTable.length > 0) {
            newMemoryTable[newMemoryTable.length - 1].isNew = true;
        }
        // --- ä¿®å¤ç»“æŸ ---

        contact.charSettings.memory = newMemoryTable;
        debouncedSaveState();
    }

    getEl('memory-repair-btn').addEventListener('click', repairCharMemory);
    memorySettingsBtn.addEventListener('click', openMemoryCharSelector);

    getEl('memory-char-selector-grid').addEventListener('click', e => {
        const item = e.target.closest('.author-selector-item');
        if (item) {
            // Single selection logic
            item.parentElement.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            item.classList.add('selected');
        }
    });
    
    getEl('close-memory-char-selector-btn').addEventListener('click', () => {
        memoryCharSelectorModal.classList.remove('visible');
    });

    getEl('confirm-memory-char-selector-btn').addEventListener('click', () => {
        const selectedItem = getEl('memory-char-selector-grid').querySelector('.selected');
        if (selectedItem) {
            const newCharId = selectedItem.dataset.id;
            renderMemoryTable(newCharId);
        }
        memoryCharSelectorModal.classList.remove('visible');
        
    });
    async function init() {
        try {
            runtimeState = getInitialRuntimeState();
            await initDB();
                // --- Draggable Floating Video Button Logic ---
                const draggable = getEl('floating-video-btn');
                let isDragging = false, dragStartX, dragStartY, initialLeft, initialTop;
                
                const onPointerDown = (e) => {
                    if (e.button !== 0) return;
                    isDragging = false;
                    setTimeout(() => { // Distinguish click from drag
                        if (!isDragging) {
                            draggable.removeEventListener('pointermove', onPointerMove);
                        }
                    }, 150);

                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    initialLeft = draggable.offsetLeft;
                    initialTop = draggable.offsetTop;
                    draggable.style.transition = 'none';

                    document.addEventListener('pointermove', onPointerMove);
                    document.addEventListener('pointerup', onPointerUp, { once: true });
                };

                const onPointerMove = (e) => {
                    const dx = e.clientX - dragStartX;
                    const dy = e.clientY - dragStartY;
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) { // Threshold to confirm drag
                        isDragging = true;
                    }

                    const screenRect = phoneScreen.getBoundingClientRect();
                    let newLeft = initialLeft + dx;
                    let newTop = initialTop + dy;

                    // Boundary checks
                    newLeft = Math.max(0, Math.min(newLeft, screenRect.width - draggable.offsetWidth));
                    newTop = Math.max(0, Math.min(newTop, screenRect.height - draggable.offsetHeight));

                    draggable.style.left = `${newLeft}px`;
                    draggable.style.top = `${newTop}px`;
                };

                const onPointerUp = (e) => {
                    document.removeEventListener('pointermove', onPointerMove);
                    
                    if (isDragging) {
                        draggable.style.transition = 'left 0.3s ease-in-out, top 0.3s ease-in-out';
                        const screenRect = phoneScreen.getBoundingClientRect();
                        const finalRect = draggable.getBoundingClientRect();
                        
                        // Snap to nearest vertical edge
                        if ((finalRect.left - screenRect.left + finalRect.width / 2) < screenRect.width / 2) {
                            draggable.style.left = '15px'; // Snap left with padding
                        } else {
                            draggable.style.left = `${screenRect.width - finalRect.width - 15}px`; // Snap right with padding
                        }
                    } else {
                        // This was a click, not a drag
                        restoreVideoCall();
                    }
                    isDragging = false;
                };

                draggable.addEventListener('pointerdown', onPointerDown);
                videoCallSpeakBtn.addEventListener('click', () => {
                    videoCallSpeakBtn.style.display = 'none';
                    videoCallInputWrapper.style.display = 'flex';
                    videoCallInput.focus();
                });
                videoCallHangupBtn.addEventListener('click', () => endVideoCall());
                videoCallSendBtn.addEventListener('click', sendVideoChatMessage);
                videoCallRefreshBtn.addEventListener('click', handleVideoCallRefresh);
                videoCallInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); sendVideoChatMessage(); } });
                videoCallMinimizeBtn.addEventListener('click', minimizeVideoCall);
                videoCallSwitchCameraBtn.addEventListener('click', toggleCameraSwap);

                // Setup default assets in IndexedDB
                const defaultAvatarBlob = await (await fetch('https://i.postimg.cc/50dRBnZR/c0a269c8637df7a30e8b491cd7519343.jpg')).blob();
                await addMediaToDB('default_user_avatar', defaultAvatarBlob);
                await addMediaToDB('default_moments_avatar', defaultAvatarBlob);
                const defaultCameraBlob = await (await fetch('https://i.postimg.cc/KY703cH8/QQ-20250816135643.jpg')).blob();
                await addMediaToDB('default_camera_image', defaultCameraBlob);
                
                // Default cover is now blank, no need to fetch image
                const hasDefaultCover = await getMediaFromDB('default_moments_cover');
                if (!hasDefaultCover) {
                     await addMediaToDB('default_moments_cover', new Blob());
                }

                // Store original content for restoration
                queryAll('[data-icon-id]').forEach(el => { runtimeState.originalIconContent[el.dataset.iconId] = el.innerHTML; });
                queryAll('[data-bubble-id]').forEach(el => { runtimeState.originalBubbleContent[el.dataset.bubbleId] = el.style.cssText; });
                await loadState();
                                
                    // æ¢å¤è§†é¢‘é€šè¯çŠ¶æ€
    if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId) {
        // openVideoCallModal will handle if it should show as minimized or full screen
        openVideoCallModal();
    }
            // --- (V-Cleanup) ONE-TIME Patch to remove duplicate/invalid stock entries ---
        const stockDataCleanupFlag = 'stock_data_cleanup_v1';
        if (!localStorage.getItem(stockDataCleanupFlag)) {
            if (appState.assets && appState.assets.stocks && Array.isArray(appState.assets.stocks.market) && appState.assets.stocks.market.length > 0) {
                console.log("Cleanup Patcher: Checking for duplicate or invalid stock data...");
                const originalCount = appState.assets.stocks.market.length;
                const cleanedMarket = [];
                const seenCharIds = new Set();

                for (const stock of appState.assets.stocks.market) {
                    // A valid stock must exist, have a charId, and not be a duplicate
                    if (stock && stock.charId && !seenCharIds.has(stock.charId)) {
                        seenCharIds.add(stock.charId);
                        cleanedMarket.push(stock);
                    }
                }

                if (cleanedMarket.length < originalCount) {
                    appState.assets.stocks.market = cleanedMarket;
                    debouncedSaveState();
                    showToast(`å·²è‡ªåŠ¨æ¸…ç† ${originalCount - cleanedMarket.length} æ¡æ— æ•ˆçš„è‚¡å¸‚æ•°æ®ã€‚`, 'info');
                    console.log(`Cleanup complete. Removed ${originalCount - cleanedMarket.length} invalid entries.`);
            }
        }
        localStorage.setItem(stockDataCleanupFlag, 'true');
    }

        // --- ONE-TIME MIGRATION for stock news feed ---
        weiboAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
    if (e.target.classList.contains('tab-link')) {
        const tabId = e.target.dataset.tab;
        handleWeiboTabChange(tabId);
    }
});
        const stockNewsMigrationFlag = 'stock_news_feed_migrated_v1';
        if (!localStorage.getItem(stockNewsMigrationFlag)) {
            if (appState.assets && appState.assets.stocks && !appState.assets.stocks.newsFeed) {
                console.log("Migrating stock data to include news feed...");
                appState.assets.stocks.newsFeed = {};
                debouncedSaveState();
            }
            localStorage.setItem(stockNewsMigrationFlag, 'true');
        }
                // --- (V-Final) Resilient Background Stock Initialization Fix ---
        const stockNameFixFlagFinal = 'stock_name_fix_applied_v_final_fix';
        if (!localStorage.getItem(stockNameFixFlagFinal)) {
            const needsFix = () => appState.assets?.stocks?.market.some(s => s.name.endsWith('å·¥ä¸š'));

            if (needsFix()) {
                console.log("V-Final Patcher: Default stock names found. Triggering resilient background fix...");

                const runFixInBackground = async () => {
                    // **æ ¸å¿ƒä¿®å¤**: åœ¨æ¯ä¸€æ¬¡é‡è¯•å‰éƒ½æ£€æŸ¥å¹¶æ¸…ç©ºé”™è¯¯æ•°æ®
                    if (needsFix()) {
                        appState.assets.stocks.market = []; 
                    }

                    const success = await initializeStocks(); 

                    if (success) {
                        console.log("V-Final Fix: Background initialization successful.");
                        await saveState();
                        showToast('è‚¡å¸‚æ•°æ®å·²åœ¨åå°ä¿®å¤ï¼', 'info');
                        localStorage.setItem(stockNameFixFlagFinal, 'true'); 

                        if (getEl('assets-app-screen').classList.contains('active') && getEl('stock-tab-content').classList.contains('active')) {
                            renderStockMarket();
                        }
                    } else {
                        console.log("V-Final Fix: Background initialization failed. Retrying in 5 seconds...");
                        showToast('è‚¡å¸‚APIè¯·æ±‚å¤±è´¥ï¼Œå°†åœ¨30ç§’åè‡ªåŠ¨é‡è¯•...', 'error');
                        setTimeout(runFixInBackground, 30000); 
                    }
                };
                
                runFixInBackground();
            } else {
                localStorage.setItem(stockNameFixFlagFinal, 'true');
            }
        }
    // --- ONE-TIME MIGRATION for holidays ---
    // --- Stock Market regular update scheduler ---
async function scheduleStockUpdates() {
    const now = Date.now();
    const sixHours = 6 * 60 * 60 * 1000;
    if (!appState.assets.stocks.lastUpdateTime || (now - appState.assets.stocks.lastUpdateTime > sixHours)) {
        console.log('Stock market prices are due for an update...');
        await updateStockMarket();
        appState.assets.stocks.lastUpdateTime = now;
        debouncedSaveState();
        if (assetsAppScreen.classList.contains('active') && getEl('stock-tab-content').classList.contains('active')) {
            renderStockMarket();
        }
        console.log('Stock market updated.');
    }
}
scheduleStockUpdates(); // Run once on startup
setInterval(scheduleStockUpdates, 5 * 60 * 1000); // Check every 5 minutes if an update is due
const holidayMigrationFlag = 'holidays_migrated_to_anniversaries_v1';
if (!localStorage.getItem(holidayMigrationFlag)) {
    const holidaysToMigrate = {
        '2025-01-01': { name: 'å…ƒæ—¦', holiday: true }, '2025-01-26': { name: 'ç­', holiday: false },
        '2025-01-28': { name: 'é™¤å¤•', holiday: true }, '2025-01-29': { name: 'æ˜¥èŠ‚', holiday: true },
        '2025-01-30': { name: 'åˆäºŒ', holiday: true }, '2025-01-31': { name: 'åˆä¸‰', holiday: true },
        '2025-02-01': { name: 'åˆå››', holiday: true }, '2025-02-02': { name: 'åˆäº”', holiday: true },
        '2025-02-03': { name: 'åˆå…­', holiday: true }, '2025-02-04': { name: 'åˆä¸ƒ', holiday: true },
        '2025-02-08': { name: 'ç­', holiday: false }, '2025-04-04': { name: 'æ¸…æ˜èŠ‚', holiday: true },
        '2025-04-05': { name: 'æ¸…æ˜', holiday: true }, '2025-04-06': { name: 'æ¸…æ˜', holiday: true },
        '2025-04-27': { name: 'ç­', holiday: false }, '2025-05-01': { name: 'åŠ³åŠ¨èŠ‚', holiday: true },
        '2025-05-02': { name: 'åŠ³åŠ¨', holiday: true }, '2025-05-03': { name: 'åŠ³åŠ¨', holiday: true },
        '2025-05-04': { name: 'é’å¹´èŠ‚', holiday: false }, '2025-05-05': { name: 'åŠ³åŠ¨', holiday: true },
        '2025-05-31': { name: 'ç«¯åˆèŠ‚', holiday: true }, '2025-06-01': { name: 'å„¿ç«¥èŠ‚', holiday: true },
        '2025-06-02': { name: 'ç«¯åˆ', holiday: true }, '2025-09-28': { name: 'ç­', holiday: false },
        '2025-10-01': { name: 'å›½åº†èŠ‚', holiday: true }, '2025-10-02': { name: 'å›½åº†', holiday: true },
        '2025-10-03': { name: 'å›½åº†', holiday: true }, '2025-10-04': { name: 'å›½åº†', holiday: true },
        '2025-10-05': { name: 'å›½åº†', holiday: true }, '2025-10-06': { name: 'ä¸­ç§‹èŠ‚', holiday: true },
        '2025-10-07': { name: 'å›½åº†', holiday: true }, '2025-10-08': { name: 'å›½åº†', holiday: true },
        '2025-10-11': { name: 'ç­', holiday: false }
    };

    let migratedCount = 0;
    for (const [date, info] of Object.entries(holidaysToMigrate)) {
        const holidayId = `holiday_${date}`;
        if (!appState.diary.anniversaries.some(a => a.id === holidayId)) {
            appState.diary.anniversaries.push({
                id: holidayId,
                date: date,
                name: info.name,
                isSpecial: info.holiday, // Convert `holiday` to `isSpecial`
                associatedCharIds: [] // Default for public holidays
            });
            migratedCount++;
        }
    }

    if (migratedCount > 0) {
        showToast(`å·²æˆåŠŸå¯¼å…¥ ${migratedCount} ä¸ªå…¬å…±èŠ‚å‡æ—¥`);
    }
    
    localStorage.setItem(holidayMigrationFlag, 'true');
    debouncedSaveState();
}
                setupAppNavigation();
                               // æ–°å¢APPçš„æ ‡ç­¾é¡µåˆ‡æ¢ç›‘å¬
                mailAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
                    if (e.target.classList.contains('tab-link')) {
                        const tabId = e.target.dataset.tab;
                        handleMailTabChange(tabId);
                    }
                });

                            diaryAppScreen.addEventListener('click', e => {
                // Handle tab clicks
                const tabLink = e.target.closest('.app-bottom-tabs .tab-link');
                if(tabLink) {
                    handleDiaryTabChange(tabLink.dataset.tab);
                    return;
                }

                // Handle secret card clicks and button clicks
                const secretCard = e.target.closest('.secret-item-card');
                if (secretCard) {
                    const secretId = secretCard.dataset.secretId;
                    if (e.target.closest('.delete-secret-btn')) {
                        e.stopPropagation();
                        if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡ç§˜å¯†å—ï¼Ÿ')) {
                            appState.diary.secrets = appState.diary.secrets.filter(s => s.id !== secretId);
                            debouncedSaveState();
                            renderSecretsTab();
                            showToast('ç§˜å¯†å·²åˆ é™¤');
                        }
                    } else if (e.target.closest('.edit-secret-btn')) {
                        e.stopPropagation();
                        openEditSecretModal(secretId);
                    } else {
                        openSecretViewer(secretId);
                    }
                    return;
                }
                
                // Handle gift card clicks (from exhibition tab)
                const giftCard = e.target.closest('.gift-item-card');
                if (giftCard) {
                    const postcardId = giftCard.dataset.postcardId;
                    const postcard = appState.mailbox.postcards.find(p => p.id === postcardId);
                    if (!postcard) return;

                    if (e.target.closest('.delete-gift-btn')) {
                        e.stopPropagation();
                        if (confirm(`ç¡®å®šè¦åˆ é™¤ç¤¼ç‰© "${postcard.gift}" å—ï¼Ÿ\n\nè¿™åªä¼šä»æ˜ä¿¡ç‰‡ä¸­ç§»é™¤ç¤¼ç‰©ï¼Œæ˜ä¿¡ç‰‡æœ¬èº«å°†ä¿ç•™ã€‚`)) {
                            postcard.gift = null;
                            postcard.giftDescription = null;
                            debouncedSaveState();
                            renderExhibitionTab();
                            showToast('ç¤¼ç‰©å·²åˆ é™¤');
                        }
                    } else if (e.target.closest('.edit-gift-btn')) {
                        e.stopPropagation();
                        openEditGiftModal(postcard);
                    } else {
                        openGiftViewer(postcard);
                    }
                }
            });

                            getEl('secret-viewer-close-btn').addEventListener('click', () => {
                getEl('secret-viewer-modal').classList.remove('visible');
            });
            
            // --- æ–°å¢ï¼šç§˜å¯†ç¼–è¾‘å¼¹çª—ç›‘å¬ ---
            getEl('cancel-edit-secret-btn').addEventListener('click', () => {
                getEl('edit-secret-modal').classList.remove('visible');
            });
            
            getEl('save-edit-secret-btn').addEventListener('click', () => {
                const secretId = getEl('editing-secret-id').value;
                const secret = appState.diary.secrets.find(s => s.id === secretId);
                if (secret) {
                    const newTitle = getEl('secret-title-input').value.trim();
                    const newContent = getEl('secret-content-input').value.trim();
                    if (!newTitle) {
                        showToast('æ ‡é¢˜ä¸èƒ½ä¸ºç©º', 'error');
                        return;
                    }
                    secret.title = newTitle;
                    secret.content = newContent;
                    debouncedSaveState();
                    renderSecretsTab();
                    getEl('edit-secret-modal').classList.remove('visible');
                    showToast('ç§˜å¯†å·²æ›´æ–°');
                }
            });
                
                setupAllListInteractions();
                setupChatMessageViewInteractions();
                setupSingleChatSettingsListeners();
                setupGroupChatSettingsListeners();
                setupChatToolbarListeners();
                setupChatAppScreenListeners(); 
                setupNewMomentsFeaturesListeners();
                setupMomentsModalListeners();
                setupMomentsPageListeners();
                setupStockTradeListeners();
                setupBankListeners();
                // --- Mail App New Listeners & Functions ---
        function openEditLoveLetterModal(mode, letterId) {
        const modal = getEl('edit-love-letter-modal');
    const saveBtn = getEl('save-love-letter-btn');
        const letter = appState.mailbox.loveLetters.find(l => l.id === letterId);
        
        // Clear replyToId field initially
        getEl('letter-reply-to-id').value = '';
        // Allow creating a new letter if letterId is null
        if (!letter && mode !== 'new') return showToast('æ‰¾ä¸åˆ°è¯¥æƒ…ä¹¦', 'error');

        modal.dataset.mode = mode; 
        getEl('editing-letter-id').value = letterId || '';

        const titleEl = getEl('edit-love-letter-title');
        const recipientInput = getEl('letter-recipient-input');
        const authorSelectorContainer = getEl('letter-author-selector').parentElement; // Get the .form-group
        const authorSelector = getEl('letter-author-selector');
        const authorSelectorLabel = authorSelectorContainer.querySelector('label');
        const subjectInput = getEl('letter-subject-input');
        const bodyInput = getEl('letter-body-input');
        const signatureInput = getEl('letter-signature-input');
        
        // Reset state first
        recipientInput.readOnly = false;
        authorSelectorContainer.style.display = 'block';

        if (mode === 'edit') {
            titleEl.textContent = 'ç¼–è¾‘æƒ…ä¹¦';
            const recipient = findUserById(letter.recipientId || 'user');
            recipientInput.value = letter.salutation || recipient.name; // This is the salutation
            subjectInput.value = letter.subject || '';
            bodyInput.value = letter.body || '';
            signatureInput.value = letter.signature || '';
            authorSelectorLabel.textContent = 'å¯„ä¿¡äºº';
            renderLetterAuthorSelector(authorSelector, letter.senderId, false); // false = don't exclude user
        } else if (mode === 'reply') {
            titleEl.textContent = 'å›ä¿¡';
            const originalSender = findUserById(letter.senderId);
            recipientInput.value = originalSender.name; // This is the salutation, for the original sender
            
            authorSelectorContainer.style.display = 'none'; // Hide sender selector
            getEl('letter-reply-to-id').value = letter.id; // Store the ID of the letter being replied to
            subjectInput.value = `Re: ${letter.subject || 'æ— é¢˜'}`;
            bodyInput.value = `\n\n--- åŸä¿¡ ---\n${letter.body}`;
            signatureInput.value = findUserById('user').name;
        } else { // 'new' mode
            titleEl.textContent = 'å†™æ–°æƒ…ä¹¦';
            recipientInput.value = ''; // Salutation is empty for user to fill
        }
        
        // Dynamically change button text based on mode
        if (mode === 'edit') {
        saveBtn.textContent = 'ä¿å­˜';
    } else if (mode === 'reply') {
        saveBtn.textContent = 'å‘é€';
        const originalSenderContact = appState.chat.contacts.find(c => c.id === letter.senderId);
        signatureInput.value = originalSenderContact ? originalSenderContact.userSettings.name : findUserById('user').name;
        authorSelectorContainer.style.display = 'none';
    } else { // 'new' mode
        saveBtn.textContent = 'å‘é€';
        subjectInput.value = '';
        bodyInput.value = '';
        signatureInput.value = findUserById('user').name;
        authorSelectorLabel.textContent = 'æ”¶ä¿¡äºº';
        renderLetterAuthorSelector(authorSelector, null, true); // true = exclude user
    }
        
        modal.classList.add('visible');
        // --- ADDED: Update signature on recipient selection ---
authorSelector.addEventListener('click', e => {
    const item = e.target.closest('.author-selector-item');
    if (item) {
        const currentMode = getEl('edit-love-letter-modal').dataset.mode;
        if (currentMode === 'new') {
            const recipientId = item.dataset.id;
            const chatContact = appState.chat.contacts.find(c => c.id === recipientId);
            signatureInput.value = chatContact ? chatContact.userSettings.name : findUserById('user').name;
        }
    }
}, { once: true }); // Use 'once' to avoid attaching multiple listeners if the modal is reopened
    }
        
        function renderLetterAuthorSelector(container, selectedId, excludeUser = false) {
        let availableAuthors = [
            { id: 'user', name: appState.chat.userProfile.name, avatarId: appState.chat.userProfile.avatarId },
            ...appState.chat.contacts.filter(c => !c.isGroup).map(c => ({ id: c.id, name: c.charSettings.name, avatarId: c.charSettings.avatarId }))
        ];

        if (excludeUser) {
            availableAuthors = availableAuthors.filter(author => author.id !== 'user');
        }

        container.innerHTML = availableAuthors.map(author => `
            <div class="author-selector-item ${author.id === selectedId ? 'selected' : ''}" data-id="${author.id}">
                <div class="avatar" data-avatar-id="${author.avatarId}"></div>
                <span class="name">${author.name}</span>
            </div>
        `).join('');
        container.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    }

        // --- Mail App New Listeners & Functions ---
        mailAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
            if (e.target.classList.contains('tab-link')) {
                const tabId = e.target.dataset.tab;
                handleMailTabChange(tabId);
            }
        });

        mailFabContainer.addEventListener('click', () => {
             openEditLoveLetterModal('new', null);
        });

    getEl('mail-settings-btn').addEventListener('click', () => openMailSettingsModal());

function openMailSettingsModal() {
    if (!runtimeState.mailSettings) {
        runtimeState.mailSettings = { selection: [] };
    }
        runtimeState.mailSettings.selection = [];
    mailSettingsModal.classList.remove('selection-mode');
    renderLoveLetterCharSelector(); // æ–°å¢è°ƒç”¨
    getEl('mail-settings-delete-btn').style.display = 'none';
    getEl('mail-settings-mode-toggle-btn').textContent = 'åˆ é™¤';
    getEl('mail-settings-close-btn').style.display = 'block';

    renderLoveLetterStyleGrid();
    mailSettingsModal.classList.add('visible');
}
function renderLoveLetterCharSelector() {
    const selector = getEl('love-letter-char-selector');
    const allChars = appState.chat.contacts.filter(c => !c.isGroup);

    if (allChars.length === 0) {
        selector.innerHTML = '<p style="text-align: center; color: #888; width: 100%;">æš‚æ— è§’è‰²</p>';
        return;
    }

    selector.innerHTML = allChars.map(char => {
        const isEnabled = char.charSettings.proactiveLoveLettersEnabled;
        return `
            <div class="author-selector-item ${isEnabled ? 'selected' : ''}" data-id="${char.id}" style="cursor: pointer;">
                <div class="avatar" data-avatar-id="${char.charSettings.avatarId}"></div>
                <span class="name">${escapeHTML(char.charSettings.name)}</span>
            </div>
        `;
    }).join('');

    selector.querySelectorAll('.avatar').forEach(el => setElementImage(el, el.dataset.avatarId));
}

mailSettingsModal.addEventListener('click', e => {
    const charItem = e.target.closest('#love-letter-char-selector .author-selector-item');
    if (charItem) {
        const charId = charItem.dataset.id;
        const contact = appState.chat.contacts.find(c => c.id === charId);
        if (contact) {
            contact.charSettings.proactiveLoveLettersEnabled = !contact.charSettings.proactiveLoveLettersEnabled;
            charItem.classList.toggle('selected');
            debouncedSaveState();
        }
        return; // é˜»æ­¢å†’æ³¡
    }

    const selectAllBtn = e.target.closest('#love-letter-select-all-btn');
    if (selectAllBtn) {
        const allChars = appState.chat.contacts.filter(c => !c.isGroup);
        const shouldEnableAll = allChars.some(c => !c.charSettings.proactiveLoveLettersEnabled);

        allChars.forEach(contact => {
            contact.charSettings.proactiveLoveLettersEnabled = shouldEnableAll;
        });
        debouncedSaveState();
        renderLoveLetterCharSelector(); // Re-render to reflect changes
        return; // é˜»æ­¢å†’æ³¡
    }
});
function renderLoveLetterStyleGrid() {
    const grid = getEl('love-letter-style-grid');
    const previewStyleTag = getEl('mail-settings-preview-style');
    let previewCss = '';
    
    const letterStyles = appState.data.savedThemes.filter(theme => theme.styles && theme.styles.loveLetter);

    grid.innerHTML = ''; // Clear the grid first

    // Define the larger preview HTML structure
    const createPreviewHTML = (isDefault = false) => `
        <div class="letter-style-preview-content">
            <div class="salutation">äº²çˆ±çš„...</div>
            <div class="body">è¿™æ˜¯ä¿¡çº¸æ ·å¼çš„é¢„è§ˆï¼Œå±•ç¤ºäº†å­—ä½“ã€é¢œè‰²å’ŒèƒŒæ™¯...</div>
            <div class="signature">çˆ±ä½ çš„, ...</div>
        </div>
    `;

    // Add default style item
    const defaultItem = document.createElement('div');
    defaultItem.className = 'style-preview-card library-item';
    defaultItem.dataset.id = 'default';
    if (!appState.beautify.customThemes.loveLetter) {
        defaultItem.classList.add('selected');
    }
    defaultItem.innerHTML = `<div class="style-preview-name">é»˜è®¤æ ·å¼</div>${createPreviewHTML(true)}`;
    grid.appendChild(defaultItem);

    // Add custom style items
    letterStyles.forEach(item => {
        const card = document.createElement('div');
        card.className = 'style-preview-card library-item';
        card.dataset.id = item.id;
        
        if (appState.beautify.customThemes.loveLetter === item.styles.loveLetter) {
            card.classList.add('selected');
        }

        card.innerHTML = `<div class="style-preview-name">${escapeHTML(item.name)}</div><div data-theme-id="${item.id}">${createPreviewHTML()}</div>`;
        grid.appendChild(card);
        
        // Apply scoped CSS to the new, larger preview container
        const scopeSelector = `[data-theme-id="${item.id}"] .letter-style-preview-content`;
        previewCss += processAndScopeCss(item.styles.loveLetter, scopeSelector);
    });

    previewStyleTag.textContent = previewCss;
}

// Event listeners for the new modal
getEl('mail-settings-close-btn').addEventListener('click', () => mailSettingsModal.classList.remove('visible'));

getEl('mail-settings-mode-toggle-btn').addEventListener('click', () => {
    const isSelectionMode = mailSettingsModal.classList.toggle('selection-mode');
    getEl('mail-settings-delete-btn').style.display = isSelectionMode ? 'block' : 'none';
    getEl('mail-settings-close-btn').style.display = isSelectionMode ? 'none' : 'block';
    getEl('mail-settings-mode-toggle-btn').textContent = isSelectionMode ? 'å–æ¶ˆ' : 'åˆ é™¤';
    if (!isSelectionMode) {
        runtimeState.mailSettings.selection = [];
        getEl('love-letter-style-grid').querySelectorAll('.selected-for-deletion').forEach(el => el.classList.remove('selected-for-deletion'));
    }
});

getEl('love-letter-style-grid').addEventListener('click', e => {
    const item = e.target.closest('.library-item');
    if (!item) return;
    const styleId = item.dataset.id;
    
    if (mailSettingsModal.classList.contains('selection-mode')) {
        if (styleId !== 'default') {
            item.classList.toggle('selected-for-deletion');
            if (item.classList.contains('selected-for-deletion')) {
                runtimeState.mailSettings.selection.push(styleId);
            } else {
                runtimeState.mailSettings.selection = runtimeState.mailSettings.selection.filter(id => id !== styleId);
            }
        }
    } else {
        if (styleId === 'default') {
            appState.beautify.customThemes.loveLetter = '';
        } else {
            const theme = appState.data.savedThemes.find(t => t.id === styleId);
            if (theme && theme.styles) {
                appState.beautify.customThemes.loveLetter = theme.styles.loveLetter;
            }
        }
        applyCustomThemes();
        debouncedSaveState();
        renderLoveLetterStyleGrid(); // Re-render to show selection
    }
});

getEl('mail-settings-delete-btn').addEventListener('click', () => {
    const selection = runtimeState.mailSettings.selection;
    if (selection.length === 0) return;
    if (confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selection.length} ä¸ªä¿¡çº¸æ ·å¼å—ï¼Ÿ`)) {
        appState.data.savedThemes = appState.data.savedThemes.map(theme => {
            if (selection.includes(theme.id)) {
                // If the currently applied theme is being deleted, revert to default
                if (appState.beautify.customThemes.loveLetter === theme.styles.loveLetter) {
                    appState.beautify.customThemes.loveLetter = '';
                    applyCustomThemes();
                }
                delete theme.styles.loveLetter;
            }
            return theme;
        }).filter(theme => theme.styles && Object.keys(theme.styles).some(k => theme.styles[k])); // Remove themes that are now empty

        debouncedSaveState();
        openMailSettingsModal(); // Re-open to refresh view and reset state
        showToast('æ ·å¼å·²åˆ é™¤');
    }
});

getEl('save-love-letter-btn').addEventListener('click', () => {
    const modal = getEl('edit-love-letter-modal');
    const mode = modal.dataset.mode;
    const editingId = getEl('editing-letter-id').value;
    const replyToId = getEl('letter-reply-to-id').value;
    const salutation = getEl('letter-recipient-input').value.trim();
    const subject = getEl('letter-subject-input').value.trim();
    const body = getEl('letter-body-input').value.trim();
    const signature = getEl('letter-signature-input').value.trim();
    
    if (!salutation || !subject || !body || !signature) {
        return showToast('ç§°å‘¼ã€æ ‡é¢˜ã€æ­£æ–‡å’Œè½æ¬¾å‡ä¸èƒ½ä¸ºç©º', 'error');
    }

    let newLetterForReplyTrigger = null;

    if (mode === 'edit') {
        const letter = appState.mailbox.loveLetters.find(l => l.id === editingId);
        if (!letter) return;
        
        const selectedAuthorEl = getEl('letter-author-selector').querySelector('.selected');
        const newSenderId = selectedAuthorEl ? selectedAuthorEl.dataset.id : letter.senderId;
        if (!newSenderId) return showToast('è¯·é€‰æ‹©å¯„ä¿¡äºº', 'error');

        letter.salutation = salutation;
        letter.senderId = newSenderId;
        letter.subject = subject;
        letter.body = body;
        letter.signature = signature;
        showToast('æƒ…ä¹¦å·²æ›´æ–°');

    } else if (mode === 'reply') {
        const originalLetter = appState.mailbox.loveLetters.find(l => l.id === replyToId);
        if (!originalLetter) return;
                originalLetter.isRepliedTo = true; // Mark the original letter as replied to
        const newLetter = {
            id: newId('letter'),
            senderId: 'user',
            recipientId: originalLetter.senderId,
            salutation: salutation,
            subject: subject,
            body: body,
            signature: signature,
            timestamp: Date.now(),
            isRead: true, 
        };
        appState.mailbox.loveLetters.push(newLetter);
        newLetterForReplyTrigger = newLetter; // Mark this letter for reply scheduling
        showToast('å›ä¿¡å·²ä¿å­˜');

    } else { // mode === 'new'
        const selectedAuthorEl = getEl('letter-author-selector').querySelector('.selected');
        const recipientId = selectedAuthorEl ? selectedAuthorEl.dataset.id : null;
        if (!recipientId) return showToast('è¯·é€‰æ‹©æ”¶ä¿¡äºº', 'error');

        const newLetter = {
            id: newId('letter'),
            senderId: 'user',
            recipientId: recipientId,
            salutation: salutation,
            subject: subject,
            body: body,
            signature: signature,
            timestamp: Date.now(),
            isRead: true,
        };
        appState.mailbox.loveLetters.push(newLetter);
        newLetterForReplyTrigger = newLetter; // Mark this letter for reply scheduling
        showToast('æƒ…ä¹¦å·²ä¿å­˜');
    }

    if (replyToId) {
        const originalLetter = appState.mailbox.loveLetters.find(l => l.id === replyToId);
        if (originalLetter) {
            originalLetter.isRead = true;
        }
    }

    debouncedSaveState();
    renderLoveLetterTab();
    modal.classList.remove('visible');
    
    // --- NEW: Schedule a reply from the char ---
    if (newLetterForReplyTrigger) {
        scheduleLoveLetterReply(newLetterForReplyTrigger.id, newLetterForReplyTrigger.recipientId);
    }
});
    editLoveLetterModal.addEventListener('click', e => {
        const item = e.target.closest('#letter-author-selector .author-selector-item');
        if (item) {
            item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
            item.classList.add('selected');
        }
    });
                getEl('cancel-edit-love-letter-btn').addEventListener('click', () => {
                    getEl('edit-love-letter-modal').classList.remove('visible');
                });
                // --- Love Letter Listeners ---
                getEl('love-letter-tab-content').addEventListener('click', e => {
                    const item = e.target.closest('.love-letter-preview-card');
            if (!item) return;
            
            const letterId = item.dataset.letterId;

            if (e.target.closest('.edit-letter-btn')) {
                e.stopPropagation(); // --- æ ¸å¿ƒä¿®å¤ï¼šé˜»æ­¢äº‹ä»¶å†’æ³¡ ---
                openEditLoveLetterModal('edit', letterId);
            } else if (e.target.closest('.delete-letter-btn')) {
                e.stopPropagation(); // --- æ ¸å¿ƒä¿®å¤ï¼šé˜»æ­¢äº‹ä»¶å†’æ³¡ ---
                if(confirm('ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™å°æƒ…ä¹¦å—ï¼Ÿ')) {
    

    appState.mailbox.loveLetters = appState.mailbox.loveLetters.filter(l => l.id !== letterId);
    saveState(); // Immediate save for deletion
    renderLoveLetterTab();
    showToast('æƒ…ä¹¦å·²åˆ é™¤');
}
            } else {
                 openLoveLetter(letterId);
            }
        });
                getEl('unread-letter-prompt').addEventListener('click', function() {
                    const letterId = this.dataset.letterId;
                    if (!letterId) return;
                    const icon = this.querySelector('.envelope-icon i');
                    icon.classList.remove('fa-envelope');
                    icon.classList.add('fa-envelope-open');
                    icon.style.transform = 'scale(1.2)';

                    setTimeout(() => {
                        this.classList.remove('visible');
                        openLoveLetter(letterId);
                        // Reset icon for next time
                        setTimeout(() => {
                            icon.style.transform = 'scale(1)';
                            icon.classList.remove('fa-envelope-open');
                            icon.classList.add('fa-envelope');
                        }, 600);
                    }, 400);
                });
                getEl('letter-close-btn').addEventListener('click', () => {
                    getEl('love-letter-viewer').classList.remove('visible');
                });
                letterReplyBtn.addEventListener('click', () => {
                    const viewer = getEl('love-letter-viewer');
                    const letterId = viewer.dataset.letterId;
                    if (letterId) {
                        viewer.classList.remove('visible'); // Close the reader first
                        openEditLoveLetterModal('reply', letterId);
                    }
                });
                setupGlobalEventListeners(); // CRITICAL FIX for image uploads
                        
        // --- æ–°å¢ï¼šè®°å¿†è¡¨æ ¼äº¤äº’ç›‘å¬ ---
getEl('char-memory-table').querySelector('tbody').addEventListener('click', e => {
    const contactId = runtimeState.memoryViewCharId;
    const contact = appState.chat.contacts.find(c => c.id === contactId);
    if (!contact) return;

    const actionBtn = e.target.closest('[data-action]');
    if (!actionBtn) return;

    const action = actionBtn.dataset.action;
    const rowIndex = parseInt(actionBtn.closest('tr').dataset.index);
    const memoryArray = contact.isGroup ? contact.groupSettings.memory : contact.charSettings.memory;
    const memoryEntry = memoryArray[rowIndex];

    if (action === 'delete') {
        if (confirm(`ç¡®å®šè¦åˆ é™¤è¿™æ¡å…³äºâ€œ${memoryEntry.event.content.substring(0, 15)}...â€çš„è®°å¿†å—ï¼Ÿ`)) {
            memoryArray.splice(rowIndex, 1);
            debouncedSaveState();
            renderMemoryTable(contactId);
            showToast('è®°å¿†å·²åˆ é™¤');
        }
    } else if (action === 'edit') {
        const field = actionBtn.dataset.field;
        const fieldParts = field.split('.');
        let currentValue = memoryEntry;
        let currentLabel = '';
        
        const labelMap = { 'relationship': 'å…³ç³»', 'attitude': 'æ€åº¦', 'date': 'æ—¥æœŸ', 'time': 'æ—¶é—´', 'location': 'åœ°ç‚¹', 'people': 'äººç‰©', 'content': 'å†…å®¹', 'emotion': 'æƒ…ç»ª', 'weight': 'æƒé‡', 'item': 'é‡è¦ç‰©å“', 'promise': 'çº¦å®š' };
        fieldParts.forEach(part => {
            currentValue = currentValue?.[part];
            currentLabel = labelMap[part] || part;
        });

        getEl('editing-memory-char-id').value = contactId; // Use contactId
        getEl('editing-memory-row-index').value = rowIndex;
        getEl('editing-memory-field').value = field;
        getEl('memory-cell-editor-label').textContent = `ç¼–è¾‘ï¼š${currentLabel}`;
        getEl('memory-cell-editor-input').value = currentValue || '';

        editMemoryCellModal.classList.add('visible');
    }
});

getEl('cancel-edit-memory-cell-btn').addEventListener('click', () => {
    editMemoryCellModal.classList.remove('visible');
});

getEl('save-memory-cell-btn').addEventListener('click', () => {
const contactId = getEl('editing-memory-char-id').value;
const rowIndex = parseInt(getEl('editing-memory-row-index').value);
const field = getEl('editing-memory-field').value;
let newValue = getEl('memory-cell-editor-input').value;
const contact = appState.chat.contacts.find(c => c.id === contactId);
const memoryArray = contact.isGroup ? contact.groupSettings.memory : contact.charSettings.memory;

if (contact && memoryArray && memoryArray[rowIndex]) {
    const fieldParts = field.split('.');
    let targetObject = memoryArray[rowIndex];

    for (let i = 0; i < fieldParts.length - 1; i++) {
        if (!targetObject[fieldParts[i]]) {
            targetObject[fieldParts[i]] = {};
        }
        targetObject = targetObject[fieldParts[i]];
    }

    if (field.endsWith('weight')) {
        newValue = parseInt(newValue, 10) || 0;
    }

    targetObject[fieldParts[fieldParts.length - 1]] = newValue;
    
    debouncedSaveState();
    renderMemoryTable(contactId);
    editMemoryCellModal.classList.remove('visible');
    showToast('è®°å¿†å·²æ›´æ–°');
}
});
                setupCharFriendRequestModalListeners();
                setupFriendRequestModalListeners();
                    // --- Bubble CSS Editor Listeners ---
    function setupBubbleEditorListeners(context) {
        const editor = getEl(`${context}-bubble-css`);
        const applyBtn = getEl(`${context}-bubble-apply-btn`);
        const restoreBtn = getEl(`${context}-bubble-restore-btn`);

        editor.addEventListener('input', () => updateBubbleCssPreview(context, runtimeState.tempChatSettings));

        applyBtn.addEventListener('click', () => {
            if (confirm('ç¡®å®šåº”ç”¨å½“å‰çš„æ°”æ³¡æ ·å¼å—ï¼Ÿ')) {
                runtimeState.tempChatSettings.userSettings.bubbleCss = editor.value;
                showToast('æ ·å¼å·²åº”ç”¨ï¼è¯·è¿”å›èŠå¤©ç•Œé¢æŸ¥çœ‹ã€‚');
            }
        });

        restoreBtn.addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦è¿˜åŸæ­¤ä¼šè¯çš„é»˜è®¤æ°”æ³¡æ ·å¼å—ï¼Ÿ')) {
                runtimeState.tempChatSettings.userSettings.bubbleCss = '';
                editor.value = '';
                updateBubbleCssPreview(context, runtimeState.tempChatSettings);
                showToast('å·²è¿˜åŸä¸ºé»˜è®¤æ ·å¼ã€‚');
            }
        });
    }
    setupBubbleEditorListeners('us');
    setupBubbleEditorListeners('gcs-us');

                initializeAllRealtimeActivity();
            scheduleLoveLetterChecks(); // æ¯æ¬¡å¯åŠ¨éƒ½æ£€æŸ¥æ˜¯å¦éœ€è¦å®‰æ’ä¸»åŠ¨å†™ä¿¡
        checkAllDueLetters(); // Run once on startup to catch up
            setInterval(checkAllDueLetters, 3 * 60 * 1000); // Check every 5 minutes
            // --- åŠ¨æ€é€šçŸ¥åˆå§‹åŒ– ---
                momentsNotificationBtn.addEventListener('click', openMomentsNotificationModal);
                closeMomentsNotificationModalBtn.addEventListener('click', () => momentsNotificationModal.classList.remove('visible'));
                new ListInteractionHandler(momentsNotificationList, {
                itemSelector: '.notification-item',
                contentSelector: '.notification-item-container',
                actionsSelector: '.preset-data-item-actions',
                onDelete: (item) => {
                    const notificationId = item.dataset.notificationId;
                    if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡é€šçŸ¥å—ï¼Ÿ')) {
                        const index = appState.chat.moments.notifications.findIndex(n => n.id === notificationId);
                        if (index > -1) {
                            appState.chat.moments.notifications.splice(index, 1);
                            saveState();
                            renderMomentsNotifications();
                            updateMomentsNotificationUI();
                        }
                    }
                },
                onTap: (item) => {
                    const notificationId = item.dataset.notificationId;
                    const notification = appState.chat.moments.notifications.find(n => n.id === notificationId);
                    
                    momentsNotificationModal.classList.remove('visible');

                    if (notification) {
                        setTimeout(() => {
                            navigateToMomentsContent(notification);
                        }, 250); 
                    } else {
                         setTimeout(() => {
                            showToast('æ‰¾ä¸åˆ°è¯¥é€šçŸ¥çš„è¯¦æƒ…');
                        }, 250);
                    }
                }
            });

            // åˆå§‹åŒ–è§’æ ‡
            updateMomentsNotificationUI(false);

            appState.music.currentQueueIndex = -1;
                updateMusicListPlayingStatus();
                
                updateTime();
                updateBattery();
                setInterval(updateTime, 30000);
                setInterval(checkExpiredPackets, 60 * 1000);
                
                queueNotification("æ¬¢è¿ä½¿ç”¨åœŸçš‡å¸å°æ‰‹æœºï¼", 'system', 'system');
                            checkForAnniversaryEvents(); // æ£€æŸ¥æ˜¯å¦æœ‰çºªå¿µæ—¥äº‹ä»¶
                    [addMusicModal, addFontModal, replaceIconModal, addEmojiModal, groupRedPacketModal, editMessageModal, libraryModal, loadPersonaModal, gcsMemberModal, gcsManageMembersModal, gcsMemberActionModal, postMomentModal, stockTradeModal].forEach(setupModalTabs);
                
                document.addEventListener('click', (e) => {
                    // Close wb-group-dropdowns
                    document.querySelectorAll('.wb-group-dropdown.visible').forEach(dropdown => {
                        if (!dropdown.parentElement.contains(e.target)) {
                            dropdown.classList.remove('visible');
                        }
                    });

                    // Close FAB menu when clicking outside
                    if (runtimeState.moments.isFabMenuOpen && !e.target.closest('.moments-fab-container')) {
                        runtimeState.moments.isFabMenuOpen = false;
                        const fabOptions = document.querySelector('#moments-fab-options');
                        if (fabOptions) {
                            fabOptions.style.display = 'none';
                        }
                    }
                    if (worldBookFilterDropdown.classList.contains('visible') && !e.target.closest('#world-book-filter-dropdown') && !e.target.closest('#data-filter-btn')) {
                        worldBookFilterDropdown.classList.remove('visible');
                    }
                    // æ–°å¢ï¼šå…³é—­æƒ…ä¹¦ç­›é€‰èœå•
                    if (mailFilterDropdown.classList.contains('visible') && !e.target.closest('#mail-filter-dropdown') && !e.target.closest('#mail-filter-btn')) {
                        mailFilterDropdown.classList.remove('visible');
                    }
                });
            } catch (error) {
                console.error("CRITICAL INITIALIZATION FAILURE:", error);
                alert("åº”ç”¨åˆå§‹åŒ–å¤±è´¥ï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½æ— æ³•ä½¿ç”¨ã€‚è¯·æ£€æŸ¥æ§åˆ¶å°å¹¶å°è¯•åˆ·æ–°ã€‚");
            }
        }

function setupModalTabs(modal) { if (!modal) return; const tabs = modal.querySelectorAll('.tab-btn'); const contents = modal.querySelectorAll('.modal-tab-content'); if (tabs.length === 0) return; tabs.forEach(tab => { tab.addEventListener('click', () => { tabs.forEach(t => t.classList.remove('active')); contents.forEach(c => c.classList.remove('active')); tab.classList.add('active'); const contentId = tab.dataset.tab; const targetContent = modal.querySelector(`.modal-tab-content[id*="${contentId}"]`); if (targetContent) { targetContent.classList.add('active'); } }); }); }
                // --- ä¼˜åŒ–ï¼šå…³é—­èƒŒæ™¯åº“æ—¶ï¼Œæ¸…ç†é¢„è§ˆæ¨¡å¼ç±» ---
                getEl('background-library-close-btn').addEventListener('click', () => {
                    getEl('background-library-modal').classList.remove('background-preview-mode');
                });
                document.addEventListener('click', (e) => {
                    // --- ä¼˜åŒ–ï¼šç‚¹å‡»å¤–éƒ¨åŒºåŸŸæ—¶å…³é—­è¡¨æƒ…é€‰æ‹©å™¨ ---
                    if (emojiPickerPanel.classList.contains('visible') && !emojiPickerPanel.contains(e.target) && !chatEmojiBtn.contains(e.target)) {
                        if (runtimeState.emojiSelectionMode) {
                            exitEmojiSelectionMode();
                        } else {
                            emojiPickerPanel.classList.remove('visible');
                        }
                    }

                    // Close wb-group-dropdowns
                    document.querySelectorAll('.wb-group-dropdown.visible').forEach(dropdown => {
                        if (!dropdown.parentElement.contains(e.target)) {
                            dropdown.classList.remove('visible');
                        }
                    });

                    // Close FAB menu when clicking outside
                    if (runtimeState.moments.isFabMenuOpen && !e.target.closest('.moments-fab-container')) {
                        runtimeState.moments.isFabMenuOpen = false;
                        const fabOptions = document.querySelector('#moments-fab-options');
                        if (fabOptions) {
                            fabOptions.style.display = 'none';
                        }
                    }
                    if (worldBookFilterDropdown.classList.contains('visible') && !e.target.closest('#world-book-filter-dropdown') && !e.target.closest('#data-filter-btn')) {
                        worldBookFilterDropdown.classList.remove('visible');
                    }
                    // æ–°å¢ï¼šå…³é—­æƒ…ä¹¦ç­›é€‰èœå•
                                    if (mailFilterDropdown.classList.contains('visible') && !e.target.closest('#mail-filter-dropdown') && !e.target.closest('#mail-filter-btn')) {
                    mailFilterDropdown.classList.remove('visible');
                }
                if (postcardFilterDropdown.classList.contains('visible') && !e.target.closest('#postcard-filter-dropdown') && !e.target.closest('#mail-filter-btn')) {
                    postcardFilterDropdown.classList.remove('visible');
                }
                if (secretFilterDropdown.classList.contains('visible') && !e.target.closest('#secret-filter-dropdown') && !e.target.closest('#diary-filter-btn')) {
                    secretFilterDropdown.classList.remove('visible');
                }
                });

function enterEmojiSelectionMode() {
    runtimeState.emojiSelectionMode = true;
    emojiPickerPanel.classList.add('selection-mode');
    emojiModeToggleBtn.style.display = 'none'; // éšè—â€œåˆ é™¤â€
    addEmojiBtn.style.display = 'none'; // éšè—â€œæ·»åŠ â€
    emojiDeleteBtn.style.display = 'block'; // æ˜¾ç¤ºâ€œç¡®è®¤â€
    closeEmojiPickerBtn.textContent = 'å–æ¶ˆ'; // â€œå…³é—­â€å˜ä¸ºâ€œå–æ¶ˆâ€
}
function exitEmojiSelectionMode() {
    runtimeState.emojiSelectionMode = false;
    emojiPickerPanel.classList.remove('selection-mode');
    emojiModeToggleBtn.style.display = 'block'; // æ¢å¤â€œåˆ é™¤â€
    addEmojiBtn.style.display = 'block'; // æ¢å¤â€œæ·»åŠ â€
    emojiDeleteBtn.style.display = 'none'; // éšè—â€œç¡®è®¤â€
    closeEmojiPickerBtn.textContent = 'å…³é—­'; // â€œå–æ¶ˆâ€å˜å›â€œå…³é—­â€
    runtimeState.selectedEmojis = [];
    queryAll('.emoji-item.selected').forEach(i => i.classList.remove('selected'));
}
function toggleEmojiSelection(item) { const emojiId = item.dataset.emojiId; item.classList.toggle('selected'); if (runtimeState.selectedEmojis.includes(emojiId)) { runtimeState.selectedEmojis = runtimeState.selectedEmojis.filter(id => id !== emojiId); } else { runtimeState.selectedEmojis.push(emojiId); } if (runtimeState.selectedEmojis.length === 0) { exitEmojiSelectionMode(); } }
function showIncomingCallUI(contactId) {
            if (runtimeState.incomingCall.from) return; // é˜²æ­¢å¤šä¸ªæ¥ç”µ
            
            runtimeState.incomingCall.from = contactId;
            const contact = appState.chat.contacts.find(c => c.id === contactId);
            if (!contact) {
                runtimeState.incomingCall.from = null;
                return;
            }

            setElementImage(incomingCallAvatar, contact.charSettings.avatarId);
            incomingCallName.textContent = getDisplayName(contactId, contactId);
            incomingCallBanner.style.display = 'block';

            // 30ç§’æ— åº”ç­”åˆ™è‡ªåŠ¨æŒ‚æ–­
            runtimeState.incomingCall.timer = setTimeout(() => {
                hideIncomingCallUI();
                addSystemNotification(contactId, 'è§†é¢‘é€šè¯æ— äººæ¥å¬', true);
            }, 30000);
        }

        function hideIncomingCallUI() {
            incomingCallBanner.style.display = 'none';
            if (runtimeState.incomingCall.timer) {
                clearTimeout(runtimeState.incomingCall.timer);
            }
            runtimeState.incomingCall = { from: null, timer: null };
        }

        incomingCallAcceptBtn.addEventListener('click', async () => {
            const callerId = runtimeState.incomingCall.from;
            if (!callerId) return;

            const currentCall = appState.chat.videoCallState;
            // å¦‚æœæ­£åœ¨å’Œåˆ«äººé€šè¯
            if (currentCall.isActive && currentCall.chatId !== callerId) {
                endVideoCall({ reason: 'interrupted' }); // æŒ‚æ–­å½“å‰é€šè¯
            }
            
            hideIncomingCallUI();
            
            // æ¥å—æ–°é€šè¯
            const contact = appState.chat.contacts.find(c => c.id === callerId);
            if(contact) {
                appState.chat.videoCallState = {
                    isActive: true, chatId: callerId, isGroup: contact.isGroup,
                    startTime: Date.now(), log: [], participants: [callerId],
                    isMinimized: false, isCameraSwapped: false, initiator: 'char'
                };
                debouncedSaveState();
                
                addSystemNotification(callerId, 'ä½ æ¥å¬äº†è§†é¢‘é€šè¯', false);
                activateDynamicIslandTimer();
                await openVideoCallModal();
                await triggerAiResponse(callerId, false, false, true); // è§¦å‘AIå¼€åœºç™½
            }
        });

        incomingCallRejectBtn.addEventListener('click', () => {
            const callerId = runtimeState.incomingCall.from;
            if (!callerId) return;
            
            hideIncomingCallUI();

            const currentCall = appState.chat.videoCallState;
            if (currentCall.isActive) {
                // å¦‚æœæ­£åœ¨é€šè¯ä¸­ï¼Œé€šçŸ¥å¯¹æ–¹å çº¿
                addSystemNotification(callerId, 'å¯¹æ–¹æ­£åœ¨é€šè¯ä¸­', true, { callInitiator: 'char' });
            } else {
                // å¦åˆ™ï¼Œæ­£å¸¸æ‹’ç»
                addSystemNotification(callerId, 'ä½ æ‹’ç»äº†è§†é¢‘é€šè¯', true, { callInitiator: 'char' });
            }
        });
        setupBackgroundLibraryListeners();
    // --- ADDED: Draggable Floating Lyrics & Player Opener ---
    const lyricsContainer = getEl('lyrics-container');
    let isLyricDragging = false, lyricStartX, lyricStartY, lyricInitialLeft, lyricInitialTop;

lyricsContainer.addEventListener('pointerdown', (e) => {
    if (e.target.closest('a')) return; // Ignore links if any are added later
    isLyricDragging = false;
    
    // Set a short timeout to differentiate between a click and a drag
    const dragCheck = setTimeout(() => {
        isLyricDragging = true;
    }, 200);

    lyricStartX = e.clientX;
    lyricStartY = e.clientY;
    lyricInitialLeft = lyricsContainer.offsetLeft;
    lyricInitialTop = lyricsContainer.offsetTop;

    const onPointerMove = (moveEvent) => {
        const dx = moveEvent.clientX - lyricStartX;
        const dy = moveEvent.clientY - lyricStartY;
        if(Math.abs(dx) > 5 || Math.abs(dy) > 5) {
            isLyricDragging = true;
        }

        if(isLyricDragging) {
            const screenRect = phoneScreen.getBoundingClientRect();
            let newLeft = lyricInitialLeft + dx;
            let newTop = lyricInitialTop + dy;

            // Boundary checks
            newLeft = Math.max(0, Math.min(newLeft, screenRect.width - lyricsContainer.offsetWidth));
            newTop = Math.max(0, Math.min(newTop, screenRect.height - lyricsContainer.offsetHeight));

            lyricsContainer.style.left = `${newLeft}px`;
            lyricsContainer.style.top = `${newTop}px`;
            lyricsContainer.style.transform = 'none'; // Override the initial transform
        }
    };
    
    const onPointerUp = () => {
        clearTimeout(dragCheck);
        document.removeEventListener('pointermove', onPointerMove);
        document.removeEventListener('pointerup', onPointerUp);

        if (!isLyricDragging) {
            // This was a click, open the player
            if (appState.music.currentQueueIndex !== -1) {
                 playerModal.classList.add('show');
            }
        }
    };

    document.addEventListener('pointermove', onPointerMove);
    document.addEventListener('pointerup', onPointerUp);
});

    // --- END ADDED ---
            function openForwardModal() {
const forwardList = getEl('forward-contact-list');
const currentChatId = runtimeState.currentChatId;
forwardList.innerHTML = ''; // Clear previous content
const contactsToDisplay = appState.chat.contacts.filter(c => c.id !== currentChatId);

if (contactsToDisplay.length === 0) {
    forwardList.innerHTML = '<p style="text-align:center; color:#888; padding: 20px;">æ²¡æœ‰å…¶ä»–è”ç³»äººå¯è½¬å‘</p>';
} else {
    contactsToDisplay.forEach(contact => {
        const li = document.createElement('div');
        li.className = 'contact-list-item';
        li.dataset.forwardToId = contact.id;

        let avatarHTML;
        if (contact.isGroup) {
            const groupAvatarId = contact.groupSettings.avatarId;
            if (groupAvatarId) {
                avatarHTML = `<div class="contact-avatar" data-avatar-id="${groupAvatarId}"></div>`;
            } else {
                const memberAvatarIds = ['user', ...contact.members].slice(0, 4).map(id => {
                    if (id === 'user') return appState.chat.userProfile.avatarId;
                    return appState.chat.contacts.find(c => c.id === id)?.charSettings.avatarId || '';
                }).filter(Boolean);
                const puzzlePieces = memberAvatarIds.map(avatarId => `<div class="puzzle-piece" data-avatar-id="${avatarId}"></div>`).join('');
                avatarHTML = `<div class="contact-avatar group-puzzle">${puzzlePieces}</div>`;
            }
        } else {
            avatarHTML = `<div class="contact-avatar" data-avatar-id="${contact.charSettings.avatarId}"></div>`;
        }

        li.innerHTML = `
            <div class="contact-item-content">
                ${avatarHTML}
                <div class="contact-info">
                    <div class="contact-name">${escapeHTML(contact.remark || (contact.isGroup ? contact.groupSettings.name : contact.charSettings.name))}</div>
                </div>
            </div>`;
        forwardList.appendChild(li);
    });
    forwardList.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
}
getEl('forward-message-modal').classList.add('visible');
}
function openForwardedViewer(forwardedMsg) {
const modal = getEl('view-forwarded-modal');
const title = getEl('view-forwarded-title');
const content = getEl('view-forwarded-content');
title.textContent = `æ¥è‡ª ${escapeHTML(forwardedMsg.content.from)} çš„èŠå¤©è®°å½•`;

let messagesHTML = '';
let lastTimestamp = 0;
forwardedMsg.content.messages.forEach(msg => {
    if (msg.timestamp - lastTimestamp > 5 * 60 * 1000) {
        messagesHTML += `<div class="message-timestamp">${new Date(msg.timestamp).toLocaleString()}</div>`;
        lastTimestamp = msg.timestamp;
    }

    const isUserInOriginalChat = msg.sender === 'user';
    const avatarId = isUserInOriginalChat ? appState.chat.userProfile.avatarId : findUserById(msg.sender)?.avatarId || '';

    let msgContentHTML = '';
     switch (msg.type) {
        case 'text': msgContentHTML = `<div class="message-bubble">${escapeHTML(msg.content)}</div>`; break;
        default: msgContentHTML = `<div class="message-bubble">${escapeHTML(truncateText(msg.content || `[${msg.type}]`, 100))}</div>`; break;
    }

    messagesHTML += `
        <div class="message-item ${isUserInOriginalChat ? 'user' : 'contact'}">
            ${!isUserInOriginalChat ? `<div class="avatar" data-avatar-id="${avatarId}"></div>` : ''}
            <div class="message-content-wrapper">
                <div class="group-message-header" style="font-size: 11px;">${escapeHTML(msg.senderName)}</div>
                ${msgContentHTML}
            </div>
            ${isUserInOriginalChat ? `<div class="avatar" data-avatar-id="${avatarId}"></div>` : ''}
        </div>`;
});

content.innerHTML = messagesHTML;
content.querySelectorAll('.avatar').forEach(el => setElementImage(el, el.dataset.avatarId));
modal.classList.add('visible');
}
getEl('chat-forward-btn').addEventListener('click', () => {
if (runtimeState.selectedMessages.length > 0) {
openForwardModal();
} else {
showToast('è¯·å…ˆé€‰æ‹©è¦è½¬å‘çš„æ¶ˆæ¯', 'error');
}
});
getEl('cancel-forward-message-btn').addEventListener('click', () => {
getEl('forward-message-modal').classList.remove('visible');
});
getEl('close-view-forwarded-btn').addEventListener('click', () => {
getEl('view-forwarded-modal').classList.remove('visible');
});
getEl('forward-contact-list').addEventListener('click', (e) => {
const item = e.target.closest('.contact-list-item');
if (!item) return;
const targetContactId = item.dataset.forwardToId;
if (confirm(`ç¡®å®šè¦è½¬å‘ ${runtimeState.selectedMessages.length} æ¡æ¶ˆæ¯ç»™ ${item.querySelector('.contact-name').textContent} å—ï¼Ÿ`)) {
    const currentContact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
    const targetContact = appState.chat.contacts.find(c => c.id === targetContactId);
    
    const messagesToForward = runtimeState.selectedMessages
        .map(msgId => currentContact.conversation.find(m => m.id === msgId))
        .filter(Boolean)
        .sort((a, b) => a.timestamp - b.timestamp);

    const fromContactName = currentContact.isGroup ? currentContact.groupSettings.name : (currentContact.remark || currentContact.charSettings.name);
    
    const forwardedMessage = {
        id: newId('msg'),
        type: 'forwarded',
        sender: 'user',
        timestamp: Date.now(),
        status: 'pending',
        contactId: targetContactId,
        content: {
            from: fromContactName,
            messages: messagesToForward.map(msg => {
                const senderName = getDisplayName(msg.sender, currentContact.id);
                return { ...msg, senderName };
            })
        }
    };

    targetContact.conversation.push(forwardedMessage);
    updateContactLastMessage(targetContactId);
    
    debouncedSaveState();
    getEl('forward-message-modal').classList.remove('visible');
    exitChatSelectionMode();
    showToast('å·²è½¬å‘ï¼Œè¯·åˆ°å¯¹åº”ä¼šè¯å‘é€');
    
    openSingleChat(targetContactId);
}
});
// --- æ–°å¢ï¼šæ”¶è—åŠŸèƒ½æ ¸å¿ƒé€»è¾‘ ---
function renderCollectionTab() {
const gridEl = getEl('collection-grid');
const collections = appState.diary.collections || [];
collections.sort((a,b) => b.timestamp - a.timestamp);
if (collections.length === 0) {
    gridEl.innerHTML = `<p style="text-align:center; color:#888; margin-top: 50px; grid-column: 1 / -1;">è¿˜æ²¡æœ‰ä»»ä½•æ”¶è—å“¦</p>`;
    return;
}

gridEl.innerHTML = collections.map(collection => {
    const date = new Date(collection.timestamp).toLocaleDateString([], { month: '2-digit', day: '2-digit' });
    const time = new Date(collection.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    return `
        <div class="collection-item-card" data-collection-id="${collection.id}">
            <div class="icon"><i class="fa-solid fa-scroll"></i></div>
            <div class="name">${escapeHTML(collection.name)}</div>
            <div class="participants">${escapeHTML(collection.participants)}</div>
            <div class="date">${date} ${time}</div>
            <div class="collection-item-actions">
                <button class="icon-btn edit-collection-btn" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
                <button class="icon-btn delete-collection-btn" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
            </div>
        </div>
    `;
}).join('');

}

function openCollectionViewer(collectionId) {
    const collection = appState.diary.collections.find(c => c.id === collectionId);
    if (!collection) return;

    const modal = getEl('collection-viewer-modal');
    const titleEl = getEl('collection-viewer-title');
    const contentEl = getEl('collection-viewer-content');
contentEl.dataset.collectionId = collectionId; // Store for later reference
    titleEl.textContent = escapeHTML(collection.name);
    
   let messagesHTML = '';
let lastTimestamp = 0;
collection.messages.forEach(msg => {
    if (msg.timestamp - lastTimestamp > 5 * 60 * 1000) {
        messagesHTML += `<div class="message-timestamp">${new Date(msg.timestamp).toLocaleString()}</div>`;
        lastTimestamp = msg.timestamp;
    }
    
    const isUser = msg.sender === 'user';
    const avatarId = msg.senderAvatarId; // Use the stored avatarId
    
    let msgContentHTML = '';
    // --- æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨ä¸ renderConversation ç›¸åŒçš„æ¸²æŸ“é€»è¾‘ ---
    switch(msg.type) {
        case 'text':
            msgContentHTML += `<div class="message-bubble">${escapeHTML(msg.content)}</div>`;
            break;
        case 'forwarded':
            const summaryLines = msg.content.messages.slice(0, 4).map(fwdMsg => {
                let contentPreview = '';
                switch(fwdMsg.type) {
                    case 'text': contentPreview = fwdMsg.content; break;
                    case 'emoji': contentPreview = `[${fwdMsg.description || 'è¡¨æƒ…'}]`; break;
                    default: contentPreview = `[${fwdMsg.type}]`; break;
                }
                return `${fwdMsg.senderName}: ${truncateText(contentPreview, 20)}`;
            });
            msgContentHTML += `
                <div class="message-bubble forwarded">
                    <div class="forwarded-title">[èŠå¤©è®°å½•] ${escapeHTML(msg.content.from)}</div>
                    <div class="forwarded-summary">${escapeHTML(summaryLines.join('\n'))}</div>
                </div>`;
            break;
        case 'emoji':
            msgContentHTML += `<div class="message-bubble emoji-bubble"><img data-emoji-id="${msg.emojiId}" alt="${msg.description}"></div>`;
            break;
        case 'voice':
            const bubbleWidth = Math.min(60 + msg.duration * 8, 220);
            const spanCount = Math.floor(bubbleWidth / 4);
            const waveformSpans = Array(spanCount).fill(0).map(() => `<span style="height: ${Math.random() * 90 + 10}%"></span>`).join('');
            msgContentHTML += `<div class="message-bubble voice" style="width: ${bubbleWidth}px;"><div class="voice-waveform-container">${waveformSpans}</div><span class="voice-duration">${msg.duration}â€</span></div><div class="voice-text">${msg.content}</div>`;
            break;
        case 'image':
        case 'camera':
            const isCamera = msg.type === 'camera';
            const cameraOverlay = isCamera ? `<div class="camera-text-overlay">(${msg.content})</div>` : '';
            msgContentHTML += `<div class="message-bubble ${msg.type}"><img data-image-id="${msg.imageId}">${cameraOverlay}</div>`;
            break;
        default:
            msgContentHTML += `<div class="message-bubble">[${msg.type}] ${escapeHTML(truncateText(String(msg.content || ''), 100))}</div>`;
            break;
    }

    messagesHTML += `
        <div class="message-item ${isUser ? 'user' : 'contact'}" data-id="${msg.id}">
            ${!isUser ? `<div class="avatar" data-avatar-id="${avatarId}"></div>` : ''}
            <div class="message-content-wrapper">
                <div class="group-message-header" style="font-size: 11px;">${escapeHTML(msg.senderName)}</div>
                ${msgContentHTML}
            </div>
            ${isUser ? `<div class="avatar" data-avatar-id="${avatarId}"></div>` : ''}
        </div>`;
});

contentEl.innerHTML = messagesHTML;
contentEl.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
contentEl.querySelectorAll('[data-emoji-id]').forEach(el => setElementImage(el, el.dataset.emojiId, 'src'));
contentEl.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'src'));
modal.classList.add('visible');}

getEl('chat-collect-btn').addEventListener('click', () => {
if (runtimeState.selectedMessages.length === 0) {
showToast('è¯·å…ˆé€‰æ‹©è¦æ”¶è—çš„æ¶ˆæ¯', 'error');
return;
}
const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
if (!contact) return;

const userDisplayName = getDisplayName('user', contact.id);
const otherDisplayName = contact.isGroup ? contact.groupSettings.name : getDisplayName(contact.id, contact.id);
const defaultName = `${userDisplayName}ä¸${otherDisplayName}çš„èŠå¤©è®°å½•`;

const collectionName = prompt('ä¸ºè¿™æ®µè®°å½•å‘½å:', defaultName);
if (collectionName === null) return; // User cancelled

const messagesToCollect = runtimeState.selectedMessages
    .map(msgId => contact.conversation.find(m => m.id === msgId))
    .filter(Boolean)
    .sort((a, b) => a.timestamp - b.timestamp)
    .map(msg => {
        const senderName = getDisplayName(msg.sender, contact.id);
        const senderIsUser = msg.sender === 'user';
        let senderAvatarId;
        if (contact.isGroup) {
             senderAvatarId = contact.groupSettings.members[msg.sender]?.avatarId || findUserById(msg.sender).avatarId;
        } else {
             senderAvatarId = senderIsUser ? contact.userSettings.avatarId : contact.charSettings.avatarId;
        }
        return { ...msg, senderName, senderAvatarId };
    });

const newCollection = {
    id: newId('collection'),
    name: collectionName || defaultName,
    timestamp: Date.now(),
    participants: `${userDisplayName} & ${otherDisplayName}`,
    messages: messagesToCollect
};

if (!appState.diary.collections) {
    appState.diary.collections = [];
}
appState.diary.collections.push(newCollection);
debouncedSaveState();

// --- æ ¸å¿ƒä¿®å¤ï¼šè°ƒç”¨æ¸²æŸ“å‡½æ•°ä»¥å®æ—¶æ›´æ–°UI ---
renderCollectionTab();

exitChatSelectionMode();
showToast('æ”¶è—æˆåŠŸï¼');
});
getEl('close-collection-viewer-btn').addEventListener('click', () => {
getEl('collection-viewer-modal').classList.remove('visible');
});
// --- æ–°å¢ï¼šä¸ºæ”¶è—æŸ¥çœ‹å™¨æ·»åŠ äº¤äº’äº‹ä»¶ç›‘å¬ ---
getEl('collection-viewer-modal').addEventListener('click', (e) => {
const target = e.target;
// --- è¯­éŸ³ & æ–‡å­—å›¾äº¤äº’ ---
const voiceBubble = target.closest('.message-bubble.voice');
if (voiceBubble) {
    const voiceText = voiceBubble.nextElementSibling;
    if (voiceText) voiceText.style.display = voiceText.style.display === 'block' ? 'none' : 'block';
    return;
}

const cameraBubble = target.closest('.message-bubble.camera');
if (cameraBubble) {
    cameraBubble.classList.toggle('show-text');
    return;
}

// --- è½¬å‘è®°å½•äº¤äº’ ---
const forwardedBubble = target.closest('.message-bubble.forwarded');
if (forwardedBubble) {
    const modal = getEl('collection-viewer-modal');
    const contentEl = modal.querySelector('#collection-viewer-content');
    const collectionId = contentEl.dataset.collectionId; // We need to store this when opening
    const collection = appState.diary.collections.find(c => c.id === collectionId);
    
    const msgItem = forwardedBubble.closest('.message-item');
    if (collection && msgItem) {
        const msgId = msgItem.dataset.id;
        const msg = collection.messages.find(m => m.id === msgId);
        if (msg) {
            openForwardedViewer(msg);
        }
    }
    return;
}

// --- å›¾ç‰‡ç‚¹å‡»äº¤äº’ ---

});
// --- æ–°å¢ï¼šæ”¶è—ç¼–è¾‘ä¸åˆ é™¤äº¤äº’ ---
function openEditCollectionModal(collectionId) {
const modal = getEl('edit-collection-modal');
const collection = appState.diary.collections.find(c => c.id === collectionId);
if (!collection) return;
getEl('editing-collection-id').value = collectionId;
getEl('collection-name-input').value = collection.name;
modal.classList.add('visible');
}
getEl('collection-grid').addEventListener('click', e => {
const card = e.target.closest('.collection-item-card');
if (!card) return;
const collectionId = card.dataset.collectionId;
const collection = appState.diary.collections.find(c => c.id === collectionId);
if (!collection) return;

if (e.target.closest('.delete-collection-btn')) {
    e.stopPropagation();
    if (confirm(`ç¡®å®šè¦åˆ é™¤æ”¶è— "${collection.name}" å—ï¼Ÿ`)) {
        appState.diary.collections = appState.diary.collections.filter(c => c.id !== collectionId);
        debouncedSaveState();
        renderCollectionTab();
        showToast('æ”¶è—å·²åˆ é™¤');
    }
} else if (e.target.closest('.edit-collection-btn')) {
    e.stopPropagation();
    openEditCollectionModal(collectionId);
} else {
    openCollectionViewer(collectionId);
}
});
getEl('cancel-edit-collection-btn').addEventListener('click', () => {
getEl('edit-collection-modal').classList.remove('visible');
});
// --- æ–°å¢ï¼šè‚¡ç¥¨ç¼–è¾‘å¼¹çª—çš„ç›‘å¬å™¨ ---
getEl('cancel-edit-stock-btn').addEventListener('click', () => {
getEl('edit-stock-modal').classList.remove('visible');
});
getEl('save-stock-btn').addEventListener('click', () => {
const stockId = getEl('editing-stock-id').value;
const stock = appState.assets.stocks.market.find(s => s.id === stockId);
if (stock) {
const newName = getEl('stock-name-input').value.trim();
const newTicker = getEl('stock-ticker-input').value.trim().toUpperCase();
if (!newName || !newTicker || newTicker.length !== 4) {
showToast('è‚¡ç¥¨åç§°å’Œ4ä½ä»£ç å‡ä¸èƒ½ä¸ºç©º', 'error');
return;
}
stock.name = newName;
stock.ticker = newTicker;
debouncedSaveState();
renderStockMarket();
getEl('edit-stock-modal').classList.remove('visible');
showToast('è‚¡ç¥¨ä¿¡æ¯å·²æ›´æ–°');
}
});

// ===================================================================
// --- å¾®åš (Weibo) ç•Œé¢é€»è¾‘ ---
// ===================================================================
function getWeiboData(profileId) {
    if (profileId === 'user') {
        return appState.chat.userProfile.weibo;
    }
    const contact = appState.chat.contacts.find(c => c.id === profileId);
    return contact?.charSettings?.weibo;
}

function getWeiboDisplayNameWithVIP(profileId) {
    const weiboData = getWeiboData(profileId);
    if (!weiboData || !weiboData.profile) {
        const genericProfile = findUserById(profileId);
        return escapeHTML(genericProfile.name || 'æœªçŸ¥ç”¨æˆ·');
    }
    const name = weiboData.profile.name;
    const followerCount = weiboData.followerCount || 0;
    const vipIcon = '<i class="fa-solid fa-crown" style="color: #ffc107; margin-left: 5px; font-size: 0.9em;"></i>';
    return escapeHTML(name) + (followerCount >= 1000000 ? vipIcon : '');
}

        function getMomentsDisplayName(profileId) {
            if (profileId === 'user') {
                return appState.chat.moments.profile.name;
            }
            const contact = appState.chat.contacts.find(c => c.id === profileId);
            // Prioritize remark over the base name, which is consistent with the chat list.
            return contact ? (contact.remark || contact.charSettings.name) : 'æœªçŸ¥ç”¨æˆ·';
        }
        function openWeiboProfileEditor(profileId) {
    const modal = getEl('edit-weibo-profile-modal');
    const weiboData = getWeiboData(profileId);
    if (!weiboData || !weiboData.profile) {
        showToast('æ— æ³•åŠ è½½ä¸ªäººèµ„æ–™', 'error');
        return;
    }

    getEl('editing-weibo-profile-id').value = profileId;
    getEl('weibo-bio-input').value = weiboData.profile.bio || '';
    getEl('weibo-persona-input').value = weiboData.profile.persona || '';
    
    modal.classList.add('visible');
}
function handleWeiboTabChange(tabId) {
            const titleEl = weiboAppScreen.querySelector('.title');
        const headerActionsEl = getEl('weibo-header-actions');
        const tabMap = { 'weibo-main': 'ä½ çš„ä¸»é¡µ', 'weibo-char-main': 'TAçš„ä¸»é¡µ', 'hot-search': 'çƒ­æœ', 'weibo-square': 'å¹¿åœº' };
        titleEl.textContent = tabMap[tabId] || 'å¾®åš';

        headerActionsEl.innerHTML = ''; // Clear actions by default

        if (tabId === 'weibo-main') {
            renderWeiboPage('user');
            headerActionsEl.innerHTML = `<button class="action-btn" id="weibo-profile-settings-btn"><i class="fa-solid fa-gear"></i></button>`;
        } else if (tabId === 'weibo-char-main') {
        headerActionsEl.innerHTML = `<button class="action-btn" id="weibo-char-select-btn"><i class="fa-solid fa-gear"></i></button>`;
        if (!runtimeState.weibo.currentCharProfileId) {
            const firstChar = appState.chat.contacts.find(c => !c.isGroup);
            if (firstChar) {
                runtimeState.weibo.currentCharProfileId = firstChar.id;
            }
        }
        const charTabContent = getEl('weibo-char-main-tab-content');
        charTabContent.innerHTML = ''; // Clear previous content before rendering
        if (runtimeState.weibo.currentCharProfileId) {
            renderWeiboPage(runtimeState.weibo.currentCharProfileId);
        } else {
            charTabContent.innerHTML = '<p style="text-align:center; color: #888; margin-top: 50px;">æš‚æ— å…¶ä»–è§’è‰²</p>';
        }
    }
}

weiboAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
    if (e.target.classList.contains('tab-link')) {
        const tabId = e.target.dataset.tab;
        weiboAppScreen.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
        weiboAppScreen.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        e.target.classList.add('active');
        getEl(`${tabId}-tab-content`).classList.add('active');
        handleWeiboTabChange(tabId);
    }
});

function renderWeiboPage(profileId) {
    runtimeState.weibo = runtimeState.weibo || {};
    runtimeState.weibo.currentProfileId = profileId;
    const isUserPage = profileId === 'user';
    
    let profileData, weiboData;
    if (isUserPage) {
        profileData = getActiveUserProfile();
        weiboData = profileData.weibo;
    } else {
        const contact = appState.chat.contacts.find(c => c.id === profileId);
if (!contact) return;
        // --- æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿è§’è‰²æ‹¥æœ‰å¾®åšæ•°æ®ç»“æ„ ---
        if (!contact.charSettings.weibo) {
            contact.charSettings.weibo = {
                profile: {
                    name: contact.charSettings.name,
                    bio: 'è¿™ä¸ªäººå¾ˆæ‡’ï¼Œä»€ä¹ˆéƒ½æ²¡å†™...',
                    avatarId: contact.charSettings.avatarId,
                    coverId: 'default_moments_cover',
                },
                posts: [], followingCount: Math.floor(Math.random() * 500),
                followerCount: Math.floor(Math.random() * 10000),
                followingIds: [], followerIds: []
            };
            debouncedSaveState(); // Save the newly created structure
        }        profileData = contact.charSettings;
        weiboData = profileData.weibo;
    }

    const container = isUserPage ? getEl('weibo-main-tab-content') : getEl('weibo-char-main-tab-content');
    container.innerHTML = `
        <div class="weibo-scroll-container">
            <div class="weibo-cover" style="background-image: url('${DEFAULT_WALLPAPER_URL}');"></div>
            <div class="weibo-profile-header">
                <div class="weibo-profile-content">
                    <div class="weibo-profile-avatar" data-avatar-id="${weiboData.profile.avatarId}"></div>
                    <div class="weibo-profile-actions">
                         <!-- Action buttons like 'Follow', 'Message' can be added here later -->
                    </div>
                </div>
            </div>
                    <div class="weibo-profile-details">
            <div class="weibo-profile-name">${getWeiboDisplayNameWithVIP(profileId)}</div>
            <div class="weibo-profile-bio">${escapeHTML(weiboData.profile.bio)}</div>
                <div class="weibo-stats">
                    <div class="weibo-stat-item"><div class="count">${(weiboData.posts || []).length}</div><div class="label">å¾®åš</div></div>
                    <div class="weibo-stat-item" data-stat-type="following"><div class="count">${formatNumber(weiboData.followingCount || 0)}</div><div class="label">å…³æ³¨</div></div>
                    <div class="weibo-stat-item" data-stat-type="followers"><div class="count">${formatNumber(weiboData.followerCount || 0)}</div><div class="label">ç²‰ä¸</div></div>
                </div>
            </div>
            <div class="weibo-feed">
                <!-- Feed will be rendered by renderWeiboFeed -->
            </div>
        </div>
        <div class="moments-fab-container" id="weibo-fab-container">
             <div id="weibo-fab" class="moments-fab"><i class="fa-solid fa-plus"></i></div>
        </div>
    `;

    setElementImage(container.querySelector('.weibo-profile-avatar'), weiboData.profile.avatarId);
    setElementImage(container.querySelector('.weibo-cover'), weiboData.profile.coverId);

    renderWeiboFeed(profileId);
}

function renderWeiboFeed(profileId) {
    const containerSelector = profileId === 'user' ? '#weibo-main-tab-content' : '#weibo-char-main-tab-content';
    const feedEl = document.querySelector(`${containerSelector} .weibo-feed`);
    if (!feedEl) return;
    
    // For now, the feed only shows the current profile's posts.
    let weiboData;
     if (profileId === 'user') {
        weiboData = appState.chat.userProfile.weibo;
    } else {
        const contact = appState.chat.contacts.find(c => c.id === profileId);
        if (!contact) return;
        weiboData = contact.charSettings.weibo;
    }

    const postsToRender = (weiboData.posts || []).sort((a,b) => b.timestamp - a.timestamp);

    if (postsToRender.length === 0) {
        feedEl.innerHTML = `<p style="text-align:center; color:#888; margin-top: 50px;">è¿™é‡Œç©ºç©ºå¦‚ä¹Ÿ~</p>`;
    } else {
        feedEl.innerHTML = postsToRender.map(post => renderSingleWeiboPost(post)).join('');
    }

    feedEl.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    feedEl.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));
    setupWeiboListInteraction(feedEl);
}

function renderSingleWeiboPost(post) {
    const author = findUserById(post.authorId);
    if (!author) { // Safety check for deleted authors
        console.warn(`Could not render Weibo post ${post.id} because author ${post.authorId} was not found.`);
        return '';
    }
    const isLiked = (post.likes || []).includes('user');
    const realComments = (post.comments || []).filter(c => !c.authorId.startsWith('npc_'));
    const totalCommentsCount = (post.commentCount || 0) + realComments.length;
    
    let commentsSectionHTML = '';
    const commentInputHTML = `
        <div class="comment-input-area">
            <input type="text" placeholder="å‘è¡¨ä½ çš„è¯„è®º...">
            <button class="settings-button secondary send-comment-btn" style="width: 50px; padding: 5px; display: flex; align-items: center; justify-content: center;"><i class="fa-solid fa-paper-plane"></i></button>
        </div>
    `;

    if (post.isLoadingComments) {
        commentsSectionHTML = `
            <p style="text-align:center; color:#888; padding: 20px 0;">è¯„è®ºæ­£åœ¨åŠ è½½ä¸­...</p>
            ${commentInputHTML}
        `;
    } else {
        const commentsHTML = (post.comments || []).map(comment => renderSingleWeiboComment(comment, post.id)).join('');
        commentsSectionHTML = `
            <div class="details-comments-list">${commentsHTML}</div>
            ${commentInputHTML}
        `;
    }

    let contentHTML = '';

    // Reposted Content
    if (post.type === 'repost' && post.repostedFrom) {
        const originalPostData = post.repostedFrom;
        const originalAuthorNameHTML = getWeiboDisplayNameWithVIP(originalPostData.originalAuthorId);
        
        // --- æ ¸å¿ƒä¿®å¤ï¼šæ£€æŸ¥åŸå¾®åšæ˜¯å¦å­˜åœ¨ ---
        let originalPostExists = false;
        let allPostsFlat = [];
        appState.chat.userProfiles.forEach(p => allPostsFlat.push(...(p.weibo.posts || [])));
        appState.chat.contacts.forEach(c => allPostsFlat.push(...(c.charSettings?.weibo?.posts || [])));
        if (allPostsFlat.some(p => p.id === originalPostData.originalPostId)) {
            originalPostExists = true;
        }

        if (originalPostExists) {
            let originalContentText = '';
             if (originalPostData.topic && originalPostData.topic.trim()) {
                originalContentText += `<span class="post-topic" style="color: var(--accent-color); font-weight: 500;">#${escapeHTML(originalPostData.topic.replace(/^#/, ''))}#</span> `;
            }
            originalContentText += escapeHTML(originalPostData.originalContent.text);

            contentHTML += `
                <div class="post-forwarded-content" data-original-post-id="${originalPostData.originalPostId}">
                    <div class="post-header" style="margin-bottom: 5px;">
                        <div class="post-author-name">@${originalAuthorNameHTML}</div>
                    </div>
                    <div class="post-content-text">${originalContentText}</div>
                </div>
            `;
        } else {
             contentHTML += `
                <div class="post-forwarded-content deleted">
                    <p style="text-align: center; color: var(--secondary-text-color);">æ­¤å¾®åšå·²è¢«åˆ é™¤</p>
                </div>
            `;
        }
    }

    // Normal Post Content
    let displayText = '';
    if (post.topic && post.topic.trim()) {
        const formattedTopic = post.topic.trim().replace(/^#/, '');
        displayText += `<span class="post-topic" style="color: var(--accent-color); font-weight: 500;">#${escapeHTML(formattedTopic)}</span> `;
    }
    if (post.content.text) {
        displayText += escapeHTML(post.content.text);
    }
    const postText = displayText ? `<div class="post-content-text">${displayText}</div>` : '';
    const imageGridHTML = post.content.images && post.content.images.length > 0 
        ? `<div class="post-image-grid">${post.content.images.map(imgData => {
            const isTextImage = typeof imgData === 'object' && imgData.isTextImage;
            const imageId = isTextImage ? imgData.imageId : imgData;
            const textOverlay = isTextImage ? `<div class="camera-text-overlay">(${escapeHTML(imgData.description)})</div>` : '';
            const itemClass = isTextImage ? 'post-image-item text-image-post' : 'post-image-item';
            return `<div class="${itemClass}" data-image-id="${imageId}" data-is-text-image="${isTextImage}">${textOverlay}</div>`;
          }).join('')}</div>`
        : '';
    contentHTML = `${postText}${imageGridHTML}${contentHTML}`;

    return `
        <div class="weibo-post-item" data-post-id="${post.id}">
            <div class="post-item-content">
                <div class="post-header">
                    <div class="post-avatar" data-avatar-id="${author.avatarId}"></div>
                    <div class="post-author-info">
                            <div class="post-author-name">${getWeiboDisplayNameWithVIP(post.authorId)}</div>
                        <div class="post-timestamp">${new Date(post.timestamp).toLocaleString()}</div>
                    </div>
                </div>
                ${contentHTML}
                <div class="post-footer">
                    <div class="post-footer-stats">
                        <div class="footer-stat-item">è½¬å‘: ${post.repostCount || 0}</div>
                        <div class="footer-stat-item">è¯„è®º: ${totalCommentsCount}</div>
                        <div class="footer-stat-item">èµ: ${post.likeCount + (post.likes || []).length}</div>
                    </div>
                    <div class="comment-actions-inline" style="justify-content: space-around;">
                        <button class="icon-btn repost-btn"><i class="fa-solid fa-share-from-square"></i></button>
                        <button class="icon-btn" data-action="toggle-comments"><i class="fa-regular fa-comment"></i> <span class="comment-count">${totalCommentsCount}</span></button>
                        <button class="icon-btn like-btn ${isLiked ? 'liked' : ''}">${isLiked ? '<i class="fa-solid fa-heart"></i>' : '<i class="fa-regular fa-heart"></i>'}</button>
                    </div>
                    <div class="weibo-comments-wrapper" style="display: none;">
                        ${commentsSectionHTML}
                    </div>
                </div>
            </div>
            <div class="post-item-actions">
                <div class="edit-action"><i class="fa-solid fa-pen-to-square"></i></div>
                <div class="delete-action"><i class="fa-solid fa-trash-can"></i></div>
            </div>
        </div>
    `;
}

function renderSingleWeiboComment(comment, postId) {
    let author;
    if (comment.authorId.startsWith('npc_')) {
        author = { id: comment.authorId, name: comment.authorName, avatarId: comment.authorAvatarId };
    } else {
        author = findUserById(comment.authorId);
    }
    if (!author) return '';

    const repliesHTML = (comment.replies || []).map(reply => renderSingleWeiboReply(reply, comment.replies, postId, comment.id)).join('');
    const canModify = true; 
    return `
        <div class="comment-item" data-comment-id="${comment.id}">
            <div class="comment-item-main" style="padding-top: 8px; padding-bottom: 8px;">
                <div class="comment-avatar" data-avatar-id="${author.avatarId}" style="width: 32px; height: 32px;"></div>
                <div class="comment-content">
                    <div class="comment-header">
                        <span class="comment-author">${comment.authorId.startsWith('npc_') ? escapeHTML(author.name) : getWeiboDisplayNameWithVIP(comment.authorId)}</span>
                        <span class="comment-timestamp">${new Date(comment.timestamp).toLocaleString()}</span>
                        <div class="comment-actions-inline" style="display: none;">
                            ${canModify ? `
                            <button class="icon-btn" data-action="edit-comment" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
                            <button class="icon-btn" data-action="delete-comment" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
                            ` : ''}
                        </div>
                    </div>
                    <p class="comment-text">${escapeHTML(comment.text)}</p>
                    <div class="comment-replies" style="margin-left: 0;">${repliesHTML}</div>
                    <div class="reply-input-container">
                        <input type="text" placeholder="å›å¤ ${author.name}...">
                        <button class="settings-button secondary" style="padding: 5px 10px;">å‘é€</button>
                    </div>
                </div>
            </div>
        </div>`;
}

function renderSingleWeiboReply(reply, allReplies, postId, commentId) {
        let author;
        if (reply.authorId.startsWith('npc_')) {
            author = { id: reply.authorId, name: reply.authorName, avatarId: reply.authorAvatarId };
        } else {
            author = findUserById(reply.authorId);
        }
        if (!author) return '';

        let replyText = escapeHTML(reply.text);
    const mentionMatch = replyText.match(/^@(\S+)\s(.*)/s);
    let targetHTML = '';
    if(mentionMatch) {
        targetHTML = `å›å¤ <span class="reply-target">@${mentionMatch[1]}</span>: `;
        replyText = mentionMatch[2];
    } else if (reply.replyTo) {
         const targetReply = allReplies.find(r => r.id === reply.replyTo);
        if (targetReply) {
            const targetAuthor = findUserById(targetReply.authorId);
            targetHTML = `å›å¤ <span class="reply-target">@${targetAuthor.name}</span>: `;
        }
    }
    const canModify = true;
    return `
        <div class="reply-item" data-reply-id="${reply.id}">
            <div class="reply-avatar" data-avatar-id="${author.avatarId}"></div>
            <div class="reply-content">
                <div class="comment-header">
                     <div>
                        <span class="reply-author">${reply.authorId.startsWith('npc_') ? escapeHTML(author.name) : getWeiboDisplayNameWithVIP(reply.authorId)}</span>
                        <span class="reply-timestamp">${new Date(reply.timestamp).toLocaleString()}</span>
                     </div>
                     <div class="comment-actions-inline" style="display: none;">
                        ${canModify ? `
                        <button class="icon-btn" data-action="edit-comment" title="ç¼–è¾‘"><i class="fa-solid fa-pen-to-square"></i></button>
                        <button class="icon-btn" data-action="delete-comment" title="åˆ é™¤"><i class="fa-solid fa-trash-can"></i></button>
                        ` : ''}
                     </div>
                </div>
                <p class="comment-text">${targetHTML}${replyText}</p>
                <div class="reply-input-container">
                    <input type="text" placeholder="å›å¤ ${author.name}...">
                    <button class="settings-button secondary" style="padding: 5px 10px;">å‘é€</button>
                </div>
            </div>
        </div>`;
}
    document.addEventListener('click', e => {
        if (e.target.closest('#weibo-profile-settings-btn')) {
            openWeiboProfileSettingsModal();
        }
    });
    getEl('weibo-app-screen').addEventListener('click', e => {
    const charSelectBtn = e.target.closest('#weibo-char-select-btn');
    if (charSelectBtn) {
        openWeiboCharSelector();
        return;
    }
    const fab = e.target.closest('#weibo-fab');
    if (fab) {
        // BUG FIX: Post as the current profile owner (user or char)
        const authorId = runtimeState.weibo.currentProfileId || 'user';
        openPostWeiboModal(null, authorId);
        return;
    }
    const createFileInput = (accept, onchange) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = accept;
        input.style.display = 'none';
        input.onchange = onchange;
        document.body.appendChild(input);
        input.click();
        document.body.removeChild(input);
    };

    const isUserPage = runtimeState.weibo.currentProfileId === 'user';
    if (isUserPage) {
        if (e.target.closest('.weibo-profile-avatar')) {
            createFileInput('image/*', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const newAvatarId = newId('lib');
                await addMediaToDB(newAvatarId, file);
                appState.chat.userProfile.weibo.profile.avatarId = newAvatarId;

                debouncedSaveState();
                renderWeiboPage('user');
                showToast('å¤´åƒå·²æ›´æ–°');
            });
            return;
        }
        if (e.target.closest('.weibo-cover')) {
            createFileInput('image/*', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const newCoverId = newId('lib');
                await addMediaToDB(newCoverId, file);
                appState.chat.userProfile.weibo.profile.coverId = newCoverId;

                debouncedSaveState();
                renderWeiboPage('user');
                showToast('èƒŒæ™¯å·²æ›´æ–°');
            });
            return;
        }
        if (e.target.closest('.weibo-profile-name')) {
            const currentName = appState.chat.userProfile.weibo.profile.name;
            const newName = prompt('ä¿®æ”¹ä½ çš„æ˜µç§°:', currentName);
            if (newName && newName.trim() !== currentName) {
                const finalName = newName.trim();
                appState.chat.userProfile.weibo.profile.name = finalName;

                debouncedSaveState();
                renderWeiboPage('user');
                showToast('æ˜µç§°å·²æ›´æ–°');
            }
            return;
        }
        if (e.target.closest('.weibo-profile-bio')) {
            const profileId = runtimeState.weibo.currentProfileId;
            openWeiboProfileEditor(profileId);
            return;
        }
    } else { // Char's Page
        const charId = runtimeState.weibo.currentProfileId;
        const contact = appState.chat.contacts.find(c => c.id === charId);
        if (!contact) return;

        if (e.target.closest('.weibo-profile-avatar')) {
            createFileInput('image/*', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const newAvatarId = newId('lib');
                await addMediaToDB(newAvatarId, file);
                contact.charSettings.weibo.profile.avatarId = newAvatarId;
                debouncedSaveState();
                renderWeiboPage(charId);
                showToast('å¤´åƒå·²æ›´æ–°');
            });
            return;
        }
        if (e.target.closest('.weibo-cover')) {
            createFileInput('image/*', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const newCoverId = newId('lib');
                await addMediaToDB(newCoverId, file);
                contact.charSettings.weibo.profile.coverId = newCoverId;
                debouncedSaveState();
                renderWeiboPage(charId);
                showToast('èƒŒæ™¯å·²æ›´æ–°');
            });
            return;
        }
        if (e.target.closest('.weibo-profile-name')) {
            const currentName = contact.charSettings.weibo.profile.name;
            const newName = prompt(`ä¿®æ”¹ ${currentName} çš„æ˜µç§°:`, currentName);
            if (newName && newName.trim() !== currentName) {
                contact.charSettings.weibo.profile.name = newName.trim();
                debouncedSaveState();
                renderWeiboPage(charId);
                showToast('æ˜µç§°å·²æ›´æ–°');
            }
            return;
        }
        if (e.target.closest('.weibo-profile-bio')) {
            openWeiboProfileEditor(charId);
            return;
        }
    }
    
    const statItem = e.target.closest('.weibo-stat-item[data-stat-type]');
    if (statItem) {
        const statType = statItem.dataset.statType;
        const profileId = runtimeState.weibo.currentProfileId;
        
        let weiboData;
        if (profileId === 'user') {
            weiboData = appState.chat.userProfile.weibo;
        } else {
            const contact = appState.chat.contacts.find(c => c.id === profileId);
            if (!contact) return;
            weiboData = contact.charSettings.weibo;
        }

        const currentCount = (statType === 'following') ? (weiboData.followingCount || 0) : (weiboData.followerCount || 0);
        const typeLabel = (statType === 'following') ? 'å…³æ³¨' : 'ç²‰ä¸';

        const newCountStr = prompt(`ä¿®æ”¹${typeLabel}æ•°é‡:`, currentCount);
        if (newCountStr === null) return; // User cancelled

        const newCount = parseInt(newCountStr, 10);
        if (isNaN(newCount) || newCount < 0) {
            showToast('è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„éè´Ÿæ•´æ•°', 'error');
            return;
        }

        if (statType === 'following') {
            weiboData.followingCount = newCount;
            if (isUserPage) {
                getActiveUserProfile().weibo.followingCount = newCount;
            }
        } else {
            weiboData.followerCount = newCount;
            if (isUserPage) {
                getActiveUserProfile().weibo.followerCount = newCount;
            }
        }
        showToast(`${typeLabel}æ•°é‡å·²æ›´æ–°`);
        return; // Stop further processing
    }
    const postItem = e.target.closest('.weibo-post-item');
    if (!postItem) return;

    const postId = postItem.dataset.postId;
    const profileId = runtimeState.weibo.currentProfileId;
    
    let postOwnerData = (profileId === 'user') ? appState.chat.userProfile.weibo : appState.chat.contacts.find(c => c.id === profileId)?.charSettings.weibo;
    // This is a simplification. A real Weibo would need to search all users' posts.
    let post = postOwnerData?.posts.find(p => p.id === postId);

    if (!post) return;

    if (e.target.closest('.like-btn')) {
            if (!post.likes) post.likes = [];
            const userIndex = post.likes.indexOf('user');
            if (userIndex > -1) {
                post.likes.splice(userIndex, 1);
            } else {
                post.likes.push('user');
            }
            if (profileId === 'user') {
                getActiveUserProfile().weibo = postOwnerData;
            }
            debouncedSaveState();
            renderWeiboFeed(profileId);
        } else if (e.target.closest('.comment-btn')) {
        const commentInputArea = postItem.querySelector('.comment-input-area');
        commentInputArea.style.display = commentInputArea.style.display === 'flex' ? 'none' : 'flex';
        if (commentInputArea.style.display === 'flex') {
            commentInputArea.querySelector('input').focus();
        }
    } else if (e.target.closest('.send-comment-btn')) {
        const input = e.target.closest('.comment-input-area').querySelector('input');
        const text = input.value.trim();
        if (!text) return;
        if (!post.comments) post.comments = [];
        post.comments.push({ id: newId('comment'), authorId: 'user', text, likes: [], replies: [], timestamp: Date.now() });
        input.value = '';
        debouncedSaveState();
        renderWeiboFeed(profileId);
    } else if (e.target.closest('.repost-btn')) {
        const modal = getEl('repost-weibo-modal');
        const preview = getEl('repost-weibo-preview');
        modal.dataset.postId = postId;
        
        const originalAuthor = findUserById(post.authorId);
        
        preview.innerHTML = `
            <div class="post-header" style="margin-bottom: 5px;">
                <div class="post-author-name">@${escapeHTML(originalAuthor.name)}</div>
            </div>
<div class="post-content-text">${ (post.topic ? `<span style="color: var(--accent-color); font-weight: 500;">#${escapeHTML(post.topic.replace(/^#/, ''))}</span> ` : '') + escapeHTML(post.content.text) }</div>
        `;
        modal.classList.add('visible');
    }

    // Handle comment/reply interactions
    const commentOrReplyItem = e.target.closest('.comment-item, .reply-item');
    if (commentOrReplyItem) {
        handleWeiboCommentInteraction(e, commentOrReplyItem, post, profileId);
    }
    const toggleCommentsBtn = e.target.closest('[data-action="toggle-comments"]');
    if (toggleCommentsBtn) {
        const postItem = toggleCommentsBtn.closest('.weibo-post-item');
        if (postItem) {
            const commentsWrapper = postItem.querySelector('.weibo-comments-wrapper');
            if (commentsWrapper) {
                commentsWrapper.style.display = commentsWrapper.style.display === 'none' ? 'block' : 'none';
            }
        }
        return;
    }
        // --- æ–°å¢ï¼šå¤„ç†å¾®åšå›¾ç‰‡ç‚¹å‡» ---
    const imageItem = e.target.closest('.post-image-item');
    if (imageItem) {
        const clickedImageId = imageItem.dataset.imageId;
        const allImages = post.content.images.map(imgData => {
            const isTextImage = typeof imgData === 'object' && imgData.isTextImage;
            return {
                imageId: isTextImage ? imgData.imageId : imgData,
                isTextImage: isTextImage,
                description: isTextImage ? imgData.description : null
            };
        });
        const startIndex = allImages.findIndex(img => img.imageId === clickedImageId);
        
        if (startIndex > -1) {
            openSimpleViewer(allImages, startIndex);
        }
    }
});

getEl('cancel-repost-weibo-btn').addEventListener('click', () => {
    getEl('repost-weibo-modal').classList.remove('visible');
    getEl('repost-weibo-content').value = '';
});

getEl('confirm-repost-weibo-btn').addEventListener('click', () => {
    const modal = getEl('repost-weibo-modal');
    const originalPostId = modal.dataset.postId;
    const reposterId = 'user'; // For now, only user can repost
    
    // Again, simplification. We need a global way to find posts.
    let originalPost = null;
    let originalPostOwner = null;
    for (const contact of [appState.chat.userProfile, ...appState.chat.contacts.map(c => c.charSettings)]) {
        if (contact.weibo && contact.weibo.posts) {
            originalPost = contact.weibo.posts.find(p => p.id === originalPostId);
            if (originalPost) {
                originalPostOwner = contact;
                break;
            }
        }
    }
    
    if (!originalPost) {
        showToast('è½¬å‘å¤±è´¥ï¼šæ‰¾ä¸åˆ°åŸå¾®åš', 'error');
        return;
    }

    const repostContent = getEl('repost-weibo-content').value.trim();

    const newPost = {
        id: newId('weibo_post'),
        authorId: reposterId,
        type: 'repost',
        timestamp: Date.now(),
        content: { text: repostContent },
        repostedFrom: {
            originalPostId: originalPost.id,
            originalAuthorId: originalPost.authorId,
            originalAuthorName: findUserById(originalPost.authorId).name,
            originalContent: { text: originalPost.content.text.substring(0, 140) }
        },
        reposts: 0,
        comments: [],
        likes: []
    };

    if (!originalPost.reposts) originalPost.reposts = 0;
    originalPost.reposts++;

    appState.chat.userProfile.weibo.posts.push(newPost);
    debouncedSaveState();
    
    modal.classList.remove('visible');
    getEl('repost-weibo-content').value = '';
    renderWeiboPage(runtimeState.weibo.currentProfileId);
    showToast('è½¬å‘æˆåŠŸ');
});

function handleWeiboCommentInteraction(e, item, post, profileId) {
    const isReply = item.classList.contains('reply-item');
    const parentCommentItem = item.closest('.comment-item');
    const commentId = parentCommentItem.dataset.commentId;
    const comment = post.comments.find(c => c.id === commentId);
    if (!comment) return;

    const actionBtn = e.target.closest('.icon-btn[data-action]');
    const sendBtn = e.target.closest('.reply-input-container button');

    if (actionBtn) {
        const action = actionBtn.dataset.action;
        if (action === 'edit-comment') {
            openWeiboCommentEditor(post.id, commentId, isReply ? item.dataset.replyId : null);
        } else if (action === 'delete-comment') {
            if (confirm(`ç¡®å®šè¦åˆ é™¤è¿™æ¡${isReply ? 'å›å¤' : 'è¯„è®º'}å—ï¼Ÿ`)) {
                if (isReply) {
                    const replyId = item.dataset.replyId;
                    comment.replies = comment.replies.filter(r => r.id !== replyId);
                } else {
                    post.comments = post.comments.filter(c => c.id !== commentId);
                }
                debouncedSaveState();
                renderWeiboFeed(profileId);
            }
        }
    } else if (sendBtn) {
        const input = sendBtn.previousElementSibling;
        const text = input.value.trim();
        if (!text) return;
        if (!comment.replies) comment.replies = [];
        
        let newReply;
        if (isReply) {
            const targetReply = comment.replies.find(r => r.id === item.dataset.replyId);
            const targetAuthor = findUserById(targetReply.authorId);
            newReply = { id: newId('reply'), authorId: 'user', text: `@${targetAuthor.name} ${text}`, replyTo: targetReply.id, timestamp: Date.now() };
        } else {
            const targetAuthor = findUserById(comment.authorId);
            newReply = { id: newId('reply'), authorId: 'user', text: `@${targetAuthor.name} ${text}`, replyTo: null, timestamp: Date.now() };
        }
        comment.replies.push(newReply);
        debouncedSaveState();
        renderWeiboFeed(profileId);
    } else {
        const actionIcons = item.querySelector('.comment-actions-inline');
        const replyInput = item.querySelector('.reply-input-container');
        
        document.querySelectorAll('.weibo-post-item .comment-actions-inline, .weibo-post-item .reply-input-container.active').forEach(el => {
            if (el !== actionIcons && el !== replyInput) {
                if(el.classList.contains('reply-input-container')) el.classList.remove('active');
                else el.style.display = 'none';
            }
        });
        
        if (actionIcons) actionIcons.style.display = actionIcons.style.display === 'flex' ? 'none' : 'flex';
        if (replyInput) replyInput.classList.toggle('active');
        if (replyInput && replyInput.classList.contains('active')) {
            replyInput.querySelector('input').focus();
        }
    }
}

function setupWeiboListInteraction(feedElement) {
    if (runtimeState.weibo && runtimeState.weibo.listHandler) {
        runtimeState.weibo.listHandler.destroy();
    }
    const handler = new ListInteractionHandler(feedElement, {
        itemSelector: '.weibo-post-item',
        contentSelector: '.post-item-content',
        actionsSelector: '.post-item-actions',
        onDelete: (item) => {
            const postId = item.dataset.postId;
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡å¾®åšå—ï¼Ÿ')) {
                const profileId = runtimeState.weibo.currentProfileId;
                const weiboData = (profileId === 'user') ? appState.chat.userProfile.weibo : appState.chat.contacts.find(c => c.id === profileId).charSettings.weibo;

                // --- æ–°å¢ï¼šæ£€æŸ¥è¢«åˆ é™¤çš„æ˜¯å¦ä¸ºè½¬å‘ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æ›´æ–°åŸå¾®åšçš„è½¬å‘æ•° ---
                const postToDelete = weiboData.posts.find(p => p.id === postId);
                if (postToDelete && postToDelete.type === 'repost' && postToDelete.repostedFrom) {
                    const originalPostId = postToDelete.repostedFrom.originalPostId;
                    let originalPost = null;
                    // åœ¨æ‰€æœ‰äººçš„å¾®åšä¸­æŸ¥æ‰¾åŸå¾®åš
                    for (const profile of [appState.chat.userProfile, ...appState.chat.contacts.map(c => c.charSettings)]) {
                        if (profile.weibo && profile.weibo.posts) {
                            originalPost = profile.weibo.posts.find(p => p.id === originalPostId);
                            if (originalPost) break;
                        }
                    }
                    if (originalPost && originalPost.reposts > 0) {
                        originalPost.reposts--;
                    }
                }
                // --- æ–°å¢ç»“æŸ ---

                weiboData.posts = weiboData.posts.filter(p => p.id !== postId);

                const isUserPage = profileId === 'user';
                if (isUserPage) {
                    getActiveUserProfile().weibo = weiboData;
                }

                debouncedSaveState();
                renderWeiboPage(profileId);
                showToast('å¾®åšå·²åˆ é™¤');
            }
        },
                        onEdit: (item) => {
                    const postId = item.dataset.postId;
                    const profileId = runtimeState.weibo.currentProfileId;
                    openPostWeiboModal(postId, profileId);
                }
    });
    runtimeState.weibo.listHandler = handler;
}

    function openPostWeiboModal(postId = null, profileIdForContext = 'user') {
    const isEditing = postId !== null;
    let post = null;
    if (isEditing) {
        const weiboData = getWeiboData(profileIdForContext);
        if (weiboData && weiboData.posts) {
            post = weiboData.posts.find(p => p.id === postId);
        }
    }
    if (isEditing && !post) return;

    runtimeState.weibo.postContext = { 
        images: isEditing ? [...(post.content.images || [])] : [],
        editingPostId: postId,
        authorId: isEditing ? (post.authorId || 'user') : profileIdForContext
    };
    
    const modal = getEl('post-weibo-modal');
    getEl('post-weibo-modal-title').textContent = isEditing ? 'ç¼–è¾‘å¾®åš' : 'å‘å¾®åš';
    getEl('editing-weibo-post-id').value = postId || '';
    
        const modalBody = getEl('post-weibo-modal-body');
    const authorSelectorGroup = getEl('weibo-post-author-selector-group');
    const existingAuthorDisplay = modalBody.querySelector('#weibo-post-author-display-group');
    if (existingAuthorDisplay) {
        existingAuthorDisplay.remove();
    }
    
    if (isEditing) {
        authorSelectorGroup.style.display = 'none';
        const author = findUserById(post.authorId);
        const authorDisplayHTML = `
            <div class="form-group" id="weibo-post-author-display-group">
                <label>å‘å¸ƒè€…</label>
                <p style="padding: 8px; color: var(--secondary-text-color); margin: 0;">${escapeHTML(author.name)}</p>
            </div>`;
        modalBody.insertAdjacentHTML('afterbegin', authorDisplayHTML);
    } else {
        authorSelectorGroup.style.display = 'none';
    }

    getEl('post-weibo-status-content').value = isEditing ? post.content.text : '';
        
    // --- æ–°å¢ï¼šåŠ è½½è¯é¢˜å’Œå¯è§æ€§ ---
    getEl('post-weibo-topic-input').value = isEditing ? (post.topic || '') : '';
    const friendsCheckbox = getEl('weibo-visibility-friends');
    const privateCheckbox = getEl('weibo-visibility-private');
    friendsCheckbox.checked = false;
    privateCheckbox.checked = false;
    if (isEditing) {
        if (post.visibility === 'friends') {
            friendsCheckbox.checked = true;
        } else if (post.visibility === 'private') {
            privateCheckbox.checked = true;
        }
    }
    // Reset and hide image sections for now
    getEl('post-weibo-image-buttons').classList.add('hidden-by-logic');
    getEl('post-weibo-text-image-input').classList.add('hidden-by-logic');
    queryAll('input[name="weibo-status-type"]').forEach(r => r.checked = r.value === 'text');
    
    modal.classList.add('visible');
}

function openWeiboCommentEditor(postId, commentId, replyId = null) {
    const profileId = runtimeState.weibo.currentProfileId;
    const weiboData = (profileId === 'user') ? appState.chat.userProfile.weibo : appState.chat.contacts.find(c => c.id === profileId).charSettings.weibo;
    const post = weiboData.posts.find(p => p.id === postId);
    if (!post) return;

    const commentToEdit = replyId 
        ? post.comments.find(c => c.replies && c.replies.some(r => r.id === replyId))?.replies.find(r => r.id === replyId)
        : post.comments.find(c => c.id === commentId);

    if (!commentToEdit) return;

    runtimeState.editingComment = { source: 'weibo', postId, commentId, replyId };
    getEl('edit-weibo-comment-content').value = commentToEdit.text;
    renderMomentAuthorSelector('weibo-comment-author-selector', commentToEdit.authorId);
    getEl('edit-weibo-comment-modal').classList.add('visible');
}

getEl('post-weibo-status-type').addEventListener('change', e => {
    const type = e.target.value;
    getEl('post-weibo-image-buttons').classList.toggle('hidden-by-logic', type !== 'image');
    getEl('post-weibo-text-image-input').classList.toggle('hidden-by-logic', type !== 'text-image');
});
getEl('post-weibo-upload-btn').addEventListener('click', () => getEl('post-weibo-image-input').click());
getEl('post-weibo-add-url-btn').addEventListener('click', () => {
    const url = prompt('è¯·è¾“å…¥å›¾ç‰‡URL:');
    if(url && url.startsWith('http')) {
        runtimeState.weibo.postContext.images.push(url);
        showToast('å›¾ç‰‡é“¾æ¥æ·»åŠ æˆåŠŸï¼');
    } else if (url) {
        showToast('æ— æ•ˆçš„URL', 'error');
    }
});
getEl('post-weibo-image-input').addEventListener('change', async e => {
    const files = e.target.files;
    if(files.length > 0){
        showToast(`æ­£åœ¨æ·»åŠ  ${files.length} å¼ å›¾ç‰‡...`);
        for(const file of files) {
            const compressedFile = await compressImageBeforeSaving(file);
            const newImageId = newId('moment_img'); // Reusing prefix for consistency
            await addMediaToDB(newImageId, compressedFile);
            runtimeState.weibo.postContext.images.push(newImageId);
        }
        showToast('å›¾ç‰‡æ·»åŠ æˆåŠŸï¼');
        e.target.value = '';
    }
});
getEl('cancel-post-weibo-btn').addEventListener('click', () => getEl('post-weibo-modal').classList.remove('visible'));
getEl('confirm-post-weibo-btn').addEventListener('click', () => { // Removed async from here
    const postId = getEl('editing-weibo-post-id').value;
    const isEditing = !!postId;
    const profileId = runtimeState.weibo.currentProfileId;
    const weiboData = getWeiboData(profileId);
    const isUserPage = profileId === 'user';
    
    let post = isEditing ? weiboData.posts.find(p => p.id === postId) : null;

    const text = getEl('post-weibo-status-content').value.trim();
    const statusType = query('input[name="weibo-status-type"]:checked').value;

    if (statusType === 'text') {
        runtimeState.weibo.postContext.images = [];
    }
    let images = [...(runtimeState.weibo.postContext.images || [])];

    if (statusType === 'text-image') {
        const desc = getEl('post-weibo-text-image-desc').value.trim();
        if (desc) images.push({ isTextImage: true, imageId: 'default_camera_image', description: desc });
    }

    if (!text && images.length === 0) return showToast('è¯·è¯´ç‚¹ä»€ä¹ˆæˆ–æ·»åŠ ä¸€å¼ å›¾ç‰‡å§', 'error');

    let topic = getEl('post-weibo-topic-input').value.trim();
    let visibility = 'public';
    if (getEl('weibo-visibility-friends').checked) {
        visibility = 'friends';
    } else if (getEl('weibo-visibility-private').checked) {
        visibility = 'private';
    }

    if (visibility !== 'public') {
        topic = '';
    }

    // --- Start of Asynchronous Flow ---
    (async () => {
        if (isEditing) {
            post.content = { text, images };
            post.topic = topic;
            post.visibility = visibility;
        } else {
            const authorId = runtimeState.weibo.postContext.authorId;
            const authorWeiboData = getWeiboData(authorId);
            const followerCount = authorWeiboData.followerCount || 0;

            const newPost = {
                id: newId('weibo_post'),
                authorId: authorId,
                topic: topic,
                visibility: visibility,
                type: 'status',
                timestamp: Date.now(),
                content: { text, images },
                repostCount: Math.floor(followerCount * (Math.random() * 0.05 + 0.001)),
                commentCount: Math.floor(followerCount * (Math.random() * 0.01)),
                likeCount: Math.floor(followerCount * (Math.random() * 0.2 + 0.01)),
                comments: [],
                likes: [],
                isLoadingComments: visibility === 'public'
            };
            
            weiboData.posts.unshift(newPost);
            
            // --- Immediate UI Update ---
            if (isUserPage) getActiveUserProfile().weibo = weiboData;
            debouncedSaveState();
            renderWeiboFeed(profileId);
            getEl('post-weibo-modal').classList.remove('visible');
            
            // --- Background NPC Comment Generation ---
            if (visibility === 'public') {
                try {
                    const npcComments = await generateNpcCommentsForPost(newPost);
                    const postInState = getWeiboData(profileId).posts.find(p => p.id === newPost.id);
                    if (postInState) {
                        postInState.comments.push(...npcComments);
                        postInState.commentCount += npcComments.length;
                        delete postInState.isLoadingComments;

                        if (isUserPage) getActiveUserProfile().weibo = weiboData;
                        debouncedSaveState();
                        renderWeiboFeed(profileId);
                    }
                } catch (error) {
                    console.error("Background NPC comment generation failed:", error);
                    const postInState = getWeiboData(profileId).posts.find(p => p.id === newPost.id);
                    if (postInState) {
                        delete postInState.isLoadingComments;
                        debouncedSaveState();
                        renderWeiboFeed(profileId);
                    }
                }
            }
        }

        // For editing, we just save and re-render directly
        if (isEditing) {
            if (isUserPage) getActiveUserProfile().weibo = weiboData;
            debouncedSaveState();
            renderWeiboFeed(profileId);
            getEl('post-weibo-modal').classList.remove('visible');
        }
    })();
});

getEl('cancel-edit-weibo-comment-btn').addEventListener('click', () => getEl('edit-weibo-comment-modal').classList.remove('visible'));
getEl('save-edit-weibo-comment-btn').addEventListener('click', () => {
    const { postId, commentId, replyId } = runtimeState.editingComment;
    const profileId = runtimeState.weibo.currentProfileId;
    const weiboData = (profileId === 'user') ? appState.chat.userProfile.weibo : appState.chat.contacts.find(c => c.id === profileId).charSettings.weibo;
    const post = weiboData.posts.find(p => p.id === postId);
    if (!post) return;

    const commentToEdit = replyId 
        ? post.comments.find(c => c.replies && c.replies.some(r => r.id === replyId))?.replies.find(r => r.id === replyId)
        : post.comments.find(c => c.id === commentId);

    if (!commentToEdit) return;

    const newContent = getEl('edit-weibo-comment-content').value;
const selectedAuthorEl = getEl('weibo-comment-author-selector').querySelector('.selected');
const oldAuthorId = commentToEdit.authorId;
const newAuthorId = selectedAuthorEl ? selectedAuthorEl.dataset.id : oldAuthorId;
if (oldAuthorId !== newAuthorId) {
    const oldAuthor = findUserById(oldAuthorId);
    const newAuthor = findUserById(newAuthorId);
    if (!replyId && post.comments) {
        const parentComment = post.comments.find(c => c.id === commentId);
        if (parentComment && parentComment.replies) {
            parentComment.replies.forEach(reply => {
                const expectedOldMention = `@${oldAuthor.name} `;
                if (reply.text.startsWith(expectedOldMention)) {
                    reply.text = reply.text.replace(expectedOldMention, `@${newAuthor.name} `);
                }
            });
        }
    }
}
    commentToEdit.text = newContent;
    if (selectedAuthorEl) commentToEdit.authorId = selectedAuthorEl.dataset.id;
    
    debouncedSaveState();
    renderWeiboFeed(profileId);
    getEl('edit-weibo-comment-modal').classList.remove('visible');
});
getEl('edit-weibo-comment-modal').addEventListener('click', e => {
    const item = e.target.closest('#weibo-comment-author-selector .author-selector-item');
    if(item) {
        item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
        item.classList.add('selected');
    }
});

getEl('post-weibo-modal').addEventListener('click', e => {
    const item = e.target.closest('#weibo-post-author-selector .author-selector-item');
    if(item) {
        item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
        item.classList.add('selected');
    }
});

function openWeiboCharSelector() {
    const modal = getEl('weibo-char-selector-modal');
    const grid = getEl('weibo-char-selector-grid');
    const allChars = appState.chat.contacts.filter(c => !c.isGroup);
    const currentSelectedId = runtimeState.weibo.currentCharProfileId;

    if (allChars.length === 0) {
        grid.innerHTML = '<p style="text-align: center; color: #888;">æš‚æ— å…¶ä»–è§’è‰²</p>';
    } else {
        grid.innerHTML = allChars.map(char => {
            const isSelected = char.id === currentSelectedId;
            return `
                <div class="author-selector-item ${isSelected ? 'selected' : ''}" data-id="${char.id}">
                    <div class="avatar" data-avatar-id="${char.charSettings.avatarId}"></div>
                    <span class="name">${escapeHTML(char.charSettings.name)}</span>
                </div>
            `;
        }).join('');
        grid.querySelectorAll('.avatar').forEach(el => setElementImage(el, el.dataset.avatarId));
    }
    modal.classList.add('visible');
}

getEl('weibo-char-selector-grid').addEventListener('click', e => {
    const item = e.target.closest('.author-selector-item');
    if (item) {
        item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
        item.classList.add('selected');
    }
});

getEl('close-weibo-char-selector-btn').addEventListener('click', () => {
    getEl('weibo-char-selector-modal').classList.remove('visible');
});

getEl('confirm-weibo-char-selector-btn').addEventListener('click', () => {
    const selectedItem = getEl('weibo-char-selector-grid').querySelector('.selected');
    if (selectedItem) {
        const newCharId = selectedItem.dataset.id;
        runtimeState.weibo.currentCharProfileId = newCharId;
        renderWeiboPage(newCharId);
    }
    getEl('weibo-char-selector-modal').classList.remove('visible');
});

getEl('weibo-visibility-options').addEventListener('change', (e) => {
    if (e.target.type !== 'checkbox') return;

    const topicGroup = getEl('post-weibo-modal').querySelector('.form-group:has(#post-weibo-topic-input)');

    const friendsCheckbox = getEl('weibo-visibility-friends');
    const privateCheckbox = getEl('weibo-visibility-private');

    if (e.target.id === friendsCheckbox.id && friendsCheckbox.checked) {
        privateCheckbox.checked = false;
    } else if (e.target.id === privateCheckbox.id && privateCheckbox.checked) {
        friendsCheckbox.checked = false;
    }
    // --- æ–°å¢ï¼šæ ¹æ®å¯è§æ€§æ˜¾ç¤º/éšè—è¯é¢˜è¾“å…¥æ¡† ---
    if (friendsCheckbox.checked || privateCheckbox.checked) {
        topicGroup.style.display = 'none';
    } else {
        topicGroup.style.display = 'block';
    }
});

getEl('save-collection-btn').addEventListener('click', () => {
const collectionId = getEl('editing-collection-id').value;
const newName = getEl('collection-name-input').value.trim();
if (!newName) {
    showToast('åç§°ä¸èƒ½ä¸ºç©º', 'error');
    return;
}

const collection = appState.diary.collections.find(c => c.id === collectionId);
if (collection) {
    collection.name = newName;
    debouncedSaveState();
    renderCollectionTab();
    getEl('edit-collection-modal').classList.remove('visible');
    showToast('æ”¶è—å·²æ›´æ–°');
}
});
// --- æ–°å¢ï¼šå¾®åšèµ„æ–™ç¼–è¾‘å¼¹çª—ç›‘å¬ ---
getEl('cancel-edit-weibo-profile-btn').addEventListener('click', () => {
    getEl('edit-weibo-profile-modal').classList.remove('visible');
});

getEl('save-weibo-profile-btn').addEventListener('click', () => {
    const profileId = getEl('editing-weibo-profile-id').value;
    const weiboData = getWeiboData(profileId);
    if (!weiboData || !weiboData.profile) return;

    const newBio = getEl('weibo-bio-input').value.trim();
    const newPersona = getEl('weibo-persona-input').value.trim();

    weiboData.profile.bio = newBio;
    weiboData.profile.persona = newPersona;
    
    // å¦‚æœæ˜¯ç”¨æˆ·ï¼Œä»…æ›´æ–°å½“å‰æ´»åŠ¨çš„ä¸»profileä¸­çš„weiboéƒ¨åˆ†ï¼Œå¹¶åˆ·æ–°æ´»åŠ¨å‰¯æœ¬
    if (profileId === 'user') {
        const activeProfile = getActiveUserProfile();
        activeProfile.weibo.profile.bio = newBio;
        activeProfile.weibo.profile.persona = newPersona;
        // æ›´æ–°weibo profileé‡Œçš„nameï¼Œä»¥é˜²åœ¨å…¶ä»–åœ°æ–¹è¢«ä¿®æ”¹
        activeProfile.weibo.profile.name = activeProfile.name;
        // æ›´æ–°æ´»åŠ¨å‰¯æœ¬
        appState.chat.userProfile = JSON.parse(JSON.stringify(activeProfile));
    }

    debouncedSaveState();
    renderWeiboPage(profileId);
    getEl('edit-weibo-profile-modal').classList.remove('visible');
    showToast('ä¸ªäººèµ„æ–™å·²æ›´æ–°');
});
function openWeiboCharSettingsModal(charId) {
    const contact = appState.chat.contacts.find(c => c.id === charId);
    if (!contact) return;
    runtimeState.weibo.profileSettings = { mode: 'select', editingCharId: charId };
    renderWeiboProfileSelector(); // This function will now be adapted for chars
    renderProfileManagementButtons();
    updateProfileSettingsVisibility('select');
    getEl('weibo-add-profile-fields').classList.add('hidden-by-logic');
    getEl('weibo-profile-settings-modal').classList.add('visible');
}
function getActiveUserProfile() {
    if (!appState.chat.userProfiles || appState.chat.userProfiles.length === 0) {
        const defaultProfile = getInitialState().chat.userProfiles[0];
        appState.chat.userProfiles = [defaultProfile];
        appState.chat.activeUserProfileId = defaultProfile.id;
        return defaultProfile;
    }
    const activeProfile = appState.chat.userProfiles.find(p => p.id === appState.chat.activeUserProfileId);
    return activeProfile || appState.chat.userProfiles[0];
}

function updateProfileSettingsVisibility(mode) {
    const grid = getEl('weibo-profile-selector-grid');
    const managementActions = getEl('weibo-profile-management-actions');
    const mainActions = getEl('close-weibo-profile-settings-btn').parentElement;
    const { selectedId } = runtimeState.weibo.profileSettings;

    switch (mode) {
        case 'add':
            grid.style.display = 'none';
            managementActions.style.display = 'none';
            mainActions.style.display = 'none';
            break;
        case 'edit-selection':
            grid.style.display = selectedId ? 'none' : 'grid';
            managementActions.style.display = 'flex';
            mainActions.style.display = 'none';
            break;
        case 'delete-selection':
            grid.style.display = 'grid';
            managementActions.style.display = 'flex';
            mainActions.style.display = 'none';
            break;
        case 'select':
        default:
            grid.style.display = 'grid';
            managementActions.style.display = 'flex';
            mainActions.style.display = 'flex';
            break;
    }
}
function renderWeiboProfileSelector() {
    const grid = getEl('weibo-profile-selector-grid');
    const profiles = appState.chat.userProfiles;
    const mode = runtimeState.weibo.profileSettings.mode;
    const currentSelectedId = (mode === 'select') ? runtimeState.weibo.tempActiveProfileId : runtimeState.weibo.profileSettings.selectedId;

    grid.innerHTML = profiles.map(profile => {
        const isSelected = profile.id === currentSelectedId;
        let itemClass = 'author-selector-item';
        if (isSelected) itemClass += ' selected';
        if (mode === 'delete-selection' && isSelected) itemClass += ' danger-selection'; // Add danger class for visual cue
        return `
            <div class="${itemClass}" data-id="${profile.id}">
                <div class="avatar" data-avatar-id="${profile.avatarId}"></div>
                <span class="name">${escapeHTML(profile.name)}</span>
            </div>
        `;
    }).join('');
    grid.querySelectorAll('.avatar').forEach(el => setElementImage(el, el.dataset.avatarId));
}

function renderProfileManagementButtons() {
    const container = getEl('weibo-profile-management-actions');
    const mode = runtimeState.weibo.profileSettings.mode;

    switch (mode) {
        case 'edit-selection':
            container.innerHTML = `
                <button id="weibo-cancel-action-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="weibo-save-changes-action-btn" class="confirm-btn" disabled>ä¿å­˜</button>
            `;
            break;
        case 'delete-selection':
            container.innerHTML = `
                <button id="weibo-cancel-action-btn" class="cancel-btn">å–æ¶ˆ</button>
                <button id="weibo-confirm-delete-action-btn" class="danger-btn" disabled>åˆ é™¤</button>
            `;
            break;
        case 'select':
        default:
            container.innerHTML = `
                <button id="weibo-add-profile-action-btn" class="settings-button secondary" style="flex:1;">æ·»åŠ ä¸»é¡µ</button>
                <button id="weibo-edit-profile-action-btn" class="settings-button secondary" style="flex:1;">ç¼–è¾‘ä¸»é¡µ</button>
                <button id="weibo-delete-profile-action-btn" class="settings-button danger-btn" style="flex:1;">åˆ é™¤ä¸»é¡µ</button>
            `;
            break;
    }
}

function populateProfileForm(profileData) {
    const form = getEl('weibo-add-profile-fields');
    const nameLabel = getEl('weibo-profile-form-name-label');
    const bioLabel = getEl('weibo-profile-form-bio-label');
    const personaLabel = getEl('weibo-profile-form-persona-label');
    const nameInput = getEl('new-weibo-profile-name');
    const bioInput = getEl('new-weibo-profile-bio');
    const personaInput = getEl('new-weibo-profile-persona');
    const saveBtnContainer = getEl('weibo-save-profile-btn').parentElement; // Get the button container

    if (profileData) { // Editing mode
        nameLabel.textContent = 'ç¼–è¾‘åå­—';
        bioLabel.textContent = 'ç¼–è¾‘ç®€ä»‹';
        personaLabel.textContent = 'ç¼–è¾‘äººè®¾';
        nameInput.value = profileData.name;
        bioInput.value = profileData.signature;
        personaInput.value = profileData.persona;
        saveBtnContainer.style.display = 'none'; // Hide the add/cancel buttons
        form.classList.remove('hidden-by-logic');
    } else { // Adding mode
        nameLabel.textContent = 'æ–°ä¸»é¡µåå­—';
        bioLabel.textContent = 'æ–°ä¸»é¡µç®€ä»‹';
        personaLabel.textContent = 'æ–°ä¸»é¡µäººè®¾';
        nameInput.value = '';
        bioInput.value = '';
        personaInput.value = '';
        saveBtnContainer.style.display = 'flex'; // Show the add/cancel buttons
        form.classList.remove('hidden-by-logic');
    }
}

getEl('weibo-profile-management-actions').addEventListener('click', e => {
const settings = runtimeState.weibo.profileSettings;
if (e.target.closest('#weibo-add-profile-action-btn')) {
    settings.mode = 'add';
    updateProfileSettingsVisibility('add');
    populateProfileForm(null);
} 
else if (e.target.closest('#weibo-edit-profile-action-btn')) {
    settings.mode = 'edit-selection';
    settings.selectedId = null;
    renderProfileManagementButtons();
    renderWeiboProfileSelector();
    updateProfileSettingsVisibility('edit-selection');
}
else if (e.target.closest('#weibo-delete-profile-action-btn')) {
    settings.mode = 'delete-selection';
    settings.selectedId = null;
    renderProfileManagementButtons();
    renderWeiboProfileSelector();
    updateProfileSettingsVisibility('delete-selection');
}
else if (e.target.closest('#weibo-cancel-action-btn')) {
    settings.mode = 'select';
    settings.selectedId = null;
    getEl('weibo-add-profile-fields').classList.add('hidden-by-logic');
    renderProfileManagementButtons();
    renderWeiboProfileSelector();
    updateProfileSettingsVisibility('select');
}
    else if (e.target.closest('#weibo-save-changes-action-btn')) {
        const profile = appState.chat.userProfiles.find(p => p.id === settings.selectedId);
        if (profile) {
            profile.name = getEl('new-weibo-profile-name').value.trim();
            profile.signature = getEl('new-weibo-profile-bio').value.trim();
            profile.persona = getEl('new-weibo-profile-persona').value.trim();
            // Sync weibo sub-profile
            profile.weibo.profile.name = profile.name;
            profile.weibo.profile.bio = profile.signature;
            profile.weibo.profile.persona = profile.persona;
            
            if (appState.chat.activeUserProfileId === profile.id) {
                appState.chat.userProfile = JSON.parse(JSON.stringify(profile));
            }
            
            debouncedSaveState();
            showToast('ä¸»é¡µå·²æ›´æ–°');
            getEl('weibo-cancel-action-btn').click(); // Reset view
        }
    }
    else if (e.target.closest('#weibo-confirm-delete-action-btn')) {
        if (appState.chat.userProfiles.length <= 1) {
            showToast('ä¸èƒ½åˆ é™¤æœ€åä¸€ä¸ªä¸»é¡µ', 'error');
            return;
        }
        if (confirm(`ç¡®å®šè¦æ°¸ä¹…åˆ é™¤ä¸»é¡µ "${getEl('new-weibo-profile-name').value.trim()}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
            const deletedId = settings.selectedId;
            appState.chat.userProfiles = appState.chat.userProfiles.filter(p => p.id !== deletedId);

            if (appState.chat.activeUserProfileId === deletedId) {
                const newActiveProfile = appState.chat.userProfiles[0];
                appState.chat.activeUserProfileId = newActiveProfile.id;
                appState.chat.userProfile = JSON.parse(JSON.stringify(newActiveProfile));
                renderWeiboPage('user');
            }
            
            debouncedSaveState();
            showToast('ä¸»é¡µå·²åˆ é™¤');
            getEl('weibo-cancel-action-btn').click(); // Reset view
        }
    }
});

getEl('weibo-profile-selector-grid').addEventListener('click', e => {
    const item = e.target.closest('.author-selector-item');
    if (!item) return;

    const settings = runtimeState.weibo.profileSettings;
    const profileId = item.dataset.id;

        switch (settings.mode) {
        case 'edit-selection':
            settings.selectedId = profileId;
            renderWeiboProfileSelector();
            const profileToEdit = appState.chat.userProfiles.find(p => p.id === profileId);
            if (profileToEdit) {
                populateProfileForm(profileToEdit);
                getEl('weibo-save-changes-action-btn').disabled = false;
                updateProfileSettingsVisibility('edit-selection');
            }
            break;
        case 'delete-selection':
            settings.selectedId = profileId;
            renderWeiboProfileSelector();
            const profileToDelete = appState.chat.userProfiles.find(p => p.id === profileId);
             if (profileToDelete) {
                // Populate form just to show the name in the confirmation dialog
                 getEl('new-weibo-profile-name').value = profileToDelete.name;
             }
            getEl('weibo-confirm-delete-action-btn').disabled = false;
            break;
        case 'select':
        default:
            runtimeState.weibo.tempActiveProfileId = profileId;
            renderWeiboProfileSelector();
            break;
    }
});

getEl('close-weibo-profile-settings-btn').addEventListener('click', () => {
    getEl('weibo-profile-settings-modal').classList.remove('visible');
});

getEl('confirm-weibo-profile-settings-btn').addEventListener('click', () => {
    const newActiveId = runtimeState.weibo.tempActiveProfileId;
    const newActiveProfile = appState.chat.userProfiles.find(p => p.id === newActiveId);
    if (newActiveProfile) {
        appState.chat.activeUserProfileId = newActiveId;
        appState.chat.userProfile = JSON.parse(JSON.stringify(newActiveProfile));
        debouncedSaveState();
        renderWeiboPage('user');
        getEl('weibo-profile-settings-modal').classList.remove('visible');
        showToast('ä¸»é¡µå·²åˆ‡æ¢');
    }
});

getEl('weibo-cancel-add-profile-btn').addEventListener('click', () => {
    runtimeState.weibo.profileSettings.mode = 'select';
    getEl('weibo-add-profile-fields').classList.add('hidden-by-logic');
    updateProfileSettingsVisibility('select');
});

getEl('weibo-save-profile-btn').addEventListener('click', () => {
    const name = getEl('new-weibo-profile-name').value.trim();
    const bio = getEl('new-weibo-profile-bio').value.trim();
    const persona = getEl('new-weibo-profile-persona').value.trim();

    if (!name || !bio || !persona) {
        showToast('è¯·å¡«å†™æ‰€æœ‰å­—æ®µ', 'error');
        return;
    }

    const newProfileId = newId('user_profile');
    const defaultWeiboData = getInitialState().chat.userProfiles[0].weibo;
    
    const newProfile = {
        id: newProfileId,
        name: name,
        avatarId: 'default_user_avatar',
        avatarFrameId: '',
        persona: persona,
        signature: bio,
        cashBalance: 1000000.00,
        bankBalance: 0,
        loan: 0,
        lastInterestCalc: '',
        weibo: {
            ...JSON.parse(JSON.stringify(defaultWeiboData)),
            profile: {
                ...JSON.parse(JSON.stringify(defaultWeiboData.profile)),
                id: newProfileId,
                name: name,
                bio: bio,
                persona: persona,
                avatarId: 'default_user_avatar'
            },
            posts: [],
            followingCount: 0,
            followerCount: 0
        }
    };

    appState.chat.userProfiles.push(newProfile);
    debouncedSaveState();
    
    // Reset form and UI state
    getEl('weibo-add-profile-fields').classList.add('hidden-by-logic');
    runtimeState.weibo.profileSettings.mode = 'select';
    renderProfileManagementButtons();
    renderWeiboProfileSelector();
    updateProfileSettingsVisibility('select');
    showToast('æ–°ä¸»é¡µå·²æ·»åŠ ï¼');
});
// ===================================================================
// --- å¾®åš (Weibo) éšæœºNPCç”Ÿæˆé€»è¾‘ ---
// ===================================================================
function generateRandomNpcProfile() {
    const names = ['è¿½é£å°‘å¹´', 'å¤å¤©çš„é£', 'æœˆäº®ä¸ç¡æˆ‘ä¸ç¡', 'æ³¡æ³¡é±¼', 'åŒ¿åç½‘å‹', 'åƒç“œç¬¬ä¸€çº¿', 'ä»Šå¤©æ²¡åƒé¥±', 'å“ˆå“ˆå“ˆ', 'è·¯äººç”²', 'äº’è”ç½‘å˜´æ›¿', 'ç†¬å¤œå† å†›', 'å¯ä¹çˆ±å¥½è€…'];
    const avatars = [
        'https://i.postimg.cc/k402r5sV/image.png', 'https://i.postimg.cc/8P0K2Lwq/image.png', 'https://i.postimg.cc/mkjsw2Tf/image.png',
        'https://i.postimg.cc/sXhT3gqS/image.png', 'https://i.postimg.cc/zX3wG36Y/image.png', 'https://i.postimg.cc/J0TzSTvy/image.png'
    ];
    return {
        id: newId('npc'),
        name: names[Math.floor(Math.random() * names.length)],
        avatarId: avatars[Math.floor(Math.random() * avatars.length)]
    };
}

async function generateNpcCommentsForPost(post) {
    try {
        const postAuthor = findUserById(post.authorId);
        const weiboContext = {
            taskType: 'GENERATE_NPC_COMMENTS',
            post: { ...post, authorName: postAuthor.name }
        };
        // We need an AI to generate comments. Let's pick any available char.
        const interpreterChar = appState.chat.contacts.find(c => !c.isGroup);
        if (!interpreterChar) {
            console.warn("No available char to generate NPC comments, returning empty.");
            return [];
        }

        const systemPrompt = constructWeiboSystemPrompt(interpreterChar, weiboContext);
        
        const { apiUrl, selectedModel } = appState.settings;
        const apiKey = getNextApiKey();
        if (!apiUrl || !apiKey || !selectedModel) throw new Error("API not configured for NPC comments.");
        const messages = [{ role: 'system', content: systemPrompt }];
        if (!apiUrl.includes('generativelanguage.googleapis.com')) messages[0].role = 'user';
        
        let data;
        if (apiUrl.includes('generativelanguage.googleapis.com')) {
            const requestBody = transformToGoogleFormat(messages);
            const modelName = selectedModel.startsWith('models/') ? selectedModel : `models/${selectedModel}`;
            const response = await fetch(`https://cors.eu.org/${apiUrl}/v1beta/${modelName}:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            if (!response.ok) throw new Error(`Google API Error: ${response.status} - ${await response.text()}`);
            data = transformFromGoogleFormat(await response.json());
        } else {
            const response = await fetch(`${apiUrl}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ model: selectedModel, messages, stream: false }) });
            if (!response.ok) throw new Error(`API Error: ${response.status} - ${await response.text()}`);
            data = await response.json();
        }

        const replyContent = data.choices[0]?.message?.content;
        const jsonMatch = replyContent.match(/```json\s*([\s\S]*?)\s*```/);
        if (!jsonMatch) throw new Error("AI response for NPC comments was not a valid JSON block.");
        const parsedData = JSON.parse(jsonMatch[1]);
        
        if (parsedData.comments && Array.isArray(parsedData.comments)) {
            let commentTimestampOffset = 60000; // Start first comment 1 minute after post
            return parsedData.comments.map(comment => {
                const npc = generateRandomNpcProfile();
                const commentTimestamp = post.timestamp + commentTimestampOffset;
                commentTimestampOffset += Math.floor(Math.random() * 60000) + 10000; // Next comment is 10-70s later

                let replyTimestampOffset = commentTimestamp + 5000; // Start first reply 5s after comment

                const replies = (comment.replies && Array.isArray(comment.replies)) ? comment.replies.map(reply => {
                    const replyNpc = generateRandomNpcProfile();
                    const replyTimestamp = replyTimestampOffset;
                    replyTimestampOffset += Math.floor(Math.random() * 20000) + 5000; // Next reply is 5-25s later
                    return {
                        id: newId('reply'),
                        authorId: replyNpc.id,
                        authorName: reply.authorName,
                        authorAvatarId: replyNpc.avatarId,
                        text: reply.text,
                        timestamp: replyTimestamp,
                        likes: []
                    };
                }) : [];

                return {
                    id: newId('comment'),
                    authorId: npc.id,
                    authorName: comment.authorName,
                    authorAvatarId: npc.avatarId,
                    text: comment.text,
                    timestamp: commentTimestamp,
                    likes: [],
                    replies: replies
                };
            });
        }
        return [];
    } catch (error) {
        console.error("Failed to generate AI-based NPC comments:", error);
        // Fallback to old template method on failure
        showToast('AIç”Ÿæˆè·¯äººè¯„è®ºå¤±è´¥ï¼Œä½¿ç”¨æ¨¡æ¿æ›¿ä»£...', 'error');
        const followerCount = getWeiboData(post.authorId).followerCount || 0;
        const npcComments = [];
        let commentCount = 0;
    if (followerCount >= 1000000) { // Celebrity
        commentCount = Math.floor(Math.random() * 6) + 5; // 5-10 comments
    } else if (followerCount >= 100) { // Normal person
        commentCount = Math.floor(Math.random() * 3) + 1; // 1-3 comments
    }

    if (commentCount === 0) return [];
    
    // For now, we use predefined templates. Step 2 will replace this with AI.
    const templates = {
        praise: ['å“‡ï¼Œå¥½æ£’ï¼', 'æ”¯æŒï¼', 'å‰æ’å›´è§‚', 'å¤ªå‰å®³äº†ï¼', 'å­¦åˆ°äº†', 'å¥½å¥½çœ‹ï¼', 'AWSL'],
        neutral: ['å—¯å—¯', 'è·¯è¿‡', 'çœ‹çœ‹', 'å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ', 'è¿™æ˜¯å“ªé‡Œï¼Ÿ', 'æœ‰ç‚¹æ„æ€'],
        troll: ['å°±è¿™ï¼Ÿ', 'å‘µå‘µ', 'æ— è¯­', 'ä»€ä¹ˆé¬¼', 'çœ‹ä¸æ‡‚']
    };

    for (let i = 0; i < commentCount; i++) {
        const npc = generateRandomNpcProfile();
        let text = '';
        const rand = Math.random();

        if (followerCount >= 1000000) {
            if (rand < 0.7) text = templates.praise[Math.floor(Math.random() * templates.praise.length)];
            else if (rand < 0.9) text = templates.neutral[Math.floor(Math.random() * templates.neutral.length)];
            else text = templates.troll[Math.floor(Math.random() * templates.troll.length)];
        } else {
            if (rand < 0.5) text = templates.praise[Math.floor(Math.random() * templates.praise.length)];
            else text = templates.neutral[Math.floor(Math.random() * templates.neutral.length)];
        }

        npcComments.push({
            id: newId('comment'),
            authorId: npc.id,
            authorName: npc.name,
            authorAvatarId: npc.avatarId,
            text: text,
            timestamp: post.timestamp + Math.floor(Math.random() * 3600000) + 60000, // Within an hour of posting
            likes: [],
            replies: []
        });
    }

    return npcComments;
}}
async function constructWeiboSocialFeedForAI(charId) {
    let feed = '';
    const allProfiles = [getActiveUserProfile(), ...appState.chat.contacts.filter(c => !c.isGroup).map(c => c.charSettings)];
    const allPosts = allProfiles.flatMap(p => p.weibo.posts || []).sort((a, b) => b.timestamp - a.timestamp).slice(0, 10); // Get latest 10 posts globally

    if (allPosts.length === 0) {
        return "å¾®åšä¸Šå¾ˆå®‰é™ï¼Œè¿˜æ²¡æœ‰ä»»ä½•åŠ¨æ€ã€‚\n";
    }

    allPosts.forEach(post => {
        if (post.visibility !== 'public' && post.authorId !== charId && post.authorId !== 'user') return; // Simplified visibility check for AI
        const author = findUserById(post.authorId);
        const authorMarker = post.authorId === 'user' ? ' (ç”¨æˆ·)' : (post.authorId === charId ? ' (ä½ )' : ' (å…¶ä»–è§’è‰²)');
        feed += `- **${author.name}${authorMarker}** (å¾®åšID: ${post.id}) å‘å¸ƒäº†: "${truncateText(post.content.text, 30)}"\n`;
        if (post.comments && post.comments.length > 0) {
            feed += `  - è¯„è®º:\n`;
            post.comments.forEach(c => {
                const cAuthorId = c.authorId.startsWith('npc_') ? 'npc' : c.authorId;
                const cAuthorName = c.authorId.startsWith('npc_') ? c.authorName : findUserById(c.authorId).name;
                const cAuthorMarker = cAuthorId === 'user' ? ' (ç”¨æˆ·)' : (cAuthorId === charId ? ' (ä½ )' : (cAuthorId === 'npc' ? ' (è·¯äºº)' : ' (å…¶ä»–è§’è‰²)'));
                feed += `    - **${cAuthorName}${cAuthorMarker}** (è¯„è®ºID: ${c.id}): "${truncateText(c.text, 20)}"\n`;
            });
        }
    });

    return feed;
}

function handleWeiboAction(action, args, actorId) {
    if (!action || args.length === 0) return;

    const targetId = args[0];
    let targetPost = null;
    let targetPostOwnerData = null;

    // Find the target post across all profiles
    const allProfilesWithWeibo = [getActiveUserProfile(), ...appState.chat.contacts.filter(c => !c.isGroup && c.charSettings.weibo).map(c => c.charSettings)];
    for (const profile of allProfilesWithWeibo) {
        targetPost = profile.weibo.posts.find(p => p.id === targetId);
        if (targetPost) {
            targetPostOwnerData = profile.weibo;
            break;
        }
    }

    const actorWeiboData = getWeiboData(actorId);

    switch(action) {
case 'WEIBO_POST':
const [content, topic] = args;
if (content) {
const followerCount = actorWeiboData.followerCount || 0;
const newPost = {
id: newId('weibo_post'),
authorId: actorId,
type: 'status',
timestamp: Date.now(),
content: { text: content, images: [] },
topic: topic || '',
visibility: 'public',
repostCount: Math.floor(followerCount * (Math.random() * 0.05 + 0.001)),
commentCount: 0,
likeCount: Math.floor(followerCount * (Math.random() * 0.2 + 0.01)),
comments: [],
likes: [],
isLoadingComments: true
};
actorWeiboData.posts.unshift(newPost);
            // Asynchronously generate NPC comments in the background
            (async () => {
                try {
                    const npcComments = await generateNpcCommentsForPost(newPost);
                    const postInState = getWeiboData(actorId).posts.find(p => p.id === newPost.id);
                    if (postInState) {
                        postInState.comments.push(...npcComments);
                        postInState.commentCount += npcComments.length;
                        delete postInState.isLoadingComments;
                        debouncedSaveState();
                        // If the user is currently viewing this page, refresh it
                        if (weiboAppScreen.classList.contains('active') && runtimeState.weibo.currentProfileId === actorId) {
                            renderWeiboFeed(actorId);
                        }
                    }
                } catch (error) {
                     console.error(`Background NPC comment generation for ${actorId} failed:`, error);
                     const postInState = getWeiboData(actorId).posts.find(p => p.id === newPost.id);
                     if (postInState) {
                        delete postInState.isLoadingComments;
                        debouncedSaveState();
                     }
                }
            })();
        }
        break;

        case 'WEIBO_LIKE':
            if (targetPost && !targetPost.likes.includes(actorId)) {
                targetPost.likes.push(actorId);
            }
            break;
        
        case 'WEIBO_COMMENT':
            const commentText = args[1];
            if (targetPost && commentText) {
                const newComment = { id: newId('comment'), authorId: actorId, text: commentText, timestamp: Date.now(), likes: [], replies: [] };
                targetPost.comments.push(newComment);
                targetPost.commentCount = (targetPost.commentCount || 0) + 1;
            }
            break;

        case 'WEIBO_REPOST':
            const repostText = args[1] || '';
            if (targetPost) {
                const newRepost = {
                    id: newId('weibo_post'),
                    authorId: actorId,
                    type: 'repost',
                    timestamp: Date.now(),
                    content: { text: repostText, images: [] },
                    visibility: 'public',
                    repostedFrom: {
                        originalPostId: targetPost.id,
                        originalAuthorId: targetPost.authorId,
                        topic: targetPost.topic,
                        originalContent: { text: targetPost.content.text }
                    },
                    repostCount: 0, commentCount: 0, likeCount: 0, comments: [], likes: []
                };
                actorWeiboData.posts.unshift(newRepost);
                targetPost.repostCount = (targetPost.repostCount || 0) + 1;
            }
            break;

        case 'WEIBO_REPLY_COMMENT':
            const [postIdForReply, commentId, replyText] = args;
            // Refind post because targetId was the postID here
            let postForReply = allProfilesWithWeibo.flatMap(p => p.weibo.posts).find(p => p.id === postIdForReply);
            if (postForReply) {
                const targetComment = postForReply.comments.find(c => c.id === commentId);
                if (targetComment && replyText) {
                    const newReply = { id: newId('reply'), authorId: actorId, text: replyText, timestamp: Date.now(), likes: [] };
                    if (!targetComment.replies) targetComment.replies = [];
                    targetComment.replies.push(newReply);
                    postForReply.commentCount = (postForReply.commentCount || 0) + 1;
                }
            }
            break;
    }
    debouncedSaveState();
}
init();


});

</script>

</body>
</html>