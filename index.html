<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ÂúüÁöáÂ∏ùÂ∞èÊâãÊú∫</title>
    <!-- Safari PWA/Fullscreen Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/50dRBnZR/c0a269c8637df7a30e8b491cd7519343.jpg">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* --- ÂÖ®Â±Ä‰∏éÂü∫Á°ÄÊ†∑Âºè --- */
        :root {
            --bg-color: #f0f2f5;
            --app-screen-bg: #ffffff;
            --primary-text-color: #000000;
            --secondary-text-color: #8e8e93;
            --accent-color: #007aff;
            --danger-color: #ff3b30;
            --edit-color: #ff9500;
            --border-color: #c6c6c8;
            --input-bg: #ffffff;
            --button-bg: #007aff;
            --button-text-color: #ffffff;
            --item-bg: #ffffff;
            --item-active-bg: #e5e5ea;
            --system-font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --system-font-color: #000000;
            --online-color: #34c759;
            --busy-color: #ff9500;
            --offline-color: #8e8e93;
            --like-color: #ff3b30;
            --listen-together-color: #ff4d6d;
            --owner-title-bg: #ffc107;
            --admin-title-bg: #28a745;
            --member-title-bg: #6c757d;
        }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden;
            font-family: var(--system-font-family);
            background-color: #000;
            display: flex; justify-content: center; align-items: center;
            user-select: none; -webkit-user-select: none;
        }
        
        body, .app-screen, .modal-content, .settings-item label, .music-item-info .title, .preset-item-content {
            color: var(--system-font-color);
        }
        
        *:focus { outline: none; -webkit-tap-highlight-color: transparent; }
        /* --- Font Awesome Icon Sizing --- */
            .app-icon .icon i { font-size: 30px; color: #333; }
            #dock .app-icon .icon i { font-size: 28px; }
            .action-btn i, .back-btn i { font-size: 20px; }
            .player-controls .icon-btn i { font-size: 24px; color: white; }
            .player-controls .play-pause-btn i { font-size: 40px; }
            #player-modal .player-header .icon-btn i { font-size: 22px; color: white; }
            .chat-toolbar .icon-btn i { font-size: 24px; color: #555; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; }
            #chat-input-buttons .icon-btn i, #chat-send-real-btn i { font-size: 26px; color: #555; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; }
            #close-quote-btn i { font-size: 16px; color: white; }
            .comment-actions-inline .icon-btn i { font-size: 18px; }
            .post-footer .comment-actions-inline .icon-btn i { font-size: 20px; }
            .like-btn.liked i { color: var(--like-color); }
            .edit-action i, .delete-action i { font-size: 18px; }
            #status-bar #battery-icon i { font-size: 18px; }
        /* --- ÊâãÊú∫Â±èÂπïÂÆπÂô® (Fullscreen/PWA Optimized) --- */
        #phone-screen {
            width: 100%; height: 100%;
            background-image: url('https://img.xjh.me/random_img.php?type=bg&ctype=nature&return=302');
            background-size: cover; background-position: center;
            display: flex; flex-direction: column;
            position: relative; overflow: hidden;
            transition: background-image 0.5s ease-in-out;
        }
        /* ÂΩìAPPÊâìÂºÄÊó∂ÔºåÈöêËóè‰∏ªÂ±èÂπïÂÜÖÂÆπ */
        #phone-screen.app-open > #main-content,
        #phone-screen.app-open > #dock {
            visibility: hidden;
        }

        /* --- È°∂ÈÉ®Âå∫Âüü (Áä∂ÊÄÅÊ†è + ÁÅµÂä®Â≤õ) --- */
        #top-area { 
            position: absolute; top: 0; left: 0; right: 0; 
            padding: 10px; 
            padding-top: calc(env(safe-area-inset-top, 10px)); /* iPhone Safe Area */
            display: flex; justify-content: center; align-items: flex-start; 
            z-index: 50; pointer-events: none; 
            height: 74px; /* Â¢ûÂä†È´òÂ∫¶ */
            box-sizing: border-box;
        }
        #status-bar { width: 100%; display: flex; justify-content: space-between; align-items: center; color: white; font-weight: 600; font-size: 14px; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); padding: 0 15px; position: relative; top: 0; }
        #time { min-width: 50px; text-align: left; }
        #battery-status { display: flex; justify-content: flex-end; align-items: center; gap: 5px; }
        #battery-icon { font-size: 18px; }

        /* --- ÁÅµÂä®Â≤õ --- */
        #dynamic-island { position: absolute; top: calc(env(safe-area-inset-top, 8px) + 1px); /* Âêë‰∏äÂÅèÁßª2px */ height: 20px; width: 100px; max-width: 50%; background-color: black; border-radius: 10px; transition: all 0.5s cubic-bezier(0.65, 0, 0.35, 1); pointer-events: auto; display: flex; align-items: center; justify-content: space-between; padding: 0 8px; box-sizing: border-box; overflow: hidden; }
        #dynamic-island.music-active { width: 240px; }
        .island-content { color: white; font-size: 11px; opacity: 0; transition: opacity 0.3s ease; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #dynamic-island.music-active .island-content { opacity: 1; }
        .island-music-info { flex-grow: 1; text-align: left; padding: 0 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .island-waveform { width: 20px; height: 12px; display: flex; justify-content: space-between; align-items: flex-end; }
        .island-waveform span { width: 2px; height: 100%; background-color: #34c759; border-radius: 1px; animation: waveform-dance 1.2s infinite ease-in-out; }
        .island-waveform span:nth-child(2) { animation-delay: -1.0s; }
        .island-waveform span:nth-child(3) { animation-delay: -0.8s; }
        .island-waveform.paused span { animation-play-state: paused; height: 2px; }
        @keyframes waveform-dance { 0%, 100% { height: 2px; } 50% { height: 100%; } }
        /* --- ÁÅµÂä®Â≤õ (ËßÜÈ¢ëÈÄöËØù) --- */
        #dynamic-island.video-call-active { width: 150px; background-color: #34c759; }
        #dynamic-island.video-call-active .island-content { opacity: 1; }
        #dynamic-island.video-call-active .island-music-info,
        #dynamic-island.video-call-active .island-waveform { display: none; }
        #dynamic-island .island-video-call-icon,
        #dynamic-island .island-video-call-timer { display: none; color: white; font-weight: 500; font-variant-numeric: tabular-nums; }
        #dynamic-island.video-call-active .island-video-call-icon,
        #dynamic-island.video-call-active .island-video-call-timer { display: block; }
        .island-video-call-icon::before { content: 'üìπ'; font-size: 13px; margin-right: 5px; }
        .island-video-call-timer { font-size: 13px; }

        /* --- ÈÄöÁü•Ê®™ÂπÖ --- */
        #notification-container { position: absolute; top: calc(env(safe-area-inset-top, 10px) + 60px); left: 0; right: 0; padding: 0 10px; z-index: 250; pointer-events: none; display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .notification-banner { width: 90%; max-width: 380px; background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 12px 16px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); color: #000; font-size: 15px; transform: translateY(-150%); transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease-out; pointer-events: auto; cursor: grab; opacity: 1; position: relative; }
        .notification-banner.show { transform: translateY(0); }
        .notification-banner:not(.show) { opacity: 0; }

        /* --- ‰∏ªÂÜÖÂÆπÂå∫‰∏éAPPÂõæÊ†á --- */
        #main-content { flex-grow: 1; padding: calc(env(safe-area-inset-top, 10px) + 80px) 20px 20px 20px; }
        #app-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; justify-items: center; }
        .app-icon { display: flex; flex-direction: column; align-items: center; gap: 8px; text-align: center; cursor: pointer; width: 70px; position: relative; }
        .app-icon .icon { width: 60px; height: 60px; background-color: rgba(255, 255, 255, 0.9); border-radius: 15px; display: flex; justify-content: center; align-items: center; font-size: 30px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: transform 0.1s ease-in-out; overflow: hidden; }
        .app-icon .icon img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon:active .icon { transform: scale(0.9); }
        .app-icon .label { color: white; font-size: 12px; text-shadow: 1px 1px 2px rgba(0,0,0,0.6); }

        /* --- Â∫ïÈÉ® Dock Ê†è --- */
        #dock { padding: 8px 20px; padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 8px); margin: 15px; margin-bottom: 0; background-color: rgba(255, 255, 255, 0.2); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 25px; display: flex; justify-content: space-around; align-items: center; flex-shrink: 0; }
        #dock .app-icon { position: relative; top: 3px; /* Âêë‰∏ãÂÅèÁßª3px */ }

        /* --- APP ÁïåÈù¢ÈÄöÁî®Ê†∑Âºè --- */
        .app-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-color); transform: translateY(100%); transition: transform 0.3s ease-in-out; display: flex; flex-direction: column; z-index: 10; }
        .app-screen.sub-screen { z-index: 11; } /* Â≠êÂ±èÂπïÂ±ÇÁ∫ßÊõ¥È´ò */
        .app-screen.active { transform: translateY(0); }
        .app-screen.parent-hidden { visibility: hidden; } /* ÈöêËóèË¢´Ë¶ÜÁõñÁöÑÁà∂Á∫ßÁïåÈù¢ */
.app-header { position: sticky; top: 0; display: flex; align-items: center; justify-content: space-between; padding: 10px 15px; background-color: var(--app-screen-bg); border-bottom: 1px solid var(--border-color); flex-shrink: 0; padding-top: calc(env(safe-area-inset-top, 10px) + 15px); min-height: 45px; /* Â¢ûÂä†È´òÂ∫¶ */ box-sizing: content-box; z-index: 10; /* Á°Æ‰øùheaderÂú®ÂÜÖÂÆπ‰πã‰∏ä */ }        .app-header-left, .app-header-right { flex: 0 0 60px; display: flex; }
        .app-header-left { justify-content: flex-start; }
        .app-header-right { justify-content: flex-end; align-items: center; }
        .app-header .back-btn, .app-header .action-btn { position: relative; top: 8px; /* Âêë‰∏ãÂÅèÁßª8px */ }
        .app-header .back-btn { font-size: 16px; color: var(--accent-color); cursor: pointer; background: none; border: none; padding: 5px 10px; white-space: nowrap; }
        .app-header .title-wrapper { flex-grow: 1; text-align: center; }
        .app-header .title { font-size: 17px; font-weight: 600; position: relative; top: -5px; /* Âêë‰∏äÂÅèÁßª5px */ }
        .app-header .action-btn { font-size: 28px; color: var(--accent-color); cursor: pointer; background: none; border: none; padding: 5px 10px; line-height: 1; display: flex; align-items: center; justify-content: center; }
        .app-header .action-btn.small { font-size: 16px; font-weight: normal; padding: 5px 10px; }
        /* OPTIMIZATION: ÊîæÂ§ßËÆæÁΩÆÊåâÈíÆÂõæÊ†á */
        .app-header .action-btn[data-icon-id="header-settings"] img { height: 48px; width: 48px; }
        .app-header .action-btn img { height: 24px; width: auto; } /* ÈªòËÆ§ÊåâÈíÆÂõæÊ†áÂ§ßÂ∞è */
        .app-content { flex-grow: 1; overflow-y: auto; position: relative; /* ‰∏∫FABÊåâÈíÆÂÆö‰ΩçÊèê‰æõÂü∫ÂáÜ */ padding-top: calc(env(safe-area-inset-top, 10px) + 60px); }
        .app-bottom-tabs { position: absolute; bottom: 0; left: 0; right: 0; height: 50px; padding-bottom: env(safe-area-inset-bottom, 0px); background-color: var(--item-bg); border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; align-items: flex-start; z-index: 5; box-sizing: border-box; }
        .tab-link { flex: 1; text-align: center; padding: 8px 0; cursor: pointer; color: var(--secondary-text-color); border-top: 2px solid transparent; font-size: 14px; }
        .tab-link.active { color: var(--accent-color); border-top-color: var(--accent-color); }
        .tab-content-wrapper { flex-grow: 1; overflow: hidden; position: relative; }
        .tab-content { display: none; padding: 15px; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow-y: auto; box-sizing: border-box; padding-bottom: 80px; /* FIX: ‰øÆÂ§çÂ∫ïÈÉ®ÈÅÆÊå°ÈóÆÈ¢ò */ }
        .tab-content.active { display: block; }

        /* --- ËÆæÁΩÆ APP ÁâπÂÆöÊ†∑Âºè --- */
        .settings-group { margin-bottom: 25px; padding: 0 20px; }
        .settings-group .group-title { font-size: 14px; color: var(--secondary-text-color); margin-bottom: 8px; padding-left: 15px; text-transform: uppercase; }
        .settings-group .group-content { background-color: var(--item-bg); border-radius: 10px; overflow: hidden; }
        .settings-item { padding: 12px 15px; border-bottom: 1px solid var(--border-color); display: flex; flex-direction: column; }
        .settings-item:last-child { border-bottom: none; }
        .settings-item label { font-size: 16px; margin-bottom: 8px; }
        .settings-item input, .settings-item select { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 5px; font-size: 15px; box-sizing: border-box; }
        .settings-item input[type="password"] { -webkit-text-security: disc; }
        .settings-button { width: 100%; padding: 12px; font-size: 16px; color: var(--button-text-color); background-color: var(--button-bg); border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
        .settings-button:active { background-color: #0056b3; }
        .settings-button.secondary { background-color: #555; }
        .settings-button.secondary:active { background-color: #333; }
        #global-realtime-char-selector {
        display: grid;
        grid-template-columns: repeat(6, minmax(0, 1fr));
        gap: 15px;
        padding-top: 5px;
    }
    .realtime-char-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        cursor: pointer;
        border: 2px solid transparent;
        border-radius: 8px;
        padding: 5px;
        transition: border-color 0.2s;
    }
    .realtime-char-item .avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-size: cover;
        background-position: center;
        flex-shrink: 0;
    }
    .realtime-char-item .name {
        font-size: 11px;
        text-align: center;
        word-break: break-all;
        line-height: 1.2;
        height: 2.4em; /* Á°Æ‰øùÊúÄÂ§öÊòæÁ§∫‰∏§Ë°å */
        overflow: hidden;
    }
    .realtime-char-item.selected {
        border-color: var(--accent-color);
    }
        #confirm-api-btn { margin-top: 15px; }
        .button-group { display: flex; gap: 10px; margin-top: 10px; }
        .filter-dropdown {
        display: none;
        position: absolute;
        top: calc(env(safe-area-inset-top, 10px) + 75px); /* Position below the header */
        right: 15px;
        width: 180px;
        background-color: var(--item-bg);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        border: 1px solid var(--border-color);
        z-index: 20;
        max-height: 250px;
        overflow-y: auto;
        padding: 10px;
    }
    .filter-dropdown.visible {
        display: block;
    }
    .filter-dropdown .checkbox-label {
        width: 100%;
        padding: 8px 5px;
        border: none;
        border-radius: 4px;
    }
    .filter-dropdown .checkbox-label:hover {
        background-color: var(--item-active-bg);
    }
        /* --- Èü≥‰πê APP --- */
        #music-list { list-style: none; padding: 0; margin: 0; }
        .music-list-item { position: relative; background-color: var(--item-bg); border-bottom: 1px solid var(--border-color); overflow: hidden; }
        .music-item-content { padding: 10px 15px; background-color: var(--item-bg); transition: transform 0.3s ease; position: relative; z-index: 2; display: flex; justify-content: space-between; align-items: center; }
        .music-item-info { display: flex; flex-direction: column; overflow: hidden; }
        .music-item-info .title { font-size: 16px; font-weight: 500; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
        .music-item-info .artist { font-size: 13px; color: var(--secondary-text-color); white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
        .music-item-duration { font-size: 14px; color: var(--secondary-text-color); flex-shrink: 0; padding-left: 10px; }
        .music-list-item.playing .music-item-info .title, .music-list-item.playing .music-item-info .artist { color: var(--accent-color); }

        /* --- ÊµÆÂä®Ê≠åËØç --- */
        #lyrics-container { position: absolute; top: calc(env(safe-area-inset-top, 10px) + 60px); left: 50%; transform: translateX(-50%); width: 90%; max-width: 380px; background-color: rgba(0,0,0,0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); color: white; border-radius: 12px; padding: 10px; box-sizing: border-box; font-size: 14px; text-align: center; z-index: 40; cursor: grab; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        #lyrics-container.visible { opacity: 1; visibility: visible; }
        #lyrics-line { font-weight: bold; text-shadow: 1px 1px 2px black; }

        /* --- Èü≥‰πêÊí≠ÊîæÂô®Ê®°ÊÄÅÊ°Ü --- */
        #player-modal { position: absolute; top: 50%; left: 50%; width: 80%; max-width: 300px; height: 45%; max-height: 400px; transform: translate(-50%, -50%) scale(0.9); background-color: rgba(50, 50, 50, 0.2); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); border-radius: 20px; z-index: 150; display: flex; flex-direction: column; color: white; opacity: 0; visibility: hidden; transition: opacity 0.3s, transform 0.3s, visibility 0.3s; }
        #player-modal.show { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); }
        .player-header { padding: 15px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .player-header .icon-btn { background: none; border: none; cursor: pointer; padding: 5px; font-size: 22px; color: white; }
        .player-song-info { text-align: center; }
        .player-song-info .title { font-size: 16px; font-weight: bold; }
        .player-song-info .artist { font-size: 13px; color: #ccc; }
        #listen-together-info { font-size: 12px; color: var(--listen-together-color); margin-top: 4px; display: none; align-items: center; justify-content: center; gap: 5px; }
        .listen-heart { width: 14px; height: 12px; position: relative; animation: heart-beat 1.2s infinite cubic-bezier(0.215, 0.61, 0.355, 1); }
        .listen-heart::before, .listen-heart::after { content: ""; position: absolute; top: 0; left: 7px; width: 7px; height: 11px; background: var(--listen-together-color); border-radius: 7px 7px 0 0; transform: rotate(-45deg); transform-origin: 0 100%; }
        .listen-heart::after { left: 0; transform: rotate(45deg); transform-origin: 100% 100%; }
        @keyframes heart-beat { 0% { transform: scale(0.95); } 5% { transform: scale(1.1); } 39% { transform: scale(0.85); } 45% { transform: scale(1); } 60% { transform: scale(0.95); } 100% { transform: scale(0.9); } }
        .player-body { flex-grow: 1; overflow: hidden; position: relative; }
        .player-view { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow-y: auto; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        .player-view.active { opacity: 1; pointer-events: auto; }
        #player-lyrics-view { padding: 10px 20px; font-size: 16px; line-height: 1.8; text-align: center; }
        #player-lyrics-view .lyric-line { transition: color 0.3s, transform 0.3s, opacity 0.3s; opacity: 0.5; }
        #player-lyrics-view .lyric-line.active { color: white; opacity: 1; transform: scale(1.1); font-weight: bold; }
        .player-playlist-view { list-style: none; padding: 0; margin: 0; }
        .player-playlist-item { display: flex; align-items: center; padding: 10px 20px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .player-playlist-item.playing .info .title { color: var(--accent-color); }
        .player-playlist-item .info { flex-grow: 1; }
        .player-playlist-item .info .title { font-size: 15px; }
        .player-playlist-item .info .artist { font-size: 12px; color: #aaa; }
        .delete-from-queue-btn { background: transparent; border: none; color: white; font-size: 18px; cursor: pointer; }
        .player-playlist-header { padding: 10px 20px; display: flex; justify-content: flex-end; }
        .player-footer { padding: 15px 20px; flex-shrink: 0; }
        #progress-bar { width: 100%; -webkit-appearance: none; appearance: none; height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; outline: none; }
        #progress-bar::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; background: white; border-radius: 50%; cursor: pointer; }
        #progress-bar::-moz-range-thumb { width: 14px; height: 14px; background: white; border-radius: 50%; cursor: pointer; }
        .player-controls { display: flex; justify-content: space-around; align-items: center; margin-top: 15px; }
        .player-controls .icon-btn { background: none; border: none; cursor: pointer; padding: 5px; }
        .player-controls .icon-btn img { height: 20px; width: auto; }
        .player-controls .play-pause-btn img { height: 32px; }
        #player-playback-mode-btn { font-size: 20px; }

        /* --- ÁæéÂåñ APP --- */
        #beautify-app-screen .app-content { padding-bottom: 50px; }
        #wallpaper-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .wallpaper-item { width: 100%; height: auto; aspect-ratio: 9 / 16; border-radius: 8px; cursor: pointer; position: relative; overflow: hidden; border: 2px solid transparent; transition: border-color 0.2s; background-color: #f0f0f0; }
        .wallpaper-item img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .wallpaper-item.is-wallpaper { border-color: var(--accent-color); }
        .wallpaper-item.is-chat-bg { border-color: var(--listen-together-color); }
        .wallpaper-item.is-wallpaper.is-chat-bg { border-image: linear-gradient(45deg, var(--accent-color), var(--listen-together-color)) 1; }
        .wallpaper-item::before { content: 'Â£ÅÁ∫∏'; position: absolute; bottom: 2px; left: 4px; background-color: var(--accent-color); color: white; padding: 1px 4px; border-radius: 3px; font-size: 9px; font-weight: bold; display: none; }
        .wallpaper-item.is-wallpaper::before { display: block; }
        .wallpaper-item::after { content: 'ËÉåÊôØ'; position: absolute; bottom: 2px; right: 4px; background-color: var(--listen-together-color); color: white; padding: 1px 4px; border-radius: 3px; font-size: 9px; font-weight: bold; display: none; }
        .wallpaper-item.is-chat-bg::after { display: block; }
        #font-list { list-style: none; padding: 0; margin: 0; }
        .font-list-item { position: relative; background-color: var(--item-bg); border-bottom: 1px solid var(--border-color); overflow: hidden; }
        .font-item-content { padding: 15px; background-color: var(--item-bg); transition: transform 0.3s ease; position: relative; z-index: 2; display: flex; justify-content: space-between; align-items: center; }
        .font-item-content.active { color: var(--accent-color); font-weight: bold; }
        .font-color-btn { background: none; border: 1px solid var(--border-color); border-radius: 5px; padding: 3px 8px; cursor: pointer; font-size: 14px; }
        #icon-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; }
        .icon-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; }
        .icon-item .icon-preview { width: 36px; height: 36px; display: flex; justify-content: center; align-items: center; font-size: 24px; }
        .icon-item .icon-preview img { max-width: 100%; max-height: 100%; }
        .icon-item .icon-name { font-size: 9px; color: var(--secondary-text-color); text-align: center; word-break: break-word; }
        #bubble-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .bubble-item { display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; padding: 10px; border-radius: 8px; }
        .bubble-item .bubble-preview-container { width: 100%; height: 40px; display: flex; justify-content: center; align-items: center; }
        .bubble-item .bubble-preview-container button { background-color: white; border: 1px solid var(--border-color); border-radius: 8px; padding: 5px 10px; font-size: 14px; color: var(--accent-color); }
        .bubble-item .bubble-preview-container button img { height: 24px; width: auto; }
        .bubble-item.global-bubble-item { border: 2px solid transparent; } /* Replaced dashed border with transparent */

        /* --- ÂºπÁ™ó/Ê®°ÊÄÅÊ°ÜÊ†∑Âºè (Z-Index Management) --- */
        .modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: flex; justify-content: center; align-items: center; z-index: 100; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        #gcs-member-modal { z-index: 110; }
        #library-modal, #load-persona-modal, #gcs-manage-members-modal, #gcs-member-action-modal, #bubble-io-modal, #post-moment-modal { z-index: 120; }
        #edit-photo-modal { z-index: 140; }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--app-screen-bg); padding: 20px; border-radius: 14px; width: 90%; max-width: 350px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); transform: scale(0.9); transition: transform 0.2s; }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-title { font-size: 18px; font-weight: 600; text-align: center; margin-bottom: 15px; }
        .modal-body { margin-bottom: 20px; max-height: 60vh; overflow-y: auto; }
        .modal-body .form-group { margin-bottom: 12px; }
        .modal-body .form-group label { display: block; font-size: 14px; margin-bottom: 5px; color: var(--secondary-text-color); }
        .modal-body .form-group input, .modal-body .form-group select { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 5px; font-size: 15px; box-sizing: border-box; }
        .wide-textarea { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 5px; font-size: 15px; box-sizing: border-box; resize: vertical; min-height: 120px; font-family: inherit; }
        #pat-suffix-input { width: 100%; box-sizing: border-box; }
        .uniform-input-box { width: 100%; height: 40px; min-height: 40px !important; padding: 8px 15px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 5px; font-size: 15px; font-family: inherit; resize: none; }
        .modal-actions { display: flex; justify-content: space-around; gap: 10px; flex-direction: column; }
        .modal-actions button { width: 100%; padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 500; }
        .modal-actions .confirm-btn { background-color: var(--accent-color); color: white; }
        .modal-actions .cancel-btn { background-color: #e5e5ea; color: var(--accent-color); }
        .modal-actions .danger-btn { background-color: var(--danger-color); color: white; }
        .modal-actions.row { flex-direction: row; } .modal-actions.row button { flex: 1; }
        .modal-tabs { display: flex; margin-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .tab-btn { flex: 1; padding: 10px; border: none; background: none; cursor: pointer; font-size: 16px; color: var(--secondary-text-color); border-bottom: 2px solid transparent; }
        .tab-btn.active { color: var(--accent-color); border-bottom-color: var(--accent-color); }
        .modal-tab-content { display: none; }
        .modal-tab-content.active { display: block; }
        #add-music-modal .modal-actions .single-button { flex: none; width: 100%; }
        .inline-inputs { display: flex; gap: 10px; }
        .inline-inputs .form-group { flex: 1; }
        .inline-inputs input { text-align: center; }
        #bubble-preview-wrapper { width: 100%; height: 80px; border: 1px dashed var(--border-color); margin-top: 15px; display: flex; justify-content: center; align-items: center; border-radius: 8px; overflow: hidden; }
        #bubble-preview { display: flex; justify-content: center; align-items: center; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
        .hidden-by-logic { display: none !important; }

        /* --- ÂàóË°®ÊªëÂä®ÈÄöÁî®Ê†∑Âºè --- */
        .preset-list-item, .preset-data-item, .music-list-item, .font-list-item, .contact-list-item, .comment-item, .moments-post-item, .message-board-item { position: relative; background-color: var(--item-bg); border-bottom: 1px solid var(--border-color); overflow: hidden; touch-action: pan-y; }
        .preset-item-content, .preset-data-item-content, .music-item-content, .font-item-content, .contact-item-content, .comment-item-main, .post-item-content, .message-board-item-main { background-color: var(--item-bg); transition: transform 0.3s ease; position: relative; z-index: 2; }
        .preset-item-actions, .music-item-actions, .font-item-actions, .preset-data-item-actions, .contact-item-actions, .comment-item-actions-swipe, .post-item-actions, .message-board-item-actions { position: absolute; top: 0; right: 0; height: 100%; display: flex; z-index: 1; }
        .preset-item-actions > div, .music-item-actions > div, .font-item-actions > div, .preset-data-item-actions > div, .contact-item-actions > div, .comment-item-actions-swipe > div, .post-item-actions > div, .message-board-item-actions > div { width: 70px; height: 100%; color: white; display: flex; justify-content: center; align-items: center; cursor: pointer; }
        .edit-action { background-color: var(--edit-color); }
        .delete-action { background-color: var(--danger-color); }
        #manage-presets-modal .modal-content { min-height: 300px; }
        #manage-presets-modal .modal-body p { margin-top: 0; margin-bottom: 15px; }
        
        /* --- Ê≠åÊõ≤ËØ¶ÊÉÖÈ°µ & Âä®ÊÄÅËØÑËÆ∫Âå∫ (ÈÄöÁî®Ê†∑Âºè) --- */
        #song-details-screen { background-color: var(--app-screen-bg); display: flex; flex-direction: column; }
        #song-details-screen .app-content { display: flex; flex-direction: column; overflow: hidden; padding: 0; }
        .details-song-info { text-align: center; padding: 15px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .details-song-info .title { font-size: 20px; font-weight: bold; }
        .details-song-info .artist { font-size: 16px; color: var(--secondary-text-color); }
        .details-lyrics-container { flex: 1; overflow-y: auto; padding: 20px; font-size: 18px; line-height: 2; text-align: center; }
        .details-lyrics-container .lyric-line { transition: color 0.3s, transform 0.3s, opacity 0.3s; opacity: 0.4; }
        .details-lyrics-container .lyric-line.active { color: var(--primary-text-color); opacity: 1; transform: scale(1.1); font-weight: bold; }
        .details-comments-section { flex: 1; border-top: 1px solid var(--border-color); display: flex; flex-direction: column; }
        .details-comments-list { flex-grow: 1; overflow-y: auto; padding: 15px; }
        .comment-item { border-bottom: none; }
        .comment-item-main { display: flex; gap: 10px; padding: 10px 0; }
        .comment-avatar { width: 40px; height: 40px; border-radius: 50%; background-color: #ccc; flex-shrink: 0; background-size: cover; background-position: center; }
        .comment-content { flex-grow: 1; }
        .comment-header { display: flex; justify-content: space-between; align-items: center; }
        .comment-author { font-weight: bold; font-size: 15px; }
        .comment-actions-inline { display: flex; gap: 15px; font-size: 14px; color: var(--secondary-text-color); }
        .comment-actions-inline .icon-btn { background: none; border: none; cursor: pointer; padding: 0 5px; display: flex; align-items: center; gap: 4px; }
        .comment-actions-inline .icon-btn.liked { color: var(--like-color); }
        .comment-text { margin-top: 5px; font-size: 15px; line-height: 1.5; }
        .comment-replies { margin-left: 50px; margin-top: 10px; border-left: 2px solid #eee; padding-left: 10px; }
        .reply-item { font-size: 14px; margin-bottom: 8px; position: relative; cursor: pointer; }
        .reply-author { font-weight: bold; }
        .reply-target { color: var(--accent-color); }
        .reply-input-container { display: none; margin-top: 5px; }
        .reply-input-container.active { display: flex; gap: 5px; }
        .reply-input-container input { flex-grow: 1; border: 1px solid var(--border-color); border-radius: 15px; padding: 5px 10px; }
        .comment-timestamp, .reply-timestamp { font-size: 12px; color: var(--secondary-text-color); margin-left: 8px; }
        .reply-item { display: flex; gap: 8px; align-items: flex-start; }
        .reply-avatar { width: 24px; height: 24px; border-radius: 50%; background-color: #ccc; flex-shrink: 0; background-size: cover; background-position: center; margin-top: 2px; }
        .reply-content { flex-grow: 1; }
        .comment-input-area { padding: 10px; border-top: 1px solid var(--border-color); background-color: #f9f9f9; flex-shrink: 0; display: flex; gap: 10px; align-items: center; }
        .comment-input-area input { flex-grow: 1; padding: 10px; border: 1px solid var(--border-color); border-radius: 20px; box-sizing: border-box; }
        .comment-input-area button { flex-shrink: 0; width: 70px; padding: 8px 15px; border-radius: 20px; }

        /* --- ËµÑÊñô APP --- */
        #data-app-screen .app-content { padding: 0; display: flex; flex-direction: column; }
        #data-app-screen .tab-content { padding: 0; } /* ÁßªÈô§ÂÜÖËæπË∑ù */
        .preset-data-list { list-style: none; padding: 0; margin: 0; padding-bottom: 50px; /* BUG FIX: ‰øÆÂ§çÂ∫ïÈÉ®ÈÅÆÊå° */ }
        .preset-data-item-content { display: flex; align-items: center; gap: 15px; padding: 15px; }
        .preset-data-avatar { width: 50px; height: 50px; border-radius: 50%; background-color: #e0e0e0; background-size: cover; background-position: center; flex-shrink: 0; }
        .preset-data-info { overflow: hidden; }
        .preset-data-name { font-size: 16px; font-weight: 500; }
        .preset-data-excerpt { font-size: 13px; color: var(--secondary-text-color); white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
        .modal-avatar-preview { width: 80px; height: 80px; border-radius: 50%; background-color: #f0f0f0; margin: 0 auto 15px; background-size: cover; background-position: center; }
        .modal-avatar-actions { display: flex; gap: 10px; justify-content: center; margin-bottom: 15px; }
        .modal-avatar-actions button { flex: 1; }
        .data-group-input-wrapper {
        display: flex;
        align-items: center; /* Á°Æ‰øùÂú®flexÂÆπÂô®‰∏≠ÂûÇÁõ¥Â±Ö‰∏≠ÂØπÈΩê */
        gap: 10px;
    }
    .data-group-input-wrapper #data-group,
    .data-group-input-wrapper #data-group-select {
        width: 50%;
        /* ‰∏çËÆæÁΩÆÂõ∫ÂÆöÈ´òÂ∫¶ÔºåËÆ©ÂÖ∂Áî±ÂÜÖËæπË∑ùÂíåÂ≠ó‰ΩìÂ§ßÂ∞èËá™ÁÑ∂ÂÜ≥ÂÆö */
    }
    /* Á°Æ‰øù‰∏ãÊãâÊ°ÜÁªßÊâø‰∏éÂÖ∂‰ªñËæìÂÖ•Ê°ÜÁõ∏ÂêåÁöÑÈÄöÁî®Ê†∑Âºè */
    .data-group-input-wrapper #data-group-select {
        background-color: var(--input-bg);
        color: var(--primary-text-color);
    }

        /* --- ËÅäÂ§© APP --- */
        #chat-app-screen .app-content { padding-bottom: 50px; }
        #chat-app-screen.selection-mode .contact-list-item.selected .contact-item-content { background-color: var(--item-active-bg); }
        #message-list { list-style: none; padding: 0; margin: 0; padding-bottom: calc(50px + env(safe-area-inset-bottom, 0px)); /* ‰øÆÂ§çÂàóË°®Êà™Êñ≠ */ }
        .contact-item-content { display: flex; align-items: center; gap: 12px; padding: 10px 15px; }
        .contact-avatar { width: 50px; height: 50px; border-radius: 50%; background-color: #e0e0e0; background-size: cover; background-position: center; flex-shrink: 0; position: relative; }
        .contact-avatar.group-puzzle { background-color: transparent; }
        .puzzle-piece { position: absolute; width: 50%; height: 50%; background-size: cover; background-position: center; }
        .puzzle-piece:nth-child(1) { top: 0; left: 0; border-top-left-radius: 50%; }
        .puzzle-piece:nth-child(2) { top: 0; right: 0; border-top-right-radius: 50%; }
        .puzzle-piece:nth-child(3) { bottom: 0; left: 0; border-bottom-left-radius: 50%; }
        .puzzle-piece:nth-child(4) { bottom: 0; right: 0; border-bottom-right-radius: 50%; }
        .unread-badge { position: absolute; top: -2px; left: -2px; width: 18px; height: 18px; background-color: var(--danger-color); color: white; border-radius: 50%; font-size: 11px; font-weight: bold; display: flex; justify-content: center; align-items: center; border: 2px solid var(--item-bg); }
        .contact-avatar.shake, .moments-notification-btn.shake { animation: shake-anim 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake-anim { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
        .contact-info { flex-grow: 1; overflow: hidden; }
        .contact-name { font-size: 17px; font-weight: 500; }
        .contact-last-msg { font-size: 14px; color: var(--secondary-text-color); white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
        .contact-meta { text-align: right; flex-shrink: 0; font-size: 12px; color: var(--secondary-text-color); }
        .contact-status { display: flex; align-items: center; justify-content: flex-end; gap: 4px; }
        .status-indicator { width: 8px; height: 8px; border-radius: 50%; }
        .status-indicator.online { background-color: var(--online-color); }
        .status-indicator.busy { background-color: var(--busy-color); }
        .status-indicator.offline { background-color: var(--offline-color); }
        #single-chat-screen { display: flex; flex-direction: column; background-size: cover; background-position: center; }
        #single-chat-screen .app-header .title-wrapper { display: flex; flex-direction: column; align-items: center; line-height: 1.2; position: relative; top: 10px; /* Âêë‰∏ãÂÅèÁßª10px */ }
        #single-chat-screen .chat-header-name { font-size: 16px; font-weight: 600; cursor: pointer; }
        #single-chat-screen .chat-header-status { font-size: 11px; color: var(--secondary-text-color); cursor: pointer; display: flex; align-items: center; gap: 5px; }
        #single-chat-screen .chat-header-signature { font-size: 11px; color: var(--secondary-text-color); cursor: pointer; margin-top: 2px; }
        #single-chat-screen.selection-mode #chat-settings-btn { font-size: 16px; font-weight: normal; padding: 5px 10px; }
        #single-chat-screen .app-content { flex-grow: 1; padding: 10px; overflow-y: auto; display: flex; flex-direction: column-reverse; background-color: transparent; }
        #chat-messages-view { display: flex; flex-direction: column; gap: 15px; padding-bottom: 10px; }
        .message-item { display: flex; align-items: flex-start; gap: 8px; position: relative; -webkit-touch-callout: none; /* Disable iOS default long-press menu */ }
        .message-item.selected::before, .message-timestamp.selected::before { content: ''; position: absolute; top: -5px; left: -5px; right: -5px; bottom: -5px; background-color: rgba(0, 122, 255, 0.15); border-radius: 12px; z-index: -1; }
        .message-content-wrapper { max-width: 70%; display: flex; flex-direction: column; }
        .message-bubble { padding: 8px 12px; border-radius: 18px; line-height: 1.5; word-wrap: break-word; }
        .message-item.user { justify-content: flex-end; }
        .message-item.contact { justify-content: flex-start; }
        .message-item .avatar { width: 40px; height: 40px; border-radius: 50%; background-color: #ccc; flex-shrink: 0; cursor: pointer; background-size: cover; background-position: center; position: relative; }
        .message-item .avatar .avatar-frame { position: absolute; top: 50%; left: 50%; transform: translate(-50%, calc(-50% - 5px)); width: calc(100% * 250 / 268 + 10px); height: calc(100% + 10px); background-size: contain; background-repeat: no-repeat; background-position: center; }
        .message-item.user .avatar { order: 2; }
        .message-item.user .message-content-wrapper { align-items: flex-end; }
        .message-item.user .message-bubble { background-color: var(--accent-color); color: white; border-bottom-right-radius: 4px; }
        .message-item.contact .message-bubble { background-color: white; color: black; border-bottom-left-radius: 4px; }
        .message-timestamp { width: 100%; text-align: center; font-size: 12px; color: var(--secondary-text-color); margin: 10px 0; cursor: pointer; position: relative; }
        .typing-indicator { text-align: center; font-size: 12px; color: var(--secondary-text-color); padding: 5px; }
        #chat-footer { flex-shrink: 0; background-color: #f7f7f7; border-top: 1px solid var(--border-color); padding: 5px 8px; padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 5px); display: flex; flex-direction: column; position: relative; top: -2px; }
        #quote-preview { display: none; padding: 8px; margin-bottom: 5px; background-color: #e9e9e9; border-radius: 8px; font-size: 13px; color: #555; position: relative; }
        #quote-preview-content { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #close-quote-btn { position: absolute; top: 5px; right: 5px; background: #aaa; color: white; border: none; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; line-height: 16px; text-align: center; cursor: pointer; }
        .chat-input-area { display: flex; align-items: center; gap: 5px; }
        #chat-send-real-btn { background: none; border: none; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; }
        #chat-input { flex-grow: 1; border: none; background-color: white; border-radius: 18px; padding: 8px 15px; font-size: 16px; resize: none; max-height: 100px; }
        #chat-input-buttons { display: flex; align-items: center; }
        #chat-input-buttons .icon-btn { background: none; border: none; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; }
        .chat-toolbar-wrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; position: relative; left: 3px; padding-top: 2px; }
        .chat-toolbar-wrapper::-webkit-scrollbar { display: none; }
        .chat-toolbar { display: flex; justify-content: flex-start; white-space: nowrap; gap: 15px; }
        .chat-toolbar .icon-btn { background: none; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; }
        .chat-toolbar .icon-btn img, #chat-input-buttons .icon-btn img, #chat-send-real-btn img { height: 44px; width: 44px; object-fit: contain; }
        .chat-toolbar .icon-btn.disabled, #chat-emoji-btn.disabled { opacity: 0.5; cursor: not-allowed; }
        #emoji-picker-panel { position: absolute; bottom: 0; left: 0; right: 0; height: 250px; background-color: #f9f9f9; border-top: 1px solid var(--border-color); transform: translateY(100%); transition: transform 0.3s ease; z-index: 20; display: flex; flex-direction: column; padding-bottom: env(safe-area-inset-bottom, 0px); }
        #emoji-picker-panel.visible { transform: translateY(0); }
        .emoji-picker-header { padding: 10px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); }
        .emoji-picker-header button { background: none; border: none; font-size: 16px; color: var(--accent-color); cursor: pointer; }
        #emoji-grid { flex-grow: 1; overflow-y: auto; padding: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 10px; }
        .emoji-item { width: 40px; height: 40px; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; position: relative; border: 2px solid transparent; border-radius: 4px; }
        #emoji-picker-panel.selection-mode .emoji-item.selected { border-color: var(--accent-color); }
        
        /* --- New/Modified Message Bubble Types --- */
        .message-bubble.voice { padding: 5px 10px; display: flex; align-items: center; gap: 8px; cursor: pointer; overflow: hidden; /* BUG FIX */ }
        .voice-waveform-container { flex-grow: 1; height: 20px; display: flex; align-items: center; justify-content: space-between; padding: 0 5px; min-width: 0; /* BUG FIX */ }
        .voice-waveform-container span { width: 2px; background-color: #888; border-radius: 1px; transition: height 0.2s; }
        .voice-waveform-container.playing span { animation: waveform-play 1.2s infinite ease-in-out; }
        .voice-waveform-container.playing span:nth-child(2n) { animation-delay: -0.2s; }
        .voice-waveform-container.playing span:nth-child(3n) { animation-delay: -0.4s; }
        .voice-waveform-container.playing span:nth-child(4n) { animation-delay: -0.6s; }
        .voice-waveform-container.playing span:nth-child(5n) { animation-delay: -0.8s; }
        @keyframes waveform-play { 0%, 100% { height: 10%; } 50% { height: 100%; } }
        .message-item.user .voice-waveform-container span { background-color: white; }
        .voice-duration { font-size: 12px; flex-shrink: 0; /* BUG FIX */ }
        .voice-text { display: none; margin-top: 5px; padding: 8px; background-color: #f0f0f0; border-radius: 8px; font-size: 14px; }
        
        .message-bubble.image, .message-bubble.camera { padding: 0; background: none; max-width: 60%; }
        .message-bubble.image img, .message-bubble.camera img { max-width: 100%; border-radius: 12px; display: block; }
        
        .message-bubble.emoji-bubble { background: none; padding: 0; display: inline-block; line-height: 0; max-width: 100px; }
        .message-bubble.emoji-bubble img { width: 100%; height: auto; display: block; }

        .message-bubble.camera { position: relative; cursor: pointer; }
        .camera-text-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: white; color: black; display: flex; justify-content: center; align-items: flex-start; text-align: center; padding: 10px; box-sizing: border-box; border-radius: 12px; opacity: 0; visibility: hidden; transition: opacity 0.2s; }
        .message-bubble.camera.show-text .camera-text-overlay { opacity: 1; visibility: visible; }
        .camera-text-overlay { word-break: break-all; overflow-y: auto; } /* BUG FIX: ‰øÆÂ§çÊñáÂ≠óÊ∫¢Âá∫ */
        .message-bubble.link { background-color: white; padding: 10px; cursor: pointer; border-radius: 12px; display: flex; flex-direction: column; gap: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .link-info .title { font-weight: bold; font-size: 15px; }
        .link-info .summary { font-size: 13px; color: var(--secondary-text-color); }
        .link-info .source { font-size: 12px; color: var(--secondary-text-color); border-top: 1px solid #eee; padding-top: 5px; margin-top: 5px; }
        .message-bubble.red-packet { background-color: #fa9d3b; color: white; width: 200px; cursor: pointer; }
        .message-bubble.red-packet.claimed, .message-bubble.red-packet.returned, .message-bubble.red-packet.expired { background-color: #fbcda5; }
        .red-packet-header { display: flex; align-items: center; gap: 8px; }
        .red-packet-icon { font-size: 24px; }
        .red-packet-body { margin-top: 5px; font-size: 14px; }
        .red-packet-footer { font-size: 10px; color: #eee; border-top: 1px solid rgba(255,255,255,0.5); margin-top: 8px; padding-top: 4px; }
        .message-bubble.red-packet.claimed .red-packet-footer, .message-bubble.red-packet.returned .red-packet-footer, .message-bubble.red-packet.expired .red-packet-footer { color: #fff; }
        .message-quote { background-color: #f0f0f0; padding: 5px 8px; border-radius: 6px; font-size: 13px; color: #666; border-left: 3px solid #ccc; margin-bottom: 5px; }
        .message-item.user .message-quote { background-color: rgba(255,255,255,0.2); color: #eee; border-left-color: #fff; }
        /* Group Chat Styles */
        .group-message-header { margin-bottom: 4px; font-size: 12px; color: var(--secondary-text-color); display: flex; align-items: center; gap: 6px; }
        .group-title { padding: 1px 5px; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; }
        .title-owner { background-color: var(--owner-title-bg); }
        .title-admin { background-color: var(--admin-title-bg); }
        .title-member { background-color: var(--member-title-bg); }
        .group-nickname { cursor: pointer; }
        .message-item.user .group-message-header { justify-content: flex-end; }

        /* --- ÈïøÊåâËèúÂçï --- */
        #context-menu, #wallpaper-context-menu { position: absolute; display: none; background-color: rgba(40, 40, 40, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 8px; padding: 5px; z-index: 110; flex-direction: column; }
        #context-menu { flex-direction: row; } /* Original menu remains row */
        .context-menu-btn { background: none; border: none; color: white; font-size: 13px; padding: 8px 12px; cursor: pointer; border-radius: 5px; text-align: left; width: 100%; box-sizing: border-box; }
        #context-menu .context-menu-btn { text-align: center; } /* Keep original centered */
        .context-menu-btn:hover { background-color: rgba(255, 255, 255, 0.2); }
        .context-menu-btn.danger { color: var(--danger-color); }
        #background-context-menu { position: absolute; display: none; background-color: rgba(40, 40, 40, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 8px; padding: 5px; z-index: 120; flex-direction: column; }
        #background-context-menu .context-menu-btn { text-align: left; }

        /* --- Ëá™ÂÆö‰πâÂçïÈÄâ/Â§öÈÄâÊåâÈíÆ --- */
        .radio-group, .checkbox-list { display: flex; gap: 10px; flex-wrap: wrap; }
        .radio-label, .checkbox-label { display: flex; align-items: center; gap: 5px; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 20px; cursor: pointer; }
        .radio-label input[type="radio"], .checkbox-label input[type="checkbox"] { display: none; }
        .radio-label input[type="radio"]:checked + span, .checkbox-label input[type="checkbox"]:checked + span { color: var(--accent-color); font-weight: bold; }
        .radio-label:has(input:checked), .checkbox-label:has(input:checked) { border-color: var(--accent-color); }

        /* --- ËÅäÂ§©ËÆæÁΩÆÁïåÈù¢ --- */
        #chat-app-screen .app-content, #chat-settings-screen .app-content, #group-chat-settings-screen .app-content { padding: 0; display: flex; flex-direction: column; padding-bottom: 50px; }
        .chat-settings-layout { display: flex; gap: 15px; }
        .chat-settings-main { flex-grow: 1; display: flex; flex-direction: column; }
        .chat-settings-side { flex-shrink: 0; width: 80px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .chat-settings-avatar { width: 60px; height: 60px; border-radius: 50%; background-color: #eee; background-size: cover; background-position: center; position: relative; flex-shrink: 0; }
        .chat-settings-avatar .avatar-frame { position: absolute; top: 50%; left: 50%; transform: translate(-50%, calc(-50% - 5px)); width: calc(100% * 250 / 268 + 10px); height: calc(100% + 10px); background-size: contain; background-repeat: no-repeat; background-position: center; }
        .chat-settings-side-btn { font-size: 12px; padding: 5px 0; width: 100%; text-align: center; background-color: #eee; border-radius: 5px; cursor: pointer; }
        .chat-settings-section { margin-bottom: 20px; }
        .chat-settings-section .group-title { font-size: 14px; color: var(--secondary-text-color); margin-bottom: 8px; }
        .world-book-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .world-book-header label { font-size: 14px; color: var(--secondary-text-color); }
        .world-book-list-container { max-height: 100px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; padding: 10px; }
        .world-book-list-container .checkbox-label { display: flex; width: 100%; border: none; padding: 5px 0; border-radius: 0; }
        .form-group.aligned-right { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .form-group.aligned-right label { margin-bottom: 0; }
        .form-group.aligned-right input[type="checkbox"] { order: 2; -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; position: relative; }
        .form-group.aligned-right input[type="checkbox"]:checked { background-color: var(--accent-color); border-color: var(--accent-color); }
            .form-group .checkbox-label.tick-style {
        border: none;
        padding-left: 0;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border-radius: 0; /* Override default */
    }
    .form-group .checkbox-label.tick-style input[type="checkbox"] {
        display: inline-block; /* Make it visible */
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        cursor: pointer;
        position: relative;
        flex-shrink: 0;
    }
    .form-group .checkbox-label.tick-style input[type="checkbox"]:checked {
        background-color: var(--accent-color);
        border-color: var(--accent-color);
    }
    .form-group .checkbox-label.tick-style input[type="checkbox"]:checked::after {
        content: '‚úì';
        color: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 12px;
        font-weight: bold;
    }
        .form-group.aligned-right input[type="checkbox"]:checked::after { content: '‚úì'; color: white; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 14px; }
        .form-group.aligned-right input[type="number"] { width: 60px; text-align: right; }
        #cs-context-memory, #gcs-context-memory { width: 80px !important; }
        .chat-settings-actions { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        .chat-settings-actions .button-group { display: flex; gap: 10px; }
        .chat-settings-actions .button-group button { flex: 1; }
        .library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .library-item { aspect-ratio: 1 / 1; border-radius: 8px; cursor: pointer; position: relative; border: 2px solid transparent; flex-shrink: 0; overflow: hidden; /* BUG FIX: Add overflow hidden for masking */ }
        .library-item.circular { border-radius: 50%; }
        .library-item img { width: 100%; height: 100%; object-fit: cover; }
        .library-item.no-frame { border: 2px dashed #ccc; display: flex; justify-content: center; align-items: center; font-size: 24px; color: #ccc; }
        .library-item.selected { border-color: var(--accent-color); }
        .library-item::after { content: '‚úì'; position: absolute; top: 2px; right: 2px; width: 16px; height: 16px; background-color: var(--accent-color); color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 10px; transform: scale(0); transition: transform 0.2s; }
        .library-modal.selection-mode .library-item.selected::after { transform: scale(1); }
        #avatar-frame-preview-area { width: 100%; height: 120px; display: flex; justify-content: center; align-items: center; margin-bottom: 15px; }
        #avatar-frame-preview { width: 80px; height: 80px; background-color: #eee; background-size: cover; background-position: center; border-radius: 50%; position: relative; flex-shrink: 0; }
        #avatar-frame-preview .avatar-frame { position: absolute; top: 50%; left: 50%; transform: translate(-50%, calc(-50% - 6px)); width: calc(100% * 250 / 268 + 10px); height: calc(100% + 10px); background-size: contain; background-repeat: no-repeat; background-position: center; }
        /* Group Red Packet Modal */
        #group-red-packet-member-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 10px; max-height: 150px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; }
        .group-member-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; border: 2px solid transparent; border-radius: 8px; padding: 5px; }
        .group-member-item.selected { border-color: var(--accent-color); }
        .group-member-item .avatar { width: 40px; height: 40px; border-radius: 50%; background-size: cover; flex-shrink: 0; }
        .group-member-item .name { font-size: 12px; text-align: center; }
        /* Group Chat Settings */
        #gcs-member-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 15px; }
        .gcs-member-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; }
        .gcs-member-item .avatar { width: 50px; height: 50px; border-radius: 50%; background-size: cover; background-position: center; position: relative; flex-shrink: 0; }
        .gcs-member-item .avatar .role-badge { position: absolute; bottom: 0; right: 0; width: 16px; height: 16px; border-radius: 50%; color: white; font-size: 10px; display: flex; justify-content: center; align-items: center; font-weight: bold; }
        .role-badge.owner { background-color: var(--owner-title-bg); }
        .role-badge.admin { background-color: var(--admin-title-bg); }
        .gcs-member-item .name { font-size: 12px; text-align: center; }
        .gcs-action-btn { width: 50px; height: 50px; border-radius: 50%; border: 2px dashed var(--border-color); background: none; font-size: 24px; color: var(--border-color); cursor: pointer; }
        #gcs-member-action-body { display: flex; flex-direction: column; gap: 10px; }
        #gcs-manage-members-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; max-height: 250px; overflow-y: auto; }
        .gcs-manage-member-item { position: relative; }
        .gcs-manage-member-item input[type="checkbox"] { display: none; }
        .gcs-manage-member-item label { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; border: 2px solid transparent; border-radius: 8px; padding: 5px; }
        .gcs-manage-member-item input[type="checkbox"]:checked + label { border-color: var(--accent-color); background-color: rgba(0, 122, 255, 0.1); }
        .gcs-manage-member-item .avatar { width: 40px; height: 40px; border-radius: 50%; background-size: cover; background-position: center; flex-shrink: 0; }
        .gcs-manage-member-item .name { font-size: 12px; text-align: center; }

        /* --- World Book Group Selector --- */
        .wb-group-selector { position: relative; }
        .wb-group-selector-btn { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 5px; font-size: 15px; text-align: left; background-color: white; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .wb-group-selector-btn::after { content: '‚ñº'; font-size: 12px; }
        .wb-group-dropdown { display: none; position: absolute; top: 100%; left: 0; right: 0; background-color: white; border: 1px solid var(--border-color); border-radius: 5px; max-height: 150px; overflow-y: auto; z-index: 10; }
        .wb-group-dropdown.visible { display: block; }
        .wb-group-dropdown .checkbox-label { width: 100%; border: none; border-radius: 0; border-bottom: 1px solid #eee; padding: 8px 12px; box-sizing: border-box; }
        .wb-group-dropdown .checkbox-label:last-child { border-bottom: none; }

        /* --- Âä®ÊÄÅ (Moments) ÁïåÈù¢ --- */
        #moments-tab-content, #char-moments-screen .app-content { position: relative; } /* For FAB positioning */
        #moments-tab-content { padding: 0; background-color: #f0f2f5; }
        #moments-tab-content > .app-content { height: 100%; box-sizing: border-box; }
        .moments-scroll-container { height: 100%; overflow-y: auto; padding-bottom: 20px; /* Â¢ûÂä†Â∫ïÈÉ®ÂÜÖËæπË∑ù‰ª•ÈÅøÂÖçFABÈÅÆÊå° */ box-sizing: border-box; position: relative; }
        .moments-cover { width: 100%; height: auto; aspect-ratio: 16 / 9; min-height: 200px; background-color: #ccc; background-size: cover; background-position: center; cursor: pointer; position: relative; }
        .moments-profile-header { display: flex; justify-content: flex-end; position: relative; padding: 0 15px; bottom: 40px; margin-bottom: -40px; }
        .moments-profile-info { display: flex; align-items: flex-end; }
        .moments-profile-text { margin-right: 15px; text-align: right; }
        .moments-profile-name { font-size: 20px; font-weight: bold; color: #fff; text-shadow: 1px 1px 3px rgba(0,0,0,0.7); cursor: pointer; }
        .moments-profile-signature { font-size: 13px; color: #f0f0f0; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); margin-top: 5px; cursor: pointer; word-break: break-all; }
        .moments-profile-avatar { width: 80px; height: 80px; border-radius: 12px; border: 3px solid white; background-color: #eee; background-size: cover; background-position: center; cursor: pointer; flex-shrink: 0; }
        .moments-filter-tabs { display: flex; justify-content: space-around; padding: 10px 0; background-color: var(--item-bg); border-top: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color); margin-top: 15px; }
        .moments-filter-tab { color: var(--secondary-text-color); cursor: pointer; font-size: 15px; padding: 5px 10px; }
        .moments-filter-tab.active { color: var(--accent-color); font-weight: bold; }
        .moments-feed { padding: 15px; display: flex; flex-direction: column; gap: 20px; }
        /* .moments-post-item is now in the generic swipeable list styles */
        .post-item-content { padding: 15px; }
        .post-header { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; padding-bottom: 0; }
        .post-avatar { width: 44px; height: 44px; border-radius: 50%; background-color: #ccc; background-size: cover; background-position: center; cursor: pointer; }
        .post-author-info { flex-grow: 1; }
        .post-author-name { font-weight: 500; font-size: 16px; cursor: pointer; }
        .post-timestamp { font-size: 12px; color: var(--secondary-text-color); }
        .post-content-text { font-size: 15px; line-height: 1.6; word-break: break-word; padding-top:0; padding-bottom: 10px; }
        .post-image-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; margin-bottom: 10px; padding-top:0; padding-bottom: 10px;}
        .post-image-item { width: 100%; aspect-ratio: 1 / 1; background-size: cover; background-position: center; border-radius: 6px; position: relative; cursor: pointer; }
        .post-image-item .camera-text-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: white; color: black; display: flex; justify-content: center; align-items: flex-start; text-align: center; padding: 10px; box-sizing: border-box; border-radius: 6px; opacity: 0; visibility: hidden; transition: opacity 0.2s; }
        .post-image-item.show-text .camera-text-overlay { opacity: 1; visibility: visible; }
        .post-log-summary { font-size: 15px; line-height: 1.6; background-color: #f9f9f9; padding: 10px; border-radius: 6px; cursor: pointer; }
        .post-visibility-info { font-size: 12px; color: var(--secondary-text-color); padding-top: 5px; padding-bottom: 0; }
        .post-footer { border-top: 1px solid #f0f0f0; padding-top: 10px; margin-top: 0; }
        .post-likes-summary { font-size: 14px; color: var(--secondary-text-color); padding: 8px 0; border-top: 1px solid #f0f0f0; display: flex; align-items: center; gap: 6px; }
        .post-likes-summary .icon { color: var(--like-color); }
        .moments-fab-container { position: absolute; right: 20px; bottom: calc(env(safe-area-inset-bottom, 0px) + 10px); /* Ë∞ÉÊï¥È´òÂ∫¶‰ª•ÊÇ¨ÊµÆÂú®Ê†áÁ≠æÊ†è‰∏äÊñπ */ z-index: 15; }        .moments-fab { width: 56px; height: 56px; border-radius: 50%; background-color: var(--accent-color); color: white; font-size: 28px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); cursor: pointer; transition: transform 0.2s; display: flex; justify-content: center; align-items: center; }
        #moments-tab-content .moments-fab-container { bottom: calc(env(safe-area-inset-bottom, 0px) + 60px); }
        #moments-fab:active { transform: scale(0.95); }
        #moments-fab-options { position: absolute; bottom: 65px; right: 0; display: none; flex-direction: column; gap: 10px; align-items: flex-end; }
        .fab-option { background-color: white; padding: 8px 16px; border-radius: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; font-size: 14px; white-space: nowrap; }
        #mail-app-screen .moments-fab-container { bottom: calc(env(safe-area-inset-bottom, 0px) + 60px); }
        #moments-notification-btn { position: relative; }
        #moments-notification-badge { position: absolute; top: -2px; left: -2px; width: 18px; height: 18px; background-color: var(--danger-color); color: white; border-radius: 50%; font-size: 11px; font-weight: bold; display: none; justify-content: center; align-items: center; border: 2px solid var(--item-bg); }
        #moments-notification-badge.visible, .moments-notification-badge-clone.visible { display: flex; }
        .moments-notification-badge-clone { position: absolute; top: -2px; left: -2px; width: 18px; height: 18px; background-color: var(--danger-color); color: white; border-radius: 50%; font-size: 11px; font-weight: bold; display: none; justify-content: center; align-items: center; border: 2px solid var(--item-bg); }
        /* --- Âä®ÊÄÅÂèëÂ∏ÉÂºπÁ™ó --- */
        #post-moment-modal .modal-content { max-width: 400px; }
        #post-moment-modal-body .form-group { margin-bottom: 15px; }
        #post-moment-modal-body label { font-weight: 500; }
        .friend-selector-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; max-height: 120px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; }
        .friend-selector-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; border: 2px solid transparent; border-radius: 8px; padding: 5px; }
        .friend-selector-item.selected { border-color: var(--accent-color); }
        .friend-selector-item .avatar { width: 40px; height: 40px; border-radius: 50%; background-size: cover; background-position: center; flex-shrink: 0; }
    .friend-selector-item .name { font-size: 12px; text-align: center; }
    #moment-comment-author-selector, #moment-post-author-selector, #leave-message-author-selector { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; max-height: 120px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; }
    .author-selector-item { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; border: 2px solid transparent; border-radius: 8px; padding: 5px; }
        .author-selector-item.selected { border-color: var(--accent-color); }
        .author-selector-item .avatar { width: 40px; height: 40px; border-radius: 50%; background-size: cover; background-position: center; flex-shrink: 0; }
        .author-selector-item .name { font-size: 12px; text-align: center; }
        /* --- Âä®ÊÄÅÈÄöÁü•ÂºπÁ™ó --- */
        #moments-notification-modal .modal-body { max-height: 70vh; }
        #moments-notification-list { list-style: none; padding: 0; margin: 0; }
        .notification-item-container {
            position: relative;
            z-index: 2;
            background-color: var(--item-bg);
            transition: transform 0.3s ease;
            cursor: pointer;
        }
        .notification-item-container:hover { background-color: var(--item-active-bg); }
        .notification-item-content { display: flex; align-items: center; gap: 15px; padding: 12px 15px; padding-bottom: 0; }
        .notification-avatar { width: 44px; height: 44px; border-radius: 50%; background-color: #e0e0e0; background-size: cover; background-position: center; flex-shrink: 0; }
        .notification-info { overflow: hidden; font-size: 15px; line-height: 1.5; }
        .notification-actor-name { font-weight: 500; color: var(--accent-color); }
        .notification-content-summary { color: var(--secondary-text-color); margin-left: 5px; }
        .notification-timestamp { font-size: 12px; color: var(--secondary-text-color); margin-top: 4px; padding-left: 59px; padding-bottom: 8px; }
        .notification-item.unread .notification-item-container { background-color: #f0f8ff; }
        /* --- ÊèêÁ§∫Ê∂àÊÅØ --- */
        #toast { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px; border-radius: 20px; font-size: 14px; z-index: 200; opacity: 0; transition: opacity 0.3s, bottom 0.3s; pointer-events: none; }
        #toast.show { opacity: 1; bottom: 100px; }
        /* --- Áõ∏ÂÜå‰∏éÁÖßÁâáÁÆ°ÁêÜ --- */
        #view-album-screen .app-content { padding: 10px; }
        .album-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .album-item { width: 100%; aspect-ratio: 1 / 1; position: relative; cursor: pointer; border-radius: 8px; overflow: hidden; }
        .album-item-cover { width: 100%; height: 100%; background-size: cover; background-position: center; background-color: #eee; }
        .album-item-overlay { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.8), transparent); padding: 8px; color: white; display: flex; flex-direction: column; justify-content: flex-end; gap: 4px; }
        .album-item-name { font-weight: bold; font-size: 14px; }
        .album-item-info { font-size: 11px; opacity: 0.9; }
        .album-item-footer {display: flex;justify-content: space-between;align-items: center;}
        .album-item-actions { text-align: right; }
        .album-item-actions .icon-btn { background-color: rgba(0,0,0,0.5); border-radius: 50%; width: 24px; height: 24px; color: white; border: none; cursor: pointer; }
        .album-item.selected-for-deletion { border: 3px solid var(--danger-color); }
        .photo-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .photo-grid-item { width: 100%; aspect-ratio: 1 / 1; background-size: cover; background-position: center; border-radius: 6px; position: relative; cursor: pointer; }
        .photo-grid-item.selected-for-deletion { outline: 3px solid var(--danger-color); }
        #manage-albums-modal .modal-actions.multi-button { flex-direction: row; }
        #manage-albums-modal .modal-actions.multi-button button { flex: 1; }

        /* --- ÁïôË®ÄÊùø --- */
        .message-board-avatar { width: 32px; height: 32px; border-radius: 50%; background-color: #eee; background-size: cover; background-position: center; flex-shrink: 0; }
        .message-board-signature { display: flex; align-items: center; justify-content: flex-end; gap: 8px; }
        .message-board-feed { padding: 15px; display: flex; flex-direction: column; gap: 15px; }
        .message-board-item { background-color: transparent; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border-bottom: none; }
        .message-board-item-main { padding: 15px; border-radius: 8px; }
        .message-board-header { display: flex; align-items: center; gap: 10px; }
        .message-board-recipient { font-weight: bold; font-size: 16px; margin: 0; }
        .message-board-content { font-size: 15px; line-height: 1.6; margin: 15px 0; text-align: center; }
        .message-board-footer { text-align: right; }
        .message-board-sender { font-style: italic; }
        .message-board-timestamp { font-size: 12px; color: var(--secondary-text-color); margin-top: 5px; }
        .message-board-replies { margin-left: 42px; margin-top: 10px; border-left: 2px solid #eee; padding-left: 10px; }

        /* --- ÁÖßÁâá‰∏ä‰º†ÂºπÁ™ó --- */
        #upload-photo-image-preview-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 5px; max-height: 120px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; margin-top: 10px; }
        .upload-preview-item { width: 60px; height: 60px; background-size: cover; background-position: center; border-radius: 4px; }
        .post-photo-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-top: 10px; }
        .post-photo-item { width: 100%; aspect-ratio: 1 / 1; background-size: cover; background-position: center; border-radius: 6px; }
        /* --- Photo Viewer Modal (New Style) --- */
        .viewer-nav-btn { position: absolute; top: 50%; transform: translateY(-50%); background-color: rgba(0,0,0,0.3); color: white; border: none; border-radius: 50%; width: 44px; height: 44px; font-size: 24px; cursor: pointer; z-index: 15; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        .viewer-nav-btn.prev-btn { left: 15px; }
        .viewer-nav-btn.next-btn { right: 15px; }
        #photo-viewer-container { width: 100%; height: 100%; position: relative; display: flex; }
        #viewer-image-view, #viewer-text-view { display: none; width: 100%; height: 100%; }
        #view-photo-modal.image-mode #viewer-image-view, #view-photo-modal.text-mode #viewer-text-view { display: flex; }
        
        #viewer-text-view { display: flex; flex-direction: column; align-items: center; background-color: white; padding: 22px 20px 20px; box-sizing: border-box; width: 75vw; height: 75vh; max-width: 400px; max-height: 400px; margin: auto; border-radius: 12px; position: relative; }
        #view-photo-text-display { height: 100%; width: 100%; overflow-y: auto; font-size: 16px; line-height: 1.8; color: black; text-align: center; box-sizing: border-box; }
        #view-photo-modal { background-color: rgba(0,0,0,0.85); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        .photo-viewer-content { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0; box-sizing: border-box; cursor: pointer; }
        .photo-viewer-close-btn { position: absolute; top: calc(env(safe-area-inset-top, 0px) + 15px); right: 15px; font-size: 30px; color: white; background: none; border: none; cursor: pointer; z-index: 10; width: 40px; height: 40px; text-shadow: 0 0 5px black; }
        .photo-viewer-name { position: absolute; top: 0; left: 0; right: 0; z-index: 5; font-size: 18px; font-weight: bold; color: white; text-align: center; text-shadow: 1px 1px 3px black; transition: opacity 0.3s; padding: 10px 15px; background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent); cursor: text; }
        #view-photo-image { max-width: 100%; max-height: 100%; object-fit: contain; }
        .photo-viewer-desc { position: absolute; bottom: 0; left: 0; right: 0; font-size: 14px; color: white; text-align: center; max-height: 25%; overflow-y: auto; text-shadow: 1px 1px 3px black; transition: opacity 0.3s; padding: 10px 15px; background: linear-gradient(to top, rgba(0,0,0,0.7), transparent); cursor: text; }
        .photo-viewer-image-container { position: relative; max-width: 100%; max-height: 100%; display: flex; align-items: center; justify-content: center; }
        #view-photo-modal.text-hidden .photo-viewer-name, #view-photo-modal.text-hidden .photo-viewer-desc, #view-photo-modal.text-hidden .photo-viewer-close-btn, #view-photo-modal.text-hidden .viewer-nav-btn { opacity: 0; pointer-events: none; }
            /* --- Simple Image Viewer --- */
            #simple-viewer-modal { background-color: rgba(0,0,0,0.8); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); z-index: 130; cursor: pointer; }
            .simple-viewer-content { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box; }
            #simple-viewer-image { max-width: 100%; max-height: 100%; object-fit: contain; display: none; }
            #simple-viewer-text { background-color: white; color: black; padding: 30px; padding-top: 32px; border-radius: 8px; overflow-y: auto; font-size: 16px; line-height: 1.8; text-align: center; display: none; justify-content: center; align-items: flex-start; cursor: default; width: 75vw; height: 75vh; max-width: 400px; max-height: 400px; box-sizing: border-box; }
            /* --- ËßÜÈ¢ëÈÄöËØùÂºπÁ™ó --- */
        #video-call-modal { display: none; transition: opacity 0.3s, transform 0.3s; }
        #video-call-modal.visible { display: flex; }
        #video-call-modal.minimized { opacity: 0; transform: scale(0.5); pointer-events: none; }
        #video-call-main-view { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center; z-index: 1; transition: opacity 0.3s ease-in-out; }
        #video-call-pip-view { position: absolute; top: calc(env(safe-area-inset-top, 15px) + 15px); right: 15px; width: calc(100% / 6); height: auto; aspect-ratio: 9 / 16; background-size: cover; background-position: center; border-radius: 12px; border: 2px solid rgba(255, 255, 255, 0.7); box-shadow: 0 4px 10px rgba(0,0,0,0.5); z-index: 3; transition: all 0.3s ease-in-out; }
        .video-call-content { position: relative; z-index: 2; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; padding: calc(env(safe-area-inset-top, 20px)) 15px calc(env(safe-area-inset-bottom, 20px)) 15px; box-sizing: border-box; background: linear-gradient(to bottom, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0) 30%, rgba(0,0,0,0) 70%, rgba(0,0,0,0.6) 100%); }
    .video-call-header { position: relative; display: flex; justify-content: center; align-items: flex-start; min-height: 120px; flex-shrink: 0; flex-wrap: wrap; }
        .video-call-avatar-img { width: 80px; height: 80px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.8); object-fit: cover; } /* BUG FIX: Added object-fit */
        .video-call-char-info { display: flex; flex-direction: column; align-items: center; text-align: center; } /* Âçï‰∫∫ÈÄöËØùÊó∂‰ΩøÁî® */
        #video-call-participants-container { display: flex; justify-content: center; align-items: flex-start; gap: 15px; flex-wrap: wrap; width: 100%; padding: 0 40px; box-sizing: border-box; } /* Áæ§ËÅäÂÆπÂô® */
        .video-participant-info { display: flex; flex-direction: column; align-items: center; max-width: 80px; } /* Áæ§ËÅäÂçï‰∫∫‰ø°ÊÅØ */
        #video-call-minimize-btn { position: absolute; top: 0; left: 0; background-color: rgba(0, 0, 0, 0.4); border: none; color: white; width: 36px; height: 36px; border-radius: 50%; font-size: 24px; line-height: 36px; text-align: center; text-shadow: 1px 1px 3px black; cursor: pointer; z-index: 5; transition: background-color 0.2s; }
        #video-call-minimize-btn:active { background-color: rgba(0, 0, 0, 0.7); }
        .video-call-avatar-img { width: 80px; height: 80px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.8); } /* Âçï‰∫∫ÈÄöËØùÂ§¥ÂÉè */
        .video-participant-info .video-call-avatar-img { width: 50px; height: 50px; } /* Áæ§ËÅäÂ§¥ÂÉè */
        .video-call-name-text { margin-top: 10px; font-size: 20px; font-weight: bold; color: white; text-shadow: 1px 1px 3px black; } /* Âçï‰∫∫ÈÄöËØùÂêçÂ≠ó */
        .video-participant-info .video-call-name-text { font-size: 12px; margin-top: 5px; font-weight: normal; } /* Áæ§ËÅäÂêçÂ≠ó */
    .video-call-message-box { flex-grow: 1; overflow-y: auto; background-color: rgba(0, 0, 0, 0.4); border-radius: 12px; margin: 15px 0; padding: 15px; color: white; line-height: 1.6; font-size: 16px; scrollbar-width: none; margin-top: calc((100vw / 6 * 16 / 9) - 90px); }
    .video-call-message-box::-webkit-scrollbar { display: none; }
    .video-chat-msg-user { color: #a7d7ff; font-weight: bold; margin-bottom: 5px; }
    .video-chat-msg-char { margin-bottom: 15px; white-space: pre-wrap; }
    .video-call-footer { display: flex; flex-direction: column; align-items: center; gap: 25px; }
    .video-call-controls { display: flex; justify-content: center; align-items: center; width: 100%; gap: 40px; }
    .video-call-button-placeholder { display: flex; flex-direction: column; align-items: center; gap: 8px; color: white; font-size: 12px; }
    .video-call-icon-btn { background-color: rgba(80, 80, 80, 0.7); border: 1px solid rgba(255, 255, 255, 0.1); width: 64px; height: 64px; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: transform 0.2s, background-color 0.2s; }
    .video-call-icon-btn:active { transform: scale(0.95); background-color: rgba(100, 100, 100, 0.8); }
    .video-call-icon-btn img { width: 32px; height: 32px; }
    .video-call-icon-btn.hangup { background-color: var(--danger-color); }
    .video-call-icon-btn.hangup:active { background-color: #d13026; }
    .video-call-input-area { width: 100%; display: flex; justify-content: center; margin-bottom: 5px; }
    .video-call-speak-btn { background-color: var(--accent-color); color: white; border: none; border-radius: 25px; padding: 12px 30px; font-size: 16px; font-weight: 500; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: transform 0.2s, background-color 0.2s; position: relative; top: -5px; }
    .video-call-speak-btn:active { transform: scale(0.98); background-color: #0062cc; }
    #video-call-input-wrapper { display: flex; width: 100%; max-width: 400px; gap: 8px; }
    #video-call-input { flex-grow: 1; border: 1px solid rgba(255,255,255,0.2); background-color: rgba(0,0,0,0.3); color: white; border-radius: 20px; padding: 10px 15px; font-size: 16px; }
    #video-call-send-btn { background-color: var(--accent-color); color: white; border: none; border-radius: 20px; padding: 0 20px; font-size: 16px; cursor: pointer; }
    #video-call-refresh-btn {
    background: none;
    border: none;
    color: white;
    font-size: 20px;
    cursor: pointer;
    padding: 0 10px;
    opacity: 0.8;
}
#video-call-refresh-btn:active {
    opacity: 1;
}
    #video-call-float-btn { position: fixed; right: 15px; bottom: 100px; width: 60px; height: 60px; background-color: var(--accent-color); border-radius: 50%; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 199; cursor: pointer; display: flex; justify-content: center; align-items: center; background-size: cover; background-position: center; border: 2px solid white; transform: scale(0); opacity: 0; transition: opacity 0.3s, transform 0.3s; }
    #video-call-float-btn.visible { transform: scale(1); opacity: 1; }
    #video-call-float-btn img { width: 32px; height: 32px; }
    #video-call-float-btn { display: none; position: absolute; z-index: 201; bottom: 100px; right: 20px; width: 60px; height: 60px; background-color: var(--accent-color); border-radius: 50%; box-shadow: 0 4px 12px rgba(0,0,0,0.3); cursor: pointer; background-size: cover; background-position: center; border: 2px solid white; transition: transform 0.2s; }
    #video-call-float-btn.visible { display: block; }
    #video-call-float-btn:active { transform: scale(0.9); }
    /* --- ‰ø°ÁÆ± APP --- */
/* --- ‰ø°ÁÆ± APP (‰ºòÂåñÂêé) --- */
#love-letter-tab-content.active { padding: 0; display: flex; flex-direction: column; height: 100%; }
.love-letter-list { list-style: none; padding: 0; margin: 0; flex-shrink: 0; } /* Unread list doesn't scroll */
.love-letter-item { padding: 12px 15px; border-bottom: 1px solid var(--border-color); cursor: pointer; background-color: var(--item-bg); }
.love-letter-item.unread { background-color: #eaf3ff; }
.love-letter-item:hover { background-color: var(--item-active-bg); }
.love-letter-main { display: flex; align-items: center; }
.love-letter-avatar { width: 44px; height: 44px; border-radius: 50%; background-color: #eee; background-size: cover; background-position: center; flex-shrink: 0; margin-right: 12px; }
.love-letter-info { flex-grow: 1; overflow: hidden; }
.love-letter-sender { font-size: 16px; font-weight: bold; }
.love-letter-preview { font-size: 13px; color: var(--secondary-text-color); white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
.love-letter-meta { text-align: right; font-size: 12px; color: var(--secondary-text-color); }
.love-letter-actions { display: flex; justify-content: flex-end; align-items: center; gap: 20px; padding-top: 8px; margin-left: 56px; /* Align with avatar */ }
.love-letter-actions .icon-btn { background: none; border: none; font-size: 16px; color: var(--secondary-text-color); cursor: pointer; }
.love-letter-actions .icon-btn:hover { color: var(--accent-color); }
.love-letter-actions .delete-btn:hover { color: var(--danger-color); }

.love-letter-collection-container { flex-grow: 1; overflow-y: auto; padding: 15px; border-top: 1px solid var(--border-color); } /* Makes this area scrollable */

.love-letter-collection-container { padding: 15px; border-top: 1px solid var(--border-color); }
.love-letter-collection-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; }
.collected-letter-item { display: flex; flex-direction: column; align-items: center; text-align: center; cursor: pointer; }
.collected-letter-item .title { font-size: 11px; font-weight: bold; width: 100%; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; margin-bottom: 5px; }
.collected-letter-item .icon { font-size: 48px; color: #a38c6d; margin-bottom: 5px; }
.collected-letter-item .sender { font-size: 10px; color: var(--secondary-text-color); }
.collected-letter-item .date { font-size: 9px; color: #ccc; }
/* --- ÊãÜ‰ø°Âä®Áîª --- */
#unread-letter-prompt { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.3); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); z-index: 210; display: flex; justify-content: center; align-items: center; cursor: pointer; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
#unread-letter-prompt.visible { opacity: 1; visibility: visible; }
#unread-letter-prompt .envelope-icon { font-size: 80px; color: white; transition: transform 0.4s ease-in-out; }

/* --- ‰ø°Á∫∏ÈòÖËØªÂô® --- */
:root {
    --love-letter-texture: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
    --love-letter-gradient: linear-gradient(to bottom right, #f4f0e8, #fdfbf7);
}
#love-letter-viewer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 220; display: flex; flex-direction: column;
    padding: calc(env(safe-area-inset-top, 10px) + 20px) 25px calc(env(safe-area-inset-bottom, 10px) + 20px);
    box-sizing: border-box;
    font-family: 'KaiTi', 'STKaiti', serif; color: #333;
    transform: scale(0.1) rotate(-15deg); border-radius: 50%; opacity: 0; visibility: hidden;
    transition: all 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    background: var(--love-letter-texture), var(--love-letter-gradient);
}
#love-letter-viewer.visible { transform: scale(1) rotate(0deg); border-radius: 0; opacity: 1; visibility: visible; }
.letter-content-wrapper { flex-grow: 1; overflow-y: auto; line-height: 2; font-size: 17px; }
.letter-salutation { margin-bottom: 2em; }
.letter-body { white-space: pre-wrap; }
.letter-signature { text-align: right; margin-top: 3em; position: relative; padding-right: 80px; }
.letter-sender-name { display: block; }
.letter-timestamp { display: block; font-size: 14px; color: #888; margin-top: 0.5em; }
.letter-stamp {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 70px;
    height: 70px;
    background-color: rgba(255,255,255,0.5);
    border: 3px dashed #bba0a0;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.letter-close-btn { position: absolute; top: calc(env(safe-area-inset-top, 10px) + 5px); right: 5px; width: 40px; height: 40px; background: none; border: none; font-size: 32px; color: #aaa; cursor: pointer; z-index: 10; text-shadow: 0 0 3px white; }
/* --- ‰ø°ÁÆ± APP ‰ºòÂåñÊ†∑Âºè --- */
        #love-letter-tab-content.active { display: flex; flex-direction: column; height: 100%; }
        #unread-letters-container { flex-shrink: 0; }
        #read-letters-container { flex-grow: 1; overflow-y: auto; }
        .love-letter-meta { display: flex; align-items: center; justify-content: space-between; flex-grow: 1; }
        .love-letter-actions { display: flex; gap: 15px; }
        .love-letter-actions .icon-btn { background: none; border: none; font-size: 16px; color: var(--secondary-text-color); cursor: pointer; padding: 5px; }
        .letter-reply-btn { position: absolute; bottom: calc(env(safe-area-inset-bottom, 15px) + 15px); left: 50%; transform: translateX(-50%); width: 56px; height: 56px; background-color: #a38c6d; color: white; border-radius: 50%; border: none; font-size: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); cursor: pointer; transition: transform 0.2s; z-index: 15; }
        .letter-reply-btn:active { transform: translateX(-50%) scale(0.95); }
        .author-selector-grid { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 10px; }
        .author-selector-grid::-webkit-scrollbar { height: 4px; }
        .author-selector-grid::-webkit-scrollbar-thumb { background: #ccc; border-radius: 2px; }
        .author-selector-grid .author-selector-item { flex-shrink: 0; }
/* --- ËßÜÈ¢ëÈÄöËØùÂºπÁ™óÔºöÊñ∞Â¢ûÊ†∑Âºè --- */
        #video-call-modal.minimized {
            display: none !important; /* ÊúÄÂ∞èÂåñÊó∂ÈöêËóèÂºπÁ™ó */
        }
        #user-video-view {
            position: absolute;
            top: calc(env(safe-area-inset-top, 20px) + 15px);
            right: 15px;
            width: 25%;
            max-width: 120px;
            aspect-ratio: 9 / 16;
            background-size: cover;
            background-position: center;
            background-color: #333;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            z-index: 3;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        #video-call-minimize-btn {
            position: absolute;
            top: calc(env(safe-area-inset-top, 20px) + 15px);
            left: 15px;
            width: 30px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.4);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            line-height: 30px;
            text-align: center;
            cursor: pointer;
            z-index: 5;
        }
        #floating-video-btn {
            display: none; /* ÈªòËÆ§ÈöêËóè */
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 80px);
            right: 20px;
            width: 60px;
            height: 60px;
            background-color: var(--accent-color);
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            cursor: pointer;
            z-index: 99;
            background-size: cover;
            background-position: center;
        }
        #floating-video-btn.visible {
            display: block;
        }
        /* --- ÂìçÂ∫îÂºèË∞ÉÊï¥ÔºöÈÄÇÈÖçÁßªÂä®Á´ØÁöÑÂ∞èÂ±èÂπï --- */
        @media (max-width: 600px) {
            #viewer-text-view, #simple-viewer-text {
                width: 90vw; /* Âú®Â∞èÂ±èÂπï‰∏äÔºåËÆ©ÊñáÂ≠óÂõæÊõ¥ÂÆΩ‰∏Ä‰∫õ */
            }
        }
    </style>
    <script src="https://kit.fontawesome.com/492a2d863d.js" crossorigin="anonymous"></script>
</head>
<body>
    <audio id="audio-player"></audio>

    <!-- ÊâãÊú∫Â±èÂπï‰∏ªÂÆπÂô® -->
    <div id="phone-screen">
        <div id="top-area">
            <div id="dynamic-island">
                <div class="island-content island-music-info"></div>
                <div class="island-content island-waveform"><span></span><span></span><span></span></div>
                <div class="island-content island-video-call-icon"></div>
                <div class="island-content island-video-call-timer"></div>
            </div>
            <div id="status-bar">
                <div id="time">12:00</div>
                <div id="battery-status"><span id="battery-level">100%</span><span id="battery-icon" data-icon-id="status-battery-default"><i class="fa-solid fa-battery-full"></i></span></div>
            </div>
        </div>
        <div id="notification-container"></div>
        <!-- Êñ∞Â¢ûÔºöÊù•ÁîµÈÄöÁü•Ê®™ÂπÖ -->
            <div id="incoming-call-banner" style="display: none; position: absolute; top: calc(env(safe-area-inset-top, 10px) + 60px); left: 50%; transform: translateX(-50%); width: 90%; max-width: 380px; background-color: rgba(60, 60, 60, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 250; color: white;">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div id="incoming-call-avatar" style="width: 60px; height: 60px; border-radius: 50%; background-size: cover; background-position: center; flex-shrink: 0;"></div>
                    <div style="flex-grow: 1;">
                        <div id="incoming-call-name" style="font-weight: bold; font-size: 18px;"></div>
                        <div style="font-size: 14px; margin-top: 4px;">ÈÇÄËØ∑‰Ω†ËøõË°åËßÜÈ¢ëÈÄöËØù</div>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-around; gap: 20px; margin-top: 15px;">
                    <button id="incoming-call-reject-btn" style="flex: 1; padding: 10px; border-radius: 25px; border: none; background-color: #ff3b30; color: white; font-size: 16px; cursor: pointer;"><i class="fa-solid fa-phone-slash"></i></button>
                    <button id="incoming-call-accept-btn" style="flex: 1; padding: 10px; border-radius: 25px; border: none; background-color: #34c759; color: white; font-size: 16px; cursor: pointer;"><i class="fa-solid fa-phone"></i></button>
                </div>
            </div>
        <!-- ‰∏ªÂ±èÂπïAPPÂõæÊ†á -->
        <div id="main-content">
            <div id="app-grid">
                <div class="app-icon" id="chat-app-btn"><div class="icon" data-icon-id="app-chat"><i class="fa-solid fa-comment-dots"></i></div><span class="label">ËÅäÂ§©</span></div>
                <div class="app-icon" id="music-app-btn"><div class="icon" data-icon-id="app-music"><i class="fa-solid fa-music"></i></div><span class="label">Èü≥‰πê</span></div>
                <div class="app-icon"><div class="icon" data-icon-id="app-shop"><i class="fa-solid fa-shop"></i></div><span class="label">Ë¥≠Áâ©</span></div>
                <div class="app-icon" id="diary-app-btn"><div class="icon" data-icon-id="app-diary"><i class="fa-solid fa-book-bookmark"></i></div><span class="label">ÊâãË¥¶</span></div>
                <div class="app-icon" id="mail-app-btn"><div class="icon" data-icon-id="app-mail"><i class="fa-solid fa-envelope"></i></div><span class="label">‰ø°ÁÆ±</span></div>
                <div class="app-icon"><div class="icon" data-icon-id="app-ranking"><i class="fa-solid fa-chart-simple"></i></div><span class="label">Ê¶úÂçï</span></div>
                <div class="app-icon"><div class="icon" data-icon-id="app-pet"><i class="fa-solid fa-paw"></i></div><span class="label">Ê°åÂÆ†</span></div>
                <div class="app-icon"><div class="icon" data-icon-id="app-game"><i class="fa-solid fa-gamepad"></i></div><span class="label">Ê∏∏Êàè</span></div>
                <div class="app-icon"><div class="icon" data-icon-id="app-forum"><i class="fa-solid fa-blog"></i></div><span class="label">ËÆ∫Âùõ</span></div>
            </div>
        </div>

        <!-- Â∫ïÈÉ®DockÊ†è -->
        <div id="dock">
            <div class="app-icon" id="settings-app-btn"><div class="icon" data-icon-id="dock-settings"><i class="fa-solid fa-wrench"></i></div></div>
            <div class="app-icon" id="beautify-app-btn"><div class="icon" data-icon-id="dock-beautify"><i class="fa-solid fa-icons"></i></div></div>
            <div class="app-icon" id="data-app-btn"><div class="icon" data-icon-id="dock-data"><i class="fa-solid fa-folder-open"></i></div></div>
        </div>

        <!-- ËÆæÁΩÆAPPÁïåÈù¢ -->
        <div id="settings-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title">ËÆæÁΩÆ</h2></div>
                <div class="app-header-right"></div>
            </div>
            <div class="app-content">
                <div class="settings-group"><div class="group-title">API ÈÖçÁΩÆ</div><div class="group-content"><div class="settings-item"><label for="api-url">Âèç‰ª£Âú∞ÂùÄ</label><input type="text" id="api-url" placeholder="‰æãÂ¶Ç: https://api.example.com"></div><div class="settings-item"><label for="api-key">API ÂØÜÈí•</label><input type="password" id="api-key" placeholder="ËØ∑ËæìÂÖ•ÊÇ®ÁöÑ API Key"></div></div><button id="confirm-api-btn" class="settings-button" data-bubble-id="settings-load-model">Âä†ËΩΩÊ®°Âûã</button></div>
                <div class="settings-group"><div class="group-title">Ê®°ÂûãÈÄâÊã©</div><div class="group-content"><div class="settings-item"><select id="model-select"><option value="">ËØ∑ÂÖàÂä†ËΩΩÊ®°Âûã</option></select></div></div></div>
                <div class="settings-group"><div class="group-title">API È¢ÑËÆæ</div><div class="group-content"><div class="settings-item"><label for="preset-select">ÈÄâÊã©È¢ÑËÆæ</label><select id="preset-select"><option value="">Êó†</option></select></div></div><div class="button-group"><button id="save-preset-btn" class="settings-button" data-bubble-id="settings-save-preset">‰øùÂ≠òÈ¢ÑËÆæ</button><button id="manage-presets-btn" class="settings-button secondary" data-bubble-id="settings-manage-presets">ÁÆ°ÁêÜÈ¢ÑËÆæ</button></div></div>
                <div class="settings-group"><div class="group-title">Êï∞ÊçÆÁÆ°ÁêÜ</div><div class="button-group" style="flex-direction: column; gap: 10px;">
                    <div style="display: flex; gap: 10px;">
                        <button id="export-config-btn" class="settings-button" data-bubble-id="settings-export-config">ÂØºÂá∫ÈÖçÁΩÆ‰∏éËÆ∞ÂΩï</button>
                        <button id="import-config-btn" class="settings-button secondary" data-bubble-id="settings-import-config">ÂØºÂÖ•ÈÖçÁΩÆ‰∏éËÆ∞ÂΩï</button>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button id="export-media-btn" class="settings-button" data-bubble-id="settings-export-media">ÂØºÂá∫Â™í‰ΩìÂ∫ì</button>
                        <button id="import-media-btn" class="settings-button secondary" data-bubble-id="settings-import-media">ÂØºÂÖ•Â™í‰ΩìÂ∫ì</button>
                    </div>
                    <input type="file" id="import-file-input" style="display: none;">
                </div>
            </div>
            <div class="settings-group">
                <div class="group-title">ÂÖ®Â±ÄÂêéÂè∞ÂÆûÊó∂Ê¥ªÂä®</div>
                <div class="group-content">
                    <div class="settings-item">
                        <div class="form-group aligned-right">
                            <label for="global-realtime-interval">ÂÖ®Â±ÄÊ¥ªÂä®Èó¥Èöî(ÂàÜÈíü)</label>
                            <input type="number" id="global-realtime-interval" value="30" style="width: 80px !important;">
                        </div>
                    </div>
                    <div class="settings-item">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label>ÈÄâÊã©Ë¶ÅÂºÄÂêØÁöÑËßíËâ≤</label>
                            <button id="global-realtime-select-all" class="settings-button secondary" style="width: auto; padding: 5px 10px; font-size: 14px;">ÂÖ®ÈÄâ/ÂÖ®‰∏çÈÄâ</button>
                        </div>
                        <div id="global-realtime-char-selector">
                            <!-- Char items will be injected here -->
                        </div>
                    </div>
                </div>
            </div>
            </div>
        </div>

        <!-- Èü≥‰πêAPPÁïåÈù¢ -->
        <div id="music-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title">Èü≥‰πê</h2></div>
                <div class="app-header-right"><button class="action-btn" id="add-music-btn" data-icon-id="music-add"><i class="fa-solid fa-plus"></i></button></div>
            </div>
            <div class="app-content" style="padding:0;"><ul id="music-list"></ul></div>
        </div>

        <!-- Ê≠åÊõ≤ËØ¶ÊÉÖÈ°µ -->
        <div id="song-details-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="song-details-back-btn">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title">Ê≠åÊõ≤ËØ¶ÊÉÖ</h2></div>
                <div class="app-header-right"></div>
            </div>
            <div class="app-content">
                <div class="details-song-info"><div class="title" id="details-song-title">Ê≠åÊõ≤Âêç</div><div class="artist" id="details-song-artist">Ê≠åÊâã</div></div>
                <div class="details-lyrics-container" id="details-lyrics-view"></div>
                <div class="details-comments-section">
                    <div class="details-comments-list" id="details-comments-list"></div>
                    <div class="comment-input-area"><input type="text" id="comment-input" placeholder="ÂèëË°®‰Ω†ÁöÑËØÑËÆ∫..."> <button id="send-comment-btn" class="settings-button" data-icon-id="comment-send" style="width: 50px; padding: 5px; display: flex; align-items: center; justify-content: center;"><i class="fa-solid fa-paper-plane"></i></button></div>
                </div>
            </div>
        </div>

        <!-- ÁæéÂåñAPPÁïåÈù¢ -->
        <div id="beautify-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title">ÁæéÂåñ</h2></div>
                <div class="app-header-right">
                    <button class="action-btn" id="beautify-action-btn" data-icon-id="beautify-add"><i class="fa-solid fa-plus"></i></button>
                    <button class="action-btn" id="bubble-action-btn" style="display: none;"><i class="fa-solid fa-plus"></i></button>
                </div>
            </div>
            <div class="app-content tab-content-wrapper">
                <div id="wallpaper-tab-content" class="tab-content active">
                    <div id="wallpaper-grid"></div>
                    <input type="file" id="wallpaper-file-input" multiple accept="image/*" style="display:none;">
                </div>
                <div id="font-tab-content" class="tab-content"><ul id="font-list"></ul></div>
                <div id="icon-tab-content" class="tab-content"><div id="icon-grid"></div></div>
                <div id="bubble-tab-content" class="tab-content"><div id="bubble-grid"></div></div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="wallpaper">Â£ÅÁ∫∏</div><div class="tab-link" data-tab="font">Â≠ó‰Ωì</div><div class="tab-link" data-tab="icon">ÂõæÊ†á</div><div class="tab-link" data-tab="bubble">Ê∞îÊ≥°</div>
            </div>
        </div>

        <!-- ËµÑÊñôAPPÁïåÈù¢ -->
        <div id="data-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title">ËµÑÊñô</h2></div>
                <div class="app-header-right">
                <button class="action-btn" id="data-filter-btn" style="display: none;"><i class="fa-solid fa-filter"></i></button>
                <button class="action-btn" id="data-action-btn" data-icon-id="data-add"><i class="fa-solid fa-plus"></i></button>
            </div>
        </div>
        <div id="world-book-filter-dropdown" class="filter-dropdown"></div>
            <div class="app-content tab-content-wrapper">
                <div id="world-book-tab-content" class="tab-content active"><ul id="world-book-list" class="preset-data-list"></ul></div>
                <div id="archive-tab-content" class="tab-content"><ul id="archive-list" class="preset-data-list"></ul></div>
                <div id="info-tab-content" class="tab-content"><ul id="info-list" class="preset-data-list"></ul></div>
                <div id="memory-tab-content" class="tab-content"><p style="text-align:center; color: #888; margin-top: 50px;">ËÆ∞ÂøÜÂäüËÉΩÂæÖÂºÄÂèë...</p></div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="world-book">‰∏ñÁïå‰π¶</div><div class="tab-link" data-tab="archive">Ê°£Ê°à</div><div class="tab-link" data-tab="info">‰ø°ÊÅØ</div><div class="tab-link" data-tab="memory">ËÆ∞ÂøÜ</div>
            </div>
        </div>

        <!-- ËÅäÂ§©APPÁïåÈù¢ -->
        <div id="chat-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="chat-list-back-btn">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title" id="chat-list-title">Ê∂àÊÅØ</h2></div>
                <div class="app-header-right">
                    <button class="action-btn" id="chat-list-action-btn" data-icon-id="chat-add"><i class="fa-solid fa-plus"></i></button>
                    <button class="action-btn" id="moments-notification-btn" data-icon-id="header-notification" style="display: none;">
                        <i class="fa-solid fa-bell"></i>
                        <div id="moments-notification-badge">0</div>
                    </button>
                </div>
            </div>
            <div class="app-content tab-content-wrapper">
                <div id="message-list-tab-content" class="tab-content active" style="padding:0;"><ul id="message-list"></ul></div>
                <div id="moments-tab-content" class="tab-content">
                    <!-- User's Moments Page Content will be injected by JS -->
                </div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="message-list">Ê∂àÊÅØ</div><div class="tab-link" data-tab="moments">Âä®ÊÄÅ</div>
            </div>
        </div>

        <!-- ÂçïËÅä/Áæ§ËÅäÁïåÈù¢ -->
        <div id="single-chat-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="chat-back-btn">&lt; Ê∂àÊÅØ</button></div>
                <div class="title-wrapper">
                    <div class="chat-header-name" id="chat-header-name">ËÅîÁ≥ª‰∫∫</div>
                    <div class="chat-header-status" id="chat-header-status"></div>
                    <div class="chat-header-signature" id="chat-header-signature">‰∏™ÊÄßÁ≠æÂêç</div>
                </div>
                <div class="app-header-right">
                    <button class="action-btn" id="add-friend-btn" style="display: none;" data-icon-id="chat-add-friend"><i class="fa-solid fa-plus"></i></button>
                    <button class="action-btn" id="chat-settings-btn" data-icon-id="header-settings"><i class="fa-solid fa-gear"></i></button>
                </div>
            </div>
            <div class="app-content">
                <div id="chat-messages-view"></div>
            </div>
            <div id="chat-footer">
                <div id="quote-preview"><span id="quote-preview-content"></span><button id="close-quote-btn" data-icon-id="chat-quote-close"><i class="fa-solid fa-xmark"></i></button></div>
                <div class="typing-indicator" id="typing-indicator" style="display: none;">ÂØπÊñπÊ≠£Âú®ËæìÂÖ•...</div>
                <div class="chat-input-area">
                    <button id="chat-send-real-btn" data-icon-id="chat-send-real"><i class="fa-solid fa-comments"></i></button>
                    <textarea id="chat-input" rows="1" placeholder="ËæìÂÖ•Ê∂àÊÅØ..."></textarea>
                    <div id="chat-input-buttons">
                        <button class="icon-btn" id="chat-emoji-btn" data-icon-id="chat-emoji"><i class="fa-solid fa-face-smile"></i></button>
                        <button class="icon-btn" id="chat-send-fake-btn" style="display: none;" data-icon-id="chat-send-fake"><i class="fa-solid fa-keyboard"></i></button>
                    </div>
                </div>
                <div class="chat-toolbar-wrapper">
                    <div class="chat-toolbar">
                        <button class="icon-btn" id="chat-refresh-btn" data-icon-id="chat-refresh"><i class="fa-solid fa-arrows-rotate"></i></button>
                        <button class="icon-btn" id="chat-voice-btn" data-icon-id="chat-voice"><i class="fa-solid fa-microphone"></i></button>
                        <button class="icon-btn" id="chat-image-btn" data-icon-id="chat-image"><i class="fa-solid fa-images"></i></button>
                        <button class="icon-btn" id="chat-camera-btn" data-icon-id="chat-camera"><i class="fa-solid fa-camera"></i></button>
                        <button class="icon-btn" id="chat-video-btn" data-icon-id="chat-video"><i class="fa-solid fa-video"></i></button>
                        <button class="icon-btn" id="chat-music-btn" data-icon-id="chat-music"><i class="fa-solid fa-headphones"></i></button>
                        <button class="icon-btn" id="chat-link-btn" data-icon-id="chat-link"><i class="fa-solid fa-newspaper"></i></button>
                        <button class="icon-btn" id="chat-redpacket-btn" data-icon-id="chat-redpacket"><i class="fa-solid fa-wallet"></i></button>
                        <button class="icon-btn" id="chat-shop-btn" data-icon-id="chat-shop"><i class="fa-solid fa-bag-shopping"></i></button>
                    </div>
                </div>
                <input type="file" id="chat-image-input" accept="image/*" style="display: none;">
            </div>
            <div id="emoji-picker-panel">
                <div class="emoji-picker-header">
                    <button id="close-emoji-picker-btn" data-bubble-id="emoji-close">ÂÖ≥Èó≠</button>
                    <div><button id="add-emoji-btn" data-bubble-id="emoji-add">Ê∑ªÂä†</button></div>
                </div>
                <div id="emoji-grid"></div>
            </div>
        </div>

        <!-- ÂçïËÅäËÆæÁΩÆÁïåÈù¢ -->
        <div id="chat-settings-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="chat-settings-back-btn">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title">ËÅäÂ§©ËÆæÁΩÆ</h2></div>
                <div class="app-header-right"></div>
            </div>
            <div class="app-content tab-content-wrapper">
                <!-- Char ËÆæÁΩÆ -->
                <div id="char-settings-tab-content" class="tab-content active">
                    <div class="chat-settings-layout">
                        <div class="chat-settings-main">
                            <div class="form-group"><label for="cs-char-name">ÂêçÂ≠ó</label><input type="text" id="cs-char-name"></div>
                            <div class="chat-settings-section">
                                <div class="world-book-header">
                                    <label>ÂÖ≥ËÅî‰∏ñÁïå‰π¶</label>
                                    <div id="cs-world-book-group-selector" class="wb-group-selector">
                                        <button class="wb-group-selector-btn">ÈÄâÊã©ÂàÜÁªÑ</button>
                                        <div class="wb-group-dropdown"></div>
                                    </div>
                                </div>
                                <div id="cs-world-book-list-container" class="world-book-list-container"><ul id="cs-world-book-list" class="checkbox-list"></ul></div>
                            </div>
                            <div class="form-group"><label for="cs-context-memory">‰∏ä‰∏ãÊñáËÆ∞ÂøÜÊï∞Èáè</label><input type="number" id="cs-context-memory" value="99"></div>
                        </div>
                        <div class="chat-settings-side">
                            <div id="cs-char-avatar" class="chat-settings-avatar"><div class="avatar-frame"></div></div>
                            <button id="cs-char-avatar-library-btn" class="chat-settings-side-btn" data-bubble-id="cs-avatar-lib">Â§¥ÂÉèÂ∫ì</button>
                            <button id="cs-char-avatar-frame-btn" class="chat-settings-side-btn" data-bubble-id="cs-frame-lib">Â§¥ÂÉèÊ°Ü</button>
                            <button id="cs-char-background-btn" class="chat-settings-side-btn" data-bubble-id="cs-chat-bg">ËÉåÊôØ</button>
                        </div>
                    </div>
                    <div class="form-group"><label for="cs-persona">‰∫∫ËÆæ</label><textarea id="cs-persona" class="wide-textarea" rows="5"></textarea></div>
                    <div class="chat-settings-actions">
                        <div class="button-group"><button id="cs-save-persona-btn" class="settings-button secondary" data-bubble-id="cs-save-persona">‰øùÂ≠òÂà∞ËµÑÊñô</button><button id="cs-load-persona-btn" class="settings-button secondary" data-bubble-id="cs-load-persona">‰ªéËµÑÊñôËØªÂèñ</button></div>
                        <div class="button-group"><button id="cs-clear-history-btn" class="settings-button danger-btn" data-bubble-id="cs-clear-history">Ê∏ÖÁ©∫ËÆ∞ÂΩï</button><button id="cs-delete-friend-btn" class="settings-button danger-btn" data-bubble-id="cs-delete-friend">Âà†Èô§Â•ΩÂèã</button></div>
                        <div class="form-group aligned-right"><label for="cs-realtime-activity-toggle">ÂêéÂè∞ÂÆûÊó∂Ê¥ªÂä®</label><input type="checkbox" id="cs-realtime-activity-toggle"></div>
                        <div class="form-group aligned-right" id="cs-realtime-interval-group" style="display: none;"><label for="cs-realtime-interval">Ê¥ªÂä®Èó¥Èöî(ÂàÜÈíü)</label><input type="number" id="cs-realtime-interval" value="30"></div>
                        <button id="cs-restore-btn" class="settings-button secondary" data-bubble-id="cs-restore">ËøòÂéüÊõ¥Êîπ</button>
                    </div>
                </div>
                <!-- User ËÆæÁΩÆ -->
                <div id="user-settings-tab-content" class="tab-content">
                    <div class="chat-settings-layout">
                        <div class="chat-settings-main">
                            <div class="form-group"><label for="us-user-name">‰Ω†ÁöÑÂêçÂ≠ó</label><input type="text" id="us-user-name"></div>
                        </div>
                        <div class="chat-settings-side">
                            <div id="us-user-avatar" class="chat-settings-avatar"><div class="avatar-frame"></div></div>
                            <button id="us-user-avatar-library-btn" class="chat-settings-side-btn" data-bubble-id="us-avatar-lib">Â§¥ÂÉèÂ∫ì</button>
                            <button id="us-user-avatar-frame-btn" class="chat-settings-side-btn" data-bubble-id="us-frame-lib">Â§¥ÂÉèÊ°Ü</button>
                            <button id="us-user-video-background-btn" class="chat-settings-side-btn" data-bubble-id="us-video-bg">ËßÜÈ¢ëËÉåÊôØ</button>
                        </div>
                    </div>
                    <div class="form-group"><label for="us-persona">‰Ω†ÁöÑ‰∫∫ËÆæ</label><textarea id="us-persona" class="wide-textarea" rows="5"></textarea></div>
                    <div class="chat-settings-actions">
                        <div class="button-group"><button id="us-save-persona-btn" class="settings-button secondary" data-bubble-id="us-save-persona">‰øùÂ≠òÂà∞ËµÑÊñô</button><button id="us-load-persona-btn" class="settings-button secondary" data-bubble-id="us-load-persona">‰ªéËµÑÊñôËØªÂèñ</button></div>
                    </div>
                </div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="char-settings">CharËÆæÁΩÆ</div><div class="tab-link" data-tab="user-settings">UserËÆæÁΩÆ</div>
            </div>
        </div>

        <!-- Áæ§ËÅäËÆæÁΩÆÁïåÈù¢ -->
        <div id="group-chat-settings-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="gcs-back-btn">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title">Áæ§ËÅäËÆæÁΩÆ</h2></div>
                <div class="app-header-right"></div>
            </div>
            <div class="app-content tab-content-wrapper">
                <!-- Group ËÆæÁΩÆ -->
                <div id="gcs-group-settings-tab-content" class="tab-content active">
                    <div class="chat-settings-layout">
                        <div class="chat-settings-main">
                            <div class="form-group"><label for="gcs-group-name">Áæ§ËÅäÂêçÁß∞</label><input type="text" id="gcs-group-name"></div>
                            <div class="chat-settings-section">
                                <div class="world-book-header">
                                    <label>ÂÖ≥ËÅî‰∏ñÁïå‰π¶ (ÂØπÂÖ®‰ΩìÊàêÂëòÁîüÊïà)</label>
                                    <div id="gcs-world-book-group-selector" class="wb-group-selector">
                                        <button class="wb-group-selector-btn">ÈÄâÊã©ÂàÜÁªÑ</button>
                                        <div class="wb-group-dropdown"></div>
                                    </div>
                                </div>
                                <div id="gcs-world-book-list-container" class="world-book-list-container"><ul id="gcs-world-book-list" class="checkbox-list"></ul></div>
                            </div>
                            <div class="form-group"><label for="gcs-context-memory">‰∏ä‰∏ãÊñáËÆ∞ÂøÜÊï∞Èáè</label><input type="number" id="gcs-context-memory" value="99"></div>
                        </div>
                        <div class="chat-settings-side">
                            <div id="gcs-group-avatar" class="chat-settings-avatar"><div class="avatar-frame"></div></div>
                            <button id="gcs-group-avatar-library-btn" class="chat-settings-side-btn" data-bubble-id="gcs-avatar-lib">Â§¥ÂÉèÂ∫ì</button>
                            <div style="height: 29px;"></div> <!-- Á©∫ÁôΩÂç†‰Ωç -->
                            <button id="gcs-group-background-btn" class="chat-settings-side-btn" data-bubble-id="gcs-chat-bg">ËÉåÊôØ</button>
                        </div>
                    </div>
                    <div class="chat-settings-section">
                        <div class="group-title">Áæ§ÊàêÂëò</div>
                        <div id="gcs-member-list"></div>
                    </div>
                    <div class="chat-settings-actions">
                        <div class="button-group">
                            <button id="gcs-clear-history-btn" class="settings-button secondary" data-bubble-id="gcs-clear-history">Ê∏ÖÁ©∫ËÆ∞ÂΩï</button>
                            <button id="gcs-mute-all-btn" class="settings-button secondary" data-bubble-id="gcs-mute-all">ÂÖ®‰ΩìÁ¶ÅË®Ä</button>
                            <button id="gcs-disband-btn" class="settings-button danger-btn" data-bubble-id="gcs-disband">Ëß£Êï£Áæ§ËÅä</button>
                        </div>
                    </div>
                </div>
                <!-- User ËÆæÁΩÆ (Áæ§ËÅäÂÜÖ) -->
                <div id="gcs-user-settings-tab-content" class="tab-content">
                    <div class="chat-settings-layout">
                        <div class="chat-settings-main">
                            <div class="form-group"><label for="gcs-us-user-name">‰Ω†Âú®Êú¨Áæ§ÁöÑÊòµÁß∞</label><input type="text" id="gcs-us-user-name"></div>
                        </div>
                        <div class="chat-settings-side">
                            <div id="gcs-us-user-avatar" class="chat-settings-avatar"><div class="avatar-frame"></div></div>
                            <button id="gcs-us-user-avatar-library-btn" class="chat-settings-side-btn" data-bubble-id="gcs-us-avatar-lib">Â§¥ÂÉèÂ∫ì</button>
                            <button id="gcs-us-user-avatar-frame-btn" class="chat-settings-side-btn" data-bubble-id="gcs-us-frame-lib">Â§¥ÂÉèÊ°Ü</button>
                            <button id="gcs-us-user-video-background-btn" class="chat-settings-side-btn" data-bubble-id="gcs-us-video-bg">ËßÜÈ¢ëËÉåÊôØ</button>
                        </div>
                    </div>
                    <div class="form-group"><label for="gcs-us-persona">‰Ω†Âú®Êú¨Áæ§ÁöÑ‰∫∫ËÆæ</label><textarea id="gcs-us-persona" class="wide-textarea" rows="5"></textarea></div>
                    <div class="chat-settings-actions">
                        <div class="button-group"><button id="gcs-us-save-persona-btn" class="settings-button secondary" data-bubble-id="gcs-us-save-persona">‰øùÂ≠òÂà∞ËµÑÊñô</button><button id="gcs-us-load-persona-btn" class="settings-button secondary" data-bubble-id="gcs-us-load-persona">‰ªéËµÑÊñôËØªÂèñ</button></div>
                    </div>
                </div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="gcs-group-settings">Áæ§ËÆæÁΩÆ</div><div class="tab-link" data-tab="gcs-user-settings">ÊàëÁöÑËÆæÁΩÆ</div>
            </div>
        </div>
        <!-- Êü•ÁúãÁõ∏ÂÜåÁïåÈù¢ -->
        <div id="view-album-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="view-album-back-btn">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title" id="view-album-title">Áõ∏ÂÜå</h2></div>
                <div class="app-header-right">
                    <button class="action-btn small" id="delete-photos-btn" style="display: none;">Âà†Èô§</button>
                </div>
            </div>
            <div class="app-content">
                <div id="album-photo-grid" class="photo-grid"></div>
            </div>
        </div>
        <!-- CharÂä®ÊÄÅ‰∏ªÈ°µ -->
        <div id="char-moments-screen" class="app-screen sub-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" id="char-moments-back-btn">&lt; Âä®ÊÄÅ</button></div>
                <div class="title-wrapper"><h2 class="title">Âä®ÊÄÅ</h2></div>
                <div class="app-header-right">
                     <button class="action-btn" id="char-moments-notification-btn" data-icon-id="header-notification">
                        <i class="fa-solid fa-bell"></i>
                        <div id="char-moments-notification-badge" class="moments-notification-badge-clone">0</div>
                    </button>
                </div>
            </div>
            <div class="app-content" style="padding:0;">
                <!-- Content will be injected here -->
            </div>
        </div>
<!-- ‰ø°ÁÆ±APPÁïåÈù¢ -->
        <div id="mail-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title">‰ø°ÁÆ±</h2></div>
                <div class="app-header-right"><button class="action-btn" id="mail-settings-btn" data-icon-id="header-settings"><i class="fa-solid fa-gear"></i></button></div>
            </div>
            <div class="app-content tab-content-wrapper">
                <div id="love-letter-tab-content" class="tab-content active">
                    <div id="unread-letters-container">
                        <ul class="love-letter-list"></ul>
                    </div>
                    <div id="read-letters-container" style="display: none;">
                        <div class="love-letter-collection-container">
                            <div class="love-letter-collection-grid"></div>
                        </div>
                    </div>
                </div>
                <div id="postcard-tab-content" class="tab-content"><p style="text-align:center; color: #888; margin-top: 50px;">Êòé‰ø°ÁâáÂäüËÉΩÂæÖÂºÄÂèë...</p></div>
                <div id="tree-hole-tab-content" class="tab-content"><p style="text-align:center; color: #888; margin-top: 50px;">Ê†ëÊ¥ûÂäüËÉΩÂæÖÂºÄÂèë...</p></div>
                <div id="drift-bottle-tab-content" class="tab-content"><p style="text-align:center; color: #888; margin-top: 50px;">ÊºÇÊµÅÁì∂ÂäüËÉΩÂæÖÂºÄÂèë...</p></div>
            </div>
            <div class="moments-fab-container" id="mail-fab-container" style="display: none;"><div id="mail-fab" class="moments-fab"><i class="fa-solid fa-plus"></i></div></div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="love-letter">ÊÉÖ‰π¶</div>
                <div class="tab-link" data-tab="postcard">Êòé‰ø°Áâá</div>
                <div class="tab-link" data-tab="tree-hole">Ê†ëÊ¥û</div>
                <div class="tab-link" data-tab="drift-bottle">ÊºÇÊµÅÁì∂</div>
            </div>
        </div>
        <!-- ÊâãË¥¶APPÁïåÈù¢ -->
        <div id="diary-app-screen" class="app-screen">
            <div class="app-header">
                <div class="app-header-left"><button class="back-btn" onclick="closeCurrentApp()">&lt; ËøîÂõû</button></div>
                <div class="title-wrapper"><h2 class="title">ÊâãË¥¶</h2></div>
                <div class="app-header-right"></div>
            </div>
            <div class="app-content tab-content-wrapper">
                <div id="secret-diary-tab-content" class="tab-content active"><p style="text-align:center; color: #888; margin-top: 50px;">ÁßòÂØÜÊó•ËÆ∞ÂäüËÉΩÂæÖÂºÄÂèë...</p></div>
                <div id="couple-diary-tab-content" class="tab-content"><p style="text-align:center; color: #888; margin-top: 50px;">ÊÉÖ‰æ£Êó•ËÆ∞ÂäüËÉΩÂæÖÂºÄÂèë...</p></div>
                <div id="anniversary-tab-content" class="tab-content"><p style="text-align:center; color: #888; margin-top: 50px;">Á∫™ÂøµÊó•ÂäüËÉΩÂæÖÂºÄÂèë...</p></div>
                <div id="collection-tab-content" class="tab-content"><p style="text-align:center; color: #888; margin-top: 50px;">ÁèçËóèÂäüËÉΩÂæÖÂºÄÂèë...</p></div>
                <div id="exhibition-tab-content" class="tab-content"><p style="text-align:center; color: #888; margin-top: 50px;">Â±ïÂéÖÂäüËÉΩÂæÖÂºÄÂèë...</p></div>
            </div>
            <div class="app-bottom-tabs">
                <div class="tab-link active" data-tab="secret-diary">ÁßòÂØÜÊó•ËÆ∞</div>
                <div class="tab-link" data-tab="couple-diary">ÊÉÖ‰æ£Êó•ËÆ∞</div>
                <div class="tab-link" data-tab="anniversary">Á∫™ÂøµÊó•</div>
                <div class="tab-link" data-tab="collection">ÁèçËóè</div>
                <div class="tab-link" data-tab="exhibition">Â±ïÂéÖ</div>
            </div>
        </div>
    <!-- ÊµÆÂä®Ê≠åËØç & Èü≥‰πêÊí≠ÊîæÂô® -->
    <div id="lyrics-container"><div id="lyrics-line">...</div></div>
    <div id="player-modal">
        <div class="player-header"><button class="icon-btn" id="hide-player-btn" data-icon-id="player-close"><i class="fa-solid fa-circle-chevron-down"></i></button><div class="player-song-info"><div class="title">Ê≠åÊõ≤Âêç</div><div class="artist">Ê≠åÊâã</div><div id="listen-together-info"><div class="listen-heart"></div><span id="listen-together-text"></span></div></div><button class="icon-btn" id="toggle-playlist-view-btn" data-icon-id="player-playlist"><i class="fa-solid fa-bars"></i></button></div>
        <div class="player-body"><div id="player-lyrics-view" class="player-view active"></div><div id="player-playlist-view-container" class="player-view"><div class="player-playlist-header"><button class="settings-button secondary" id="restore-playlist-btn" style="padding: 5px 10px; font-size: 12px;" data-bubble-id="player-restore-playlist">ËøòÂéü</button></div><ul class="player-playlist-view"></ul></div></div>
        <div class="player-footer"><input type="range" id="progress-bar" value="0" step="1"><div class="player-controls"><button class="icon-btn" id="player-prev-btn" data-icon-id="player-prev"><i class="fa-solid fa-circle-chevron-left"></i></button><button class="icon-btn play-pause-btn" id="player-play-pause-btn" data-icon-id="player-play"><i class="fa-solid fa-circle-play"></i></button><button class="icon-btn" id="player-next-btn" data-icon-id="player-next"><i class="fa-solid fa-circle-chevron-right"></i></button><button class="icon-btn" id="player-playback-mode-btn" data-icon-id="player-mode-repeat"><i class="fa-solid fa-arrow-right-arrow-left"></i></button></div></div>
    </div>

    <!-- ÂºπÁ™óÈõÜÂêà -->
    <div id="manage-presets-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÁÆ°ÁêÜAPIÈ¢ÑËÆæ</h3><div class="modal-body"><p style="font-size: 12px; color: #888; text-align: center;">ÂêëÂ∑¶ÊªëÂä®ÂèØËøõË°åÁºñËæëÊàñÂà†Èô§</p><ul id="preset-list"></ul></div><div class="modal-actions row"><button id="close-manage-modal-btn" class="cancel-btn" data-bubble-id="modal-close-preset">ÂÖ≥Èó≠</button></div></div></div>
    <div id="edit-preset-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÁºñËæëÈ¢ÑËÆæ</h3><div class="modal-body"><input type="hidden" id="edit-preset-index"><div class="form-group"><label for="edit-preset-name">È¢ÑËÆæÂêçÁß∞</label><input type="text" id="edit-preset-name"></div><div class="form-group"><label for="edit-preset-url">Âèç‰ª£Âú∞ÂùÄ</label><input type="text" id="edit-preset-url"></div><div class="form-group"><label for="edit-preset-key">API ÂØÜÈí•</label><input type="text" id="edit-preset-key"></div></div><div class="modal-actions row"><button id="cancel-edit-btn" class="cancel-btn" data-bubble-id="modal-cancel">ÂèñÊ∂à</button><button id="save-edit-btn" class="confirm-btn" data-bubble-id="modal-save">‰øùÂ≠ò</button></div></div></div>
    <div id="add-music-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">Ê∑ªÂä†Èü≥‰πê</h3><div class="modal-body"><div class="modal-tabs"><button class="tab-btn active" data-tab="upload">‰∏ä‰º†</button><button class="tab-btn" data-tab="url">URL</button></div><div id="tab-content-music-upload" class="modal-tab-content active"><p style="font-size:12px; color:#888; text-align:center; margin-bottom:15px;">ÊîØÊåÅÊâπÈáè‰∏ä‰º†ÔºåÊñá‰ª∂ÂêçÊ†ºÂºè‰∏∫‚ÄúÁ§∫‰æãÊ≠åÊâã - Á§∫‰æãÊ≠åÊõ≤.Á§∫‰æã‰∏ªÊµÅÂ™í‰ΩìÊ†ºÂºè‚Äù„ÄÇ</p><button id="upload-music-btn" class="settings-button" data-bubble-id="modal-select-file">ÈÄâÊã©Êñá‰ª∂</button><input type="file" id="music-file-input" multiple accept="audio/*,.lrc" style="display:none;"></div><div id="tab-content-music-url" class="modal-tab-content"><p style="font-size:12px; color:#888; text-align:center; margin-bottom:10px;">ÊîØÊåÅÊâπÈáè‰∏ä‰º†ÔºåÊØèË°å‰∏ÄÊù°ÔºåÊ†ºÂºè‰∏∫‚ÄúÁ§∫‰æãÊ≠åÊâã - Á§∫‰æãÊ≠åÂêçÔºöhttp://Á§∫‰æãÈìæÊé•.Á§∫‰æã‰∏ªÊµÅÂ™í‰ΩìÊ†ºÂºè‚Äù„ÄÇ</p><textarea id="music-url-input" class="wide-textarea"></textarea><button id="confirm-add-url-btn" class="settings-button" data-bubble-id="modal-add-url">Ê∑ªÂä†URL</button></div></div><div class="modal-actions row"><button id="cancel-add-music-btn" class="cancel-btn single-button" data-bubble-id="modal-cancel-music">ÂèñÊ∂à</button></div></div></div>
    <div id="edit-song-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÁºñËæëÊ≠åÊõ≤‰ø°ÊÅØ</h3><div class="modal-body"><input type="hidden" id="edit-song-id"><div class="form-group"><label for="edit-song-title">Ê≠åÂêç</label><input type="text" id="edit-song-title"></div><div class="form-group"><label for="edit-song-artist">Ê≠åÊâã</label><input type="text" id="edit-song-artist"></div></div><div class="modal-actions row"><button id="cancel-edit-song-btn" class="cancel-btn" data-bubble-id="modal-cancel-song">ÂèñÊ∂à</button><button id="save-edit-song-btn" class="confirm-btn" data-bubble-id="modal-save-song">‰øùÂ≠ò</button></div></div></div>
    <div id="add-font-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">Ê∑ªÂä†Â≠ó‰Ωì</h3><div class="modal-body"><div class="modal-tabs"><button class="tab-btn active" data-tab="upload">‰∏ä‰º†</button><button class="tab-btn" data-tab="url">URL</button></div><div id="tab-content-font-upload" class="modal-tab-content active"><button id="upload-font-btn" class="settings-button" data-bubble-id="modal-upload-font">ÈÄâÊã©Êñá‰ª∂</button><input type="file" id="font-file-input" multiple accept=".ttf,.otf,.woff,.woff2" style="display:none;"></div><div id="tab-content-font-url" class="modal-tab-content"><textarea id="font-url-input" class="wide-textarea" placeholder="ÊØèË°å‰∏Ä‰∏™URLÔºåÊàñ‰ΩøÁî®‚ÄúÂ≠ó‰ΩìÂêç:URL‚ÄùÊ†ºÂºè"></textarea><button id="confirm-add-font-url-btn" class="settings-button" data-bubble-id="modal-add-font-url">Ê∑ªÂä†URL</button></div></div><div class="modal-actions row"><button id="cancel-add-font-btn" class="cancel-btn" data-bubble-id="modal-cancel-font">ÂèñÊ∂à</button></div></div></div>
    <div id="replace-icon-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÊõøÊç¢ÂõæÊ†á</h3><div class="modal-body"><input type="hidden" id="replace-icon-id"><div class="modal-tabs"><button class="tab-btn active" data-tab="upload">‰∏ä‰º†</button><button class="tab-btn" data-tab="url">URL</button></div><div id="tab-content-icon-upload" class="modal-tab-content active"><button id="upload-icon-btn" class="settings-button" data-bubble-id="modal-upload-icon">ÈÄâÊã©ÂõæÁâá</button><input type="file" id="icon-file-input" accept="image/*" style="display:none;"></div><div id="tab-content-icon-url" class="modal-tab-content"><textarea id="icon-url-input" class="wide-textarea" rows="1" placeholder="ËæìÂÖ•ÂõæÁâáURL"></textarea><button id="confirm-replace-icon-url-btn" class="settings-button" style="margin-top:10px;" data-bubble-id="modal-confirm-icon-url">Á°ÆËÆ§</button></div></div><div class="modal-actions"><button id="restore-icon-btn" class="danger-btn" style="margin-top: 10px;" data-bubble-id="modal-restore-icon">ËøòÂéü</button><button id="cancel-replace-icon-btn" class="cancel-btn" data-bubble-id="modal-cancel-icon">ÂèñÊ∂à</button></div></div></div>
    <div id="edit-bubble-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÁºñËæëÊ∞îÊ≥°</h3><div class="modal-body"><input type="hidden" id="edit-bubble-id"><div class="form-group"><label>ÂõæÁâáÊõøÊç¢</label><div class="checkbox-group"><input type="checkbox" id="replace-bg-only-checkbox"><label for="replace-bg-only-checkbox">‰ªÖÊõøÊç¢Â∫ïÂõæ</label></div><button class="settings-button" id="upload-bubble-btn" data-bubble-id="bubble-upload-img">‰∏ä‰º†ÂõæÁâá</button><input type="file" id="bubble-file-input" accept="image/*" style="display:none;"><textarea id="bubble-url-input" class="uniform-input-box" placeholder="ÊàñËæìÂÖ•ÂõæÁâáURL" style="margin-top:10px;"></textarea><hr style="margin:15px 0; border:none; border-top:1px solid var(--border-color);"></div><div class="inline-inputs"><div class="form-group"><label>ÂÆΩÂ∫¶</label><input type="text" id="bubble-width-input"></div><div class="form-group"><label>È´òÂ∫¶</label><input type="text" id="bubble-height-input"></div></div><div class="inline-inputs"><div class="form-group"><label>XÂÅèÁßª</label><input type="text" id="bubble-pos-x-input"></div><div class="form-group"><label>YÂÅèÁßª</label><input type="text" id="bubble-pos-y-input"></div></div><div class="form-group bubble-color-group"><label>ÊñáÂ≠óÈ¢úËâ≤</label><input type="text" id="bubble-color-input"></div><div class="form-group bubble-color-group"><label>ËÉåÊôØÈ¢úËâ≤</label><input type="text" id="bubble-bg-color-input"></div><div class="form-group bubble-color-group"><label>ËæπÊ°ÜÈ¢úËâ≤</label><input type="text" id="bubble-border-color-input"></div><label>È¢ÑËßà</label><div id="bubble-preview-wrapper"><div id="bubble-preview"><span>È¢ÑËßàÊñáÂ≠ó</span></div></div></div><div class="modal-actions"><button id="save-bubble-btn" class="confirm-btn" data-bubble-id="bubble-save">‰øùÂ≠ò</button><button id="restore-bubble-btn" class="danger-btn" data-bubble-id="bubble-restore">ËøòÂéü</button><button id="cancel-edit-bubble-btn" class="cancel-btn" data-bubble-id="bubble-cancel">ÂèñÊ∂à</button></div></div></div>
    <div id="bubble-io-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">Ê∞îÊ≥°Â§á‰ªΩ</h3><div class="modal-body"><div class="button-group" style="flex-direction: column;"><button id="export-bubbles-btn" class="settings-button">‰∏ÄÈîÆÂØºÂá∫</button><button id="import-bubbles-btn" class="settings-button secondary">‰∏ÄÈîÆÂØºÂÖ•</button><input type="file" id="import-bubbles-input" accept=".json" style="display: none;"></div></div><div class="modal-actions"><button id="cancel-bubble-io-btn" class="cancel-btn">ÂèñÊ∂à</button></div></div></div>
    <div id="data-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="data-modal-title">ÂàõÂª∫Êù°ÁõÆ</h3><div class="modal-body"><input type="hidden" id="data-editing-id"><div class="form-group avatar-group" style="display:none;"><div id="data-avatar-preview" class="modal-avatar-preview"></div><div class="modal-avatar-actions"><button id="data-upload-avatar-btn" class="settings-button secondary" data-bubble-id="data-upload-avatar">‰∏ä‰º†</button><button id="data-add-avatar-url-btn" class="settings-button secondary" data-bubble-id="data-add-avatar-url">Ê∑ªÂä†</button></div><input type="file" id="data-avatar-file-input" accept="image/*" style="display:none;"></div><div class="form-group"><label for="data-name">ÂêçÁß∞</label><input type="text" id="data-name"></div><div class.="form-group" id="data-group-container">
                <label for="data-group">ÂàÜÁªÑ</label>
                <div class="data-group-input-wrapper">
                    <input type="text" id="data-group" placeholder="ËæìÂÖ•ÊàñÈÄâÊã©ÂàÜÁªÑ">
                    <select id="data-group-select"></select>
                </div>
            </div><div class="form-group"><label for="data-content">ÂÜÖÂÆπ</label><textarea id="data-content" class="wide-textarea" rows="6"></textarea></div></div><div class="modal-actions row"><button id="cancel-data-btn" class="cancel-btn" data-bubble-id="data-cancel">ÂèñÊ∂à</button><button id="save-data-btn" class="confirm-btn" data-bubble-id="data-save">‰øùÂ≠ò</button></div></div></div>
    <div id="add-contact-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">Ê∑ªÂä†ËÅîÁ≥ª‰∫∫</h3><div class="modal-body"><div class="form-group"><label for="new-contact-name">ÂêçÂ≠ó</label><input type="text" id="new-contact-name" placeholder="ËæìÂÖ•ËÅîÁ≥ª‰∫∫ÂêçÂ≠ó"></div></div><div class="modal-actions row"><button id="cancel-add-contact-btn" class="cancel-btn" data-bubble-id="contact-add-cancel">ÂèñÊ∂à</button><button id="confirm-add-contact-btn" class="confirm-btn" data-bubble-id="contact-add-confirm">Ê∑ªÂä†</button></div></div></div>
    <div id="add-emoji-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">Ê∑ªÂä†Ë°®ÊÉÖÂåÖ</h3><div class="modal-body"><div class="modal-tabs"><button class="tab-btn active" data-tab="upload">‰∏ä‰º†</button><button class="tab-btn" data-tab="url">URL</button></div><div id="tab-content-emoji-upload" class="modal-tab-content active"><p style="font-size:12px; color:#888; text-align:center; margin-bottom:15px;">ÊîØÊåÅÊâπÈáè‰∏ä‰º†ÔºåÊØèË°å‰∏Ä‰∏™ÊèèËø∞„ÄÇ</p><textarea id="upload-emoji-desc" class="wide-textarea" placeholder="Ë°®ÊÉÖÂåÖÊñáÂ≠óÊèèËø∞(ÊØèË°å‰∏Ä‰∏™)"></textarea><button id="upload-emoji-file-btn" class="settings-button" data-bubble-id="emoji-upload-file">ÈÄâÊã©Êñá‰ª∂</button><input type="file" id="emoji-file-input" accept="image/*" multiple style="display:none;"></div><div id="tab-content-emoji-url" class="modal-tab-content"><p style="font-size:12px; color:#888; text-align:center; margin-bottom:10px;">ÊØèË°å‰∏ÄÊù°ÔºåÊ†ºÂºè‰∏∫‚ÄúÊñáÂ≠óÊèèËø∞:http://ÈìæÊé•‚Äù„ÄÇ</p><textarea id="emoji-url-input" class="wide-textarea"></textarea><button id="confirm-add-emoji-url-btn" class="settings-button" data-bubble-id="emoji-add-url">Ê∑ªÂä†URL</button></div></div><div class="modal-actions row"><button id="cancel-add-emoji-btn" class="cancel-btn single-button" data-bubble-id="emoji-add-cancel">ÂèñÊ∂à</button></div></div></div>
    <div id="pat-suffix-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">Êãç‰∏ÄÊãç</h3><div class="modal-body"><input type="text" id="pat-suffix-input" placeholder="Ê∑ªÂä†ÂêéÁºÄ (ÂèØÈÄâ)"></div><div class="modal-actions row"><button id="cancel-pat-btn" class="cancel-btn" data-bubble-id="pat-cancel">ÂèñÊ∂à</button><button id="confirm-pat-btn" class="confirm-btn" data-bubble-id="pat-confirm">Êãç</button></div></div></div>
    <div id="edit-status-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">‰øÆÊîπÁä∂ÊÄÅ</h3><div class="modal-body"><div class="form-group"><label for="status-desc-input">Áä∂ÊÄÅÊèèËø∞</label><input type="text" id="status-desc-input" placeholder="‰æãÂ¶ÇÔºöÊ≠£Âú®ÂºÄ‰ºö"></div><div class="form-group"><label>ÈÄâÊã©Áä∂ÊÄÅ</label><div id="status-select-group" class="radio-group"></div></div></div><div class="modal-actions row"><button id="cancel-edit-status-btn" class="cancel-btn" data-bubble-id="status-edit-cancel">ÂèñÊ∂à</button><button id="confirm-edit-status-btn" class="confirm-btn" data-bubble-id="status-edit-confirm">Á°ÆËÆ§</button></div></div></div>
    <div id="voice-input-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ËØ≠Èü≥ÂÜÖÂÆπ</h3><div class="modal-body"><textarea id="voice-text-input" class="wide-textarea" placeholder="ËæìÂÖ•ËØ≠Èü≥ÁöÑÊñáÂ≠óÂÜÖÂÆπ..."></textarea></div><div class="modal-actions row"><button id="cancel-voice-btn" class="cancel-btn" data-bubble-id="voice-cancel">ÂèñÊ∂à</button><button id="confirm-voice-btn" class="confirm-btn" data-bubble-id="voice-confirm">ÂèëÈÄÅ</button></div></div></div>
    <div id="camera-input-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÂõæÁâáÊèèËø∞</h3><div class="modal-body"><textarea id="camera-text-input" class="wide-textarea" placeholder="ËæìÂÖ•ÂõæÁâáÁöÑÊñáÂ≠óÊèèËø∞..."></textarea></div><div class="modal-actions row"><button id="cancel-camera-btn" class="cancel-btn" data-bubble-id="camera-cancel">ÂèñÊ∂à</button><button id="confirm-camera-btn" class="confirm-btn" data-bubble-id="camera-confirm">ÂèëÈÄÅ</button></div></div></div>
    <div id="link-share-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÂàÜ‰∫´ÈìæÊé•</h3><div class="modal-body"><div class="form-group"><label>Ê†áÈ¢ò (ÂøÖÂ°´)</label><input type="text" id="link-title-input"></div><div class="form-group"><label>ÊëòË¶Å</label><input type="text" id="link-summary-input"></div><div class="form-group"><label>Êù•Ê∫ê</label><input type="text" id="link-source-input"></div><div class="form-group"><label>ÂÆåÊï¥ÂÜÖÂÆπ</label><textarea id="link-content-input" class="wide-textarea" rows="4"></textarea></div></div><div class="modal-actions row"><button id="cancel-link-btn" class="cancel-btn" data-bubble-id="link-cancel">ÂèñÊ∂à</button><button id="confirm-link-btn" class="confirm-btn" data-bubble-id="link-confirm">ÂàÜ‰∫´</button></div></div></div>
    <div id="red-packet-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÂèëÁ∫¢ÂåÖ</h3><div class="modal-body"><div class="form-group"><label>ÈáëÈ¢ù</label><input type="number" id="red-packet-amount-input" class="uniform-input-box" placeholder="0.00"></div><div class="form-group"><label>ÁïôË®Ä</label><input type="text" id="red-packet-message-input" class="uniform-input-box" placeholder="ÊÅ≠ÂñúÂèëË¥¢ÔºåÂ§ßÂêâÂ§ßÂà©ÔºÅ"></div></div><div class="modal-actions row"><button id="cancel-red-packet-btn" class="cancel-btn" data-bubble-id="rp-cancel">ÂèñÊ∂à</button><button id="confirm-red-packet-btn" class="confirm-btn" data-bubble-id="rp-confirm">Â°ûÈí±ËøõÁ∫¢ÂåÖ</button></div></div></div>
    <div id="group-red-packet-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÂèëÁæ§Á∫¢ÂåÖ</h3><div class="modal-body"><div class="modal-tabs"><button class="tab-btn active" data-tab="exclusive">‰∏ìÂ±û</button><button class="tab-btn" data-tab="lucky">ÊãºÊâãÊ∞î</button><button class="tab-btn" data-tab="normal">ÊôÆÈÄö</button></div><div id="tab-content-rp-exclusive" class="modal-tab-content active"><div class="form-group"><label>ÈáëÈ¢ù</label><input type="number" class="red-packet-input" data-type="exclusive-amount" placeholder="0.00"></div><div class="form-group"><label>ÁïôË®Ä</label><input type="text" class="red-packet-input" data-type="exclusive-message" placeholder="ÊÅ≠ÂñúÂèëË¥¢ÔºåÂ§ßÂêâÂ§ßÂà©ÔºÅ"></div><div class="form-group"><label>ÈÄâÊã©ÂèëÈÄÅÂØπË±°</label><div id="group-red-packet-member-grid"></div></div></div><div id="tab-content-rp-lucky" class="modal-tab-content"><div class="form-group"><label>ÊÄªÈáëÈ¢ù</label><input type="number" class="red-packet-input" data-type="lucky-amount" placeholder="0.00"></div><div class="form-group"><label>Á∫¢ÂåÖ‰∏™Êï∞</label><input type="number" class="red-packet-input" data-type="lucky-count" placeholder="Â°´ÂÜô‰∏™Êï∞"></div><div class="form-group"><label>ÁïôË®Ä</label><input type="text" class="red-packet-input" data-type="lucky-message" placeholder="ÊÅ≠ÂñúÂèëË¥¢ÔºåÂ§ßÂêâÂ§ßÂà©ÔºÅ"></div></div><div id="tab-content-rp-normal" class="modal-tab-content"><div class="form-group"><label>Âçï‰∏™ÈáëÈ¢ù</label><input type="number" class="red-packet-input" data-type="normal-amount" placeholder="0.00"></div><div class="form-group"><label>Á∫¢ÂåÖ‰∏™Êï∞</label><input type="number" class="red-packet-input" data-type="normal-count" placeholder="Â°´ÂÜô‰∏™Êï∞"></div><div class="form-group"><label>ÁïôË®Ä</label><input type="text" class="red-packet-input" data-type="normal-message" placeholder="ÊÅ≠ÂñúÂèëË¥¢ÔºåÂ§ßÂêâÂ§ßÂà©ÔºÅ"></div></div></div><div class="modal-actions row"><button id="cancel-group-red-packet-btn" class="cancel-btn" data-bubble-id="grp-cancel">ÂèñÊ∂à</button><button id="confirm-group-red-packet-btn" class="confirm-btn" data-bubble-id="grp-confirm">Â°ûÈí±ËøõÁ∫¢ÂåÖ</button></div></div></div>
    <div id="edit-comment-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÁºñËæëËØÑËÆ∫</h3><div class="modal-body"><textarea id="edit-comment-input" class="wide-textarea"></textarea></div><div class="modal-actions row"><button id="cancel-edit-comment-btn" class="cancel-btn" data-bubble-id="comment-edit-cancel">ÂèñÊ∂à</button><button id="save-edit-comment-btn" class="confirm-btn" data-bubble-id="comment-edit-save">‰øùÂ≠ò</button></div></div></div>
    <div id="view-content-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="view-content-title"></h3><div class="modal-body" id="view-content-body"></div><div class="modal-actions"><button id="close-view-content-btn" class="cancel-btn" data-bubble-id="view-content-close">ÂÖ≥Èó≠</button></div></div></div>
    <div id="edit-message-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title">ÁºñËæëÊ∂àÊÅØ</h3><div class="modal-body"><input type="hidden" id="editing-message-id"><div class="form-group"><label>Ê∂àÊÅØÁ±ªÂûã</label><div id="edit-message-type-group" class="radio-group"></div></div><div id="edit-message-inputs-container"></div></div><div class="modal-actions row"><button id="cancel-edit-message-btn" class="cancel-btn" data-bubble-id="msg-edit-cancel">ÂèñÊ∂à</button><button id="save-edit-message-btn" class="confirm-btn" data-bubble-id="msg-edit-save">‰øùÂ≠ò</button></div></div></div>
    <div id="library-modal" class="modal-overlay"><div class="modal-content library-modal"><h3 class="modal-title" id="library-modal-title">Â∫ì</h3><div class="modal-body"><div id="library-modal-preview-area"></div><div class="button-group" style="margin-bottom: 15px;"><button id="library-upload-btn" class="settings-button" data-bubble-id="lib-upload">‰∏ä‰º†</button><button id="library-add-url-btn" class="settings-button" data-bubble-id="lib-add-url">Ê∑ªÂä†URL</button></div><div id="library-grid" class="library-grid"></div><input type="file" id="library-file-input" style="display:none" multiple></div><div class="modal-actions"><button id="library-delete-btn" class="danger-btn" style="display:none;" data-bubble-id="lib-delete">Á°ÆËÆ§Âà†Èô§</button><button id="library-mode-toggle-btn" class="settings-button secondary">Âà†Èô§</button><button id="library-close-btn" class="cancel-btn" data-bubble-id="lib-close">ÂÖ≥Èó≠</button></div></div></div>
    <div id="load-persona-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="load-persona-title">ËØªÂèñËµÑÊñô</h3><div class="modal-body" id="load-persona-list"></div><div class="modal-actions"><button id="load-persona-cancel-btn" class="cancel-btn" data-bubble-id="persona-load-cancel">ÂèñÊ∂à</button></div></div></div>
    <div id="gcs-member-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="gcs-member-modal-title">ÊàêÂëòËÆæÁΩÆ</h3><div class="modal-body"><input type="hidden" id="gcs-editing-member-id"><div class="chat-settings-layout"><div class="chat-settings-main"><div class="form-group"><label>Áæ§ÂêçÁâá</label><input type="text" id="gcs-member-nickname"></div><div class="chat-settings-section"><div class="world-book-header"><label>ÂÖ≥ËÅî‰∏ñÁïå‰π¶ (‰ªÖÂØπËØ•ÊàêÂëòÁîüÊïà)</label><div id="gcs-member-world-book-group-selector" class="wb-group-selector"><button class="wb-group-selector-btn">ÈÄâÊã©ÂàÜÁªÑ</button><div class="wb-group-dropdown"></div></div></div><div id="gcs-member-world-book-list-container" class="world-book-list-container"><ul id="gcs-member-world-book-list" class="checkbox-list"></ul></div></div></div><div class="chat-settings-side"><div id="gcs-member-avatar" class="chat-settings-avatar"><div class="avatar-frame"></div></div><button id="gcs-member-avatar-library-btn" class="chat-settings-side-btn" data-bubble-id="gcs-member-avatar-lib">Â§¥ÂÉèÂ∫ì</button><button id="gcs-member-avatar-frame-btn" class="chat-settings-side-btn" data-bubble-id="gcs-member-frame-lib">Â§¥ÂÉèÊ°Ü</button></div></div><div class="form-group"><label>‰∫∫ËÆæ</label><textarea id="gcs-member-persona" class="wide-textarea" rows="5"></textarea></div><div class="button-group"><button id="gcs-member-save-persona-btn" class="settings-button secondary" data-bubble-id="gcs-member-save-persona">‰øùÂ≠òÂà∞ËµÑÊñô</button><button id="gcs-member-load-persona-btn" class="settings-button secondary" data-bubble-id="gcs-member-load-persona">‰ªéËµÑÊñôËØªÂèñ</button></div></div><div class="modal-actions row"><button id="gcs-member-modal-cancel-btn" class="cancel-btn" data-bubble-id="gcs-member-cancel">ÂèñÊ∂à</button><button id="gcs-member-modal-save-btn" class="confirm-btn" data-bubble-id="gcs-member-save">‰øùÂ≠ò</button></div></div></div>
    <div id="gcs-manage-members-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="gcs-manage-members-title">ÁÆ°ÁêÜÊàêÂëò</h3><div class="modal-body" id="gcs-manage-members-list"></div><div class="modal-actions row"><button id="gcs-manage-members-cancel-btn" class="cancel-btn" data-bubble-id="gcs-manage-cancel">ÂèñÊ∂à</button><button id="gcs-manage-members-confirm-btn" class="confirm-btn" data-bubble-id="gcs-manage-confirm">Á°ÆËÆ§</button></div></div></div>
    <div id="gcs-member-action-modal" class="modal-overlay"><div class="modal-content"><h3 class="modal-title" id="gcs-member-action-title">ÁÆ°ÁêÜÊàêÂëò</h3><div class="modal-body" id="gcs-member-action-body"></div><div class="modal-actions"><button id="gcs-member-action-cancel-btn" class="cancel-btn" data-bubble-id="gcs-member-action-cancel">ÂèñÊ∂à</button></div></div></div>
    <!-- ÁïôË®ÄÂºπÁ™ó -->
    <div id="leave-message-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">ÂÜôÁïôË®Ä</h3>
            <div class="modal-body">
                <div class="form-group hidden-by-logic" id="leave-message-author-selector-container">
                        <label>ÂèëÂ∏É‰∫∫</label>
                        <div id="leave-message-author-selector"></div>
                    </div>
                <div class="form-group">
                    <label for="message-recipient">Áß∞Âëº</label>
                    <input type="text" id="message-recipient" placeholder="To:">
                </div>
                <div class="form-group">
                    <label for="message-content">ÂÜÖÂÆπ</label>
                    <textarea id="message-content" class="wide-textarea" rows="5" placeholder="ËØ¥ÁÇπ‰ªÄ‰πàÂêß..."></textarea>
                </div>
                <div class="form-group">
                    <label for="message-sender">ËêΩÊ¨æ</label>
                    <input type="text" id="message-sender" placeholder="From:">
                </div>
                <hr>
                <div class="form-group">
                    <label>Ë∞ÅÂèØ‰ª•Áúã</label>
                    <div class="radio-group" id="leave-message-visibility">
                        <label class="radio-label"><input type="radio" name="message-visibility" value="public" checked><span>ÂÖ¨ÂºÄ</span></label>
                        <label class="radio-label"><input type="radio" name="message-visibility" value="specific"><span>ÊåáÂÆöÂ•ΩÂèã</span></label>
                    </div>
                </div>
                <div class="form-group hidden-by-logic" id="leave-message-friend-selector-container">
                    <div id="leave-message-friend-selector" class="friend-selector-grid"></div>
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-leave-message-btn" class="cancel-btn">ÂèñÊ∂à</button>
                <button id="confirm-leave-message-btn" class="confirm-btn">ÂèëË°®</button>
            </div>
        </div>
    </div>
    
    <!-- Áõ∏ÂÜåÁÆ°ÁêÜÂºπÁ™ó -->
    <div id="manage-albums-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">ÁÆ°ÁêÜÁõ∏ÂÜå</h3>
            <div class="app-header-right" style="position: absolute; top: 15px; right: 15px;">
                <button class="action-btn small" id="create-album-btn">Êñ∞Âª∫</button>
            </div>
            <div class="modal-body">
                <div id="manage-albums-grid" class="album-grid"></div>
            </div>
            <div class="modal-actions multi-button">
                 <button id="delete-selected-albums-btn" class="danger-btn" style="display: none;">Âà†Èô§ÈÄâ‰∏≠</button>
                <button id="close-manage-albums-btn" class="cancel-btn">ÂÖ≥Èó≠</button>
            </div>
        </div>
    </div>

    <!-- Êñ∞Âª∫/ÁºñËæëÁõ∏ÂÜåÂºπÁ™ó -->
    <div id="edit-album-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title" id="edit-album-title">Êñ∞Âª∫Áõ∏ÂÜå</h3>
            <div class="modal-body">
                <input type="hidden" id="editing-album-id">
                <div class="form-group">
                    <label for="album-name-input">Áõ∏ÂÜåÂêçÁß∞</label>
                    <input type="text" id="album-name-input" placeholder="ÂøÖÂ°´">
                </div>
                <div class="form-group">
                    <label for="album-desc-input">Áõ∏ÂÜåÊèèËø∞</label>
                    <textarea id="album-desc-input" class="wide-textarea" rows="3" placeholder="ÈÄâÂ°´"></textarea>
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-edit-album-btn" class="cancel-btn">ÂèñÊ∂à</button>
                <button id="save-album-btn" class="confirm-btn">‰øùÂ≠ò</button>
            </div>
        </div>
    </div>
    <!-- ÁÆÄÊòìÂõæÁâá/ÊñáÂ≠óÊü•ÁúãÂô® -->
    <div id="simple-viewer-modal" class="modal-overlay">
        <div class="simple-viewer-content">
            <img id="simple-viewer-image" src="">
            <div id="simple-viewer-text"></div>
            <button id="simple-viewer-prev-btn" class="viewer-nav-btn prev-btn" style="display: none;">&lt;</button>
            <button id="simple-viewer-next-btn" class="viewer-nav-btn next-btn" style="display: none;">&gt;</button>
        </div>
    </div>
    <!-- ÁºñËæëÁÖßÁâá‰ø°ÊÅØÂºπÁ™ó -->
    <div id="edit-photo-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">ÁºñËæëÁÖßÁâá‰ø°ÊÅØ</h3>
            <div class="modal-body">
                <input type="hidden" id="editing-photo-id">
                <div class="form-group">
                    <label for="photo-name-input">ÁÖßÁâáÂêçÁß∞</label>
                    <input type="text" id="photo-name-input">
                </div>
                <div class="form-group">
                    <label for="photo-desc-input">ÁÖßÁâáÊèèËø∞</label>
                    <textarea id="photo-desc-input" class="wide-textarea" rows="3"></textarea>
                </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-edit-photo-btn" class="cancel-btn">ÂèñÊ∂à</button>
                <button id="save-photo-btn" class="confirm-btn">‰øùÂ≠ò</button>
            </div>
        </div>
    </div>
    <!-- ÁÖßÁâáÊü•ÁúãÂºπÁ™ó -->
    <div id="view-photo-modal" class="modal-overlay">
        <div id="photo-viewer-container">
            <!-- ÁúüÂÆûÂõæÁâáËßÜÂõæ -->
            <div id="viewer-image-view" class="photo-viewer-content">
                    <button id="view-photo-close-btn" class="photo-viewer-close-btn">&times;</button>
                    <div class="photo-viewer-image-container">
                        <div id="view-photo-name" class="photo-viewer-name"></div>
                        <img id="view-photo-image" src="">
                        <div id="view-photo-desc" class="photo-viewer-desc"></div>
                    </div>
                </div>
            <!-- ËôöÊãüÊñáÂ≠óÂõæËßÜÂõæ -->
            <div id="viewer-text-view">
                 <button id="view-photo-text-close-btn" class="photo-viewer-close-btn">&times;</button>
                 <div id="view-photo-text-display"></div>
            </div>
        </div>
        <button id="photo-viewer-prev-btn" class="viewer-nav-btn prev-btn" style="display: none;">&lt;</button>
        <button id="photo-viewer-next-btn" class="viewer-nav-btn next-btn" style="display: none;">&gt;</button>
    </div>
    <!-- ‰∏ä‰º†ÁÖßÁâáÂºπÁ™ó -->
    <div id="upload-photo-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">‰∏ä‰º†ÁÖßÁâá</h3>
            <div class="modal-body">
                <div class="form-group">
                    <label for="upload-photo-name">ÁÖßÁâáÂêçÁß∞</label>
                    <input type="text" id="upload-photo-name" placeholder="ÂøÖÂ°´Ôºå‰æãÂ¶ÇÔºöÊµ∑ËæπÁöÑÊó•ËêΩ">
                </div>
                <div class="form-group">
                    <div class="button-group">
                        <button id="upload-photo-local-btn" class="settings-button secondary">ÂõæÁâá</button>
                        <button id="upload-photo-text-btn" class="settings-button secondary">ÊñáÂ≠óÂõæ</button>
                    </div>
                     <input type="file" id="upload-photo-file-input" accept="image/*" style="display:none;" multiple>
                </div>
                <div id="upload-photo-image-preview-grid"></div>
                 <div class="form-group hidden-by-logic" id="upload-photo-text-image-input-group">
                    <label>ÊñáÂ≠óÂõæÊèèËø∞ (ÊØèË°å‰∏ÄÂº†)</label>
                    <textarea id="upload-photo-text-image-desc" class="wide-textarea" rows="2" placeholder="AIÂ∞ÜÊ†πÊçÆ‰Ω†ÁöÑÊèèËø∞ÁîüÊàêÂõæÁâá..."></textarea>
                </div>
                <div class="form-group">
                    <label for="upload-photo-desc">ÁÖßÁâáÊèèËø∞ (ÂèØÈÄâ)</label>
                    <textarea id="upload-photo-desc" class="wide-textarea" rows="2" placeholder="ËÆ∞ÂΩïËøô‰∏ÄÂàªÁöÑÊÉ≥Ê≥ï..."></textarea>
                </div>
                <div class="form-group">
                    <label for="upload-photo-album-select">‰∏ä‰º†Âà∞Áõ∏ÂÜå</label>
                    <select id="upload-photo-album-select"></select>
                </div>
                <hr>
                <div class="form-group">
                    <label>Ë∞ÅÂèØ‰ª•Áúã</label>
                    <div class="radio-group" id="upload-photo-visibility">
                        <label class="radio-label"><input type="radio" name="photo-visibility" value="public" checked><span>ÂÖ¨ÂºÄ</span></label>
                        <label class="radio-label"><input type="radio" name="photo-visibility" value="specific"><span>ÊåáÂÆöÂ•ΩÂèã</span></label>
                    </div>
                </div>
                <div class="form-group hidden-by-logic" id="upload-photo-friend-selector-container">
                    <div id="upload-photo-friend-selector" class="friend-selector-grid"></div>
                </div>
                <div class="form-group">
                <label class="checkbox-label tick-style">
                    <input type="checkbox" id="upload-photo-comment-private-checkbox">
                    <span>ËØÑËÆ∫Âå∫Âä†ÂØÜ</span>
                </label>
            </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-upload-photo-btn" class="cancel-btn">ÂèñÊ∂à</button>
                <button id="confirm-upload-photo-btn" class="confirm-btn">ÂèëÂ∏É</button>
            </div>
        </div>
    </div>
    <!-- Âä®ÊÄÅÂèëÂ∏ÉÂºπÁ™ó -->
    <div id="post-moment-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title" id="post-moment-modal-title">ÂèëË°®Âä®ÊÄÅ</h3>
            <div class="modal-body" id="post-moment-modal-body">
                <!-- ËØ¥ËØ¥ÂèëÂ∏ÉÂå∫ -->
                <div id="post-moment-status-section">
                    <div class="form-group">
                        <label>Á±ªÂûã</label>
                        <div class="radio-group" id="post-moment-status-type">
                            <label class="radio-label"><input type="radio" name="status-type" value="text" checked><span>ÊñáÂ≠ó</span></label>
                            <label class="radio-label"><input type="radio" name="status-type" value="image"><span>ÂõæÁâá</span></label>
                            <label class="radio-label"><input type="radio" name="status-type" value="text-image"><span>ÊñáÂ≠óÂõæ</span></label>
                        </div>
                    </div>
                    <div class="form-group hidden-by-logic" id="post-moment-image-buttons">
                        <div class="button-group">
                            <button id="post-moment-upload-btn" class="settings-button secondary">‰∏ä‰º†</button>
                            <button id="post-moment-add-url-btn" class="settings-button secondary">Ê∑ªÂä†URL</button>
                        </div>
                        <input type="file" id="post-moment-image-input" accept="image/*" style="display:none;" multiple>
                    </div>
                    <div class="form-group hidden-by-logic" id="post-moment-text-image-input">
                        <label>ÂõæÁâáÊèèËø∞</label>
                        <textarea id="post-moment-text-image-desc" class="wide-textarea" rows="2" placeholder="ËæìÂÖ•AIÁîüÊàêÂõæÁâáÁöÑÊèèËø∞..."></textarea>
                    </div>
                    <div class="form-group">
                        <label>ÂÜÖÂÆπ</label>
                        <textarea id="post-moment-status-content" class="wide-textarea" rows="4" placeholder="ÂàÜ‰∫´Êñ∞È≤ú‰∫ã..."></textarea>
                    </div>
                </div>
                <!-- Êó•ÂøóÂèëÂ∏ÉÂå∫ -->
                <div id="post-moment-log-section" class="hidden-by-logic">
                     <div class="form-group">
                        <label>Ê†áÈ¢ò</label>
                        <input type="text" id="post-moment-log-title" placeholder="ËØ∑ËæìÂÖ•Êó•ÂøóÊ†áÈ¢ò">
                    </div>
                    <div class="form-group">
                        <label>ÂÜÖÂÆπ</label>
                        <textarea id="post-moment-log-content" class="wide-textarea" rows="6" placeholder="ËÆ∞ÂΩï‰ªäÂ§©ÁöÑÂøÉÊÉÖ..."></textarea>
                    </div>
                </div>
                <hr>
                <!-- ÈÄöÁî®Âå∫Âüü -->
                <div class="form-group">
                    <label>Ë∞ÅÂèØ‰ª•Áúã</label>
                    <div class="radio-group" id="post-moment-visibility">
                        <label class="radio-label"><input type="radio" name="visibility" value="public" checked><span>ÂÖ¨ÂºÄ</span></label>
                        <label class="radio-label"><input type="radio" name="visibility" value="specific"><span>ÊåáÂÆöÂ•ΩÂèã</span></label>
                    </div>
                </div>
                <div class="form-group hidden-by-logic" id="post-moment-friend-selector-container">
                    <div id="post-moment-friend-selector" class="friend-selector-grid"></div>
                </div>
                                    <div class="form-group" id="post-moment-comment-privacy-container">
            <label class="checkbox-label tick-style">
                <input type="checkbox" id="post-moment-comment-private-checkbox">
                <span>ËØÑËÆ∫Âå∫Âä†ÂØÜ</span>
            </label>
        </div>
            </div>
            <div class="modal-actions row">
                <button id="cancel-post-moment-btn" class="cancel-btn">ÂèñÊ∂à</button>
                <button id="confirm-post-moment-btn" class="confirm-btn">ÂèëÂ∏É</button>
            </div>
        </div>
    </div>
                        <!-- Âä®ÊÄÅËØÑËÆ∫ÁºñËæëÂºπÁ™ó -->
        <div id="edit-moment-comment-modal" class="modal-overlay">
            <div class="modal-content">
                <h3 class="modal-title">ÁºñËæëËØÑËÆ∫</h3>
                <div class="modal-body">
                    <div class="form-group">
                        <label>ËØÑËÆ∫ËÄÖ</label>
                        <div id="moment-comment-author-selector"></div>
                    </div>
                    <div class="form-group">
                        <label>ËØÑËÆ∫ÂÜÖÂÆπ</label>
                        <textarea id="edit-moment-comment-content" class="wide-textarea" rows="4"></textarea>
                    </div>
                </div>
                <div class="modal-actions row">
                    <button id="cancel-edit-moment-comment-btn" class="cancel-btn">ÂèñÊ∂à</button>
                    <button id="save-edit-moment-comment-btn" class="confirm-btn">‰øùÂ≠ò</button>
                </div>
            </div>
        </div>
        <!-- Âä®ÊÄÅÈÄöÁü•ÂºπÁ™ó -->
        <div id="moments-notification-modal" class="modal-overlay">
            <div class="modal-content">
                <h3 class="modal-title">ÈÄöÁü•</h3>
                <div class="modal-body" style="padding: 0;">
                    <ul id="moments-notification-list" class="preset-data-list">
                        <!-- Notifications will be rendered here by JS -->
                    </ul>
                </div>
                <div class="modal-actions">
                    <button id="close-moments-notification-modal-btn" class="cancel-btn">ÂÖ≥Èó≠</button>
                </div>
            </div>
        </div>
    <!-- Ê∂àÊÅØÈïøÊåâËèúÂçï -->
    <div id="context-menu" style="display: none;">
        <button class="context-menu-btn" id="context-menu-edit">ÁºñËæë</button>
        <button class="context-menu-btn" id="context-menu-quote">ÂºïÁî®</button>
        <button class="context-menu-btn" id="context-menu-recall">Êí§Âõû</button>
        <button class="context-menu-btn" id="context-menu-copy">Â§çÂà∂</button>
        <button class="context-menu-btn" id="context-menu-multiselect">Â§öÈÄâ</button>
        <button class="context-menu-btn" id="context-menu-cancel">ÂèñÊ∂à</button>
    </div>
    <!-- ÊãÜ‰ø°‰∏éÈòÖËØªÂô® -->
    <div id="unread-letter-prompt">
        <div class="envelope-icon"><i class="fa-regular fa-envelope"></i></div>
    </div>
    <div id="love-letter-viewer">
        <!-- The folded corner is now done with CSS pseudo-elements -->
        <button class="letter-close-btn" id="letter-close-btn">&times;</button> <!-- BUG FIX: Added ID -->
        <div class="letter-content-wrapper">
            <div class="letter-salutation"></div>
            <div class="letter-body"></div>
            <div class="letter-signature">
                <span class="letter-sender-name"></span>
                <span class="letter-timestamp"></span>
                <!-- The stamp is now positioned relative to the signature area -->
                <div class="letter-stamp"></div>
                <button class="letter-reply-btn" id="letter-reply-btn" title="Âõû‰ø°"><i class="fa-solid fa-pen-nib"></i></button>
            </div>
        </div>
    </div>
    <!-- ËßÜÈ¢ëÈÄöËØùÂºπÁ™ó -->
<div id="video-call-modal" class="modal-overlay" style="z-index: 200; background-color: transparent;">
    <div id="video-call-main-view"></div>
    <div id="video-call-pip-view"></div> <!-- Note: This is now for the user in single calls -->
    <div class="video-call-content">
        <div class="video-call-header">
            <button id="video-call-minimize-btn" title="ÊúÄÂ∞èÂåñ"><i class="fa-solid fa-caret-down"></i></button>
            <!-- ÂçïËÅäÊó∂‰ΩøÁî® -->
            <div class="video-call-char-info" id="video-call-single-char-info" style="display: none;">
                <img id="video-call-avatar" class="video-call-avatar-img">
                <div id="video-call-name" class="video-call-name-text"></div>
            </div>
            <!-- Áæ§ËÅäÊó∂‰ΩøÁî® -->
            <div id="video-call-participants-container" style="display: none;">
                <!-- Participant avatars will be dynamically inserted here -->
            </div>
        </div>
        <div id="video-call-messages" class="video-call-message-box">
            <!-- Video chat messages will appear here -->
        </div>
        <div class="video-call-footer">
            <div class="video-call-controls">
                            <div class="video-call-button-placeholder">
                <button id="video-call-switch-camera-btn" class="video-call-icon-btn" style="font-size: 28px;"><i class="fa-solid fa-camera-rotate"></i></button>
                    <span>ÂàáÊç¢ÈïúÂ§¥</span>
                </div>
                <div class="video-call-button-placeholder">
                    <button id="video-call-hangup-btn" class="video-call-icon-btn hangup" style="font-size: 28px;"><i class="fa-solid fa-phone-slash"></i></button>
                    <span>ÊåÇÊñ≠</span>
                </div>
            </div>
            <div class="video-call-input-area">
                 <button id="video-call-speak-btn" class="video-call-speak-btn"><i class="fa-solid fa-microphone-lines"></i></button>
<div id="video-call-input-wrapper" style="display: none;">
                     <button id="video-call-refresh-btn" title="Âà∑Êñ∞ÂõûÂ§ç"><i class="fa-solid fa-rotate"></i></button>
                     <input type="text" id="video-call-input" placeholder="ËæìÂÖ•ÂÜÖÂÆπ...">
                     <button id="video-call-send-btn">ÂèëÈÄÅ</button>
                 </div>
            </div>
        </div>
    </div>
</div>
<!-- Floating Video Button -->
    <div id="floating-video-btn"></div>
<!-- Â£ÅÁ∫∏ÈïøÊåâËèúÂçï -->
 <!-- Êñ∞Â¢ûÔºöÊÉÖ‰π¶ÁºñËæë/Âõû‰ø°ÂºπÁ™ó -->
        <div id="edit-love-letter-modal" class="modal-overlay">
            <div class="modal-content">
                <h3 class="modal-title" id="edit-love-letter-title">ÁºñËæëÊÉÖ‰π¶</h3>
                <div class="modal-body">
                    <input type="hidden" id="editing-letter-id">
                    <input type="hidden" id="letter-reply-to-id">
                    <div class="form-group">
                    <label id="letter-recipient-label">Áß∞Âëº</label>
                    <input type="text" id="letter-recipient-input" placeholder="‰∫≤Áà±ÁöÑ...">
                </div>
                     <div class="form-group">
                        <label>ÂØÑ‰ø°‰∫∫</label>
                        <div id="letter-author-selector" class="author-selector-grid"></div>
                    </div>
                    <div class="form-group">
                        <label for="letter-subject-input">Ê†áÈ¢ò</label>
                        <input type="text" id="letter-subject-input" placeholder="ÁªôËøôÂ∞Å‰ø°Ëµ∑‰∏™Ê†áÈ¢òÂêß">
                    </div>
                    <div class="form-group">
                        <label for="letter-body-input">ÂÜÖÂÆπ</label>
                        <textarea id="letter-body-input" class="wide-textarea" rows="6" placeholder="Ê≠£Êñá..."></textarea>
                    </div>
                     <div class="form-group">
                        <label for="letter-signature-input">ËêΩÊ¨æ</label>
                        <input type="text" id="letter-signature-input" placeholder="From:">
                    </div>
                </div>
                <div class="modal-actions row">
                    <button id="cancel-edit-love-letter-btn" class="cancel-btn">ÂèñÊ∂à</button>
                    <button id="save-love-letter-btn" class="confirm-btn">‰øùÂ≠ò</button>
                </div>
            </div>
        </div>
<div id="wallpaper-context-menu" style="display: none;">
<button class="context-menu-btn" id="wp-set-wallpaper">ËÆæ‰∏∫Â£ÅÁ∫∏</button>
<button class="context-menu-btn" id="wp-set-chat-bg">ËÆæ‰∏∫ÂÖ®Â±ÄËÉåÊôØ</button>
<button class="context-menu-btn danger" id="wp-delete">Âà†Èô§</button>
</div>
    <!-- ËÉåÊôØÈÄâÈ°π‰∏ä‰∏ãÊñáËèúÂçï -->
    <div id="background-context-menu" style="display: none;">
        <button class="context-menu-btn" id="bg-menu-chat-bg">ËÅäÂ§©ËÉåÊôØ</button>
        <button class="context-menu-btn" id="bg-menu-video-bg">ËßÜÈ¢ëËÉåÊôØ</button>
    </div>
    <div id="toast"></div>

<script>

document.addEventListener('DOMContentLoaded', () => {
    // --- ÂÖ®Â±Ä DOM ÂÖÉÁ¥†Ëé∑Âèñ ---
    const getEl = (id) => document.getElementById(id);
    const query = (selector) => document.querySelector(selector);
    const queryAll = (selector) => document.querySelectorAll(selector);
    
    // --- Âü∫Á°Ä UI ---
    const timeEl = getEl('time');
    const batteryLevelEl = getEl('battery-level');
    const batteryIconEl = getEl('battery-icon');
    const toastEl = getEl('toast');
    const phoneScreen = getEl('phone-screen');

    // --- ÁÅµÂä®Â≤õ & ÈÄöÁü• ---
    const dynamicIsland = getEl('dynamic-island');
    const islandMusicInfo = query('.island-music-info');
    const islandWaveform = query('.island-waveform');
    const islandVideoIcon = query('.island-video-call-icon');
    const islandVideoTimer = query('.island-video-call-timer');
    const notificationContainer = getEl('notification-container');

    // --- APP Â±èÂπï ---
    const settingsAppScreen = getEl('settings-app-screen');
    const musicAppScreen = getEl('music-app-screen');
    const beautifyAppScreen = getEl('beautify-app-screen');
    const dataAppScreen = getEl('data-app-screen');
    const songDetailsScreen = getEl('song-details-screen');
    const chatAppScreen = getEl('chat-app-screen');
    const singleChatScreen = getEl('single-chat-screen');
    const chatSettingsScreen = getEl('chat-settings-screen');
    const groupChatSettingsScreen = getEl('group-chat-settings-screen');
    const viewAlbumScreen = getEl('view-album-screen');
    const charMomentsScreen = getEl('char-moments-screen');
    const mailAppScreen = getEl('mail-app-screen');
    const diaryAppScreen = getEl('diary-app-screen');

    // --- ËÆæÁΩÆ APP ---
    const confirmApiBtn = getEl('confirm-api-btn');
    const modelSelect = getEl('model-select');
    const presetSelect = getEl('preset-select');
    const savePresetBtn = getEl('save-preset-btn');
    const managePresetsBtn = getEl('manage-presets-btn');
    const exportDataBtn = getEl('export-data-btn');
    const importDataBtn = getEl('import-data-btn');
    const importFileInput = getEl('import-file-input');
    const managePresetsModal = getEl('manage-presets-modal');
    const closeManageModalBtn = getEl('close-manage-modal-btn');
    const presetListEl = getEl('preset-list');
    const editPresetModal = getEl('edit-preset-modal');
    const editPresetIndexInput = getEl('edit-preset-index');
    const editPresetNameInput = getEl('edit-preset-name');
    const editPresetUrlInput = getEl('edit-preset-url');
    const editPresetKeyInput = getEl('edit-preset-key');
    const saveEditBtn = getEl('save-edit-btn');
    const cancelEditBtn = getEl('cancel-edit-btn');
    const globalRealtimeInterval = getEl('global-realtime-interval');
const globalRealtimeCharSelector = getEl('global-realtime-char-selector');
const globalRealtimeSelectAll = getEl('global-realtime-select-all');

    // --- Èü≥‰πê APP & Ê≠åÊõ≤ËØ¶ÊÉÖ ---
    const audioPlayer = getEl('audio-player');
    const musicListEl = getEl('music-list');
    const addMusicBtn = getEl('add-music-btn');
    const addMusicModal = getEl('add-music-modal');
    const cancelAddMusicBtn = getEl('cancel-add-music-btn');
    const confirmAddUrlBtn = getEl('confirm-add-url-btn');
    const musicFileInput = getEl('music-file-input');
    const uploadMusicBtn = getEl('upload-music-btn');
    const musicUrlInput = getEl('music-url-input');
    const editSongModal = getEl('edit-song-modal');
    const editSongIdInput = getEl('edit-song-id');
    const editSongTitleInput = getEl('edit-song-title');
    const editSongArtistInput = getEl('edit-song-artist');
    const saveEditSongBtn = getEl('save-edit-song-btn');
    const cancelEditSongBtn = getEl('cancel-edit-song-btn');
    const songDetailsBackBtn = getEl('song-details-back-btn');
    const detailsSongTitle = getEl('details-song-title');
    const detailsSongArtist = getEl('details-song-artist');
    const detailsLyricsView = getEl('details-lyrics-view');
    const detailsCommentsList = getEl('details-comments-list');
    const commentInput = getEl('comment-input');
    const sendCommentBtn = getEl('send-comment-btn');
    const editCommentModal = getEl('edit-comment-modal');
    const editCommentInput = getEl('edit-comment-input');
    const saveEditCommentBtn = getEl('save-edit-comment-btn');
    const cancelEditCommentBtn = getEl('cancel-edit-comment-btn');

    // --- ÊµÆÂä®Ê≠åËØç & Êí≠ÊîæÂô® ---
    const playerModal = getEl('player-modal');
    const hidePlayerBtn = getEl('hide-player-btn');
    const playerSongTitle = query('#player-modal .player-song-info .title');
    const playerSongArtist = query('#player-modal .player-song-info .artist');
    const listenTogetherInfo = getEl('listen-together-info');
    const listenTogetherText = getEl('listen-together-text');
    const togglePlaylistViewBtn = getEl('toggle-playlist-view-btn');
    const playerLyricsView = getEl('player-lyrics-view');
    const playerPlaylistViewContainer = getEl('player-playlist-view-container');
    const playerPlaylistView = query('.player-playlist-view');
    const restorePlaylistBtn = getEl('restore-playlist-btn');
    const progressBar = getEl('progress-bar');
    const playerPlayPauseBtn = getEl('player-play-pause-btn');
    const lyricsLineEl = getEl('lyrics-line');
    const playerPrevBtn = getEl('player-prev-btn');
    const playerNextBtn = getEl('player-next-btn');
    const playerPlaybackModeBtn = getEl('player-playback-mode-btn');
    const playIconSrc = '<i class="fa-solid fa-circle-play"></i>';
    const pauseIconSrc = '<i class="fa-solid fa-circle-pause"></i>';

    // --- ÁæéÂåñ APP ---
    const beautifyActionBtn = getEl('beautify-action-btn');
    const bubbleActionBtn = getEl('bubble-action-btn');
    const beautifyTabs = query('#beautify-app-screen .app-bottom-tabs');
    const wallpaperGrid = getEl('wallpaper-grid');
    const wallpaperFileInput = getEl('wallpaper-file-input');
    const wallpaperContextMenu = getEl('wallpaper-context-menu');
    const fontListEl = getEl('font-list');
    const iconGrid = getEl('icon-grid');
    const bubbleGrid = getEl('bubble-grid');
    const addFontModal = getEl('add-font-modal');
    const uploadFontBtn = getEl('upload-font-btn');
    const fontFileInput = getEl('font-file-input');
    const fontUrlInput = getEl('font-url-input');
    const confirmAddFontUrlBtn = getEl('confirm-add-font-url-btn');
    const cancelAddFontBtn = getEl('cancel-add-font-btn');
    const replaceIconModal = getEl('replace-icon-modal');
    const replaceIconIdInput = getEl('replace-icon-id');
    const uploadIconBtn = getEl('upload-icon-btn');
    const iconFileInput = getEl('icon-file-input');
    const iconUrlInput = getEl('icon-url-input');
    const confirmReplaceIconUrlBtn = getEl('confirm-replace-icon-url-btn');
    const cancelReplaceIconBtn = getEl('cancel-replace-icon-btn');
    const restoreIconBtn = getEl('restore-icon-btn');

    // --- Ê∞îÊ≥°ÁºñËæëÂºπÁ™ó ---
    const editBubbleModal = getEl('edit-bubble-modal');
    const editBubbleIdInput = getEl('edit-bubble-id');
    const bubbleWidthInput = getEl('bubble-width-input');
    const bubbleHeightInput = getEl('bubble-height-input');
    const bubblePosXInput = getEl('bubble-pos-x-input');
    const bubblePosYInput = getEl('bubble-pos-y-input');
    const bubbleColorInput = getEl('bubble-color-input');
    const bubbleBgColorInput = getEl('bubble-bg-color-input');
    const bubbleBorderColorInput = getEl('bubble-border-color-input');
    const bubblePreviewWrapper = getEl('bubble-preview-wrapper');
    const bubblePreview = getEl('bubble-preview');
    const replaceBgOnlyCheckbox = getEl('replace-bg-only-checkbox');
    const uploadBubbleBtn = getEl('upload-bubble-btn');
    const bubbleFileInput = getEl('bubble-file-input');
    const bubbleUrlInput = getEl('bubble-url-input');
    const saveBubbleBtn = getEl('save-bubble-btn');
    const restoreBubbleBtn = getEl('restore-bubble-btn');
    const cancelEditBubbleBtn = getEl('cancel-edit-bubble-btn');
    const bubbleIoModal = getEl('bubble-io-modal');
    const exportBubblesBtn = getEl('export-bubbles-btn');
    const importBubblesBtn = getEl('import-bubbles-btn');
    const importBubblesInput = getEl('import-bubbles-input');
    const cancelBubbleIoBtn = getEl('cancel-bubble-io-btn');

    // --- ËµÑÊñô APP ---
    const dataAppTabs = query('#data-app-screen .app-bottom-tabs');
    const dataActionBtn = getEl('data-action-btn');
    const worldBookListEl = getEl('world-book-list');
    const archiveListEl = getEl('archive-list');
    const infoListEl = getEl('info-list');
    const dataModal = getEl('data-modal');
    const dataModalTitle = getEl('data-modal-title');
    const dataEditingIdInput = getEl('data-editing-id');
    const dataAvatarGroup = query('#data-modal .avatar-group');
    const dataAvatarPreview = getEl('data-avatar-preview');
    const dataUploadAvatarBtn = getEl('data-upload-avatar-btn');
    const dataAddAvatarUrlBtn = getEl('data-add-avatar-url-btn');
    const dataAvatarFileInput = getEl('data-avatar-file-input');
    const dataNameInput = getEl('data-name');
    const dataGroupInput = getEl('data-group');
    const dataContentInput = getEl('data-content');
    const dataGroupSelect = getEl('data-group-select');
    const saveDataBtn = getEl('save-data-btn');
    const cancelDataBtn = getEl('cancel-data-btn');
    const dataFilterBtn = getEl('data-filter-btn');
const worldBookFilterDropdown = getEl('world-book-filter-dropdown');
    // --- ËÅäÂ§© APP ---
    const chatListBackBtn = getEl('chat-list-back-btn');
    const chatListTitle = getEl('chat-list-title');
    const chatListActionBtn = getEl('chat-list-action-btn');
    const messageListEl = getEl('message-list');
    const addContactModal = getEl('add-contact-modal');
    const newContactNameInput = getEl('new-contact-name');
    const confirmAddContactBtn = getEl('confirm-add-contact-btn');
    const cancelAddContactBtn = getEl('cancel-add-contact-btn');
    const chatBackBtn = getEl('chat-back-btn');
    const chatHeaderName = getEl('chat-header-name');
    const chatHeaderStatus = getEl('chat-header-status');
    const chatHeaderSignature = getEl('chat-header-signature');
    const addFriendBtn = getEl('add-friend-btn');
    const chatSettingsBtn = getEl('chat-settings-btn');
    const chatMessagesView = getEl('chat-messages-view');
    const typingIndicator = getEl('typing-indicator');
    const chatInput = getEl('chat-input');
    const chatSendRealBtn = getEl('chat-send-real-btn');
    const chatEmojiBtn = getEl('chat-emoji-btn');
    const chatSendFakeBtn = getEl('chat-send-fake-btn');
    const chatToolbar = query('.chat-toolbar');
    const emojiPickerPanel = getEl('emoji-picker-panel');
    const closeEmojiPickerBtn = getEl('close-emoji-picker-btn');
    const addEmojiBtn = getEl('add-emoji-btn');
    const emojiGrid = getEl('emoji-grid');
    const addEmojiModal = getEl('add-emoji-modal');
    const cancelAddEmojiBtn = getEl('cancel-add-emoji-btn');
    const uploadEmojiFileBtn = getEl('upload-emoji-file-btn');
    const emojiFileInput = getEl('emoji-file-input');
    const uploadEmojiDescInput = getEl('upload-emoji-desc');
    const emojiUrlInput = getEl('emoji-url-input');
    const confirmAddEmojiUrlBtn = getEl('confirm-add-emoji-url-btn');
    const patSuffixModal = getEl('pat-suffix-modal');
    const patSuffixInput = getEl('pat-suffix-input');
    const confirmPatBtn = getEl('confirm-pat-btn');
    const cancelPatBtn = getEl('cancel-pat-btn');
    const editStatusModal = getEl('edit-status-modal');
    const statusDescInput = getEl('status-desc-input');
    const statusSelectGroup = getEl('status-select-group');
    const confirmEditStatusBtn = getEl('confirm-edit-status-btn');
    const cancelEditStatusBtn = getEl('cancel-edit-status-btn');
    const voiceInputModal = getEl('voice-input-modal');
    const voiceTextInput = getEl('voice-text-input');
    const confirmVoiceBtn = getEl('confirm-voice-btn');
    const cancelVoiceBtn = getEl('cancel-voice-btn');
    const cameraInputModal = getEl('camera-input-modal');
    const cameraTextInput = getEl('camera-text-input');
    const confirmCameraBtn = getEl('confirm-camera-btn');
    const cancelCameraBtn = getEl('cancel-camera-btn');
    const linkShareModal = getEl('link-share-modal');
    const linkTitleInput = getEl('link-title-input');
    const linkSummaryInput = getEl('link-summary-input');
    const linkSourceInput = getEl('link-source-input');
    const linkContentInput = getEl('link-content-input');
    const confirmLinkBtn = getEl('confirm-link-btn');
    const cancelLinkBtn = getEl('cancel-link-btn');
    const redPacketModal = getEl('red-packet-modal');
    const redPacketAmountInput = getEl('red-packet-amount-input');
    const redPacketMessageInput = getEl('red-packet-message-input');
    const confirmRedPacketBtn = getEl('confirm-red-packet-btn');
    const cancelRedPacketBtn = getEl('cancel-red-packet-btn');
    const groupRedPacketModal = getEl('group-red-packet-modal');
    const groupRedPacketMemberGrid = getEl('group-red-packet-member-grid');
    const cancelGroupRedPacketBtn = getEl('cancel-group-red-packet-btn');
    const confirmGroupRedPacketBtn = getEl('confirm-group-red-packet-btn');
    const chatImageInput = getEl('chat-image-input');
    const viewContentModal = getEl('view-content-modal');
    const viewContentTitle = getEl('view-content-title');
    const viewContentBody = getEl('view-content-body');
    const closeViewContentBtn = getEl('close-view-content-btn');
    const contextMenu = getEl('context-menu');
    const editMessageModal = getEl('edit-message-modal');
    const editingMessageIdInput = getEl('editing-message-id');
    const editMessageTypeGroup = getEl('edit-message-type-group');
    const editMessageInputsContainer = getEl('edit-message-inputs-container');
    const saveEditMessageBtn = getEl('save-edit-message-btn');
    const cancelEditMessageBtn = getEl('cancel-edit-message-btn');
    const quotePreview = getEl('quote-preview');
    const quotePreviewContent = getEl('quote-preview-content');
    const closeQuoteBtn = getEl('close-quote-btn');

    // --- Âä®ÊÄÅ (Moments) APP ---
    const momentsTabContent = getEl('moments-tab-content');
    const momentsNotificationBtn = getEl('moments-notification-btn');
    const momentsNotificationBadge = getEl('moments-notification-badge');
    const postMomentModal = getEl('post-moment-modal');
    const cancelPostMomentBtn = getEl('cancel-post-moment-btn');
    const confirmPostMomentBtn = getEl('confirm-post-moment-btn');
    const editMomentCommentModal = getEl('edit-moment-comment-modal'); // Êñ∞Â¢û
    const cancelEditMomentCommentBtn = getEl('cancel-edit-moment-comment-btn'); // Êñ∞Â¢û
    const saveEditMomentCommentBtn = getEl('save-edit-moment-comment-btn'); // Êñ∞Â¢û

    // --- ÂçïËÅäËÆæÁΩÆÁïåÈù¢ ---
    const csCharName = getEl('cs-char-name');
    const csWorldBookGroupSelector = getEl('cs-world-book-group-selector');
    const csWorldBookListContainer = getEl('cs-world-book-list-container');
    const csWorldBookList = getEl('cs-world-book-list');
    const csCharAvatar = getEl('cs-char-avatar');
    const csCharAvatarLibraryBtn = getEl('cs-char-avatar-library-btn');
    const csCharAvatarFrameBtn = getEl('cs-char-avatar-frame-btn');
    const csCharBackgroundBtn = getEl('cs-char-background-btn');
    const csContextMemory = getEl('cs-context-memory');
    const csPersona = getEl('cs-persona');
    const csSavePersonaBtn = getEl('cs-save-persona-btn');
    const csLoadPersonaBtn = getEl('cs-load-persona-btn');
    const csClearHistoryBtn = getEl('cs-clear-history-btn');
    const csDeleteFriendBtn = getEl('cs-delete-friend-btn');
    const csRealtimeActivityToggle = getEl('cs-realtime-activity-toggle');
    const csRealtimeIntervalGroup = getEl('cs-realtime-interval-group');
    const csRealtimeInterval = getEl('cs-realtime-interval');
    const csRestoreBtn = getEl('cs-restore-btn');
    const usUserName = getEl('us-user-name');
    const usUserAvatar = getEl('us-user-avatar');
    const usUserAvatarLibraryBtn = getEl('us-user-avatar-library-btn');
    const usUserAvatarFrameBtn = getEl('us-user-avatar-frame-btn');
    const usPersona = getEl('us-persona');
    const usSavePersonaBtn = getEl('us-save-persona-btn');
    const usLoadPersonaBtn = getEl('us-load-persona-btn');
    
    // --- Áæ§ËÅäËÆæÁΩÆÁïåÈù¢ ---
    const gcsBackBtn = getEl('gcs-back-btn');
    const gcsGroupName = getEl('gcs-group-name');
    const gcsWorldBookGroupSelector = getEl('gcs-world-book-group-selector');
    const gcsWorldBookListContainer = getEl('gcs-world-book-list-container');
    const gcsWorldBookList = getEl('gcs-world-book-list');
    const gcsGroupAvatar = getEl('gcs-group-avatar');
    const gcsGroupAvatarLibraryBtn = getEl('gcs-group-avatar-library-btn');
    const gcsGroupBackgroundBtn = getEl('gcs-group-background-btn');
    const gcsContextMemory = getEl('gcs-context-memory');
    const gcsMemberList = getEl('gcs-member-list');
    const gcsClearHistoryBtn = getEl('gcs-clear-history-btn');
    const gcsMuteAllBtn = getEl('gcs-mute-all-btn');
    const gcsDisbandBtn = getEl('gcs-disband-btn');
    const gcsUsUserName = getEl('gcs-us-user-name');
    const gcsUsUserAvatar = getEl('gcs-us-user-avatar');
    const gcsUsUserAvatarLibraryBtn = getEl('gcs-us-user-avatar-library-btn');
    const gcsUsUserAvatarFrameBtn = getEl('gcs-us-user-avatar-frame-btn');
    const gcsUsPersona = getEl('gcs-us-persona');
    const gcsUsSavePersonaBtn = getEl('gcs-us-save-persona-btn');
    const gcsUsLoadPersonaBtn = getEl('gcs-us-load-persona-btn');
    const gcsMemberModal = getEl('gcs-member-modal');
    const gcsMemberModalTitle = getEl('gcs-member-modal-title');
    const gcsEditingMemberIdInput = getEl('gcs-editing-member-id');
    const gcsMemberNickname = getEl('gcs-member-nickname');
    const gcsMemberWorldBookGroupSelector = getEl('gcs-member-world-book-group-selector');
    const gcsMemberWorldBookListContainer = getEl('gcs-member-world-book-list-container');
    const gcsMemberWorldBookList = getEl('gcs-member-world-book-list');
    const gcsMemberAvatar = getEl('gcs-member-avatar');
    const gcsMemberAvatarLibraryBtn = getEl('gcs-member-avatar-library-btn');
    const gcsMemberAvatarFrameBtn = getEl('gcs-member-avatar-frame-btn');
    const gcsMemberPersona = getEl('gcs-member-persona');
    const gcsMemberSavePersonaBtn = getEl('gcs-member-save-persona-btn');
    const gcsMemberLoadPersonaBtn = getEl('gcs-member-load-persona-btn');
    const gcsMemberModalCancelBtn = getEl('gcs-member-modal-cancel-btn');
    const gcsMemberModalSaveBtn = getEl('gcs-member-modal-save-btn');
    const gcsManageMembersModal = getEl('gcs-manage-members-modal');
    const gcsManageMembersTitle = getEl('gcs-manage-members-title');
    const gcsManageMembersList = getEl('gcs-manage-members-list');
    const gcsManageMembersCancelBtn = getEl('gcs-manage-members-cancel-btn');
    const gcsManageMembersConfirmBtn = getEl('gcs-manage-members-confirm-btn');
    const gcsMemberActionModal = getEl('gcs-member-action-modal');
    const gcsMemberActionTitle = getEl('gcs-member-action-title');
    const gcsMemberActionBody = getEl('gcs-member-action-body');
    const gcsMemberActionCancelBtn = getEl('gcs-member-action-cancel-btn');
    // --- Êñ∞Â¢ûÂºπÁ™ó ---
    const uploadPhotoModal = getEl('upload-photo-modal');
    const manageAlbumsModal = getEl('manage-albums-modal');
    const editAlbumModal = getEl('edit-album-modal');
    const editPhotoModal = getEl('edit-photo-modal');
    const leaveMessageModal = getEl('leave-message-modal');
    const viewPhotoModal = getEl('view-photo-modal');
    const simpleViewerModal = getEl('simple-viewer-modal');
    // --- Âä®ÊÄÅÈÄöÁü• ---
    const momentsNotificationModal = getEl('moments-notification-modal');
    const closeMomentsNotificationModalBtn = getEl('close-moments-notification-modal-btn');
    const momentsNotificationList = getEl('moments-notification-list');
    // --- ‰ø°ÁÆ± APP ‰ºòÂåñÂÖÉÁ¥† ---
        const mailFabContainer = getEl('mail-fab-container');
        const editLoveLetterModal = getEl('edit-love-letter-modal');
        const letterReplyBtn = getEl('letter-reply-btn');
    // --- Êù•ÁîµUIÂÖÉÁ¥† ---
        const incomingCallBanner = getEl('incoming-call-banner');
        const incomingCallAvatar = getEl('incoming-call-avatar');
        const incomingCallName = getEl('incoming-call-name');
        const incomingCallAcceptBtn = getEl('incoming-call-accept-btn');
        const incomingCallRejectBtn = getEl('incoming-call-reject-btn');
    // --- ËßÜÈ¢ëÈÄöËØùÂÖÉÁ¥† (ÈáçÊûÑ) ---
    const videoCallModal = getEl('video-call-modal');
    const videoCallMainView = getEl('video-call-main-view');
    const videoCallPipView = getEl('video-call-pip-view');
    const videoCallAvatar = getEl('video-call-avatar'); // Still used for single chat
    const videoCallName = getEl('video-call-name'); // Still used for single chat
    const videoCallSingleCharInfo = getEl('video-call-single-char-info');
    const videoCallParticipantsContainer = getEl('video-call-participants-container');
    const videoCallMessages = getEl('video-call-messages');
    const videoCallMinimizeBtn = getEl('video-call-minimize-btn');
    const videoCallSwitchCameraBtn = getEl('video-call-switch-camera-btn');
    const videoCallHangupBtn = getEl('video-call-hangup-btn');
    const videoCallSpeakBtn = getEl('video-call-speak-btn');
    const videoCallInputWrapper = getEl('video-call-input-wrapper');
    const videoCallInput = getEl('video-call-input');
    const videoCallSendBtn = getEl('video-call-send-btn');
    const videoCallRefreshBtn = getEl('video-call-refresh-btn');
    const videoCallFloatBtn = getEl('floating-video-btn'); // Corrected ID
    // --- ÈÄöÁî®/ÂÖ±‰∫´ÂºπÁ™ó ---
    const libraryModal = getEl('library-modal');
    const libraryModalTitle = getEl('library-modal-title');
    const libraryModalPreviewArea = getEl('library-modal-preview-area');
    const libraryUploadBtn = getEl('library-upload-btn');
    const libraryAddUrlBtn = getEl('library-add-url-btn');
    const libraryGrid = getEl('library-grid');
    const libraryFileInput = getEl('library-file-input');
    const libraryDeleteBtn = getEl('library-delete-btn');
    const libraryCloseBtn = getEl('library-close-btn');
    const libraryModeToggleBtn = getEl('library-mode-toggle-btn');
    const loadPersonaModal = getEl('load-persona-modal');
    const loadPersonaTitle = getEl('load-persona-title');
    const loadPersonaList = getEl('load-persona-list');
    const loadPersonaCancelBtn = getEl('load-persona-cancel-btn');
    // Function to open the persona loading modal
    function openLoadPersonaModal(dataType, settingsGroup, memberId = null) {
        // Store context for when an item is selected
        runtimeState.personaLoadContext = { dataType, settingsGroup, memberId };
        
        const dataArray = appState.data[dataType + 's'];
        loadPersonaTitle.textContent = `ËØªÂèñ${dataType === 'archive' ? 'Ê°£Ê°à' : '‰ø°ÊÅØ'}`;

        if (dataArray.length === 0) {
            loadPersonaList.innerHTML = `<p style="text-align:center; color:#888;">ÊöÇÊó†ÂÜÖÂÆπÂèØËØªÂèñ</p>`;
        } else {
            loadPersonaList.innerHTML = ''; // Clear previous list
            dataArray.forEach(item => {
                const li = document.createElement('li');
                li.className = 'preset-data-item'; // Use existing class for styling
                li.dataset.id = item.id;
                
                // Use the same layout as the Data App lists for consistency
                li.innerHTML = `
                    <div class="preset-data-item-content" style="cursor: pointer;">
                        <div class="preset-data-avatar"></div>
                        <div class="preset-data-info">
                            <div class="preset-data-name">${escapeHTML(item.name)}</div>
                            <div class="preset-data-excerpt">${escapeHTML(item.content.substring(0, 20) || 'Êó†ÂÜÖÂÆπ')}...</div>
                        </div>
                    </div>`;
                
                loadPersonaList.appendChild(li);
                setElementImage(li.querySelector('.preset-data-avatar'), item.avatarId);
            });
        }
        loadPersonaModal.classList.add('visible');
    }

    // Event listener for selecting a persona from the modal list
    loadPersonaList.addEventListener('click', (e) => {
        const item = e.target.closest('.preset-data-item');
        if (!item) return;

        const dataId = item.dataset.id;
        const { dataType, settingsGroup, memberId } = runtimeState.personaLoadContext;
        const dataItem = appState.data[dataType + 's'].find(d => d.id === dataId);

        if (!dataItem) {
            showToast('Êó†Ê≥ïÊâæÂà∞ÊâÄÈÄâËµÑÊñô', 'error');
            return;
        }

        if (memberId) {
            // Case: Editing a group member in the gcs-member-modal
            runtimeState.tempGcsMemberSettings.nickname = dataItem.name;
            runtimeState.tempGcsMemberSettings.avatarId = dataItem.avatarId;
            runtimeState.tempGcsMemberSettings.persona = dataItem.content;
            loadGcsMemberModalUI();
        } else {
            // Case: Editing in single chat settings OR group chat "my settings" tab
            const targetSettings = runtimeState.tempChatSettings[settingsGroup];
            targetSettings.name = dataItem.name;
            targetSettings.avatarId = dataItem.avatarId;
            targetSettings.persona = dataItem.content;
            
            // If editing user settings within a group chat, also update the nickname in the members list
            if (groupChatSettingsScreen.classList.contains('active') && settingsGroup === 'userSettings') {
                const userInGroup = runtimeState.tempChatSettings.groupSettings.members['user'];
                userInGroup.nickname = dataItem.name;
                userInGroup.avatarId = dataItem.avatarId;
            }
            
            // Refresh the correct settings screen UI
            if (chatSettingsScreen.classList.contains('active')) {
                loadSingleChatSettingsUI();
            } else if (groupChatSettingsScreen.classList.contains('active')) {
                loadGroupChatSettingsUI();
            }
        }

        loadPersonaModal.classList.remove('visible');
        showToast('ËµÑÊñôÂ∑≤ÊàêÂäüËØªÂèñÔºÅ');
    });

    // Event listener for the cancel button in the persona modal
    loadPersonaCancelBtn.addEventListener('click', () => {
        loadPersonaModal.classList.remove('visible');
    });

    // --- ÂÖ®Â±ÄÁä∂ÊÄÅÁÆ°ÁêÜ (ÂèØÂ∫èÂàóÂåñ) ---
    const DB_KEY = 'EmperorPhoneData_v2';
    const DEFAULT_WALLPAPER_URL = 'https://img.xjh.me/random_img.php?type=bg&ctype=nature&return=302';
    let appState = {};

    // --- ÂÖ®Â±ÄËøêË°åÊó∂Áä∂ÊÄÅ (‰∏çÂèØÂ∫èÂàóÂåñ) ---
    let runtimeState = {};
    let islandVideoCallTimer = null;
    let conversationLoadMoreHandler = null;
    

    // ===================================================================
    // --- Áä∂ÊÄÅÁÆ°ÁêÜÈáçÊûÑ ---
    // ===================================================================
    function getInitialState() {
return {
    settings: { apiUrl: '', apiKey: '', selectedModel: '', availableModels: [], presets: [], globalRealtimeActivity: { interval: 30 } },
    music: { playlist: [], queue: [], lyrics: {}, comments: {}, currentQueueIndex: -1, playbackMode: 'repeat' },
    beautify: {
    wallpapers: [],
    currentWallpaperId: 'default',
    currentChatBgId: 'default',
    fonts: [],
    currentFont: 'default',
    fontColor: '#000000',
    icons: {},
    bubbleSettings: { global: {}, specific: {} }
    },
    data: { worldBooks: [], archives: [], infos: [] },
    chat: {
    contacts: [],
    emojis: [],
    videoCallState: { isActive: false, chatId: null, isGroup: false, participants: [], startTime: null, log: [], isMinimized: false, isCameraSwapped: false, initiator: null, lastRejectedCallTimestamp: null },
    userProfile: {
    name: 'ÂúüÁöáÂ∏ù',
    avatarId: 'default_user_avatar',
    avatarFrameId: '',
    avatarLibrary: [],
    avatarFrameLibrary: [],
    persona: 'ÂÖ®ÁΩëÂîØ‰∏ÄÂúüÁöáÂ∏ù',
    signature: 'ÂÖ®ÁΩëÂîØ‰∏ÄÂúüÁöáÂ∏ù'
    },
    moments: {
    profile: {
    name: 'ÂúüÁöáÂ∏ù',
    signature: 'ÂÖ®ÁΩëÂîØ‰∏ÄÂúüÁöáÂ∏ù',
    avatarId: 'default_moments_avatar',
    coverId: 'default_moments_cover',
    },
    posts: [], // Âä®ÊÄÅ
    photos: [], // ÁÖßÁâáÂ∫ì
    albums: [], // Áõ∏ÂÜå
    messages: [], // ÁïôË®Ä
    notifications: [],
    visitors: []
    },
    mailbox: { 
                        activeTab: 'love-letter',
                        loveLetters: [] 
                    },
                    diary: { activeTab: 'secret-diary' }
                    }
    };
    }

    function getInitialRuntimeState() {
        return {
            originalIconContent: {},
            originalBubbleContent: {},
            isDetailsAnimatingIn: false,
            currentChatId: null,
            contactSelection: [],
            worldBookFilter: { selectedGroups: ['all'] },
            patTarget: { type: null, element: null, memberId: null },
            editingComment: { source: null, songId: null, postId: null, commentId: null, replyId: null },
            contextMenuTarget: null,
            wallpaperContextMenuTarget: null,
            chatSelectionMode: false,
            selectedMessages: [],
            quotedMessage: null,
            tempChatSettings: {},
            originalChatSettings: {},
            libraryContext: {},
            librarySelection: [],
            groupRedPacketContext: {},
            tempGcsMemberSettings: {},
            gcsManageContext: { type: '', selection: [] },
            gcsMemberActionContext: { memberId: null },
            realtimeActivityTimers: {},
            activeRequests: {},
            notificationQueue: [],
            musicSessionType: null,
            videoCallContext: {
                            aiIsResponding: false,
                            userIsTyping: false
                        },
                    incomingCall: { from: null, timer: null },
            isNotificationVisible: false,
            currentlyPlayingVoiceTimer: null,
            chatDisplayLimits: {},
            mediaObjectURLs: new Map(),
            emojiSelectionMode: false,
            selectedEmojis: [],
            moments: {
                currentFilter: 'all',
                isFabMenuOpen: false,
                currentProfileId: 'user', 
                postContext: {},
                viewerContext: { items: [], currentIndex: 0 }
        },
        videoCallContext: { // Add this new object
            aiIsResponding: false,
            userIsTyping: false
        }
    };
}

    function saveState() { 
        try { 
            const stateToSave = JSON.stringify(appState);
            localStorage.setItem(DB_KEY, stateToSave); 
        } catch (error) { 
            console.error("CRITICAL: ‰øùÂ≠òÁä∂ÊÄÅÂ§±Ë¥• (Serialization Error):", error); 
            console.error("Failing state object:", appState);
            showToast("‰øùÂ≠òÊï∞ÊçÆÂ§±Ë¥•ÔºÅËØ∑Ê£ÄÊü•ÊéßÂà∂Âè∞„ÄÇ", 'error'); 
        } 
    }
    let saveStateTimer;
    function debouncedSaveState() {
        clearTimeout(saveStateTimer);
        saveStateTimer = setTimeout(() => {
            saveState();
        }, 500); // 500ms delay
    }
    function loadState() { 
        const savedStateJSON = localStorage.getItem(DB_KEY); 
        const defaultState = getInitialState();
        if (savedStateJSON) { 
            try {
                const savedState = JSON.parse(savedStateJSON);

                appState = { 
                ...defaultState, 
                ...savedState, 
                settings: { ...defaultState.settings, ...savedState.settings, globalRealtimeActivity: { ...defaultState.settings.globalRealtimeActivity, ...(savedState.settings?.globalRealtimeActivity || {}) } },
                    music: { ...defaultState.music, ...savedState.music }, 
                    beautify: { ...defaultState.beautify, ...savedState.beautify, bubbleSettings: { ...defaultState.beautify.bubbleSettings, ...(savedState.beautify?.bubbleSettings || {}) } }, 
                    data: { ...defaultState.data, ...(savedState.data || {}) }, 
                    chat: { 
                        ...defaultState.chat, 
                        ...savedState.chat, 
                        userProfile: { ...defaultState.chat.userProfile, ...(savedState.chat?.userProfile || {}) },
                        moments: { ...defaultState.chat.moments, ...(savedState.chat?.moments || {}), profile: { ...defaultState.chat.moments.profile, ...(savedState.chat?.moments?.profile || {}) }, notifications: (savedState.chat?.moments?.notifications || []) }
                    },
                    mailbox: { ...defaultState.mailbox, ...(savedState.mailbox || {}), loveLetters: (savedState.mailbox?.loveLetters || []) },
                    diary: { ...defaultState.diary, ...(savedState.diary || {}) }
                };
                if (!appState.beautify.bubbleSettings) appState.beautify.bubbleSettings = defaultState.beautify.bubbleSettings;
                if (!appState.music.comments) appState.music.comments = {};
                if (!Array.isArray(appState.settings.presets)) appState.settings.presets = [];
                if (!appState.data.worldBooks) appState.data.worldBooks = [];
                if (!appState.chat.emojis) appState.chat.emojis = [];
                if (!appState.chat.moments) appState.chat.moments = defaultState.chat.moments;
                if (!appState.chat.userProfile.avatarFrameLibrary) appState.chat.userProfile.avatarFrameLibrary = [];
                if (!appState.chat.userProfile.signature) appState.chat.userProfile.signature = defaultState.chat.userProfile.signature;
                if (!appState.chat.moments.profile.signature) appState.chat.moments.profile.signature = defaultState.chat.moments.profile.signature;
                if (!Array.isArray(appState.chat.moments.notifications)) { appState.chat.moments.notifications = []; }
                
                
            } catch (e) {
                console.error("Failed to parse saved state, resetting to default.", e);
                appState = defaultState;
            }
        } else {
            appState = defaultState;
        }
        updateUIFromState(); 
    }

    // ===================================================================
    // --- IndexedDB Â™í‰ΩìÂ≠òÂÇ® ---
    // ===================================================================
    const IDB_NAME = 'EmperorPhoneMedia_v2';
    const IDB_STORE_NAME = 'mediaStore';
    let db;

    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(IDB_NAME, 1);
            request.onerror = (event) => reject("IndexedDB error: " + request.error);
            request.onsuccess = (event) => {
                db = event.target.result;
                resolve(db);
            };
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(IDB_STORE_NAME)) {
                    db.createObjectStore(IDB_STORE_NAME, { keyPath: 'id' });
                }
            };
        });
    }

    async function addMediaToDB(id, data) { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IDB_STORE_NAME); return new Promise((resolve, reject) => { const request = store.put({ id, data }); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); }
    async function getMediaFromDB(id) { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_STORE_NAME], 'readonly'); const store = transaction.objectStore(IDB_STORE_NAME); return new Promise((resolve, reject) => { const request = store.get(id); request.onsuccess = () => resolve(request.result ? request.result.data : null); request.onerror = () => reject(request.error); }); }
    async function deleteMediaFromDB(id) { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IDB_STORE_NAME); return new Promise((resolve, reject) => { const request = store.delete(id); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); }
    async function getAllMediaFromDB() { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_STORE_NAME], 'readonly'); const store = transaction.objectStore(IDB_STORE_NAME); return new Promise((resolve, reject) => { const request = store.getAll(); request.onsuccess = () => resolve(request.result); request.onerror = () => reject(request.error); }); }
    async function clearMediaDB() { if (!db) throw new Error("DB not initialized"); const transaction = db.transaction([IDB_STORE_NAME], 'readwrite'); const store = transaction.objectStore(IDB_STORE_NAME); return new Promise((resolve, reject) => { const request = store.clear(); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); }
    async function getMediaURL(id) { if (!id || id === 'default' || id.startsWith('https://') || id.startsWith('data:')) return id; if (runtimeState.mediaObjectURLs.has(id)) return runtimeState.mediaObjectURLs.get(id); try { const data = await getMediaFromDB(id); if (data) { const blob = (data instanceof Blob) ? data : new Blob([data]); const url = URL.createObjectURL(blob); runtimeState.mediaObjectURLs.set(id, url); return url; } return null; } catch (error) { console.error(`Failed to get media URL for ${id}:`, error); return null; } }
    async function setElementImage(element, id, property = 'backgroundImage') { if (!element) return; const url = await getMediaURL(id); if (url) { if (property === 'src') { element.src = url; } else { element.style.backgroundImage = `url("${url}")`; } } else { if (property === 'src') { element.src = ''; } else { element.style.backgroundImage = 'none'; } } }

    // ===================================================================
    // --- ÂÆåÊï¥Â§á‰ªΩ‰∏éÊÅ¢Â§ç ---
    // ===================================================================
    function downloadFile(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(url);
        a.remove();
    }

    getEl('export-config-btn').addEventListener('click', () => {
        try {
            const dataStr = JSON.stringify(appState);
            const blob = new Blob([dataStr], { type: 'application/json' });
            downloadFile(blob, `EmperorPhone-ConfigBackup-${new Date().toISOString().slice(0, 10)}.json`);
            showToast("ÈÖçÁΩÆ‰∏éËÆ∞ÂΩïÂ∑≤ÂØºÂá∫ÔºÅ");
        } catch (error) {
            showToast("ÂØºÂá∫ÈÖçÁΩÆÂ§±Ë¥•", 'error');
            console.error(error);
        }
    });

    getEl('import-config-btn').addEventListener('click', () => {
        importFileInput.accept = '.json';
        importFileInput.onchange = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                if (confirm("ËøôÂ∞ÜË¶ÜÁõñÊâÄÊúâÂΩìÂâçÁöÑÈÖçÁΩÆÂíåËÅäÂ§©ËÆ∞ÂΩïÔºàÂ™í‰ΩìÊñá‰ª∂‰∏çÂèóÂΩ±ÂìçÔºâÔºåÁ°ÆÂÆöÂêóÔºü")) {
                    try {
                        const importedState = JSON.parse(e.target.result);
                        localStorage.setItem(DB_KEY, JSON.stringify(importedState));
                        showToast("ÂØºÂÖ•ÊàêÂäüÔºåÊ≠£Âú®Âà∑Êñ∞...", 'info');
                        setTimeout(() => window.location.reload(), 1500);
                    } catch (error) {
                        showToast(`ÂØºÂÖ•Â§±Ë¥•: ${error.message}`, 'error');
                        console.error("ÂØºÂÖ•ÈîôËØØ:", error);
                    }
                }
                importFileInput.value = ''; // Reset for next import
            };
            reader.readAsText(file);
        };
        importFileInput.click();
    });

    getEl('export-media-btn').addEventListener('click', async () => {
        showToast("Ê≠£Âú®ÊâìÂåÖÂ™í‰ΩìÂ∫ì...", 'info');
        try {
            const zip = new JSZip();
            const mediaItems = await getAllMediaFromDB();
            if (mediaItems.length === 0) {
                showToast("Â™í‰ΩìÂ∫ì‰∏∫Á©∫ÔºåÊó†ÈúÄÂØºÂá∫„ÄÇ");
                return;
            }
            mediaItems.forEach(item => {
                zip.file(item.id, item.data);
            });
            const content = await zip.generateAsync({ type: "blob" });
            downloadFile(content, `EmperorPhone-MediaBackup-${new Date().toISOString().slice(0, 10)}.zip`);
            showToast("Â™í‰ΩìÂ∫ìÂ∑≤ÂØºÂá∫‰∏∫ZIPÔºÅ");
        } catch (error) {
            showToast("ÂØºÂá∫Â™í‰ΩìÂ∫ìÂ§±Ë¥•", 'error');
            console.error(error);
        }
    });
    
    getEl('import-media-btn').addEventListener('click', () => {
        importFileInput.accept = '.zip';
        importFileInput.onchange = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            if (confirm("ËøôÂ∞ÜÂØºÂÖ•ZIPÂåÖ‰∏≠ÁöÑÊâÄÊúâÂ™í‰ΩìÊñá‰ª∂ÔºåÂ¶ÇÊûúÂ≠òÂú®ÂêåÂêçÊñá‰ª∂ÔºåÊóßÊñá‰ª∂Â∞ÜË¢´Ë¶ÜÁõñ„ÄÇÁ°ÆÂÆöÂêóÔºü")) {
                showToast("Ê≠£Âú®Ëß£ÂéãÂπ∂ÂØºÂÖ•Â™í‰Ωì...", 'info');
                JSZip.loadAsync(file).then(async (zip) => {
                    const promises = [];
                    zip.forEach((relativePath, zipEntry) => {
                        const promise = zipEntry.async("blob").then(blobData => {
                            return addMediaToDB(zipEntry.name, blobData);
                        });
                        promises.push(promise);
                    });
                    await Promise.all(promises);
                    showToast(`Â™í‰ΩìÂ∫ìÂØºÂÖ•ÊàêÂäüÔºÅÂÖ± ${promises.length} ‰∏™Êñá‰ª∂„ÄÇÊ≠£Âú®Âà∑Êñ∞...`, 'info');
                    setTimeout(() => window.location.reload(), 1500);
                }).catch(error => {
                    showToast('Ëß£ÂéãÊàñÂØºÂÖ•Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•Êñá‰ª∂Ê†ºÂºè„ÄÇ', 'error');
                    console.error(error);
                });
            }
            importFileInput.value = ''; // Reset
        };
        importFileInput.click();
    });

    // ===================================================================
    // --- Âü∫Á°Ä UI & Á≥ªÁªüÂäüËÉΩ ---
    // ===================================================================
    function updateTime() { const now = new Date(); timeEl.textContent = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`; }
async function updateBattery() { try { if ('getBattery' in navigator) { const battery = await navigator.getBattery(); const update = async () => { const level = Math.floor(battery.level * 100); batteryLevelEl.textContent = `${level}%`; const isCharging = battery.charging; batteryIconEl.dataset.iconId = isCharging ? 'status-battery-charging' : 'status-battery-default'; const customIconId = appState.beautify.icons[batteryIconEl.dataset.iconId]; if (customIconId) { await setElementImage(batteryIconEl.querySelector('img') || batteryIconEl, customIconId, 'src'); } else { batteryIconEl.innerHTML = isCharging ? '<i class="fa-solid fa-battery-empty"></i>' : '<i class="fa-solid fa-battery-full"></i>'; } }; await update(); battery.addEventListener('levelchange', update); battery.addEventListener('chargingchange', update); } else { throw new Error("getBattery not supported"); } } catch (error) { batteryLevelEl.textContent = '100%'; batteryIconEl.dataset.iconId = 'status-battery-default'; const customIconId = appState.beautify.icons['status-battery-default']; if (customIconId) { await setElementImage(batteryIconEl.querySelector('img') || batteryIconEl, customIconId, 'src'); } else { batteryIconEl.innerHTML = '<i class="fa-solid fa-battery-full"></i>'; } } }    let toastTimer;
    function showToast(message, type = 'info') { toastEl.textContent = message; toastEl.className = `show ${type}`; clearTimeout(toastTimer); toastTimer = setTimeout(() => toastEl.classList.remove('show'), 2500); }
    function truncateText(text, maxLength) {
        if (typeof text !== 'string' || text.length <= maxLength) {
            return text;
        }
        let truncated = text.substring(0, maxLength);
        const lastChar = truncated.slice(-1);
        const punctuation = /[Ôºå„ÄÇÔºÅÔºü„ÄÅÔºõÔºö,.;?!]/;
        if (punctuation.test(lastChar)) {
            return truncated.slice(0, -1) + '‚Ä¶';
        } else {
            return truncated + '‚Ä¶';
        }
    }
    function getDisplayLength(str) { let len = 0; for (let i = 0; i < str.length; i++) { len += str.charCodeAt(i) > 255 ? 2 : 1; } return len; }
    function queueNotification(content, contactId, senderId, type = 'chat') { if (type === 'chat' && singleChatScreen.classList.contains('active') && runtimeState.currentChatId === contactId) { return; } if (type === 'moments' && query('#chat-app-screen .tab-link[data-tab="moments"]')?.classList.contains('active')) { return; } runtimeState.notificationQueue.push({ content, contactId, senderId, type }); processNotificationQueue(); }
    function processNotificationQueue() { if (runtimeState.isNotificationVisible || runtimeState.notificationQueue.length === 0) return; runtimeState.isNotificationVisible = true; const { content, contactId, senderId, type } = runtimeState.notificationQueue.shift(); const sender = findUserById(senderId); let message; if (type === 'chat') { const contact = appState.chat.contacts.find(c => c.id === contactId); const senderName = contact?.isGroup ? (contact.groupSettings.members[senderId]?.nickname || sender.name) : sender.name; message = `${senderName}: ${content}`; } else { message = content; } const displayMsg = truncateText(message, 20); const banner = document.createElement('div'); banner.className = 'notification-banner'; banner.textContent = displayMsg; banner.dataset.contactId = contactId; banner.dataset.type = type; notificationContainer.appendChild(banner); setTimeout(() => banner.classList.add('show'), 50); const dismiss = () => { banner.classList.remove('show'); const timer = setTimeout(() => { banner.remove(); runtimeState.isNotificationVisible = false; processNotificationQueue(); }, 400); banner.addEventListener('transitionend', () => { clearTimeout(timer); banner.remove(); runtimeState.isNotificationVisible = false; processNotificationQueue(); }, { once: true }); }; const handleClick = (event) => {
                    event.stopPropagation(); const id = banner.dataset.contactId; const notifType = banner.dataset.type; if (notifType === 'moments') { openApp(chatAppScreen); query('#chat-app-screen .tab-link[data-tab="moments"]').click(); } else if (id && id !== 'null' && id !== 'system') { openApp(chatAppScreen); openSingleChat(id); } dismiss(); }; banner.addEventListener('click', handleClick); setTimeout(dismiss, 5000); }

    // ===================================================================
    // --- APPÂØºËà™‰∏éË∑ØÁî± ---
    // ===================================================================
    function openApp(appScreen) { phoneScreen.classList.add('app-open'); appScreen.classList.add('active'); if (appScreen.id === 'beautify-app-screen') { const activeTab = query('#beautify-app-screen .tab-link.active')?.dataset.tab || 'wallpaper'; handleBeautifyTabChange(activeTab); } else if (appScreen.id === 'data-app-screen') { const activeTab = query('#data-app-screen .tab-link.active')?.dataset.tab || 'world-book'; handleDataTabChange(activeTab); 
    } else if (appScreen.id === 'settings-app-screen') {
            renderGlobalRealtimeSettings();
        } }
    function closeCurrentApp() { const activeApp = document.querySelector('.app-screen.active:not(.sub-screen)'); if (activeApp) { if (activeApp.id === 'chat-app-screen' && activeApp.classList.contains('selection-mode')) exitContactSelectionMode(); activeApp.classList.remove('active'); phoneScreen.classList.remove('app-open'); } }
    window.closeCurrentApp = closeCurrentApp;
    function closeAllScreens() { queryAll('.app-screen.active').forEach(screen => screen.classList.remove('active')); phoneScreen.classList.remove('app-open'); }
    function openSubScreen(subScreen, parentScreen) { parentScreen.classList.add('parent-hidden'); subScreen.classList.add('active'); }
    function closeSubScreen(subScreen, parentScreen) { subScreen.classList.remove('active'); parentScreen.classList.remove('parent-hidden'); if (parentScreen.id === 'single-chat-screen') { updateSingleChatUI(); } }
    function setupAppNavigation() { getEl('settings-app-btn').addEventListener('click', () => openApp(settingsAppScreen)); getEl('music-app-btn').addEventListener('click', () => openApp(musicAppScreen)); getEl('beautify-app-btn').addEventListener('click', () => openApp(beautifyAppScreen));
        getEl('diary-app-btn').addEventListener('click', () => openApp(diaryAppScreen));
        getEl('mail-app-btn').addEventListener('click', () => { openApp(mailAppScreen); handleMailTabChange('love-letter'); }); getEl('data-app-btn').addEventListener('click', () => openApp(dataAppScreen)); getEl('chat-app-btn').addEventListener('click', () => { openApp(chatAppScreen); renderMessageList(); }); }

    // ===================================================================
    // --- ËÆæÁΩÆ APP ---
    // ===================================================================
    function initializeContactSettings(contact) { const deepCopy = (obj) => JSON.parse(JSON.stringify(obj)); const userProfileDefaults = appState.chat.userProfile; if (!contact.userSettings) { contact.userSettings = deepCopy(userProfileDefaults); } else { for (const key in userProfileDefaults) { if (!contact.userSettings.hasOwnProperty(key)) { contact.userSettings[key] = deepCopy(userProfileDefaults[key]); } } } if (!contact.userSettings.avatarLibrary) { contact.userSettings.avatarLibrary = []; } if (typeof contact.userSettings.videoBackgroundId === 'undefined') { contact.userSettings.videoBackgroundId = ''; } if (contact.isGroup) { if (!contact.groupSettings) { contact.groupSettings = { name: contact.name, avatarId: '', avatarLibrary: [], chatBackgroundId: 'default', videoBackgroundId: '', linkedWorldBooks: [], contextMemory: 99, owner: 'user', admins: [], isMuted: false, isDisbanded: false, members: {} }; } if (!contact.groupSettings.chatBackgroundId) contact.groupSettings.chatBackgroundId = 'default'; if (typeof contact.groupSettings.videoBackgroundId === 'undefined') { contact.groupSettings.videoBackgroundId = ''; } const allMemberIds = ['user', ...contact.members]; allMemberIds.forEach(memberId => { if (!contact.groupSettings.members[memberId]) { if (memberId === 'user') { contact.groupSettings.members['user'] = {
        nickname: contact.userSettings.name,
        title: 'ÁöáÂ∏ù',
        avatarId: contact.userSettings.avatarId,
        avatarFrameId: contact.userSettings.avatarFrameId,
        persona: contact.userSettings.persona // Also sync persona for consistency
    };
     } else { const char = appState.chat.contacts.find(c => c.id === memberId); if (char) { contact.groupSettings.members[memberId] = { ...deepCopy(char.charSettings), nickname: char.name, title: 'ÊàêÂëò', isMuted: false }; } } } }); } else { if (!contact.charSettings) { contact.charSettings = { name: contact.name, linkedWorldBooks: [], avatarId: contact.avatarId, avatarLibrary: [contact.avatarId], avatarFrameId: '', chatBackgroundId: 'default', videoBackgroundId: '', contextMemory: 99, persona: 'ËøôÊòØ‰∏Ä‰∏™ÈªòËÆ§‰∫∫ËÆæ„ÄÇ', isFriend: true, realtimeActivity: { enabled: false, interval: 30 }, momentsCoverId: '', momentsAvatarId: '' , visitors: [], hasHadFirstChat: false}; } if (!contact.charSettings.chatBackgroundId) contact.charSettings.chatBackgroundId = 'default'; if (typeof contact.charSettings.videoBackgroundId === 'undefined') { contact.charSettings.videoBackgroundId = ''; } if (!contact.charSettings.realtimeActivity) { contact.charSettings.realtimeActivity = { enabled: false, interval: 30 }; } if (typeof contact.charSettings.momentsCoverId === 'undefined') { contact.charSettings.momentsCoverId = ''; } if (contact.userSettings.name === userProfileDefaults.name) { contact.userSettings.name = '‰Ω†'; } if (contact.userSettings.persona === userProfileDefaults.persona) { contact.userSettings.persona = 'ËøôÊòØ‰∏Ä‰∏™ÈªòËÆ§ÁöÑUser‰∫∫ËÆæ„ÄÇ'; } } }
    function updateUIFromState() { getEl('api-url').value = appState.settings.apiUrl || ''; getEl('api-key').value = appState.settings.apiKey || ''; updateModelSelect(); updatePresetSelect(); renderMusicList(); updatePlaybackModeIcon(); applyAllCustomizations(); }
    async function applyAllCustomizations() { await applyWallpaperById(appState.beautify.currentWallpaperId, phoneScreen); document.documentElement.style.setProperty('--system-font-color', appState.beautify.fontColor); await loadAllCustomFonts(); applyFont(appState.beautify.currentFont, true); Object.keys(appState.beautify.icons).forEach(iconId => { applyIconChange(iconId, appState.beautify.icons[iconId], true); }); Object.keys(bubbleNameMap).forEach(bubbleId => { applyBubbleChange(bubbleId, true); }); }
    getEl('api-url').addEventListener('input', () => { appState.settings.apiUrl = getEl('api-url').value.trim(); debouncedSaveState(); });
    getEl('api-key').addEventListener('input', () => { appState.settings.apiKey = getEl('api-key').value.trim(); debouncedSaveState(); });
    confirmApiBtn.addEventListener('click', async () => { if (!appState.settings.apiUrl) return showToast("ËØ∑ËæìÂÖ•Âèç‰ª£Âú∞ÂùÄ", 'error'); confirmApiBtn.textContent = 'Âä†ËΩΩ‰∏≠...'; confirmApiBtn.disabled = true; try { const response = await fetch(`${appState.settings.apiUrl}/v1/models`, { headers: { 'Authorization': `Bearer ${appState.settings.apiKey}` } }); if (!response.ok) throw new Error(`HTTPÈîôËØØ! Áä∂ÊÄÅ: ${response.status}`); const data = await response.json(); appState.settings.availableModels = data.data.map(model => model.id).sort(); showToast("Ê®°ÂûãÂä†ËΩΩÊàêÂäüÔºÅ"); } catch (error) { console.error("Âä†ËΩΩÊ®°ÂûãÂ§±Ë¥•:", error); showToast("Âä†ËΩΩÊ®°ÂûãÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•Âú∞ÂùÄÂíåÂØÜÈí•", 'error'); appState.settings.availableModels = []; } finally { debouncedSaveState(); updateModelSelect(); confirmApiBtn.textContent = 'Âä†ËΩΩÊ®°Âûã'; confirmApiBtn.disabled = false; } });
    function updateModelSelect() { modelSelect.innerHTML = ''; if (appState.settings.availableModels.length === 0) { modelSelect.innerHTML = '<option value="">ËØ∑ÂÖàÂä†ËΩΩÊ®°Âûã</option>'; } else { appState.settings.availableModels.forEach(modelId => { const option = document.createElement('option'); option.value = modelId; option.textContent = modelId; option.selected = modelId === appState.settings.selectedModel; modelSelect.appendChild(option); }); } }
    modelSelect.addEventListener('change', () => { appState.settings.selectedModel = modelSelect.value; debouncedSaveState(); });
    function updatePresetSelect() { presetSelect.innerHTML = '<option value="">Êó†</option>'; appState.settings.presets.forEach((preset, index) => { const option = document.createElement('option'); option.value = index; option.textContent = preset.name; presetSelect.appendChild(option); }); }
    presetSelect.addEventListener('change', () => { const index = presetSelect.value; if (index !== "") { const preset = appState.settings.presets[parseInt(index)]; if (preset) { appState.settings.apiUrl = getEl('api-url').value = preset.url; appState.settings.apiKey = getEl('api-key').value = preset.key; appState.settings.selectedModel = preset.model; debouncedSaveState(); updateModelSelect(); showToast(`Â∑≤Âä†ËΩΩÈ¢ÑËÆæ: ${preset.name}`); } } });
    savePresetBtn.addEventListener('click', () => { const presetName = prompt("ËØ∑ËæìÂÖ•È¢ÑËÆæÂêçÁß∞:"); if (!presetName || presetName.trim() === "") return; const trimmedName = presetName.trim(); const existingIndex = appState.settings.presets.findIndex(p => p.name === trimmedName); if (existingIndex !== -1) { if (!confirm(`Â∑≤Â≠òÂú®Âêç‰∏∫ "${trimmedName}" ÁöÑÈ¢ÑËÆæÔºåË¶ÅË¶ÜÁõñÂÆÉÂêóÔºü`)) return; appState.settings.presets[existingIndex] = { name: trimmedName, url: appState.settings.apiUrl, key: appState.settings.apiKey, model: appState.settings.selectedModel }; showToast("È¢ÑËÆæÂ∑≤Ë¶ÜÁõñÔºÅ"); } else { appState.settings.presets.push({ name: trimmedName, url: appState.settings.apiUrl, key: appState.settings.apiKey, model: appState.settings.selectedModel }); showToast("È¢ÑËÆæÂ∑≤‰øùÂ≠òÔºÅ"); } debouncedSaveState(); updatePresetSelect(); });
    managePresetsBtn.addEventListener('click', () => { renderPresetList(); managePresetsModal.classList.add('visible'); });
    function renderGlobalRealtimeSettings() {
        if (!globalRealtimeInterval || !globalRealtimeCharSelector) return;

        globalRealtimeInterval.value = appState.settings.globalRealtimeActivity.interval;

        const chars = appState.chat.contacts.filter(c => !c.isGroup);
        globalRealtimeCharSelector.innerHTML = chars.map(c => {
            const isEnabled = c.charSettings.realtimeActivity.enabled;
            return `
                <div class="realtime-char-item ${isEnabled ? 'selected' : ''}" data-id="${c.id}">
                    <div class="avatar" data-avatar-id="${c.charSettings.avatarId}"></div>
                    <span class="name">${c.charSettings.name}</span>
                </div>
            `;
        }).join('');
        
        globalRealtimeCharSelector.querySelectorAll('.avatar').forEach(el => setElementImage(el, el.dataset.avatarId));
    }

    globalRealtimeInterval.addEventListener('input', () => {
        const oldGlobalInterval = appState.settings.globalRealtimeActivity.interval;
        const newGlobalInterval = parseInt(globalRealtimeInterval.value) || 30;
        appState.settings.globalRealtimeActivity.interval = newGlobalInterval;

        appState.chat.contacts.forEach(contact => {
            if (!contact.isGroup) {
                if (contact.charSettings.realtimeActivity.interval === oldGlobalInterval) {
                    contact.charSettings.realtimeActivity.interval = newGlobalInterval;
                }
                if (contact.charSettings.realtimeActivity.enabled) {
                    updateRealtimeActivityTimer(contact);
                }
            }
        });
        debouncedSaveState();
    });

    globalRealtimeCharSelector.addEventListener('click', (e) => {
        const item = e.target.closest('.realtime-char-item');
        if (!item) return;
        const contactId = item.dataset.id;
        const contact = appState.chat.contacts.find(c => c.id === contactId);
        if (contact) {
            const charSettings = contact.charSettings.realtimeActivity;
            charSettings.enabled = !charSettings.enabled;
            if (charSettings.enabled) {
                charSettings.interval = appState.settings.globalRealtimeActivity.interval;
            }
            updateRealtimeActivityTimer(contact);
            item.classList.toggle('selected');
            debouncedSaveState();
        }
    });

    globalRealtimeSelectAll.addEventListener('click', () => {
        const allChars = appState.chat.contacts.filter(c => !c.isGroup);
        const shouldEnableAll = allChars.some(c => !c.charSettings.realtimeActivity.enabled);

        allChars.forEach(contact => {
            contact.charSettings.realtimeActivity.enabled = shouldEnableAll;
            if (shouldEnableAll) {
                contact.charSettings.realtimeActivity.interval = appState.settings.globalRealtimeActivity.interval;
            }
            updateRealtimeActivityTimer(contact);
        });
        renderGlobalRealtimeSettings();
        debouncedSaveState();
    });
    closeManageModalBtn.addEventListener('click', () => managePresetsModal.classList.remove('visible'));
    function renderPresetList() { presetListEl.innerHTML = ''; if (appState.settings.presets.length === 0) { presetListEl.innerHTML = '<li><div class="preset-item-content">ÊöÇÊó†È¢ÑËÆæ</div></li>'; return; } appState.settings.presets.forEach((preset, index) => { const li = document.createElement('li'); li.className = 'preset-list-item'; li.dataset.index = index; li.innerHTML = `<div class="preset-item-content">${preset.name}</div><div class="preset-item-actions"><div class="edit-action">ÁºñËæë</div><div class="delete-action">Âà†Èô§</div></div>`; presetListEl.appendChild(li); }); }
    cancelEditBtn.addEventListener('click', () => editPresetModal.classList.remove('visible'));
    saveEditBtn.addEventListener('click', () => { const index = parseInt(editPresetIndexInput.value); const newName = editPresetNameInput.value.trim(); if (!newName) return showToast("È¢ÑËÆæÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫", "error"); const existingIndex = appState.settings.presets.findIndex(p => p.name === newName); if (existingIndex !== -1 && existingIndex !== index) { if (!confirm(`Â∑≤Â≠òÂú®Âêç‰∏∫ "${newName}" ÁöÑÈ¢ÑËÆæÔºåË¶ÅË¶ÜÁõñÂÆÉÂêóÔºü`)) return; appState.settings.presets.splice(existingIndex, 1); const newCurrentIndex = appState.settings.presets.findIndex(p => p.name === appState.settings.presets[index].name); appState.settings.presets[newCurrentIndex] = { name: newName, url: editPresetUrlInput.value.trim(), key: editPresetKeyInput.value.trim(), model: appState.settings.presets[newCurrentIndex].model }; } else { appState.settings.presets[index] = { name: newName, url: editPresetUrlInput.value.trim(), key: editPresetKeyInput.value.trim(), model: appState.settings.presets[index].model }; } debouncedSaveState(); updatePresetSelect(); renderPresetList(); editPresetModal.classList.remove('visible'); showToast("È¢ÑËÆæÂ∑≤Êõ¥Êñ∞"); });

    // ===================================================================
    // --- Èü≥‰πêÊí≠ÊîæÂô®Ê†∏ÂøÉ ---
    // ===================================================================
    let listenTogetherTimer = null;
    function playSongFromQueue(queueIndex, initiatorId = null) {
        if (queueIndex < 0 || queueIndex >= appState.music.queue.length) return;

        // --- Ê†∏ÂøÉ‰øÆÂ§çÔºö‰ªÖÂú®‰ºöËØùÁ±ªÂûãÊîπÂèòÊàñÊ≤°ÊúâËÆ°Êó∂Âô®Êó∂ÊâçÊ∏ÖÈô§ ---
        const newSessionType = initiatorId ? 'together' : 'solo';
        if (newSessionType !== runtimeState.musicSessionType && listenTogetherTimer) {
            clearInterval(listenTogetherTimer);
            listenTogetherTimer = null;
        }
        runtimeState.musicSessionType = newSessionType;

        appState.music.currentQueueIndex = queueIndex;
        const song = appState.music.queue[queueIndex];
        
        if (initiatorId && runtimeState.currentChatId) {
            const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
            if (contact) {
                let initiatorName;
                if(initiatorId === 'user') {
                    initiatorName = "‰Ω†";
                } else {
                    initiatorName = findUserById(initiatorId).name;
                    if(contact.isGroup) {
                        initiatorName = contact.groupSettings.members[initiatorId]?.nickname || initiatorName;
                    }
                }
                const targetName = contact.isGroup ? 'Â§ßÂÆ∂' : (initiatorId === 'user' ? (contact.remark || contact.charSettings.name) : "‰Ω†");
                addSystemNotification(runtimeState.currentChatId, `${initiatorName} ÈÇÄËØ∑ ${targetName} ‰∏ÄËµ∑Âê¨Ê≠å: „Ää${song.title}„Äã`, false);
            }
        }
        
        audioPlayer.src = song.url;
        audioPlayer.play().catch(e => console.error("Êí≠ÊîæÂ§±Ë¥•:", e));
        updateAllPlayerUI(song);
    
        if (runtimeState.currentChatId && runtimeState.musicSessionType === 'together') {
            const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
            if (!contact) return;
            if (!contact.listenTogetherDuration) contact.listenTogetherDuration = 0;
            listenTogetherInfo.style.display = 'flex';
            
            // --- Ê†∏ÂøÉ‰øÆÂ§çÔºö‰ªÖÂú®ËÆ°Êó∂Âô®Êú™ËøêË°åÊó∂ÂêØÂä® ---
            if (!listenTogetherTimer) {
                listenTogetherTimer = setInterval(() => {
                    contact.listenTogetherDuration++;
                    const seconds = contact.listenTogetherDuration;
                    const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
                    const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
                    const s = String(seconds % 60).padStart(2, '0');
                    listenTogetherText.textContent = `‰∏ÄËµ∑Âê¨‰∫Ü ${h}:${m}:${s}`;
                    debouncedSaveState();
                }, 1000);
            }
        } else {
             listenTogetherInfo.style.display = 'none';
        }
    }
    
    function stopPlayback() {
        audioPlayer.pause();
        audioPlayer.src = '';
        appState.music.currentQueueIndex = -1;
        updateDynamicIsland(false);
        playerModal.classList.remove('show');
        lyricsLineEl.textContent = '...';
        updateMusicListPlayingStatus();
        getEl('lyrics-container').classList.remove('visible');
        clearInterval(listenTogetherTimer);
        listenTogetherInfo.style.display = 'none';
        if(runtimeState.currentChatId && runtimeState.musicSessionType === 'together') {
            addSystemNotification(runtimeState.currentChatId, '‰∏ÄËµ∑Âê¨Ê≠åÂ∑≤ÁªìÊùü', false);
        }
        runtimeState.musicSessionType = null;
    }
    
    function playNext() {
        const { currentQueueIndex, queue, playbackMode } = appState.music;
        if (queue.length === 0) return;
        let nextIndex;
        if (playbackMode === 'shuffle') {
            nextIndex = Math.floor(Math.random() * queue.length);
        } else {
            nextIndex = (currentQueueIndex + 1) % queue.length;
        }
        // --- Ê†∏ÂøÉ‰øÆÂ§çÔºöÂú®ÂàáÊ≠åÊó∂‰øùÊåÅ‰ºöËØùÁ±ªÂûã ---
        playSongFromQueue(nextIndex, runtimeState.musicSessionType === 'together' ? 'user' : null);
        
        if (runtimeState.currentChatId && runtimeState.musicSessionType === 'together') {
            addSystemNotification(runtimeState.currentChatId, `Ê≠åÊõ≤Â∑≤Ëá™Âä®ÂàáÊç¢Âà∞: „Ää${appState.music.queue[nextIndex].title}„Äã`, false);
        }
    }

    function playPrev() {
        const { currentQueueIndex, queue, playbackMode } = appState.music;
        if (queue.length === 0) return;
        let prevIndex;
        if (playbackMode === 'shuffle') {
            prevIndex = Math.floor(Math.random() * queue.length);
        } else {
            prevIndex = (currentQueueIndex - 1 + queue.length) % queue.length;
        }
        // --- Ê†∏ÂøÉ‰øÆÂ§çÔºöÂú®ÂàáÊ≠åÊó∂‰øùÊåÅ‰ºöËØùÁ±ªÂûã ---
        playSongFromQueue(prevIndex, runtimeState.musicSessionType === 'together' ? 'user' : null);

        if (runtimeState.currentChatId && runtimeState.musicSessionType === 'together') {
            addSystemNotification(runtimeState.currentChatId, `Ê≠åÊõ≤Â∑≤ÂàáÊç¢Âà∞: „Ää${appState.music.queue[prevIndex].title}„Äã`, false);
        }
    }
    
    function togglePlayPause() { if (audioPlayer.paused) { if (appState.music.currentQueueIndex === -1 && appState.music.queue.length > 0) { playSongFromQueue(0); } else { audioPlayer.play(); } } else { audioPlayer.pause(); } }
    
    function togglePlaybackMode() { const modes = ['repeat', 'repeat-one', 'shuffle']; const currentModeIndex = modes.indexOf(appState.music.playbackMode); appState.music.playbackMode = modes[(currentModeIndex + 1) % modes.length]; updatePlaybackModeIcon(); debouncedSaveState(); }
    function updatePlaybackModeIcon() { const icons = { 'repeat': '<i class="fa-solid fa-arrow-right-arrow-left"></i>', 'repeat-one': '<i class="fa-solid fa-arrows-rotate"></i>', 'shuffle': '<i class="fa-solid fa-shuffle"></i>' }; const iconIds = { 'repeat': 'player-mode-repeat', 'repeat-one': 'player-mode-repeat-one', 'shuffle': 'player-mode-shuffle' }; const currentMode = appState.music.playbackMode; playerPlaybackModeBtn.innerHTML = icons[currentMode]; playerPlaybackModeBtn.dataset.iconId = iconIds[currentMode]; }
    audioPlayer.addEventListener('play', () => { playerPlayPauseBtn.dataset.iconId = 'player-pause'; const customIconId = appState.beautify.icons['player-pause']; if (customIconId) setElementImage(playerPlayPauseBtn, customIconId, 'src'); else playerPlayPauseBtn.innerHTML = pauseIconSrc; islandWaveform.classList.remove('paused'); });
    audioPlayer.addEventListener('pause', () => { playerPlayPauseBtn.dataset.iconId = 'player-play'; const customIconId = appState.beautify.icons['player-play']; if (customIconId) setElementImage(playerPlayPauseBtn, customIconId, 'src'); else playerPlayPauseBtn.innerHTML = playIconSrc; islandWaveform.classList.add('paused'); });
    audioPlayer.addEventListener('ended', () => { if (appState.music.playbackMode === 'repeat-one') { playSongFromQueue(appState.music.currentQueueIndex); } else { playNext(); } });
    audioPlayer.addEventListener('loadedmetadata', () => { const song = appState.music.queue[appState.music.currentQueueIndex]; if (song && isNaN(song.duration)) { song.duration = audioPlayer.duration; const mainPlaylistSong = appState.music.playlist.find(s => s.id === song.id); if (mainPlaylistSong) mainPlaylistSong.duration = audioPlayer.duration; renderMusicList(); } progressBar.max = audioPlayer.duration; });
    audioPlayer.addEventListener('timeupdate', () => { progressBar.value = audioPlayer.currentTime; updateLyrics(audioPlayer.currentTime); });
    progressBar.addEventListener('input', () => { audioPlayer.currentTime = progressBar.value; });

    // ===================================================================
    // --- Èü≥‰πê APP UI & Ê≠åËØçÂåπÈÖç ---
    // ===================================================================
    function formatTime(seconds) { if (isNaN(seconds)) return '--:--'; const min = Math.floor(seconds / 60); const sec = Math.floor(seconds % 60); return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`; }
    function renderMusicList() { musicListEl.innerHTML = ''; if (appState.music.playlist.length === 0) { musicListEl.innerHTML = '<li style="padding: 20px; text-align: center; color: #888;">ÊöÇÊó†Èü≥‰πêÔºåÁÇπÂáªÂè≥‰∏äËßí+Ê∑ªÂä†</div>'; return; } appState.music.playlist.forEach((song, index) => { const li = document.createElement('li'); li.className = 'music-list-item'; li.dataset.id = song.id; li.innerHTML = `<div class="music-item-content"><div class="music-item-info"><span class="title">${song.title}</span><span class="artist">${song.artist}</span></div><div class="music-item-duration">${formatTime(song.duration)}</div></div><div class="music-item-actions"><div class="edit-action">ÁºñËæë</div><div class="delete-action">Âà†Èô§</div></div>`; musicListEl.appendChild(li); }); updateMusicListPlayingStatus(); }
    function updateMusicListPlayingStatus() {
        const currentPlayingId = appState.music.queue[appState.music.currentQueueIndex]?.id;
        queryAll('.music-list-item').forEach(item => {
            if (currentPlayingId && item.dataset.id === currentPlayingId) {
                item.classList.add('playing');
            } else {
                item.classList.remove('playing');
            }
        });
    }    addMusicBtn.addEventListener('click', () => addMusicModal.classList.add('visible'));
    cancelAddMusicBtn.addEventListener('click', () => addMusicModal.classList.remove('visible'));
    uploadMusicBtn.addEventListener('click', () => musicFileInput.click());
    musicFileInput.addEventListener('change', (e) => { const files = e.target.files; if (files.length > 0) { processFiles(files); addMusicModal.classList.remove('visible'); musicFileInput.value = ''; } });
    confirmAddUrlBtn.addEventListener('click', async () => { const lines = musicUrlInput.value.trim().split('\n').filter(line => line.trim()); musicUrlInput.value = ''; addMusicModal.classList.remove('visible'); let audioUrls = [], lrcUrls = []; lines.forEach(line => { const separatorIndex = line.search(/\s*[:Ôºö]\s*/); let meta, url; if (separatorIndex === -1) { url = line.trim(); meta = url.substring(url.lastIndexOf('/') + 1); } else { meta = line.substring(0, separatorIndex).trim(); url = line.substring(separatorIndex + 1).trim(); } if (!url.startsWith('http')) return; if (url.toLowerCase().endsWith('.lrc')) { lrcUrls.push({ meta, url }); } else { audioUrls.push({ meta, url }); } }); let addedCount = 0; audioUrls.forEach(({ meta, url }) => { const parts = meta.replace(/\.[^/.]+$/, "").split(' - '); const artist = parts.length > 1 ? parts[0].trim() : 'Êú™Áü•Ëâ∫ÊúØÂÆ∂'; const title = parts.length > 1 ? parts.slice(1).join(' - ').trim() : meta; const newSong = { id: newId('song'), title, artist, url, duration: NaN, isLocal: false }; appState.music.playlist.push(newSong); addedCount++; }); if (addedCount > 0) { showToast(`Ê≠£Âú®Ê∑ªÂä† ${addedCount} È¶ñÊ≠åÊõ≤...`); renderMusicList(); debouncedSaveState(); } for (const { meta, url } of lrcUrls) { try { const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`; const response = await fetch(proxyUrl); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const lrcContent = await response.text(); matchAndApplyLyrics(lrcContent, meta); } catch (e) { console.error(`Âä†ËΩΩÊ≠åËØçÂ§±Ë¥•: ${meta}`, e); showToast(`Êó†Ê≥ïÂä†ËΩΩÊ≠åËØç: ${meta}`, 'error'); } } });
    function processFiles(files) { let audioFiles = [], lrcFiles = []; Array.from(files).forEach(file => { if (file.name.toLowerCase().endsWith('.lrc')) { lrcFiles.push(file); } else { audioFiles.push(file); } }); let addedCount = 0; audioFiles.forEach(file => { const reader = new FileReader(); reader.onload = (event) => { const baseName = file.name.replace(/\.[^/.]+$/, ""); const parts = baseName.split(' - '); const artist = parts.length > 1 ? parts[0].trim() : 'Êú™Áü•Ëâ∫ÊúØÂÆ∂'; const title = parts.length > 1 ? parts.slice(1).join(' - ').trim() : baseName; const newSong = { id: newId('song'), title, artist, url: event.target.result, duration: NaN, isLocal: true }; appState.music.playlist.push(newSong); addedCount++; if (addedCount === audioFiles.length) { showToast(`ÊàêÂäüÊ∑ªÂä† ${addedCount} È¶ñÊ≠åÊõ≤`); renderMusicList(); debouncedSaveState(); } }; reader.readAsDataURL(file); }); lrcFiles.forEach(file => { const reader = new FileReader(); reader.onload = (e) => { const baseName = file.name.replace(/\.[^/.]+$/, ""); matchAndApplyLyrics(e.target.result, baseName); }; reader.readAsText(file); }); }
    function normalizeStringForMatching(str) { if (!str) return ''; return decodeURIComponent(str).toLowerCase().replace(/\.[^/.]+$/, "").replace(/[-_]/g, ' ').replace(/['".,]/g, '').replace(/\s+/g, ' ').trim(); }
    function matchAndApplyLyrics(lrcContent, baseName) { const lrcData = parseLRC(lrcContent); if (lrcData.length === 0) return; const normalizedBaseName = normalizeStringForMatching(baseName); const songMap = new Map(); appState.music.playlist.forEach(s => { const songBaseName = normalizeStringForMatching(`${s.artist} - ${s.title}`); songMap.set(songBaseName, s.id); }); const matchingSongId = songMap.get(normalizedBaseName); if (matchingSongId) { appState.music.lyrics[matchingSongId] = lrcData; showToast(`Ê≠åËØçÂ∑≤ÂåπÈÖçÂà∞: ${appState.music.playlist.find(s=>s.id === matchingSongId).title}`); debouncedSaveState(); } else { showToast(`Êú™ÊâæÂà∞Ê≠åÊõ≤‰ª•ÂåπÈÖçÊ≠åËØç: ${baseName}`, 'error'); console.log("Failed to match lyrics. Base name:", normalizedBaseName, "Available songs:", [...songMap.keys()]); } }
    cancelEditSongBtn.addEventListener('click', () => editSongModal.classList.remove('visible'));
    saveEditSongBtn.addEventListener('click', () => { const songId = editSongIdInput.value; const song = appState.music.playlist.find(s => s.id === songId); if (song) { song.title = editSongTitleInput.value.trim(); song.artist = editSongArtistInput.value.trim(); renderMusicList(); debouncedSaveState(); showToast("Ê≠åÊõ≤‰ø°ÊÅØÂ∑≤Êõ¥Êñ∞"); } editSongModal.classList.remove('visible'); });

    // ===================================================================
    // --- ÁÅµÂä®Â≤õ & Ê≠åËØç & Êí≠ÊîæÂô® UI ---
    // ===================================================================
    function updateAllPlayerUI(song) { updateDynamicIsland(true, song); updateMusicListPlayingStatus(); playerSongTitle.textContent = song.title; playerSongArtist.textContent = song.artist; renderPlayerQueue(); }
    function updateDynamicIsland(isPlaying, song) { if (isPlaying && song) { dynamicIsland.classList.add('music-active'); islandMusicInfo.textContent = `${song.artist} - ${song.title}`; } else { dynamicIsland.classList.remove('music-active'); } }
    function parseLRC(lrc) { const lines = lrc.split('\n'); const result = []; const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g; for (const line of lines) { const text = line.replace(/\[.*?\]/g, '').trim(); if (text) { let match; while ((match = timeRegex.exec(line)) !== null) { const time = parseInt(match[1], 10) * 60 + parseInt(match[2], 10) + parseInt(match[3].padEnd(3, '0'), 10) / 1000; result.push({ time, text }); } } } return result.sort((a, b) => a.time - b.time); }
    let currentLyricIndex = -1;
function updateLyrics(currentTime) { const song = appState.music.queue[appState.music.currentQueueIndex]; if (!song) return; const lyrics = appState.music.lyrics[song.id]; if (!lyrics || lyrics.length === 0) { playerLyricsView.innerHTML = '<div class="lyric-line active">ÊöÇÊó†Ê≠åËØç</div>'; lyricsLineEl.textContent = '...'; if (songDetailsScreen.classList.contains('active') && songDetailsScreen.dataset.songId === song.id) { detailsLyricsView.innerHTML = '<div class="lyric-line active">ÊöÇÊó†Ê≠åËØç</div>'; } return; } let newLyricIndex = lyrics.findIndex((line, i) => currentTime >= line.time && (!lyrics[i + 1] || currentTime < lyrics[i + 1].time)); if (newLyricIndex === -1 && lyrics.length > 0) newLyricIndex = 0; if (newLyricIndex !== currentLyricIndex) { currentLyricIndex = newLyricIndex; const activeLyricText = lyrics[currentLyricIndex]?.text || '...'; lyricsLineEl.textContent = activeLyricText; renderPlayerLyrics(lyrics, currentLyricIndex); if (songDetailsScreen.classList.contains('active') && songDetailsScreen.dataset.songId === song.id) { renderSongDetailsLyrics(lyrics, currentLyricIndex); } } }
    function renderPlayerLyrics(lyrics, activeIndex) { playerLyricsView.innerHTML = lyrics.map((line, index) => `<div class="lyric-line ${index === activeIndex ? 'active' : ''}">${line.text}</div>`).join(''); const activeLine = playerLyricsView.querySelector('.lyric-line.active'); if (activeLine) { activeLine.scrollIntoView({ behavior: 'smooth', block: 'center' }); } }
    hidePlayerBtn.addEventListener('click', () => playerModal.classList.remove('show'));
    playerPlayPauseBtn.addEventListener('click', togglePlayPause);
    playerNextBtn.addEventListener('click', playNext);
    playerPrevBtn.addEventListener('click', playPrev);
    playerPlaybackModeBtn.addEventListener('click', togglePlaybackMode);
    togglePlaylistViewBtn.addEventListener('click', () => { playerLyricsView.classList.toggle('active'); playerPlaylistViewContainer.classList.toggle('active'); });
function renderPlayerQueue() { playerPlaylistView.innerHTML = ''; appState.music.queue.forEach((song, index) => { const li = document.createElement('li'); li.className = 'player-playlist-item'; li.classList.toggle('playing', index === appState.music.currentQueueIndex); li.dataset.index = index; li.innerHTML = `<div class="info"><div class="title">${song.title}</div><div class="artist">${song.artist}</div></div><button class="delete-from-queue-btn" data-icon-id="player-delete"><i class="fa-solid fa-trash-can"></i></button>`; playerPlaylistView.appendChild(li); }); }    playerPlaylistView.addEventListener('click', (e) => { const item = e.target.closest('.player-playlist-item'); if (!item) return; const index = parseInt(item.dataset.index); if (e.target.closest('.delete-from-queue-btn')) { if (confirm(`Á°ÆÂÆöË¶Å‰ªéÊí≠ÊîæÂàóË°®‰∏≠ÁßªÈô§ "${appState.music.queue[index].title}" ÂêóÔºü`)) { appState.music.queue.splice(index, 1); if (index === appState.music.currentQueueIndex) { if (appState.music.queue.length > 0) { playSongFromQueue(index % appState.music.queue.length, runtimeState.musicSessionType === 'together' ? 'user' : null); } else { stopPlayback(); } } else if (index < appState.music.currentQueueIndex) { appState.music.currentQueueIndex--; } renderPlayerQueue(); debouncedSaveState(); } } else { playSongFromQueue(index, runtimeState.musicSessionType === 'together' ? 'user' : null); } });
    restorePlaylistBtn.addEventListener('click', () => { appState.music.queue = [...appState.music.playlist]; renderPlayerQueue(); debouncedSaveState(); showToast("Êí≠ÊîæÂàóË°®Â∑≤ËøòÂéü"); });
    
    // ===================================================================
    // --- Ê≠åÊõ≤ËØ¶ÊÉÖÈ°µ ---
    // ===================================================================
    function openSongDetails(songId) { const song = appState.music.playlist.find(s => s.id === songId); if (!song) return; songDetailsScreen.dataset.songId = songId; detailsSongTitle.textContent = song.title; detailsSongArtist.textContent = song.artist; const lyrics = appState.music.lyrics[song.id]; const currentPlayingSong = appState.music.queue[appState.music.currentQueueIndex]; let activeIndex = -1; if (currentPlayingSong && currentPlayingSong.id === songId) { activeIndex = currentLyricIndex; } renderSongDetailsLyrics(lyrics, activeIndex, true); renderSongComments(songId); openSubScreen(songDetailsScreen, musicAppScreen); runtimeState.isDetailsAnimatingIn = true; setTimeout(() => { runtimeState.isDetailsAnimatingIn = false; const activeLine = detailsLyricsView.querySelector('.lyric-line.active'); if (activeLine) { activeLine.scrollIntoView({ behavior: 'auto', block: 'center' }); } }, 350); }
    function renderSongDetailsLyrics(lyrics, activeIndex, isOpening = false) { if (!lyrics || lyrics.length === 0) { detailsLyricsView.innerHTML = '<div class="lyric-line active">ÊöÇÊó†Ê≠åËØç</div>'; return; } detailsLyricsView.innerHTML = lyrics.map((line, index) => `<div class="lyric-line ${index === activeIndex ? 'active' : ''}">${line.text}</div>`).join(''); const activeLine = detailsLyricsView.querySelector('.lyric-line.active'); if (activeLine && !isOpening && !runtimeState.isDetailsAnimatingIn) { activeLine.scrollIntoView({ behavior: 'smooth', block: 'center' }); } }
    function renderSongComments(songId) { if (!appState.music.comments[songId]) { appState.music.comments[songId] = []; } const comments = appState.music.comments[songId]; detailsCommentsList.innerHTML = comments.map(comment => renderSingleComment(songId, comment)).join('') || '<p style="text-align:center; color:#888;">ËøòÊ≤°ÊúâËØÑËÆ∫ÔºåÂø´Êù•Êä¢Ê≤ôÂèëÂêßÔºÅ</p>'; }
    function renderSingleComment(songId, comment) { const author = findUserById(comment.authorId, comment.authorName);
        const isLiked = comment.likes.includes('user');
        const repliesHTML = (comment.replies || []).map(reply => renderSingleReply(reply, comment.replies)).join('');
        return `
            <div class="comment-item" data-comment-id="${comment.id}">
                <div class="comment-item-main">
                    <div class="comment-avatar" data-avatar-id="${author.avatarId}"></div>
                    <div class="comment-content">
                        <div class="comment-header">
                            <span class="comment-author">${author.name}</span>
                            <div class="comment-actions-inline">
                                <button class="icon-btn like-btn ${isLiked ? 'liked' : ''}" data-icon-id="${isLiked ? 'music-like-on' : 'music-like-off'}" style="gap: 4px;">${isLiked ? '<i class="fa-solid fa-heart"></i>' : '<i class="fa-regular fa-heart"></i>'}<span class="like-count">${comment.likes.length}</span></button>
                                <button class="icon-btn reply-btn" data-icon-id="music-comment" style="gap: 4px;"><i class="fa-solid fa-message"></i></button>
                            </div>
                        </div>
                        <p class="comment-text">${escapeHTML(comment.text)}</p>
                        <div class="comment-replies">${repliesHTML}</div>
                        <div class="reply-input-container"><input type="text" placeholder="ÂõûÂ§ç ${author.name}..."><button class="settings-button secondary" style="width: 50px; padding: 5px; display: flex; align-items: center; justify-content: center;" data-icon-id="comment-send"><i class="fa-solid fa-paper-plane"></i></button></div>
                    </div>
                </div>
                <div class="comment-item-actions-swipe">
                    <div class="edit-action" data-icon-id="music-edit"><i class="fa-solid fa-pen-to-square"></i></div>
                    <div class="delete-action" data-icon-id="music-delete"><i class="fa-solid fa-trash-can"></i></div>
                </div>
            </div>
        `; }
    function renderSingleReply(reply, allReplies) { const author = findUserById(reply.authorId, reply.authorName); let targetHTML = ''; if (reply.replyTo) { const targetReply = allReplies.find(r => r.id === reply.replyTo); if (targetReply) { const targetAuthor = findUserById(targetReply.authorId, targetReply.authorName); targetHTML = `ÂõûÂ§ç <span class="reply-target">@${targetAuthor.name}</span>`; } } return `<div class="reply-item" data-reply-id="${reply.id}"><span class="reply-author">${author.name}</span> ${targetHTML}: ${reply.text}<span class="delete-reply-btn" data-icon-id="comment-reply-delete">√ó</span><div class="reply-input-container"><input type="text" placeholder="ÂõûÂ§ç ${author.name}..."><button class="settings-button secondary" style="padding: 5px 10px;" data-bubble-id="comment-reply-send">ÂèëÈÄÅ</button></div></div>`; }
    
    function findUserById(id) {
        if (id === 'user') {
            const isMomentsContext = momentsTabContent.offsetParent !== null || charMomentsScreen.classList.contains('active');
            const profileSource = isMomentsContext ? appState.chat.moments.profile : appState.chat.userProfile;
            return { id: 'user', name: profileSource.name, avatarId: profileSource.avatarId, signature: profileSource.signature };
        }
        if (id === 'system') return { id: 'system', name: 'Á≥ªÁªüÈÄöÁü•', avatarId: '', signature: '' };

        // ‰ºòÂÖàÂú®ÂΩìÂâçËÅäÂ§©ÔºàÂ¶ÇÊûúÊòØÁæ§ËÅäÔºâÁöÑÊàêÂëòÂàóË°®‰∏≠Êü•ÊâæÔºå‰ª•Ëé∑ÂèñÊúÄÊñ∞ÁöÑÊòµÁß∞
        if (runtimeState.currentChatId) {
            const currentContact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
            if (currentContact && currentContact.isGroup && currentContact.groupSettings.members[id]) {
                const member = currentContact.groupSettings.members[id];
                return { id: id, name: member.nickname, avatarId: member.avatarId, signature: member.persona };
            }
        }
        
        const contact = appState.chat.contacts.find(c => c.id === id);
        if (contact) {
            return {
                id: contact.id,
                name: contact.charSettings.name,
                avatarId: contact.charSettings.avatarId,
                signature: contact.signature
            };
        }
        return { id: id, name: 'Êú™Áü•Áî®Êà∑', avatarId: `https://api.multiavatar.com/${id}.png`, signature: '...' };
    }
    function canCharViewMoment(charId, post) {
        if (!post) return false; // Post does not exist
        if (post.authorId === charId) return true; // Author can always view their own post
        if (post.visibility === 'public') return true; // Public post is visible to all
        // Check if the char is in the specific 'visibleTo' list
        if (post.visibility === 'specific' && post.visibleTo && post.visibleTo.includes(charId)) return true;
        // The user can see everything
        if(charId === 'user') return true;
        
        return false; // Otherwise, it's not visible
    }

    sendCommentBtn.addEventListener('click', () => { const text = commentInput.value.trim(); if (!text) return; const songId = songDetailsScreen.dataset.songId; if (!songId) return; const newComment = { id: newId('comment'), authorId: 'user', authorName: appState.chat.userProfile.name, text, likes: [], replies: [], timestamp: Date.now() }; appState.music.comments[songId].unshift(newComment); debouncedSaveState(); renderSongComments(songId); commentInput.value = ''; });
    detailsCommentsList.addEventListener('click', (e) => { const songId = songDetailsScreen.dataset.songId; const commentItem = e.target.closest('.comment-item'); if (!commentItem) return; const commentId = commentItem.dataset.commentId; const comment = appState.music.comments[songId].find(c => c.id === commentId); if (!comment) return; if (e.target.closest('.like-btn')) { const userIndex = comment.likes.indexOf('user'); if (userIndex > -1) { comment.likes.splice(userIndex, 1); } else { comment.likes.push('user'); } debouncedSaveState(); renderSongComments(songId); } else if (e.target.closest('.reply-btn')) { const replyInputContainer = commentItem.querySelector('.comment-content > .reply-input-container'); replyInputContainer.classList.toggle('active'); replyInputContainer.querySelector('input').focus(); } else if (e.target.closest('.comment-content > .reply-input-container button')) { const replyInput = e.target.previousElementSibling; const text = replyInput.value.trim(); if (!text) return; if (!comment.replies) comment.replies = []; const newReply = { id: newId('reply'), authorId: 'user', authorName: appState.chat.userProfile.name, text, timestamp: Date.now() }; comment.replies.push(newReply); debouncedSaveState(); renderSongComments(songId); } else { const replyItem = e.target.closest('.reply-item'); if (replyItem) { const replyId = replyItem.dataset.replyId; if (e.target.classList.contains('delete-reply-btn')) { if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ÂõûÂ§çÂêóÔºü')) { comment.replies = comment.replies.filter(r => r.id !== replyId); debouncedSaveState(); renderSongComments(songId); } } else if (e.target.closest('.reply-input-container button')) { const replyInput = e.target.previousElementSibling; const text = replyInput.value.trim(); if (!text) return; const newReply = { id: newId('reply'), authorId: 'user', authorName: appState.chat.userProfile.name, text, replyTo: replyId, timestamp: Date.now() }; comment.replies.push(newReply); debouncedSaveState(); renderSongComments(songId); } else { const replyInputContainer = replyItem.querySelector('.reply-input-container'); replyInputContainer.classList.toggle('active'); replyInputContainer.querySelector('input').focus(); } } } });
    songDetailsBackBtn.addEventListener('click', () => closeSubScreen(songDetailsScreen, musicAppScreen));

// ===================================================================
// --- ÁæéÂåñ APP (‰ºòÂåñ) ---
// ===================================================================
function handleBeautifyTabChange(tabId) { const titleEl = beautifyAppScreen.querySelector('.title'); beautifyActionBtn.style.display = ['wallpaper', 'font'].includes(tabId) ? 'block' : 'none'; bubbleActionBtn.style.display = tabId === 'bubble' ? 'block' : 'none'; if (tabId === 'wallpaper') { titleEl.textContent = 'Â£ÅÁ∫∏'; renderWallpapers(); } else if (tabId === 'font') { titleEl.textContent = 'Â≠ó‰Ωì'; renderFonts(); } else if (tabId === 'icon') { titleEl.textContent = 'ÂõæÊ†á'; renderIcons(); } else if (tabId === 'bubble') { titleEl.textContent = 'Ê∞îÊ≥°'; renderBubbles(); } }
beautifyTabs.addEventListener('click', (e) => { if (e.target.classList.contains('tab-link')) { const tabId = e.target.dataset.tab; queryAll('#beautify-app-screen .tab-link').forEach(t => t.classList.remove('active')); queryAll('#beautify-app-screen .tab-content').forEach(c => c.classList.remove('active')); e.target.classList.add('active'); getEl(`${tabId}-tab-content`).classList.add('active'); handleBeautifyTabChange(tabId); } });
beautifyActionBtn.addEventListener('click', () => { const activeTab = query('#beautify-app-screen .tab-link.active').dataset.tab; if (activeTab === 'wallpaper') { wallpaperFileInput.click(); } else if (activeTab === 'font') { addFontModal.classList.add('visible'); } });
bubbleActionBtn.addEventListener('click', () => bubbleIoModal.classList.add('visible'));
cancelBubbleIoBtn.addEventListener('click', () => bubbleIoModal.classList.remove('visible'));
exportBubblesBtn.addEventListener('click', async () => { showToast("Ê≠£Âú®ÂØºÂá∫Ê∞îÊ≥°ËÆæÁΩÆ...", 'info'); try { const bubbleSettings = appState.beautify.bubbleSettings; const mediaIds = new Set(); Object.values(bubbleSettings.global).forEach(style => { if (style.backgroundImageId) mediaIds.add(style.backgroundImageId); }); Object.values(bubbleSettings.specific).forEach(bubble => { Object.values(bubble).forEach(style => { if (style.backgroundImageId) mediaIds.add(style.backgroundImageId); }); }); const mediaData = {}; for (const id of mediaIds) { const data = await getMediaFromDB(id); if (data) mediaData[id] = await blobToBase64(data); } const backup = { bubbleSettings, mediaData }; const dataStr = JSON.stringify(backup); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `EmperorPhone-BubblesBackup-${new Date().toISOString().slice(0, 10)}.json`; a.click(); URL.revokeObjectURL(url); a.remove(); showToast("Ê∞îÊ≥°ËÆæÁΩÆÂ∑≤ÂØºÂá∫ÔºÅ"); } catch (error) { console.error("ÂØºÂá∫Ê∞îÊ≥°Â§±Ë¥•:", error); showToast("ÂØºÂá∫Ê∞îÊ≥°Â§±Ë¥•", 'error'); } });
importBubblesBtn.addEventListener('click', () => importBubblesInput.click());
importBubblesInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = async (event) => { showToast("Ê≠£Âú®ÂØºÂÖ•Ê∞îÊ≥°ËÆæÁΩÆ...", 'info'); try { const backup = JSON.parse(event.target.result); if (!backup.bubbleSettings || !backup.mediaData) throw new Error("Â§á‰ªΩÊñá‰ª∂Ê†ºÂºèÊó†Êïà"); if (confirm("ËøôÂ∞ÜË¶ÜÁõñÊâÄÊúâÂΩìÂâçÁöÑÊ∞îÊ≥°ËÆæÁΩÆÔºåÁ°ÆÂÆöÂêóÔºü")) { for (const [id, base64] of Object.entries(backup.mediaData)) { await addMediaToDB(id, base64ToBlob(base64)); } appState.beautify.bubbleSettings = backup.bubbleSettings; debouncedSaveState(); await applyAllCustomizations(); renderBubbles(); showToast("Ê∞îÊ≥°ËÆæÁΩÆÂØºÂÖ•ÊàêÂäüÔºÅ"); bubbleIoModal.classList.remove('visible'); } } catch (error) { showToast(`ÂØºÂÖ•Â§±Ë¥•: ${error.message}`, 'error'); } finally { importBubblesInput.value = ''; } }; reader.readAsText(file); });
wallpaperFileInput.addEventListener('change', async (e) => { const files = e.target.files; if (files.length > 0) { showToast(`Ê≠£Âú®Ê∑ªÂä† ${files.length} Âº†Â£ÅÁ∫∏...`); for (const file of files) { const newWallpaperId = newId('wp'); await addMediaToDB(newWallpaperId, file); appState.beautify.wallpapers.push({ id: newWallpaperId }); } debouncedSaveState(); await renderWallpapers(); showToast(`ÊàêÂäüÊ∑ªÂä† ${files.length} Âº†Â£ÅÁ∫∏`); } wallpaperFileInput.value = ''; });
async function renderWallpapers() { wallpaperGrid.innerHTML = ''; for (const wp of appState.beautify.wallpapers) { const item = document.createElement('div'); item.className = 'wallpaper-item'; item.dataset.id = wp.id; const img = document.createElement('img'); img.alt = 'Â£ÅÁ∫∏È¢ÑËßà'; item.appendChild(img); if (wp.id === appState.beautify.currentWallpaperId) item.classList.add('is-wallpaper'); if (wp.id === appState.beautify.currentChatBgId) item.classList.add('is-chat-bg'); wallpaperGrid.appendChild(item); setElementImage(img, wp.id, 'src'); } }
function showWallpaperContextMenu(targetElement, event) { event.preventDefault(); runtimeState.wallpaperContextMenuTarget = targetElement; const screenRect = phoneScreen.getBoundingClientRect(); let x = event.clientX; let y = event.clientY; if (event.touches) { x = event.touches[0].clientX; y = event.touches[0].clientY; } wallpaperContextMenu.style.display = 'flex'; const menuRect = wallpaperContextMenu.getBoundingClientRect(); let top = y - screenRect.top; let left = x - screenRect.left; if (left + menuRect.width > screenRect.width - 10) { left = screenRect.width - menuRect.width - 10; } if (top + menuRect.height > screenRect.height - 10) { top = screenRect.height - menuRect.height - 10; } wallpaperContextMenu.style.top = `${top}px`; wallpaperContextMenu.style.left = `${left}px`; }
function hideWallpaperContextMenu() { if (wallpaperContextMenu) wallpaperContextMenu.style.display = 'none'; runtimeState.wallpaperContextMenuTarget = null; }
wallpaperGrid.addEventListener('click', (e) => {
    const item = e.target.closest('.wallpaper-item');
    if (item) {
        showWallpaperContextMenu(item, e);
    }
});
document.addEventListener('pointerdown', (e) => { if (wallpaperContextMenu.style.display === 'flex' && !wallpaperContextMenu.contains(e.target)) { hideWallpaperContextMenu(); } }, true);
getEl('wp-set-wallpaper').addEventListener('click', async () => { if (!runtimeState.wallpaperContextMenuTarget) return; const id = runtimeState.wallpaperContextMenuTarget.dataset.id; appState.beautify.currentWallpaperId = id; await applyWallpaperById(id, phoneScreen); debouncedSaveState(); renderWallpapers(); hideWallpaperContextMenu(); showToast('Â£ÅÁ∫∏Â∑≤ËÆæÁΩÆ'); });
getEl('wp-set-chat-bg').addEventListener('click', () => { if (!runtimeState.wallpaperContextMenuTarget) return; const id = runtimeState.wallpaperContextMenuTarget.dataset.id; appState.beautify.currentChatBgId = id; debouncedSaveState(); renderWallpapers(); hideWallpaperContextMenu(); showToast('ÂÖ®Â±ÄËÅäÂ§©ËÉåÊôØÂ∑≤ËÆæÁΩÆ'); });
getEl('wp-delete').addEventListener('click', async () => { if (!runtimeState.wallpaperContextMenuTarget) return; if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÂº†Â£ÅÁ∫∏ÂêóÔºü')) { const id = runtimeState.wallpaperContextMenuTarget.dataset.id; await deleteMediaFromDB(id); appState.beautify.wallpapers = appState.beautify.wallpapers.filter(wp => wp.id !== id); if (appState.beautify.currentWallpaperId === id) { appState.beautify.currentWallpaperId = 'default'; await applyWallpaperById('default', phoneScreen); } if (appState.beautify.currentChatBgId === id) { appState.beautify.currentChatBgId = 'default'; } appState.chat.contacts.forEach(contact => { if (contact.isGroup && contact.groupSettings.chatBackgroundId === id) { contact.groupSettings.chatBackgroundId = 'default'; } else if (!contact.isGroup && contact.charSettings.chatBackgroundId === id) { contact.charSettings.chatBackgroundId = 'default'; } }); debouncedSaveState(); renderWallpapers(); hideWallpaperContextMenu(); showToast('Â£ÅÁ∫∏Â∑≤Âà†Èô§'); } });
async function applyWallpaperById(id, element) { if (!id || id === 'default' || id === 'default_moments_cover') { element.style.backgroundImage = (id === 'default_moments_cover') ? 'none' : `url(${DEFAULT_WALLPAPER_URL})`; element.style.backgroundColor = (id === 'default_moments_cover') ? '#ccc' : 'var(--bg-color)'; return; } const url = await getMediaURL(id); if (url) { element.style.backgroundImage = `url(${url})`; element.style.backgroundColor = 'transparent'; } else { element.style.backgroundImage = `url(${DEFAULT_WALLPAPER_URL})`; element.style.backgroundColor = 'var(--bg-color)'; } }
function renderLoveLetterTab() {
        const unreadContainer = getEl('unread-letters-container');
        const readContainer = getEl('read-letters-container');
        const unreadListEl = unreadContainer.querySelector('.love-letter-list');
        const readGridEl = readContainer.querySelector('.love-letter-collection-grid');
        const unreadPrompt = getEl('unread-letter-prompt');

        const allLetters = [...appState.mailbox.loveLetters].sort((a, b) => b.timestamp - a.timestamp);
        const unreadLetters = allLetters.filter(l => !l.isRead);
        const readLetters = allLetters.filter(l => l.isRead);

        // Render Unread Letters List
        if (unreadLetters.length > 0) {
            unreadContainer.style.display = 'block';
            unreadListEl.innerHTML = unreadLetters.map(letter => {
                const sender = findUserById(letter.senderId);
                if (letter.senderId === 'user') { sender.avatarId = appState.chat.moments.profile.avatarId; }
                return `
                    <li class="love-letter-item unread" data-letter-id="${letter.id}">
                        <div class="love-letter-avatar" data-avatar-id="${sender.avatarId}"></div>
                        <div class="love-letter-info">
                            <div class="love-letter-sender">${sender.name}</div>
                            <div class="love-letter-preview">${escapeHTML(letter.subject) || '‰∏ÄÂ∞ÅÊú™ÂëΩÂêçÁöÑ‰ø°'}</div>
                        </div>
                        <div class="love-letter-meta">
                            <span>${new Date(letter.timestamp).toLocaleDateString()}</span>
                            <div class="love-letter-actions">
                                <button class="icon-btn edit-letter-btn" title="ÁºñËæë"><i class="fa-solid fa-pen-to-square"></i></button>
                                <button class="icon-btn delete-letter-btn" title="Âà†Èô§"><i class="fa-solid fa-trash-can"></i></button>
                            </div>
                        </div>
                    </li>
                `;
            }).join('');
            unreadListEl.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
            
            // Show the prompt for the first unread letter
            unreadPrompt.dataset.letterId = unreadLetters[0].id;
            unreadPrompt.classList.add('visible');

        } else {
            unreadContainer.style.display = 'none';
            unreadPrompt.classList.remove('visible');
        }

        // Render Read Letters Collection Grid
        if (readLetters.length > 0) {
            readContainer.style.display = 'block';
            readGridEl.innerHTML = readLetters.map(letter => {
                const sender = findUserById(letter.senderId);
                if (letter.senderId === 'user') { sender.avatarId = appState.chat.moments.profile.avatarId; }
                return `
                    <div class="collected-letter-item" data-letter-id="${letter.id}">
                        <div class="title">${escapeHTML(letter.subject || 'Êó†È¢ò')}</div>
                        <div class="icon"><i class="fa-solid fa-scroll"></i></div>
                        <div class="sender">${escapeHTML(sender.name)}</div>
                        <div class="date">${new Date(letter.timestamp).toLocaleDateString()}</div>
                         <div class="love-letter-actions" style="margin-top: 5px;">
                            <button class="icon-btn edit-letter-btn" title="ÁºñËæë"><i class="fa-solid fa-pen-to-square"></i></button>
                            <button class="icon-btn delete-letter-btn" title="Âà†Èô§"><i class="fa-solid fa-trash-can"></i></button>
                        </div>
                    </div>
                `;
            }).join('');
        } else {
            readContainer.style.display = 'none';
        }

        // Show a message if there are no letters at all
        if (allLetters.length === 0) {
             unreadContainer.style.display = 'block'; // Show the container to display the message
             unreadListEl.innerHTML = '<li style="padding: 20px; text-align: center; color: #888;">ËøòÊ≤°ÊúâÊî∂Âà∞‰ªª‰ΩïÊÉÖ‰π¶...</li>';
        }
    }

    function openLoveLetter(letterId) {
        const letterColors = [
                'linear-gradient(to bottom right, #fcd4d9, #fde8eb)', // Light Pink
                'linear-gradient(to bottom right, #d4e7fc, #e8f1fd)', // Light Blue
                'linear-gradient(to bottom right, #e5fde2, #f1fef0)', // Light Green
                'linear-gradient(to bottom right, #e7def4, #f2ecfa)'  // Light Purple
            ];
            const randomGradient = letterColors[Math.floor(Math.random() * letterColors.length)];
            const viewer = getEl('love-letter-viewer');
            viewer.style.setProperty('--love-letter-gradient', randomGradient);
            viewer.dataset.letterId = letterId; // **Êñ∞Â¢ûÔºö‰∏∫Âõû‰ø°ÂäüËÉΩÂ≠òÂÇ®ID**
            const letter = appState.mailbox.loveLetters.find(l => l.id === letterId);
            if (!letter) return;
            const sender = findUserById(letter.senderId);

            viewer.querySelector('.letter-salutation').textContent = letter.salutation || `${appState.chat.userProfile.name}Ôºö`;
            viewer.querySelector('.letter-body').textContent = letter.body || '‰ø°‰∏≠‰ºº‰πéÊ≤°ÊúâÂÜÖÂÆπ...';
            viewer.querySelector('.letter-sender-name').textContent = letter.signature || sender.name;
            viewer.querySelector('.letter-timestamp').textContent = new Date(letter.timestamp).toLocaleString();
            setElementImage(viewer.querySelector('.letter-stamp'), sender.avatarId);

            viewer.classList.add('visible');

            if (!letter.isRead) {
                letter.isRead = true;
                debouncedSaveState();
                renderLoveLetterTab();
            }
        }
function handleMailTabChange(tabId) {
            const titleEl = mailAppScreen.querySelector('.title');
            const fab = getEl('mail-fab-container');
            const tabMap = { 'love-letter': 'ÊÉÖ‰π¶', 'postcard': 'Êòé‰ø°Áâá', 'tree-hole': 'Ê†ëÊ¥û', 'drift-bottle': 'ÊºÇÊµÅÁì∂' };

            // --- Ê†∏ÂøÉ‰øÆÂ§çÔºöÂÖàÈöêËóèÊâÄÊúâÔºåÂÜçÊòæÁ§∫ÁõÆÊ†á ---
            mailAppScreen.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
            mailAppScreen.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            const activeTabLink = mailAppScreen.querySelector(`.tab-link[data-tab="${tabId}"]`);
            const activeTabContent = getEl(`${tabId}-tab-content`);
            
            if (activeTabLink) activeTabLink.classList.add('active');
            if (activeTabContent) activeTabContent.classList.add('active');
            // --- ‰øÆÂ§çÁªìÊùü ---

            fab.style.display = (tabId === 'love-letter') ? 'block' : 'none';

            if (tabId === 'love-letter') {
                renderLoveLetterTab();
            }

            titleEl.textContent = tabMap[tabId] || '‰ø°ÁÆ±';
            appState.mailbox.activeTab = tabId;
            debouncedSaveState();
        }
    
    function handleDiaryTabChange(tabId) {
        const titleEl = diaryAppScreen.querySelector('.title');
        const tabMap = { 'secret-diary': 'ÁßòÂØÜÊó•ËÆ∞', 'couple-diary': 'ÊÉÖ‰æ£Êó•ËÆ∞', 'anniversary': 'Á∫™ÂøµÊó•', 'collection': 'ÁèçËóè', 'exhibition': 'Â±ïÂéÖ' };
        titleEl.textContent = tabMap[tabId] || 'ÊâãË¥¶';
        appState.diary.activeTab = tabId;
        debouncedSaveState();
    }
async function loadAllCustomFonts() { const existingStyle = document.getElementById('all-custom-fonts-style'); if (existingStyle) existingStyle.remove(); const style = document.createElement('style'); style.id = 'all-custom-fonts-style'; let fontFaceRules = ''; for (const font of appState.beautify.fonts) { const url = await getMediaURL(font.id); if (url) { fontFaceRules += `@font-face { font-family: "${font.name}"; src: url("${url}"); }\n`; } } style.textContent = fontFaceRules; document.head.appendChild(style); }
function renderFonts() { fontListEl.innerHTML = ''; const createFontItem = (fontName, isDefault = false, font) => { const li = document.createElement('li'); li.className = 'font-list-item'; li.dataset.name = fontName; const isActive = fontName === appState.beautify.currentFont; const colorBtnHTML = isActive ? `<button class="font-color-btn" data-bubble-id="font-color-btn">È¢úËâ≤</button>` : ''; const fontStyle = isDefault ? '' : `style="font-family: '${fontName}'"`; li.innerHTML = `<div class="font-item-content ${isActive ? 'active' : ''}"><span ${fontStyle}>${isDefault ? 'ÈªòËÆ§Á≥ªÁªüÂ≠ó‰Ωì' : fontName}</span>${colorBtnHTML}</div><div class="font-item-actions"><div class="edit-action">ÁºñËæë</div><div class="delete-action">Âà†Èô§</div></div>`; fontListEl.appendChild(li); }; createFontItem('default', true); appState.beautify.fonts.forEach(font => createFontItem(font.name, false, font)); }
function isValidColor(str) { return /^#([0-9A-F]{3}){1,2}$/i.test(str) || /^(rgb|rgba)\(/i.test(str); }
function applyFont(fontName, isInitialLoad = false) { document.documentElement.style.setProperty('--system-font-family', fontName === 'default' ? '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif' : `"${fontName}"`); appState.beautify.currentFont = fontName; if (!isInitialLoad) { debouncedSaveState(); showToast(`Â≠ó‰ΩìÂ∑≤Â∫îÁî®: ${fontName}`); } renderFonts(); }
cancelAddFontBtn.addEventListener('click', () => addFontModal.classList.remove('visible'));
uploadFontBtn.addEventListener('click', () => fontFileInput.click());
fontFileInput.addEventListener('change', async (e) => { const files = e.target.files; if (files.length > 0) { for (const file of files) { const newFontId = newId('font'); const name = file.name.replace(/\.[^/.]+$/, ""); await addMediaToDB(newFontId, file); appState.beautify.fonts.push({ id: newFontId, name }); } await loadAllCustomFonts(); debouncedSaveState(); renderFonts(); showToast(`ÊàêÂäüÊ∑ªÂä† ${files.length} ‰∏™Â≠ó‰Ωì`); addFontModal.classList.remove('visible'); fontFileInput.value = ''; } });
confirmAddFontUrlBtn.addEventListener('click', async () => { const btn = confirmAddFontUrlBtn; if (btn.disabled) return; btn.disabled = true; btn.textContent = 'Â§ÑÁêÜ‰∏≠...'; try { const lines = fontUrlInput.value.trim().split('\n'); let addedCount = 0; for (const line of lines) { if (!line.trim()) continue; let name, url; const separatorIndex = line.search(/:|Ôºö/); if (separatorIndex > -1) { name = line.substring(0, separatorIndex).trim(); url = line.substring(separatorIndex + 1).trim(); } else { url = line.trim(); name = url.substring(url.lastIndexOf('/') + 1).replace(/\.[^/.]+$/, ""); } if (name && url.startsWith('http')) { const response = await fetch(url); const blob = await response.blob(); const newFontId = newId('font'); await addMediaToDB(newFontId, blob); appState.beautify.fonts.push({ id: newFontId, name }); addedCount++; } } if (addedCount > 0) { await loadAllCustomFonts(); debouncedSaveState(); renderFonts(); showToast(`ÊàêÂäüÊ∑ªÂä† ${addedCount} ‰∏™Â≠ó‰Ωì`); } addFontModal.classList.remove('visible'); fontUrlInput.value = ''; } catch (error) { console.error("Error adding font from URL:", error); showToast("Ê∑ªÂä†Â≠ó‰ΩìÂ§±Ë¥•", "error"); } finally { btn.disabled = false; btn.textContent = 'Ê∑ªÂä†URL'; } });
const iconNameMap = {
        // System & Apps
        'status-battery-default': 'Áä∂ÊÄÅÊ†è ÁîµÈáè', 'status-battery-charging': 'Áä∂ÊÄÅÊ†è ÂÖÖÁîµ', 'app-chat': 'Â∫îÁî® ËÅäÂ§©', 'app-music': 'Â∫îÁî® Èü≥‰πê', 'app-shop': 'Â∫îÁî® Ë¥≠Áâ©', 'app-diary': 'Â∫îÁî® ÊâãË¥¶', 'app-mail': 'Â∫îÁî® ‰ø°ÁÆ±', 'dock-settings': 'Dock ËÆæÁΩÆ', 'dock-beautify': 'Dock ÁæéÂåñ', 'dock-data': 'Dock ËµÑÊñô',
        // Headers & Global
        'music-add': 'Èü≥‰πê Ê∑ªÂä†', 'beautify-add': 'ÁæéÂåñ Ê∑ªÂä†', 'data-add': 'ËµÑÊñô Ê∑ªÂä†', 'chat-add': 'ËÅäÂ§© Ê∑ªÂä†', 'chat-add-friend': 'ËÅäÂ§© Ê∑ªÂä†Â•ΩÂèã', 'header-notification': 'ÈÄöÁî® ÈÄöÁü•', 'header-settings': 'ÈÄöÁî® ËÆæÁΩÆ',
        // Chat Input & Toolbar
        'chat-quote-close': 'ËÅäÂ§© ÂºïÁî®ÂÖ≥Èó≠', 'chat-send-real': 'ËÅäÂ§© ÁúüÂèëÈÄÅ', 'chat-send-fake': 'ËÅäÂ§© ÂÅáÂèëÈÄÅ', 'chat-emoji': 'ËÅäÂ§© Ë°®ÊÉÖ', 'chat-refresh': 'Â∑•ÂÖ∑Ê†è Âà∑Êñ∞', 'chat-voice': 'Â∑•ÂÖ∑Ê†è ËØ≠Èü≥', 'chat-image': 'Â∑•ÂÖ∑Ê†è ÂõæÁâá', 'chat-camera': 'Â∑•ÂÖ∑Ê†è ÊãçÁÖß', 'chat-video': 'Â∑•ÂÖ∑Ê†è ËßÜÈ¢ë', 'chat-music': 'Â∑•ÂÖ∑Ê†è Èü≥‰πê', 'chat-link': 'Â∑•ÂÖ∑Ê†è ÈìæÊé•', 'chat-redpacket': 'Â∑•ÂÖ∑Ê†è Á∫¢ÂåÖ', 'chat-shop': 'Â∑•ÂÖ∑Ê†è Ë¥≠Áâ©',
        // Music Player
        'player-close': 'Êí≠ÊîæÂô® ÂÖ≥Èó≠', 'player-playlist': 'Êí≠ÊîæÂô® ÂàóË°®', 'player-delete': 'Êí≠ÊîæÂô® Âà†Èô§', 'player-prev': 'Êí≠ÊîæÂô® ‰∏ä‰∏ÄÈ¶ñ', 'player-play': 'Êí≠ÊîæÂô® Êí≠Êîæ', 'player-pause': 'Êí≠ÊîæÂô® ÊöÇÂÅú', 'player-next': 'Êí≠ÊîæÂô® ‰∏ã‰∏ÄÈ¶ñ', 'player-mode-repeat': 'Ê®°Âºè Âæ™ÁéØ', 'player-mode-repeat-one': 'Ê®°Âºè ÂçïÊõ≤', 'player-mode-shuffle': 'Ê®°Âºè ÈöèÊú∫',
        // Moments & Music Comments (NEW)
        'comment-send': 'ËØÑËÆ∫Âå∫ ÂèëÈÄÅ',
        'moment-like-off': 'Âä®ÊÄÅ ÁÇπËµûÂâç', 'moment-like-on': 'Âä®ÊÄÅ ÁÇπËµûÂêé', 'moment-comment': 'Âä®ÊÄÅ ËØÑËÆ∫', 'moment-edit': 'Âä®ÊÄÅ ÁºñËæë', 'moment-delete': 'Âä®ÊÄÅ Âà†Èô§',
        'music-like-off': 'Èü≥‰πê ÁÇπËµûÂâç', 'music-like-on': 'Èü≥‰πê ÁÇπËµûÂêé', 'music-comment': 'Èü≥‰πê ËØÑËÆ∫', 'music-edit': 'Èü≥‰πê ÁºñËæë', 'music-delete': 'Èü≥‰πê Âà†Èô§'
    };
function renderIcons() { iconGrid.innerHTML = '';

        // NEW: A map of default icon HTML for icons that might not be in the DOM.
        const defaultIconHTML = {
            'status-battery-default': '<i class="fa-solid fa-battery-full"></i>',
            'status-battery-charging': '<i class="fa-solid fa-battery-empty"></i>',
            'player-play': '<i class="fa-solid fa-circle-play"></i>',
            'player-pause': '<i class="fa-solid fa-circle-pause"></i>',
            'player-mode-repeat': '<i class="fa-solid fa-arrow-right-arrow-left"></i>',
            'player-mode-repeat-one': '<i class="fa-solid fa-arrows-rotate"></i>',
            'player-mode-shuffle': '<i class="fa-solid fa-shuffle"></i>',
            'player-delete': '<i class="fa-solid fa-trash-can"></i>',
            'moment-like-on': '<i class="fa-solid fa-heart"></i>',
            'music-like-on': '<i class="fa-solid fa-heart"></i>',
            'moment-like-off': '<i class="fa-regular fa-heart"></i>',
            'moment-comment': '<i class="fa-solid fa-message"></i>',
            'moment-edit': '<i class="fa-solid fa-pen-to-square"></i>',
            'moment-delete': '<i class="fa-solid fa-trash-can"></i>',
            'music-like-off': '<i class="fa-regular fa-heart"></i>',
            'music-comment': '<i class="fa-solid fa-message"></i>',
            'music-edit': '<i class="fa-solid fa-pen-to-square"></i>',
            'music-delete': '<i class="fa-solid fa-trash-can"></i>'
        };

        Object.keys(iconNameMap).forEach(id => {
            const customIconId = appState.beautify.icons[id];
            const item = document.createElement('div');
            item.className = 'icon-item';
            item.dataset.id = id;

            const preview = document.createElement('div');
            preview.className = 'icon-preview';

            if (customIconId) {
                // If a custom icon is set, render it as an image
                const img = document.createElement('img');
                setElementImage(img, customIconId, 'src');
                preview.appendChild(img);
            } else {
                let foundDefault = false;
                // 1. Try to find a live element on the page first
                const defaultElement = query(`[data-icon-id="${id}"]`);
                if (defaultElement) { // BUG FIX: Check if element exists
                    // BUG FIX: Prioritize copying only the <i> tag to avoid copying badges
                    const iconTag = defaultElement.querySelector('i');
                    if (iconTag) {
                        preview.innerHTML = iconTag.outerHTML;
                    } else {
                        // Fallback for elements that might not have an <i> (like custom img buttons)
                        preview.innerHTML = defaultElement.innerHTML;
                    }
                    foundDefault = true;
                } 
                // 2. If not on page, check our fallback map
                else if (defaultIconHTML[id]) {
                    preview.innerHTML = defaultIconHTML[id];
                    foundDefault = true;
                }
                
                // 3. If all else fails, show the question mark
                if (!foundDefault) {
                    preview.innerHTML = '‚ùî';
                }
            }
            
            item.appendChild(preview);
            const nameSpan = document.createElement('span');
            nameSpan.className = 'icon-name';
            nameSpan.textContent = iconNameMap[id] || id;
            item.appendChild(nameSpan);
            iconGrid.appendChild(item);
        });
         }
iconGrid.addEventListener('click', (e) => { const item = e.target.closest('.icon-item'); if (item) { replaceIconIdInput.value = item.dataset.id; replaceIconModal.classList.add('visible'); } });
cancelReplaceIconBtn.addEventListener('click', () => replaceIconModal.classList.remove('visible'));
uploadIconBtn.addEventListener('click', () => iconFileInput.click());
iconFileInput.addEventListener('change', async (e) => { const file = e.target.files[0]; if (file) { const newIconId = newId('icon'); await addMediaToDB(newIconId, file); applyIconChange(replaceIconIdInput.value, newIconId); iconFileInput.value = ''; } });
confirmReplaceIconUrlBtn.addEventListener('click', async () => { const url = iconUrlInput.value.trim(); if (url) { const response = await fetch(url); const blob = await response.blob(); const newIconId = newId('icon'); await addMediaToDB(newIconId, blob); applyIconChange(replaceIconIdInput.value, newIconId); iconUrlInput.value = ''; } });
restoreIconBtn.addEventListener('click', async () => { const iconId = replaceIconIdInput.value; if (confirm(`Á°ÆÂÆöË¶ÅËøòÂéü "${iconNameMap[iconId] || iconId}" ÁöÑÈªòËÆ§ÂõæÊ†áÂêóÔºü`)) { const oldMediaId = appState.beautify.icons[iconId]; if (oldMediaId) await deleteMediaFromDB(oldMediaId); delete appState.beautify.icons[iconId]; applyIconChange(iconId, null, false, true); debouncedSaveState(); renderIcons(); showToast('ÂõæÊ†áÂ∑≤ËøòÂéü'); replaceIconModal.classList.remove('visible'); } });
async function applyIconChange(iconId, mediaId, isInitialLoad = false, isRestoring = false) { if (!isRestoring) { appState.beautify.icons[iconId] = mediaId; } queryAll(`[data-icon-id="${iconId}"]`).forEach(async targetEl => { if (targetEl) { if (isRestoring) { targetEl.innerHTML = runtimeState.originalIconContent[iconId]; } else { const img = targetEl.querySelector('img') || document.createElement('img'); if (!targetEl.querySelector('img')) { targetEl.innerHTML = ''; targetEl.appendChild(img); } await setElementImage(img, mediaId, 'src'); } } }); if (!isInitialLoad) { if (!isRestoring) { debouncedSaveState(); renderIcons(); replaceIconModal.classList.remove('visible'); showToast('ÂõæÊ†áÂ∑≤ÊõøÊç¢'); } } }
const bubbleNameMap = { 'global_bubble': 'ÂÖ®Â±ÄÊ∞îÊ≥°', 'settings-load-model': 'ËÆæÁΩÆ Âä†ËΩΩÊ®°Âûã', 'settings-save-preset': 'ËÆæÁΩÆ ‰øùÂ≠òÈ¢ÑËÆæ', 'settings-manage-presets': 'ËÆæÁΩÆ ÁÆ°ÁêÜÈ¢ÑËÆæ', 'settings-export': 'ËÆæÁΩÆ ÂØºÂá∫', 'settings-import': 'ËÆæÁΩÆ ÂØºÂÖ•', 'player-restore-playlist': 'Êí≠ÊîæÂô® ËøòÂéüÂàóË°®', 'modal-close-preset': 'ÂºπÁ™ó ÂÖ≥Èó≠È¢ÑËÆæ', 'modal-cancel': 'ÂºπÁ™ó ÂèñÊ∂à', 'modal-save': 'ÂºπÁ™ó ‰øùÂ≠ò', 'modal-select-file': 'ÂºπÁ™ó ÈÄâÊã©Êñá‰ª∂', 'modal-add-url': 'ÂºπÁ™ó Ê∑ªÂä†URL', 'modal-cancel-music': 'ÂºπÁ™ó ÂèñÊ∂àÈü≥‰πê', 'modal-cancel-song': 'ÂºπÁ™ó ÂèñÊ∂àÊ≠åÊõ≤', 'modal-save-song': 'ÂºπÁ™ó ‰øùÂ≠òÊ≠åÊõ≤', 'modal-upload-font': 'ÂºπÁ™ó ‰∏ä‰º†Â≠ó‰Ωì', 'modal-add-font-url': 'ÂºπÁ™ó Ê∑ªÂä†Â≠ó‰ΩìURL', 'modal-cancel-font': 'ÂºπÁ™ó ÂèñÊ∂àÂ≠ó‰Ωì', 'modal-upload-icon': 'ÂºπÁ™ó ‰∏ä‰º†ÂõæÊ†á', 'modal-confirm-icon-url': 'ÂºπÁ™ó Á°ÆËÆ§ÂõæÊ†áURL', 'modal-restore-icon': 'ÂºπÁ™ó ËøòÂéüÂõæÊ†á', 'modal-cancel-icon': 'ÂºπÁ™ó ÂèñÊ∂àÂõæÊ†á', 'font-color-btn': 'Â≠ó‰Ωì È¢úËâ≤ÊåâÈíÆ', 'comment-send-btn': 'ËØÑËÆ∫ ÂèëÈÄÅ', 'comment-reply-send': 'ËØÑËÆ∫ ÂõûÂ§çÂèëÈÄÅ', 'emoji-close': 'Ë°®ÊÉÖ ÂÖ≥Èó≠', 'emoji-add': 'Ë°®ÊÉÖ Ê∑ªÂä†', 'cs-avatar-lib': 'ËÆæÁΩÆ CharÂ§¥ÂÉèÂ∫ì', 'cs-frame-lib': 'ËÆæÁΩÆ CharÂ§¥ÂÉèÊ°ÜÂ∫ì', 'cs-chat-bg': 'ËÆæÁΩÆ CharËÅäÂ§©ËÉåÊôØ', 'cs-save-persona': 'ËÆæÁΩÆ Char‰øùÂ≠òËµÑÊñô', 'cs-load-persona': 'ËÆæÁΩÆ CharËØªÂèñËµÑÊñô', 'cs-clear-history': 'ËÆæÁΩÆ CharÊ∏ÖÁ©∫ËÆ∞ÂΩï', 'cs-delete-friend': 'ËÆæÁΩÆ CharÂà†Èô§Â•ΩÂèã', 'cs-restore': 'ËÆæÁΩÆ CharËøòÂéüÊõ¥Êîπ', 'us-avatar-lib': 'ËÆæÁΩÆ UserÂ§¥ÂÉèÂ∫ì', 'us-frame-lib': 'ËÆæÁΩÆ UserÂ§¥ÂÉèÊ°ÜÂ∫ì', 'us-video-bg': 'ËÆæÁΩÆ UserËßÜÈ¢ëËÉåÊôØ', 'us-save-persona': 'ËÆæÁΩÆ User‰øùÂ≠òËµÑÊñô', 'us-load-persona': 'ËÆæÁΩÆ UserËØªÂèñËµÑÊñô', 'bubble-upload-img': 'Ê∞îÊ≥° ‰∏ä‰º†ÂõæÁâá', 'bubble-save': 'Ê∞îÊ≥° ‰øùÂ≠ò', 'bubble-restore': 'Ê∞îÊ≥° ËøòÂéü', 'bubble-cancel': 'Ê∞îÊ≥° ÂèñÊ∂à', 'data-upload-avatar': 'ËµÑÊñô ‰∏ä‰º†Â§¥ÂÉè', 'data-add-avatar-url': 'ËµÑÊñô Ê∑ªÂä†Â§¥ÂÉèURL', 'data-cancel': 'ËµÑÊñô ÂèñÊ∂à', 'data-save': 'ËµÑÊñô ‰øùÂ≠ò', 'contact-add-cancel': 'ËÅîÁ≥ª‰∫∫ Ê∑ªÂä†ÂèñÊ∂à', 'contact-add-confirm': 'ËÅîÁ≥ª‰∫∫ Ê∑ªÂä†Á°ÆËÆ§', 'emoji-upload-file': 'Ë°®ÊÉÖ ‰∏ä‰º†Êñá‰ª∂', 'emoji-add-url': 'Ë°®ÊÉÖ Ê∑ªÂä†URL', 'emoji-add-cancel': 'Ë°®ÊÉÖ Ê∑ªÂä†ÂèñÊ∂à', 'pat-cancel': 'Êãç‰∏ÄÊãç ÂèñÊ∂à', 'pat-confirm': 'Êãç‰∏ÄÊãç Á°ÆËÆ§', 'status-edit-cancel': 'Áä∂ÊÄÅÁºñËæë ÂèñÊ∂à', 'status-edit-confirm': 'Áä∂ÊÄÅÁºñËæë Á°ÆËÆ§', 'voice-cancel': 'ËØ≠Èü≥ ÂèñÊ∂à', 'voice-confirm': 'ËØ≠Èü≥ Á°ÆËÆ§', 'camera-cancel': 'ÊãçÁÖß ÂèñÊ∂à', 'camera-confirm': 'ÊãçÁÖß Á°ÆËÆ§', 'link-cancel': 'ÈìæÊé• ÂèñÊ∂à', 'link-confirm': 'ÈìæÊé• Á°ÆËÆ§', 'rp-cancel': 'Á∫¢ÂåÖ ÂèñÊ∂à', 'rp-confirm': 'Á∫¢ÂåÖ Á°ÆËÆ§', 'grp-cancel': 'Áæ§Á∫¢ÂåÖ ÂèñÊ∂à', 'grp-confirm': 'Áæ§Á∫¢ÂåÖ Á°ÆËÆ§', 'comment-edit-cancel': 'ËØÑËÆ∫ÁºñËæë ÂèñÊ∂à', 'comment-edit-save': 'ËØÑËÆ∫ÁºñËæë ‰øùÂ≠ò', 'view-content-close': 'Êü•ÁúãÂÜÖÂÆπ ÂÖ≥Èó≠', 'msg-edit-cancel': 'Ê∂àÊÅØÁºñËæë ÂèñÊ∂à', 'msg-edit-save': 'Ê∂àÊÅØÁºñËæë ‰øùÂ≠ò', 'lib-upload': 'Â∫ì ‰∏ä‰º†', 'lib-add-url': 'Â∫ì Ê∑ªÂä†URL', 'lib-delete': 'Â∫ì Âà†Èô§', 'lib-close': 'Â∫ì ÂÖ≥Èó≠', 'persona-load-cancel': 'ËµÑÊñôËØªÂèñ ÂèñÊ∂à', 'gcs-avatar-lib': 'Áæ§ËÆæÁΩÆ Â§¥ÂÉèÂ∫ì', 'gcs-chat-bg': 'Áæ§ËÆæÁΩÆ ËÉåÊôØ', 'gcs-clear-history': 'Áæ§ËÆæÁΩÆ Ê∏ÖÁ©∫ËÆ∞ÂΩï', 'gcs-mute-all': 'Áæ§ËÆæÁΩÆ ÂÖ®‰ΩìÁ¶ÅË®Ä', 'gcs-disband': 'Áæ§ËÆæÁΩÆ Ëß£Êï£Áæ§ËÅä', 'gcs-us-avatar-lib': 'Áæ§ÊàëÁöÑËÆæÁΩÆ Â§¥ÂÉèÂ∫ì', 'gcs-us-frame-lib': 'Áæ§ÊàëÁöÑËÆæÁΩÆ Â§¥ÂÉèÊ°Ü', 'gcs-us-video-bg': 'Áæ§ÊàëÁöÑËÆæÁΩÆ ËßÜÈ¢ëËÉåÊôØ', 'gcs-us-save-persona': 'Áæ§ÊàëÁöÑËÆæÁΩÆ ‰øùÂ≠òËµÑÊñô', 'gcs-us-load-persona': 'Áæ§ÊàëÁöÑËÆæÁΩÆ ËØªÂèñËµÑÊñô', 'gcs-member-avatar-lib': 'Áæ§ÊàêÂëòËÆæÁΩÆ Â§¥ÂÉèÂ∫ì', 'gcs-member-frame-lib': 'Áæ§ÊàêÂëòËÆæÁΩÆ Â§¥ÂÉèÊ°Ü', 'gcs-member-save-persona': 'Áæ§ÊàêÂëòËÆæÁΩÆ ‰øùÂ≠òËµÑÊñô', 'gcs-member-load-persona': 'Áæ§ÊàêÂëòËÆæÁΩÆ ËØªÂèñËµÑÊñô', 'gcs-member-cancel': 'Áæ§ÊàêÂëòËÆæÁΩÆ ÂèñÊ∂à', 'gcs-member-save': 'Áæ§ÊàêÂëòËÆæÁΩÆ ‰øùÂ≠ò', 'gcs-manage-cancel': 'Áæ§ÁÆ°ÁêÜ ÂèñÊ∂à', 'gcs-manage-confirm': 'Áæ§ÁÆ°ÁêÜ Á°ÆËÆ§', 'gcs-member-action-cancel': 'Áæ§ÊàêÂëòÊìç‰Ωú ÂèñÊ∂à' };
function renderBubbles() { bubbleGrid.innerHTML = '';
        const bubbleElements = queryAll('[data-bubble-id]');
        const renderedIds = new Set();
        const createBubbleItem = (id, isGlobal = false) => {
            const item = document.createElement('div');
            item.className = 'bubble-item';
            if (isGlobal) item.classList.add('global-bubble-item');
            item.dataset.id = id;
            
            const targetEl = query(`[data-bubble-id="${id}"]`);
            let previewContent = '';

            if (targetEl) {
                const imgChild = targetEl.querySelector('img');
                const textContent = targetEl.textContent.trim();
                if (imgChild) {
                    // If there's an image, use it for the preview
                    previewContent = imgChild.outerHTML;
                } else if (textContent) {
                    // Otherwise, use the text content
                    previewContent = escapeHTML(textContent);
                } else {
                    // Fallback for empty buttons
                    previewContent = '...';
                }
            } else {
                previewContent = escapeHTML(bubbleNameMap[id] || id);
            }

            item.innerHTML = `<div class="bubble-preview-container"><button style="pointer-events: none;">${previewContent}</button></div><span class="bubble-name">${bubbleNameMap[id] || id}</span>`;
            bubbleGrid.appendChild(item);
            applyBubbleChange(id, true);
        };
        createBubbleItem('global_bubble', true);
        bubbleElements.forEach(el => {
            const id = el.dataset.bubbleId;
            if (renderedIds.has(id)) return;
            createBubbleItem(id);
            renderedIds.add(id);
        }); }
bubbleGrid.addEventListener('click', (e) => { const item = e.target.closest('.bubble-item'); if (item) { openBubbleEditor(item.dataset.id); } });
function openBubbleEditor(bubbleId) { editBubbleIdInput.value = bubbleId; const isGlobal = bubbleId === 'global_bubble'; const bubbleSettings = isGlobal ? appState.beautify.bubbleSettings.global : (appState.beautify.bubbleSettings.specific[bubbleId] || {}); const targetEl = query(`[data-bubble-id="${bubbleId}"]`); const computedStyle = targetEl ? getComputedStyle(targetEl) : {}; bubbleWidthInput.value = bubbleSettings.width || (isGlobal ? '' : computedStyle.width); bubbleHeightInput.value = bubbleSettings.height || (isGlobal ? '' : computedStyle.height); bubblePosXInput.value = bubbleSettings.transform ? (bubbleSettings.transform.match(/translateX\(([^)]+)\)/)?.[1] || '0px') : (isGlobal ? '' : '0px'); bubblePosYInput.value = bubbleSettings.transform ? (bubbleSettings.transform.match(/translateY\(([^)]+)\)/)?.[1] || '0px') : (isGlobal ? '' : '0px'); bubbleColorInput.value = bubbleSettings.color || (isGlobal ? '' : computedStyle.color); bubbleBgColorInput.value = bubbleSettings.backgroundColor || (isGlobal ? '' : computedStyle.backgroundColor); bubbleBorderColorInput.value = bubbleSettings.borderColor || (isGlobal ? '' : computedStyle.borderColor); replaceBgOnlyCheckbox.checked = bubbleSettings.replaceBgOnly || false; bubbleUrlInput.value = ''; toggleBubbleColorInputs(bubbleSettings.backgroundImageId); updateBubblePreview(); editBubbleModal.classList.add('visible'); }
async function updateBubblePreview() { const bubbleId = editBubbleIdInput.value; const previewBtn = bubblePreview.querySelector('span'); const targetEl = query(`[data-bubble-id="${bubbleId}"]`); previewBtn.textContent = targetEl ? targetEl.textContent : (bubbleNameMap[bubbleId] || 'È¢ÑËßà'); const isGlobal = bubbleId === 'global_bubble'; const globalStyles = appState.beautify.bubbleSettings.global; const specificStyles = isGlobal ? {} : (appState.beautify.bubbleSettings.specific[bubbleId] || {}); const tempStyles = { width: bubbleWidthInput.value, height: bubbleHeightInput.value, transform: `translateX(${bubblePosXInput.value}) translateY(${bubblePosYInput.value})`, color: bubbleColorInput.value, backgroundColor: bubbleBgColorInput.value, borderColor: bubbleBorderColorInput.value, backgroundImageId: (isGlobal ? globalStyles : specificStyles).backgroundImageId }; const finalStyles = { ...globalStyles, ...specificStyles, ...Object.fromEntries(Object.entries(tempStyles).filter(([_, v]) => v !== '')) }; const stylesToApply = { borderWidth: '1px', borderStyle: 'solid', borderRadius: targetEl ? getComputedStyle(targetEl).borderRadius : '8px', display: 'flex', alignItems: 'center', justifyContent: 'center', backgroundSize: 'cover', backgroundPosition: 'center', ...finalStyles }; if (finalStyles.backgroundImageId) { const url = await getMediaURL(finalStyles.backgroundImageId); if (url) { stylesToApply.backgroundImage = `url(${url})`; if (!replaceBgOnlyCheckbox.checked) { previewBtn.textContent = ''; } } } else { stylesToApply.backgroundImage = 'none'; } Object.assign(bubblePreview.style, stylesToApply); const wrapperRect = bubblePreviewWrapper.getBoundingClientRect(); const w = parseFloat(stylesToApply.width) || 100; const h = parseFloat(stylesToApply.height) || 40; const scale = Math.min(wrapperRect.width / w, wrapperRect.height / h, 1); bubblePreview.style.transform = `scale(${scale})`; }
[bubbleWidthInput, bubbleHeightInput, bubblePosXInput, bubblePosYInput, bubbleColorInput, bubbleBgColorInput, bubbleBorderColorInput].forEach(input => input.addEventListener('input', updateBubblePreview));
cancelEditBubbleBtn.addEventListener('click', () => editBubbleModal.classList.remove('visible'));
saveBubbleBtn.addEventListener('click', () => { const bubbleId = editBubbleIdInput.value; const isGlobal = bubbleId === 'global_bubble'; const settingsGroup = isGlobal ? appState.beautify.bubbleSettings.global : (appState.beautify.bubbleSettings.specific[bubbleId] || {}); const newStyles = { width: bubbleWidthInput.value, height: bubbleHeightInput.value, transform: `translateX(${bubblePosXInput.value}) translateY(${bubblePosYInput.value})`, color: bubbleColorInput.value, backgroundColor: bubbleBgColorInput.value, borderColor: bubbleBorderColorInput.value, replaceBgOnly: replaceBgOnlyCheckbox.checked, backgroundImageId: settingsGroup.backgroundImageId }; const cleanedStyles = Object.fromEntries(Object.entries(newStyles).filter(([_, v]) => v !== '' && v !== '0px')); if (isGlobal) { appState.beautify.bubbleSettings.global = cleanedStyles; } else { appState.beautify.bubbleSettings.specific[bubbleId] = cleanedStyles; } debouncedSaveState(); if (isGlobal) { Object.keys(bubbleNameMap).forEach(id => applyBubbleChange(id, true)); } else { applyBubbleChange(bubbleId, true); } editBubbleModal.classList.remove('visible'); showToast('Ê∞îÊ≥°Ê†∑ÂºèÂ∑≤‰øùÂ≠ò'); });
restoreBubbleBtn.addEventListener('click', async () => { const bubbleId = editBubbleIdInput.value; if (confirm(`Á°ÆÂÆöË¶ÅËøòÂéü "${bubbleNameMap[bubbleId] || bubbleId}" ÁöÑÊ†∑ÂºèÂêóÔºü`)) { const isGlobal = bubbleId === 'global_bubble'; const settingsGroup = isGlobal ? appState.beautify.bubbleSettings.global : appState.beautify.bubbleSettings.specific[bubbleId]; if (settingsGroup?.backgroundImageId) { await deleteMediaFromDB(settingsGroup.backgroundImageId); } if (isGlobal) { appState.beautify.bubbleSettings.global = {}; Object.keys(bubbleNameMap).forEach(id => applyBubbleChange(id, false, true)); } else { delete appState.beautify.bubbleSettings.specific[bubbleId]; applyBubbleChange(bubbleId, false, true); } debouncedSaveState(); renderBubbles(); showToast('Ê∞îÊ≥°Â∑≤ËøòÂéü'); editBubbleModal.classList.remove('visible'); } });
uploadBubbleBtn.addEventListener('click', () => bubbleFileInput.click());
bubbleFileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (file) { handleBubbleImage(file); bubbleFileInput.value = ''; } });
bubbleUrlInput.addEventListener('input', async () => { const url = bubbleUrlInput.value.trim(); if (url.startsWith('http')) { const response = await fetch(url); const blob = await response.blob(); handleBubbleImage(blob); } });
function toggleBubbleColorInputs(hasImage) { queryAll('.bubble-color-group').forEach(el => el.classList.toggle('hidden-by-logic', !!hasImage)); }
async function handleBubbleImage(fileOrBlob) { const bubbleId = editBubbleIdInput.value; const isGlobal = bubbleId === 'global_bubble'; const settingsGroup = isGlobal ? appState.beautify.bubbleSettings.global : (appState.beautify.bubbleSettings.specific[bubbleId] || {}); if (!isGlobal && !appState.beautify.bubbleSettings.specific[bubbleId]) { appState.beautify.bubbleSettings.specific[bubbleId] = settingsGroup; } if (settingsGroup.backgroundImageId) { await deleteMediaFromDB(settingsGroup.backgroundImageId); } const newBubbleId = newId('bubble'); await addMediaToDB(newBubbleId, fileOrBlob); settingsGroup.backgroundImageId = newBubbleId; toggleBubbleColorInputs(true); updateBubblePreview(); }
async function applyBubbleChange(bubbleId, isInitialLoad = false, isRestoring = false) { const targetEl = query(`[data-bubble-id="${bubbleId}"]`); if (!targetEl) return; if (!isInitialLoad) targetEl.style.transition = 'none'; if (isRestoring) { targetEl.style.cssText = runtimeState.originalBubbleContent[bubbleId] || ''; } else { const globalStyles = appState.beautify.bubbleSettings.global || {}; const specificStyles = appState.beautify.bubbleSettings.specific[bubbleId] || {}; const finalStyles = { ...globalStyles, ...specificStyles }; targetEl.style.cssText = runtimeState.originalBubbleContent[bubbleId] || ''; for (const key in finalStyles) { if (key !== 'backgroundImageId' && key !== 'replaceBgOnly') { targetEl.style[key] = finalStyles[key]; } } if (finalStyles.backgroundImageId) { const url = await getMediaURL(finalStyles.backgroundImageId); if (url) { targetEl.style.backgroundSize = 'cover'; targetEl.style.backgroundPosition = 'center'; targetEl.style.backgroundImage = `url(${url})`; if (finalStyles.replaceBgOnly) { targetEl.style.color = finalStyles.color || ''; } else { targetEl.textContent = ''; } } } } }

// ===================================================================
// --- ËµÑÊñô APP ---
// ===================================================================
function handleDataTabChange(tabId) { 
    dataActionBtn.style.display = (tabId === 'memory') ? 'none' : 'block'; 
    dataFilterBtn.style.display = (tabId === 'world-book') ? 'block' : 'none';
    
    if (tabId !== 'world-book') {
        worldBookFilterDropdown.classList.remove('visible');
    }

    if (tabId === 'world-book') renderWorldBooks(); 
    else if (tabId === 'archive') renderArchives(); 
    else if (tabId === 'info') renderInfos(); 
}
dataAppTabs.addEventListener('click', (e) => { if (e.target.classList.contains('tab-link')) { const tabId = e.target.dataset.tab; queryAll('#data-app-screen .tab-link').forEach(t => t.classList.remove('active')); queryAll('#data-app-screen .tab-content').forEach(c => c.classList.remove('active')); e.target.classList.add('active'); getEl(`${tabId}-tab-content`).classList.add('active'); handleDataTabChange(tabId); } });
dataActionBtn.addEventListener('click', () => { const activeTab = query('#data-app-screen .tab-link.active').dataset.tab; const typeMap = { 'world-book': 'worldBook', 'archive': 'archive', 'info': 'info' }; openDataEditor(typeMap[activeTab]); });
function openDataEditor(type, id = null) {
    dataModal.dataset.type = type;
    dataEditingIdInput.value = id || '';
    dataNameInput.value = '';
    dataContentInput.value = '';
    dataGroupInput.value = '';
    dataAvatarPreview.style.backgroundImage = 'none';
    dataAvatarPreview.dataset.avatarId = '';

    const dataGroupContainer = getEl('data-group-container'); // Get the container
    const dataGroupSelect = getEl('data-group-select'); // Get the select

    const typeConfig = { worldBook: { title: '‰∏ñÁïå‰π¶', hasAvatar: false, hasGroup: true }, archive: { title: 'Ê°£Ê°à', hasAvatar: true, hasGroup: false }, info: { title: '‰ø°ÊÅØ', hasAvatar: true, hasGroup: false } };
    const config = typeConfig[type];
    dataModalTitle.textContent = (id ? 'ÁºñËæë' : 'ÂàõÂª∫') + config.title;
    dataAvatarGroup.style.display = config.hasAvatar ? 'block' : 'none';
    dataGroupContainer.style.display = config.hasGroup ? 'block' : 'none';

    if (config.hasGroup && type === 'worldBook') {
        const uniqueGroups = [...new Set(appState.data.worldBooks.map(item => item.group).filter(Boolean).sort())];
        dataGroupSelect.innerHTML = '<option value="">ÈÄâÊã©Â∑≤ÊúâÂàÜÁªÑ</option>';
        uniqueGroups.forEach(group => {
            const option = document.createElement('option');
            option.value = group;
            option.textContent = group;
            dataGroupSelect.appendChild(option);
        });
    }

    if (id) {
        const item = appState.data[type + 's'].find(i => i.id === id);
        if (item) {
            dataNameInput.value = item.name;
            dataContentInput.value = item.content;
            if (config.hasAvatar && item.avatarId) {
                setElementImage(dataAvatarPreview, item.avatarId);
                dataAvatarPreview.dataset.avatarId = item.avatarId;
            }
            if (config.hasGroup) {
                dataGroupInput.value = item.group || '';
                dataGroupSelect.value = item.group || ''; // Sync select on edit
            }
        }
    } else {
         // Reset select on create
        if (config.hasGroup) {
            dataGroupSelect.value = '';
        }
    }
    dataModal.classList.add('visible');
}
cancelDataBtn.addEventListener('click', () => dataModal.classList.remove('visible'));
dataGroupSelect.addEventListener('change', () => {
    if (dataGroupSelect.value) {
        dataGroupInput.value = dataGroupSelect.value;
    }
});
saveDataBtn.addEventListener('click', () => { const type = dataModal.dataset.type; const id = dataEditingIdInput.value; const name = dataNameInput.value.trim(); const content = dataContentInput.value.trim(); const group = dataGroupInput.value.trim(); if (!name) return showToast('ÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫', 'error'); const dataArray = appState.data[type + 's']; const avatarId = dataAvatarPreview.dataset.avatarId; if (id) { const item = dataArray.find(i => i.id === id); if (item) { item.name = name; item.content = content; if (avatarId) item.avatarId = avatarId; if (type === 'worldBook') item.group = group; } } else { const newItem = { id: newId('data'), name, content }; if (avatarId) newItem.avatarId = avatarId; if (type === 'worldBook') newItem.group = group; dataArray.push(newItem); } debouncedSaveState(); dataModal.classList.remove('visible'); switch (type) { case 'worldBook': renderWorldBooks(); break; case 'archive': renderArchives(); break; case 'info': renderInfos(); break; } });
function renderWorldBookFilterDropdown() {
        const uniqueGroups = ['all', 'Êú™ÂàÜÁªÑ', ...new Set(appState.data.worldBooks.map(item => item.group).filter(Boolean).sort())];
        const selected = runtimeState.worldBookFilter.selectedGroups;
        worldBookFilterDropdown.innerHTML = uniqueGroups.map(group => `
            <label class="checkbox-label">
                <input type="checkbox" value="${group}" ${selected.includes(group) ? 'checked' : ''}>
                <span>${group}</span>
            </label>
        `).join('');
    }

    function toggleWorldBookFilterDropdown() {
        if (worldBookFilterDropdown.classList.contains('visible')) {
            worldBookFilterDropdown.classList.remove('visible');
        } else {
            renderWorldBookFilterDropdown();
            worldBookFilterDropdown.classList.add('visible');
        }
    }

    dataFilterBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleWorldBookFilterDropdown();
    });

    worldBookFilterDropdown.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox') {
            const group = e.target.value;
            const isChecked = e.target.checked;
            let selected = runtimeState.worldBookFilter.selectedGroups;

            if (group === 'all') {
                selected = ['all'];
            } else {
                selected = selected.filter(g => g !== 'all'); // Remove 'all' if another is selected
                if (isChecked) {
                    if (!selected.includes(group)) selected.push(group);
                } else {
                    selected = selected.filter(g => g !== group);
                }
            }

            if (selected.length === 0) {
                selected = ['all']; // Default back to 'all' if nothing is selected
            }
            
            runtimeState.worldBookFilter.selectedGroups = selected;
            renderWorldBookFilterDropdown(); // Re-render to update checks
            renderWorldBooks(); // Re-render the list based on new filter
        }
    });
dataUploadAvatarBtn.addEventListener('click', () => dataAvatarFileInput.click());
dataAvatarFileInput.addEventListener('change', async (e) => { const file = e.target.files[0]; if (file) { const newAvatarId = newId('data_avatar'); await addMediaToDB(newAvatarId, file); dataAvatarPreview.dataset.avatarId = newAvatarId; setElementImage(dataAvatarPreview, newAvatarId); dataAvatarFileInput.value = ''; } });
dataAddAvatarUrlBtn.addEventListener('click', async () => { const url = prompt('ËØ∑ËæìÂÖ•ÂõæÁâáURL:'); if (url && url.startsWith('http')) { const response = await fetch(url); const blob = await response.blob(); const newAvatarId = newId('data_avatar'); await addMediaToDB(newAvatarId, blob); dataAvatarPreview.dataset.avatarId = newAvatarId; setElementImage(dataAvatarPreview, newAvatarId); } else if (url) { showToast('Êó†ÊïàÁöÑURL', 'error'); } });
function escapeHTML(str) { 
    if (typeof str !== 'string') return '';
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;'); 
}
function renderWorldBooks() {
    const selectedGroups = runtimeState.worldBookFilter.selectedGroups;
    
    let booksToRender = appState.data.worldBooks;

    if (!selectedGroups.includes('all')) {
        booksToRender = booksToRender.filter(item => {
            const itemGroup = item.group || 'Êú™ÂàÜÁªÑ';
            return selectedGroups.includes(itemGroup);
        });
    }

    worldBookListEl.innerHTML = booksToRender.map(item => `
        <li class="preset-data-item" data-id="${item.id}" data-type="worldBook">
            <div class="preset-data-item-content">
                <div class="preset-data-info">
                    <div class="preset-data-name">${escapeHTML(item.name)}</div>
                    <div class="preset-data-excerpt">${item.group ? `[${escapeHTML(item.group)}] ` : ''}${escapeHTML(item.content.substring(0, 20) || 'Êó†ÂÜÖÂÆπ')}...</div>
                </div>
            </div>
            <div class="preset-data-item-actions">
                <div class="edit-action">ÁºñËæë</div>
                <div class="delete-action">Âà†Èô§</div>
            </div>
        </li>
    `).join('') || '<li><div class="preset-data-item-content" style="justify-content:center; color:#888;">ÊöÇÊó†Á¨¶ÂêàÊù°‰ª∂ÁöÑ‰∏ñÁïå‰π¶</div></li>'; 
}
function renderArchives() { archiveListEl.innerHTML = ''; if (appState.data.archives.length === 0) { archiveListEl.innerHTML = '<li><div class="preset-data-item-content" style="justify-content:center; color:#888;">ÊöÇÊó†Ê°£Ê°à</div></li>'; return; } appState.data.archives.forEach(item => { const li = document.createElement('li'); li.className = 'preset-data-item'; li.dataset.id = item.id; li.dataset.type = 'archive'; li.innerHTML = `<div class="preset-data-item-content"><div class="preset-data-avatar" data-avatar-id="${item.avatarId || ''}"></div><div class="preset-data-info"><div class="preset-data-name">${escapeHTML(item.name)}</div><div class="preset-data-excerpt">${escapeHTML(item.content.substring(0, 20) || 'Êó†ÂÜÖÂÆπ')}...</div></div></div><div class="preset-data-item-actions"><div class="edit-action">ÁºñËæë</div><div class="delete-action">Âà†Èô§</div></div>`; archiveListEl.appendChild(li); setElementImage(li.querySelector('.preset-data-avatar'), item.avatarId); }); }
function renderInfos() { infoListEl.innerHTML = ''; if (appState.data.infos.length === 0) { infoListEl.innerHTML = '<li><div class="preset-data-item-content" style="justify-content:center; color:#888;">ÊöÇÊó†‰ø°ÊÅØ</div></li>'; return; } appState.data.infos.forEach(item => { const li = document.createElement('li'); li.className = 'preset-data-item'; li.dataset.id = item.id; li.dataset.type = 'info'; li.innerHTML = `<div class="preset-data-item-content"><div class="preset-data-avatar" data-avatar-id="${item.avatarId || ''}"></div><div class="preset-data-info"><div class="preset-data-name">${escapeHTML(item.name)}</div><div class="preset-data-excerpt">${escapeHTML(item.content.substring(0, 20) || 'Êó†ÂÜÖÂÆπ')}...</div></div></div><div class="preset-data-item-actions"><div class="edit-action">ÁºñËæë</div><div class="delete-action">Âà†Èô§</div></div>`; infoListEl.appendChild(li); setElementImage(li.querySelector('.preset-data-avatar'), item.avatarId); }); }
    
// ===================================================================
// --- ËÅäÂ§© APP (ÂåÖÂê´Âä®ÊÄÅ) ---
// ===================================================================
chatListBackBtn.addEventListener('click', () => { if (chatAppScreen.classList.contains('selection-mode')) { exitContactSelectionMode(); } else { closeCurrentApp(); } });
query('#chat-app-screen .app-bottom-tabs').addEventListener('click', (e) => { if (e.target.classList.contains('tab-link')) { const tabId = e.target.dataset.tab; queryAll('#chat-app-screen .tab-link').forEach(t => t.classList.remove('active')); queryAll('#chat-app-screen .tab-content').forEach(c => c.classList.remove('active')); e.target.classList.add('active'); getEl(`${tabId}-tab-content`).classList.add('active'); const titleEl = chatAppScreen.querySelector('.title'); if (tabId === 'moments') { titleEl.textContent = 'Âä®ÊÄÅ'; chatListActionBtn.style.display = 'none'; momentsNotificationBtn.style.display = 'block'; renderMomentsPage('user'); } else { titleEl.textContent = 'Ê∂àÊÅØ'; chatListActionBtn.style.display = 'block'; momentsNotificationBtn.style.display = 'none'; } } });
chatListActionBtn.addEventListener('click', () => { if (chatAppScreen.classList.contains('selection-mode')) { if (runtimeState.contactSelection.length < 1) { showToast('Ëá≥Â∞ëÈúÄË¶ÅÈÄâÊã©‰∏Ä‰ΩçËÅîÁ≥ª‰∫∫', 'error'); return; } const groupName = prompt('ËØ∑ËæìÂÖ•Áæ§ËÅäÂêçÁß∞:', runtimeState.contactSelection.map(id => appState.chat.contacts.find(c => c.id === id).name).join(', ')); if (groupName) { createGroup(groupName, runtimeState.contactSelection); } } else { addContactModal.classList.add('visible'); } });
cancelAddContactBtn.addEventListener('click', () => addContactModal.classList.remove('visible'));
confirmAddContactBtn.addEventListener('click', () => { const name = newContactNameInput.value.trim(); const newContact = { id: newId('contact'),name: name, remark: '', avatarId: `https://api.multiavatar.com/${name}.png`, status: 'online', statusText: 'Âú®Á∫ø', signature: 'Ëøô‰∏™‰∫∫ÂæàÊáíÔºå‰ªÄ‰πàÈÉΩÊ≤°Áïô‰∏ã„ÄÇ', lastMessage: '', lastMessageTime: Date.now(), isGroup: false, conversation: [], listenTogetherDuration: 0, lastLetterSent: 0 }; initializeContactSettings(newContact); appState.chat.contacts.push(newContact); saveState(); renderMessageList(); addContactModal.classList.remove('visible'); newContactNameInput.value = ''; });
const statusMap = { online: 'Âú®Á∫ø', busy: 'ÂøôÁ¢å', offline: 'Á¶ªÁ∫ø' };
function renderMessageList() { appState.chat.contacts.sort((a, b) => b.lastMessageTime - a.lastMessageTime); messageListEl.innerHTML = ''; if (appState.chat.contacts.length === 0) { messageListEl.innerHTML = '<li style="padding: 20px; text-align: center; color: #888;">ÊöÇÊó†ËÅîÁ≥ª‰∫∫ÔºåÁÇπÂáªÂè≥‰∏äËßí+Ê∑ªÂä†</div>'; return; } appState.chat.contacts.forEach(contact => { const li = document.createElement('li'); li.className = 'contact-list-item'; li.dataset.id = contact.id; li.dataset.isGroup = contact.isGroup; const time = new Date(contact.lastMessageTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); let avatarHTML; const unreadBadgeHTML = contact.unreadCount > 0 ? `<div class="unread-badge">${contact.unreadCount}</div>` : ''; const shakeClass = contact.needsShake ? 'shake' : ''; if (contact.isGroup) { const groupAvatarId = contact.groupSettings.avatarId; if (groupAvatarId) { avatarHTML = `<div class="contact-avatar ${shakeClass}" data-avatar-id="${groupAvatarId}">${unreadBadgeHTML}</div>`; } else { const memberAvatarIds = ['user', ...contact.members].slice(0, 4).map(id => { if (id === 'user') return appState.chat.userProfile.avatarId; return appState.chat.contacts.find(c => c.id === id)?.charSettings.avatarId || ''; }).filter(Boolean); const puzzlePieces = memberAvatarIds.map(avatarId => `<div class="puzzle-piece" data-avatar-id="${avatarId}"></div>`).join(''); avatarHTML = `<div class="contact-avatar group-puzzle ${shakeClass}">${puzzlePieces}${unreadBadgeHTML}</div>`; } } else { avatarHTML = `<div class="contact-avatar ${shakeClass}" data-avatar-id="${contact.charSettings.avatarId}">${unreadBadgeHTML}</div>`; } const statusIndicator = `<div class="status-indicator ${contact.status}"></div>`; const metaHTML = contact.isGroup ? `<span>(${contact.members.length + 1})</span>` : `<div class="contact-status">${statusIndicator} ${statusMap[contact.status] || 'Êú™Áü•'}</div>`; li.innerHTML = ` <div class="contact-item-content"> ${avatarHTML} <div class="contact-info"> <div class="contact-name">${contact.remark || (contact.isGroup ? contact.groupSettings.name : contact.charSettings.name)}</div> <div class="contact-last-msg">${contact.lastMessage || ''}</div> </div> <div class="contact-meta"> <div class="contact-time">${time}</div> ${metaHTML} </div> </div> <div class="contact-item-actions"> <div class="delete-action">Âà†Èô§</div> </div>`; messageListEl.appendChild(li); li.querySelectorAll('[data-avatar-id]').forEach(el => { const id = el.dataset.avatarId; if (id.startsWith('https')) { el.style.backgroundImage = `url(${id})`; } else { setElementImage(el, id); } }); if (contact.needsShake) { setTimeout(() => { const avatarEl = li.querySelector('.contact-avatar'); if (avatarEl) avatarEl.classList.remove('shake'); contact.needsShake = false; debouncedSaveState(); }, 500); } }); }
function enterContactSelectionMode(item) { if (item.dataset.isGroup === 'true') { showToast('‰∏çËÉΩÈÄâÊã©Áæ§ÁªÑÂä†ÂÖ•Êñ∞Áæ§ËÅä', 'error'); return; } chatAppScreen.classList.add('selection-mode'); chatListBackBtn.textContent = 'ÂèñÊ∂à'; chatListActionBtn.textContent = 'Âª∫Áæ§'; chatListActionBtn.classList.add('small'); item.classList.add('selected'); runtimeState.contactSelection.push(item.dataset.id); }
function exitContactSelectionMode() { chatAppScreen.classList.remove('selection-mode'); chatListBackBtn.textContent = '< ËøîÂõû'; chatListActionBtn.textContent = '+'; chatListActionBtn.classList.remove('small'); queryAll('.contact-list-item.selected').forEach(i => i.classList.remove('selected')); runtimeState.contactSelection = []; }
function createGroup(name, memberIds) { const members = memberIds.map(id => appState.chat.contacts.find(c => c.id === id)); const newGroup = { id: newId('group'), name: name, avatarId: '', lastMessage: 'Áæ§ËÅäÂ∑≤ÂàõÂª∫', lastMessageTime: Date.now(), isGroup: true, members: memberIds, conversation: [] }; initializeContactSettings(newGroup); const memberNames = members.map(m => `'${m.name}'`).join(', '); addSystemNotification(newGroup.id, `'${appState.chat.userProfile.name}' ÈÇÄËØ∑ ${memberNames} Âä†ÂÖ•Áæ§ËÅä`, true); appState.chat.contacts.unshift(newGroup); saveState(); renderMessageList(); exitContactSelectionMode(); }
function openSingleChat(contactId) { const contact = appState.chat.contacts.find(c => c.id === contactId); if (!contact) return; runtimeState.currentChatId = contactId; if (!runtimeState.chatDisplayLimits[contactId]) { runtimeState.chatDisplayLimits[contactId] = 50; } if (contact.unreadCount > 0) { contact.unreadCount = 0; debouncedSaveState(); renderMessageList(); } runtimeState.notificationQueue = runtimeState.notificationQueue.filter(n => n.contactId !== contactId); updateSingleChatUI(); openSubScreen(singleChatScreen, chatAppScreen); }
async function updateSingleChatUI() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; const isDisbanded = contact.isGroup && contact.groupSettings.isDisbanded; const userIsMuted = contact.isGroup && contact.groupSettings.members['user']?.isMuted; const allMuted = contact.isGroup && contact.groupSettings.isMuted; const userIsAdminOrOwner = contact.isGroup && (contact.groupSettings.owner === 'user' || contact.groupSettings.admins.includes('user')); const canSpeak = !isDisbanded && (!allMuted || userIsAdminOrOwner) && !userIsMuted; if (contact.isGroup) { chatHeaderName.textContent = contact.remark || contact.groupSettings.name; chatHeaderStatus.textContent = `(${contact.members.length + 1})`; chatHeaderSignature.style.display = 'none'; addFriendBtn.style.display = 'none'; chatInput.disabled = !canSpeak; let placeholder = 'ËæìÂÖ•Ê∂àÊÅØ...'; if (isDisbanded) placeholder = 'Áæ§ËÅäÂ∑≤Ëß£Êï£'; else if (allMuted) placeholder = 'ÂÖ®ÂëòÁ¶ÅË®Ä‰∏≠'; else if (userIsMuted) placeholder = '‰Ω†Â∑≤Ë¢´Á¶ÅË®Ä'; chatInput.placeholder = placeholder; const sendIconId = appState.beautify.icons['chat-send-real'];
                if (sendIconId) setElementImage(chatSendRealBtn, sendIconId, 'src'); else chatSendRealBtn.innerHTML = '<i class="fa-solid fa-comments"></i>';  chatToolbar.querySelectorAll('.icon-btn').forEach(btn => btn.classList.toggle('disabled', !canSpeak)); chatEmojiBtn.classList.toggle('disabled', !canSpeak); } else { const settings = contact.charSettings; const statusIndicatorHTML = `<div class="status-indicator ${contact.status}"></div>`; chatHeaderName.textContent = contact.remark || settings.name; chatHeaderStatus.innerHTML = `${statusIndicatorHTML} ${statusMap[contact.status] || 'Êú™Áü•'} ${contact.statusText ? `- ${contact.statusText}` : ''}`; chatHeaderSignature.textContent = contact.signature || '(ÁÇπÂáªËÆæÁΩÆÁ≠æÂêç)'; chatHeaderSignature.style.display = 'block'; addFriendBtn.style.display = settings.isFriend ? 'none' : 'block'; chatInput.disabled = !settings.isFriend; chatInput.placeholder = settings.isFriend ? 'ËæìÂÖ•Ê∂àÊÅØ...' : '‰Ω†Ëøò‰∏çÊòØÂØπÊñπÁöÑÂ•ΩÂèã'; const sendIconId = appState.beautify.icons['chat-send-real'];
           if (sendIconId) setElementImage(chatSendRealBtn, sendIconId, 'src'); else chatSendRealBtn.innerHTML = settings.isFriend ? '<i class="fa-solid fa-comments"></i>' : 'ü§ù'; chatToolbar.querySelectorAll('.icon-btn').forEach(btn => btn.classList.toggle('disabled', !settings.isFriend)); chatEmojiBtn.classList.toggle('disabled', !settings.isFriend); } const specificBgId = contact.isGroup ? contact.groupSettings.chatBackgroundId : contact.charSettings?.chatBackgroundId; const chatBgId = (specificBgId && specificBgId !== 'default') ? specificBgId : appState.beautify.currentChatBgId; await applyWallpaperById(chatBgId, singleChatScreen); renderConversation(); updateChatInputButtons(); updateTypingIndicator(); }
chatBackBtn.addEventListener('click', () => { closeSubScreen(singleChatScreen, chatAppScreen); runtimeState.currentChatId = null; if (runtimeState.chatSelectionMode) exitChatSelectionMode(); });
chatSettingsBtn.addEventListener('click', () => { if (runtimeState.chatSelectionMode) { if (runtimeState.selectedMessages.length > 0 && confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${runtimeState.selectedMessages.length} Êù°Ê∂àÊÅØÂêóÔºü`)) { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); contact.conversation = contact.conversation.filter(msg => !runtimeState.selectedMessages.includes(msg.id)); updateContactLastMessage(runtimeState.currentChatId); debouncedSaveState(); renderConversation(); renderMessageList(); } exitChatSelectionMode(); } else { openChatSettings(); } });
function renderConversation(isLoadingMore = false) {
    let contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
    if (!contact) return;

    if (!isLoadingMore) {
        chatMessagesView.innerHTML = '';
    }

    const isSettingsPreview = (groupChatSettingsScreen.classList.contains('active') || chatSettingsScreen.classList.contains('active')) && runtimeState.tempChatSettings && Object.keys(runtimeState.tempChatSettings).length > 0;
    if (isSettingsPreview) {
        const tempContact = JSON.parse(JSON.stringify(contact));
        if (tempContact.isGroup) {
            tempContact.groupSettings = runtimeState.tempChatSettings.groupSettings;
            tempContact.userSettings = runtimeState.tempChatSettings.userSettings;
        } else {
            tempContact.charSettings = runtimeState.tempChatSettings.charSettings;
            tempContact.userSettings = runtimeState.tempChatSettings.userSettings;
        }
        contact = tempContact;
    }

    const displayLimit = runtimeState.chatDisplayLimits[contact.id] || 50;
    const conversation = contact.conversation;
    const messagesToRender = conversation.slice(-displayLimit);

    const fragment = document.createDocumentFragment();

    if (conversation.length > displayLimit) {
        const loadMoreEl = document.createElement('div');
        loadMoreEl.className = 'message-timestamp';
        loadMoreEl.id = 'load-more-messages-btn';
        loadMoreEl.textContent = 'Âä†ËΩΩÊõ¥Â§öÊ∂àÊÅØ';
        loadMoreEl.style.cursor = 'pointer';
        loadMoreEl.style.color = 'var(--accent-color)';
        fragment.appendChild(loadMoreEl);
    }
    
    let lastTimestamp = (messagesToRender.length > 0) ? (messagesToRender[0].timestamp - 6 * 60 * 1000) : 0;
    
    messagesToRender.forEach(msg => {
        if (msg.timestamp - lastTimestamp > 5 * 60 * 1000) {
            const timeEl = document.createElement('div');
                    timeEl.className = 'message-timestamp';
                    timeEl.textContent = new Date(msg.timestamp).toLocaleString();
                    fragment.appendChild(timeEl);
                    lastTimestamp = msg.timestamp;
                }

                if (msg.type === 'notification') {
                    const notificationEl = document.createElement('div');
                    notificationEl.className = 'message-timestamp';
                    notificationEl.dataset.id = msg.id;
                    notificationEl.textContent = msg.content;
                    if (msg.originalContent) {
                        notificationEl.dataset.originalContent = JSON.stringify(msg.originalContent);
                    }
                    fragment.appendChild(notificationEl);
                    return;
                }

                const msgItem = document.createElement('div');
                msgItem.className = `message-item ${msg.sender === 'user' ? 'user' : 'contact'}`;
                msgItem.dataset.id = msg.id;
                msgItem.dataset.sender = msg.sender;
                const isUser = msg.sender === 'user';

        let avatarId, avatarFrameId, senderName;
        if (contact.isGroup) {
            const memberSettings = contact.groupSettings.members[msg.sender];
            const userProfile = findUserById(msg.sender);
            avatarId = memberSettings?.avatarId || userProfile.avatarId;
            senderName = memberSettings?.nickname || userProfile.name;
            avatarFrameId = memberSettings?.avatarFrameId || '';
        } else {
            avatarId = isUser ? contact.userSettings.avatarId : contact.charSettings.avatarId;
            senderName = isUser ? contact.userSettings.name : (contact.remark || contact.charSettings.name);
            avatarFrameId = isUser ? contact.userSettings.avatarFrameId : contact.charSettings.avatarFrameId;
        }

        const avatarHTML = `<div class="avatar" data-avatar-id="${avatarId}"><div class="avatar-frame" data-avatar-frame-id="${avatarFrameId}"></div></div>`;
        let contentHTML = '';

        if (contact.isGroup && msg.sender !== 'system') {
            const memberSettings = contact.groupSettings.members[msg.sender];
            if (memberSettings) {
                const role = msg.sender === contact.groupSettings.owner ? 'owner' : (contact.groupSettings.admins.includes(msg.sender) ? 'admin' : 'member');
                contentHTML += `<div class="group-message-header"><span class="group-title title-${role}" data-member-id="${msg.sender}">${memberSettings.title || 'ÊàêÂëò'}</span><span class="group-nickname" data-member-id="${msg.sender}">${memberSettings.nickname || 'Êú™Áü•ÊàêÂëò'}</span></div>`;
            } else if (msg.sender) {
                contentHTML += `<div class="group-message-header"><span class="group-nickname" data-member-id="${msg.sender}">${senderName}</span></div>`;
            }
        }

        if (msg.quote) {
            contentHTML += `<div class="message-quote"><strong>${msg.quote.senderName}:</strong> ${msg.quote.content}</div>`;
        }
        
        switch(msg.type) {
            case 'text':
                contentHTML += `<div class="message-bubble">${msg.content}</div>`;
                break;
            case 'emoji':
                contentHTML += `<div class="message-bubble emoji-bubble"><img data-emoji-id="${msg.emojiId}" alt="${msg.description}"></div>`;
                break;
            case 'voice':
                const bubbleWidth = Math.min(60 + msg.duration * 8, 220);
                const spanCount = Math.floor(bubbleWidth / 4);
                const waveformSpans = Array(spanCount).fill(0).map(() => `<span style="height: ${Math.random() * 90 + 10}%"></span>`).join('');
                contentHTML += `<div class="message-bubble voice" style="width: ${bubbleWidth}px;"><div class="voice-waveform-container">${waveformSpans}</div><span class="voice-duration">${msg.duration}‚Äù</span></div><div class="voice-text">${msg.content}</div>`;
                break;
            case 'image':
            case 'camera':
                const isCamera = msg.type === 'camera';
                const cameraOverlay = isCamera ? `<div class="camera-text-overlay">(${msg.content})</div>` : '';
                contentHTML += `<div class="message-bubble ${msg.type}"><img data-image-id="${msg.imageId}">${cameraOverlay}</div>`;
                break;
            case 'link':
                 contentHTML += `<div class="message-bubble link" data-link-content="${encodeURIComponent(JSON.stringify(msg))}"><div class="link-info"><div class="title">${msg.title}</div><div class="summary">${msg.summary}</div><div class="source">${msg.source || 'ÈìæÊé•'}</div></div></div>`;
                 break;
            case 'musicShare':
                 contentHTML += `<div class="message-bubble link" data-song-id="${msg.songId}"><div class="link-info"><div class="title">ÂàÜ‰∫´Èü≥‰πê: ${msg.title}</div><div class="summary">Ê≠åÊâã: ${msg.artist}</div><div class="source">‚ñ∂Ô∏è ÁÇπÂáª‰∏ÄËµ∑Âê¨</div></div></div>`;
                 break;
            case 'redPacket':
                let packetStatusText = '';
                const claimedCount = Object.keys(msg.claimedBy || {}).length;
                if (msg.status === 'claimed' || (claimedCount > 0 && claimedCount >= (msg.count || 1))) {
                    packetStatusText = 'Á∫¢ÂåÖÂ∑≤Ë¢´È¢ÜÂÆå';
                } else if (msg.status === 'returned') {
                    packetStatusText = 'Á∫¢ÂåÖÂ∑≤Ë¢´ÈÄÄÂõû';
                } else if (msg.status === 'expired') {
                    packetStatusText = 'Á∫¢ÂåÖÂ∑≤ËøáÊúü';
                }
                let packetTypeFooter = '‰∏™‰∫∫Á∫¢ÂåÖ';
                if(contact.isGroup) {
                    switch(msg.packetType){
                        case 'exclusive': 
                            const targetName = findUserById(msg.exclusiveTo)?.name || 'Êú™Áü•Áî®Êà∑';
                            packetTypeFooter = `Áªô${targetName}ÁöÑ‰∏ìÂ±ûÁ∫¢ÂåÖ`;
                            break;
                        case 'lucky': packetTypeFooter = 'ÊãºÊâãÊ∞îÁ∫¢ÂåÖ'; break;
                        case 'normal': packetTypeFooter = 'ÊôÆÈÄöÁ∫¢ÂåÖ'; break;
                    }
                }
                contentHTML += `<div class="message-bubble red-packet ${msg.status || ''}" data-packet-content="${encodeURIComponent(JSON.stringify(msg))}"><div class="red-packet-header"><span class="red-packet-icon">üßß</span><span>${msg.message}</span></div><div class="red-packet-body">${packetStatusText}</div><div class="red-packet-footer">${packetTypeFooter}</div></div>`;
                break;
        }

        msgItem.innerHTML = `${isUser ? '' : avatarHTML}<div class="message-content-wrapper">${contentHTML}</div>${isUser ? avatarHTML : ''}`;
        fragment.appendChild(msgItem);
    });
    
    const oldScrollHeight = chatMessagesView.scrollHeight;
    if (isLoadingMore) {
        const firstChild = chatMessagesView.firstChild;
        chatMessagesView.insertBefore(fragment, firstChild);
        chatMessagesView.scrollTop = chatMessagesView.scrollHeight - oldScrollHeight;
    } else {
        chatMessagesView.appendChild(fragment);
        chatMessagesView.scrollTop = chatMessagesView.scrollHeight;
    }

    chatMessagesView.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    chatMessagesView.querySelectorAll('[data-avatar-frame-id]').forEach(el => setElementImage(el, el.dataset.avatarFrameId));
    chatMessagesView.querySelectorAll('[data-emoji-id]').forEach(el => setElementImage(el, el.dataset.emojiId, 'src'));
    chatMessagesView.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'src'));
}
function addMessageToConversation(message, fromAI = false) { const contact = appState.chat.contacts.find(c => c.id === message.contactId); if (!contact) return; if (runtimeState.quotedMessage && message.sender === 'user') { let senderName; if (contact.isGroup) { senderName = contact.groupSettings.members[runtimeState.quotedMessage.sender]?.nickname || findUserById(runtimeState.quotedMessage.sender).name; } else { senderName = runtimeState.quotedMessage.sender === 'user' ? (contact.userSettings.name || '‰Ω†') : (contact.remark || contact.charSettings.name); } message.quote = { id: runtimeState.quotedMessage.id, content: runtimeState.quotedMessage.content, senderName: senderName }; runtimeState.quotedMessage = null; quotePreview.style.display = 'none'; }
// --- ADDED: First Love Letter Trigger ---
if (message.sender === 'user' && !contact.isGroup && !contact.charSettings.hasHadFirstChat && contact.conversation.length === 0) {
contact.charSettings.hasHadFirstChat = true;
// Use a timeout to make it feel more natural, as if the character is writing it after the first chat.
setTimeout(() => generateAndSendLoveLetter(contact.id), 2000);
}
// --- END ADDED ---
contact.conversation.push(message); if (fromAI && (!singleChatScreen.classList.contains('active') || runtimeState.currentChatId !== contact.id)) { contact.unreadCount = (contact.unreadCount || 0) + 1; contact.needsShake = true; queueNotification(message.content, contact.id, message.sender); }
// When a new message is added, increase the display limit to ensure it's visible
if (runtimeState.chatDisplayLimits[contact.id]) {
runtimeState.chatDisplayLimits[contact.id]++;
}
if (singleChatScreen.classList.contains('active') && runtimeState.currentChatId === contact.id) { renderConversation(); } updateContactLastMessage(contact.id); renderMessageList(); debouncedSaveState(); }
function addSystemNotification(contactId, content, triggerAi = false, context = null) { const contact = appState.chat.contacts.find(c => c.id === contactId); if (!contact) return; const notification = { id: newId('msg'), type: 'notification', content, timestamp: Date.now(), contactId: contactId, sender: 'system' }; if (triggerAi === false) { notification.status = 'pending'; } contact.conversation.push(notification); updateContactLastMessage(contactId); debouncedSaveState(); if (runtimeState.currentChatId === contactId) { renderConversation(); } renderMessageList(); if (triggerAi) { const updatedContact = appState.chat.contacts.find(c => c.id === contactId); if (updatedContact.isGroup && updatedContact.members.length === 0) { return; } setTimeout(() => triggerAiResponse(contactId, false, false, false, context), 500); } }
chatSendFakeBtn.addEventListener('click', () => { const content = chatInput.value.trim(); if (!content) return; addMessageToConversation({ id: newId('msg'), type: 'text', content, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId }); chatInput.value = ''; updateChatInputButtons(); });
async function triggerAiResponse(targetChatId, isProactive = false, isJealousyTrigger = false, isVideoChat = false, context = null) {
        const contact = appState.chat.contacts.find(c => c.id === targetChatId);
        if (!contact) return;
        if (contact.isGroup && contact.groupSettings.isDisbanded) { return; }
        if (contact.isGroup && contact.members.length === 0) { return; }
        if (runtimeState.activeRequests[targetChatId]) return;
        const messagesToMarkSent = isVideoChat ? [] : contact.conversation.filter(m => m.status === 'pending');
        runtimeState.activeRequests[targetChatId] = true;
        if (!isVideoChat) {
            updateTypingIndicator();
        }
        try {
            const { apiUrl, apiKey, selectedModel } = appState.settings;
            if (!apiUrl || !apiKey || !selectedModel) {
                throw new Error("ËØ∑ÂÖàÂú®‰∏ªÂ±èÂπï‚ÄúËÆæÁΩÆ‚Äù‰∏≠ÈÖçÁΩÆAPI„ÄÅÂØÜÈí•Âπ∂ÈÄâÊã©Ê®°Âûã„ÄÇ");
            }
            const contextMemory = contact.isGroup ? contact.groupSettings.contextMemory : contact.charSettings.contextMemory;
            let systemPrompt;
            let history;
            if (isVideoChat) {
                if (contact.isGroup) {
                    systemPrompt = constructGroupVideoChatPrompt(contact);
                } else {
                    systemPrompt = constructVideoChatPrompt(contact);
                }
                history = appState.chat.videoCallState.log.slice(-10).map(msg => ({
                    role: msg.sender === 'user' ? 'user' : 'assistant',
                    content: `[${msg.senderName}]: ${msg.content}`
                }));
            } else {
                // ===============================================================
                // --- Ê†∏ÂøÉBug‰øÆÂ§çÁÇπ ---
                // ===============================================================
                // Â∞ÜÊé•Êî∂Âà∞ÁöÑ `context` ÂèÇÊï∞ÁªßÁª≠‰º†ÈÄíÁªô constructSystemPrompt
                systemPrompt = constructSystemPrompt(contact, isProactive, isJealousyTrigger, context);
                // ===============================================================

                history = contact.conversation.filter(m => m.status !== 'error').slice(-contextMemory).map(msg => {
                    let role = msg.sender === 'user' ? 'user' : 'assistant';
                    let content = '';
                    if (msg.quote) {
                        content += `[ÂºïÁî® ${msg.quote.senderName}: ${msg.quote.content}] `;
                    }
                    switch (msg.type) {
                        case 'text':
                            content += msg.content;
                            break;
                        case 'voice':
                            content += `[User sends a voice message]: "${msg.content}"`;
                            break;
                        case 'camera':
                            content += `[User sends an image with description]: "${msg.content}"`;
                            break;
                        case 'notification':
                            content += `[System Notification]: ${msg.content}`;
                            role = 'user';
                            break;
                        case 'musicShare':
                            content += `[System Notification]: Music share event - ${msg.title} by ${msg.artist}`;
                            role = 'user';
                            break;
                        case 'redPacket':
                            let rp_desc = `[User sends a red packet]: "${msg.message}"`;
                            if (contact.isGroup) {
                                let type_desc = '';
                                switch (msg.packetType) {
                                    case 'lucky':
                                        type_desc = `a lucky red packet for ${msg.count} people`;
                                        break;
                                    case 'normal':
                                        type_desc = `a normal red packet for ${msg.count} people`;
                                        break;
                                    case 'exclusive':
                                        const targetName = getDisplayName(msg.exclusiveTo, contact.id);
                                        type_desc = `an exclusive red packet for @${targetName}`;
                                        break;
                                }
                                rp_desc = `[User sends ${type_desc}]: "${msg.message}"`;
                            }
                            content += rp_desc;
                            break;
                        default:
                            content += msg.content || '';
                    }
                    return { role, content };
                });
            }
            const sanitizedHistory = history.filter(msg => msg.content && msg.content.trim() !== '');
            if (sanitizedHistory.length === 0 || sanitizedHistory[sanitizedHistory.length - 1].role === 'assistant') {
                    const proactiveInstruction = "„ÄêÁ≥ªÁªüÊåá‰ª§„ÄëÁé∞Âú®ÊòØ‰Ω†ËøõË°åËá™‰∏ªÊ¥ªÂä®ÁöÑÊó∂Èó¥„ÄÇËØ∑‰∏•Ê†ºÈÅµÂæ™‰Ω†Âú®Á≥ªÁªüËÆæÂÆö(system prompt)‰∏≠Êî∂Âà∞ÁöÑÂÖ≥‰∫é„Äê‰∏ªÂä®‰∫§‰∫í„ÄëÁöÑËØ¶ÁªÜÊåáÁ§∫Ôºö‰ºòÂÖàÊ£ÄÊü•Âπ∂Â§ÑÁêÜÊâÄÊúâÁ§æ‰∫§‰∫íÂä®ÔºàÂõûÂ§çËØÑËÆ∫„ÄÅÁÇπËµû/ËØÑËÆ∫Êñ∞Âä®ÊÄÅÁ≠âÔºâÔºåÁÑ∂ÂêéÊ†πÊçÆ‰Ω†ÁöÑ‰∫∫ËÆæÂíåÂΩìÂâçÊÉÖÊôØÔºåËá™ÁÑ∂Âú∞Â±ïÂºÄÂêéÁª≠Ë°åÂä®Ôºà‰æãÂ¶ÇÂèëÂ∏ÉËá™Â∑±ÁöÑÂä®ÊÄÅ„ÄÅ‰∏ªÂä®ËÅîÁ≥ªÁî®Êà∑ÂºÄÂêØÊñ∞ËØùÈ¢òÁ≠âÔºâ„ÄÇ‰Ω†ÁöÑÊâÄÊúâÂèëË®ÄÂíåË°åÂä®ÈÉΩÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆàÊâÄÊúâÊó¢ÂÆöËßÑÂàô„ÄÇ„ÄêÈáçË¶Å„Äë‰∏•Á¶ÅÂú®‰Ω†ÁöÑÂõûÂ§ç‰∏≠ÊèêÂèäÊàñÂºïÁî®ËøôÊù°Êåá‰ª§„ÄÇ";
                    sanitizedHistory.push({ role: 'user', content: proactiveInstruction });
                }
            const messages = [{ role: 'system', content: systemPrompt }, ...sanitizedHistory];
            const response = await fetch(`${apiUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: selectedModel, messages: messages, stream: false })
            });
            if (!response.ok) {
                        const errorText = await response.text();
                        let errorMessage = `API Error: ${response.status}`;
                        try {
                            const errorJson = JSON.parse(errorText);
                            if (errorJson.error && errorJson.error.message) {
                                 errorMessage += ` - ${errorJson.error.message}`;
                            } else {
                                errorMessage += ` ${response.statusText}`;
                            }
                        } catch(e) {
                            errorMessage += ` ${response.statusText}`;
                            if (errorText) {
                                errorMessage += ` - ${errorText}`;
                            }
                        }
                        throw new Error(errorMessage.trim());
                    }
            const data = await response.json();
            const replyContent = data.choices[0]?.message?.content;
            if (replyContent && replyContent.trim() !== "") {
                if (isVideoChat) {
                    await processAiVideoReply(replyContent, contact.id);
                } else {
                    messagesToMarkSent.forEach(msg => {
                        if (msg.type === 'redPacket') {
                            msg.status = 'unclaimed';
                        } else {
                            msg.status = 'sent';
                        }
                    });
                    await processAiReply(replyContent, contact);
                }
            } else {
                throw new Error("APIËøîÂõû‰∫ÜÁ©∫ÂõûÂ§ç„ÄÇ");
            }
        } catch (error) {
            console.error("AI reply error:", error);
            const contact = appState.chat.contacts.find(c => c.id === targetChatId);
            if (contact && !isVideoChat) {
                const errorMsg = { id: newId('msg'), type: 'text', content: `(Á≥ªÁªüÈîôËØØ: ${error.message})`, sender: contact.isGroup ? (contact.members[0] || contact.id) : contact.id, timestamp: new Date().getTime(), status: 'error', contactId: targetChatId };
                contact.conversation.push(errorMsg);
            } else if (isVideoChat) {
                addMessageToVideoChatLog('system', `(Á≥ªÁªüÈîôËØØ: ${error.message})`, 'System');
            }
        } finally {
            delete runtimeState.activeRequests[targetChatId];
            if (!isVideoChat) {
                updateTypingIndicator();
                debouncedSaveState();
                if (singleChatScreen.classList.contains('active') && runtimeState.currentChatId === targetChatId) {
                    renderConversation();
                }
            }
        }
    }
chatSendRealBtn.addEventListener('click', async () => {
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;
        
        // Add friend logic
        if (!contact.isGroup && !contact.charSettings.isFriend) {
            if (confirm('‰Ω†‰ª¨Ëøò‰∏çÊòØÂ•ΩÂèãÔºåË¶ÅÂº∫Âà∂Ê∑ªÂä†ÂØπÊñπ‰∏∫Â•ΩÂèãÂêóÔºüËøô‰ºöÁ´ãÂç≥Êàê‰∏∫Â•ΩÂèãÔºåÂπ∂ÈÄöÁü•ÂØπÊñπ„ÄÇ')) {
                contact.charSettings.isFriend = true;
                addSystemNotification(contact.id, '‰Ω†Âº∫Âà∂ÈÄöËøá‰∫ÜÂ•ΩÂèãÁî≥ËØ∑', true);
                updateSingleChatUI();
                debouncedSaveState();
            }
            return;
        }
        
        // Send pending message and trigger AI
        const pendingTextInput = chatInput.value.trim();
        if (pendingTextInput) {
            addMessageToConversation({ id: newId('msg'), type: 'text', content: pendingTextInput, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId });
            chatInput.value = '';
            updateChatInputButtons();
        }
        
        const hasPendingMessages = contact.conversation.some(m => m.status === 'pending');
        if (hasPendingMessages) {
            await triggerAiResponse(runtimeState.currentChatId);
        } else {
            showToast('Ê≤°ÊúâË¶ÅÂèëÈÄÅÁöÑÊñ∞Ê∂àÊÅØ', 'error');
        }
    });
closeEmojiPickerBtn.addEventListener('click', () => { if (runtimeState.emojiSelectionMode) { exitEmojiSelectionMode(); } else { emojiPickerPanel.classList.remove('visible'); } });
function renderEmojiPicker() { emojiGrid.innerHTML = ''; appState.chat.emojis.forEach(emoji => { const item = document.createElement('div'); item.className = 'emoji-item'; item.dataset.emojiId = emoji.id; emojiGrid.appendChild(item); setElementImage(item, emoji.id, 'backgroundImage'); }); }
addEmojiBtn.addEventListener('click', async () => { if (runtimeState.emojiSelectionMode) { if (runtimeState.selectedEmojis.length > 0 && confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${runtimeState.selectedEmojis.length} ‰∏™Ë°®ÊÉÖÂêóÔºü`)) { for (const emojiId of runtimeState.selectedEmojis) { await deleteMediaFromDB(emojiId); appState.chat.emojis = appState.chat.emojis.filter(em => em.id !== emojiId); } debouncedSaveState(); renderEmojiPicker(); showToast('Ë°®ÊÉÖÂ∑≤Âà†Èô§'); } exitEmojiSelectionMode(); } else { addEmojiModal.classList.add('visible'); } });
cancelAddEmojiBtn.addEventListener('click', () => addEmojiModal.classList.remove('visible'));
uploadEmojiFileBtn.addEventListener('click', () => { if (!uploadEmojiDescInput.value.trim()) { showToast('ËØ∑ÂÖàËæìÂÖ•Ë°®ÊÉÖÂåÖÊèèËø∞', 'error'); return; } emojiFileInput.click(); });
emojiFileInput.addEventListener('change', async (e) => { const files = e.target.files; const descs = uploadEmojiDescInput.value.trim().split('\n').filter(d => d); if (files.length === 0 || descs.length === 0) return; if (files.length !== descs.length) { showToast(`Êñá‰ª∂Êï∞Èáè(${files.length})‰∏éÊèèËø∞Êï∞Èáè(${descs.length})‰∏çÂåπÈÖç`, 'error'); return; } for (let i = 0; i < files.length; i++) { const newEmojiId = newId('emoji'); await addMediaToDB(newEmojiId, files[i]); appState.chat.emojis.push({ id: newEmojiId, description: descs[i] }); } debouncedSaveState(); renderEmojiPicker(); showToast(`ÊàêÂäüÊ∑ªÂä† ${files.length} ‰∏™Ë°®ÊÉÖÂåÖ`); addEmojiModal.classList.remove('visible'); emojiFileInput.value = ''; uploadEmojiDescInput.value = ''; });
confirmAddEmojiUrlBtn.addEventListener('click', async () => {
    const btn = confirmAddEmojiUrlBtn;
    if (btn.disabled) return;
    btn.disabled = true;
    btn.textContent = 'Â§ÑÁêÜ‰∏≠...';

    try {
        const lines = emojiUrlInput.value.trim().split('\n');
        let addedCount = 0;
        const promises = [];

        for (const line of lines) {
            if (!line.trim()) continue; // Skip empty lines

            // More robust parsing: split by the first colon
            const parts = line.split(/:|Ôºö/);
            if (parts.length < 2) continue; // Skip lines without a separator

            const desc = parts.shift().trim(); // The first part is always the description
            const url = parts.join(':').trim();   // The rest, joined back, is the URL

            if (desc && url && url.startsWith('http')) {
                const promise = (async () => {
                    try {
                        // --- CORE FIX: Removed the proxy and fetch the URL directly ---
                        const response = await fetch(url);
                        if (!response.ok) {
                            console.error(`Failed to fetch ${url}: ${response.statusText}`);
                            return; // Skip this one on failure
                        }
                        const blob = await response.blob();
                        const newEmojiId = newId('emoji');
                        await addMediaToDB(newEmojiId, blob);
                        appState.chat.emojis.push({ id: newEmojiId, description: desc });
                        addedCount++;
                    } catch (e) {
                        console.error(`Error processing URL ${url}:`, e);
                    }
                })();
                promises.push(promise);
            }
        }

        await Promise.all(promises);

        if (addedCount > 0) {
            debouncedSaveState();
            renderEmojiPicker();
            showToast(`ÊàêÂäüÊ∑ªÂä† ${addedCount} ‰∏™Ë°®ÊÉÖÂåÖ`);
        } else {
            showToast('Êú™Ê∑ªÂä†‰ªª‰ΩïË°®ÊÉÖÔºåËØ∑Ê£ÄÊü•Ê†ºÂºè (ÊèèËø∞: URL)', 'error');
        }
        
        addEmojiModal.classList.remove('visible');
        emojiUrlInput.value = '';

    } catch (error) {
        console.error("Error adding emojis from URL:", error);
        showToast(`Ê∑ªÂä†Ë°®ÊÉÖÊó∂ÂèëÁîüÈîôËØØ: ${error.message}`, "error");
    } finally {
        btn.disabled = false;
        btn.textContent = 'Ê∑ªÂä†URL';
    }
});
chatHeaderName.addEventListener('click', () => { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; if (contact.isGroup) { const oldRemark = contact.remark || contact.groupSettings.name; const newRemark = prompt('‰øÆÊîπÁæ§Â§áÊ≥® (‰ªÖËá™Â∑±ÂèØËßÅ):', oldRemark); if (newRemark !== null && newRemark.trim() !== oldRemark) { contact.remark = newRemark.trim(); debouncedSaveState(); updateSingleChatUI(); renderMessageList(); } } else { const oldRemark = contact.remark || contact.charSettings.name; const newRemark = prompt('‰øÆÊîπÂ§áÊ≥®:', oldRemark); if (newRemark !== null && newRemark.trim() !== oldRemark) { contact.remark = newRemark.trim(); debouncedSaveState(); updateSingleChatUI(); renderMessageList(); } } });
chatHeaderStatus.addEventListener('click', () => { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact || contact.isGroup) return; statusDescInput.value = contact.statusText || ''; const statuses = [ { value: 'online', text: 'Âú®Á∫ø' }, { value: 'busy', text: 'ÂøôÁ¢å' }, { value: 'offline', text: 'Á¶ªÁ∫ø' } ]; statusSelectGroup.innerHTML = statuses.map(s => `<label class="radio-label"><input type="radio" name="status" value="${s.value}" ${contact.status === s.value ? 'checked' : ''}><div class="status-indicator ${s.value}"></div><span>${s.text}</span></label>`).join(''); editStatusModal.classList.add('visible'); });
cancelEditStatusBtn.addEventListener('click', () => editStatusModal.classList.remove('visible'));
confirmEditStatusBtn.addEventListener('click', () => { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; const selectedStatus = query('input[name="status"]:checked'); if (!selectedStatus) return; const oldStatus = `${statusMap[contact.status] || ''} ${contact.statusText || ''}`.trim(); contact.status = selectedStatus.value; contact.statusText = statusDescInput.value.trim(); const newStatus = `${statusMap[contact.status] || ''} ${contact.statusText || ''}`.trim(); if (oldStatus !== newStatus) { addSystemNotification(runtimeState.currentChatId, `${contact.name} Â∞ÜÁä∂ÊÄÅ‰øÆÊîπ‰∏∫Ôºö${newStatus}`, false); } debouncedSaveState(); updateSingleChatUI(); renderMessageList(); editStatusModal.classList.remove('visible'); });
chatHeaderSignature.addEventListener('click', () => { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact || contact.isGroup) return; const newSig = prompt('‰øÆÊîπÂØπÊñπÁöÑÁ≠æÂêç(Ê≠§‰∏∫Áî®Êà∑Á∫†Ê≠£Ë°å‰∏∫ÔºåÂØπÊñπ‰∏ç‰ºöÊúâÁñëÈóÆ):', contact.signature); if (newSig !== null) { const oldSig = contact.signature; contact.signature = newSig.trim() || '(ÁÇπÂáªËÆæÁΩÆÁ≠æÂêç)'; if (oldSig !== contact.signature) { addSystemNotification(runtimeState.currentChatId, `${contact.charSettings.name} Â∞ÜÁ≠æÂêç‰øÆÊîπ‰∏∫Ôºö‚Äú${contact.signature}‚Äù`, false); } debouncedSaveState(); updateSingleChatUI(); } });
closeViewContentBtn.addEventListener('click', () => viewContentModal.classList.remove('visible'));
cancelPatBtn.addEventListener('click', () => patSuffixModal.classList.remove('visible'));
confirmPatBtn.addEventListener('click', () => {
        const suffix = patSuffixInput.value.trim();
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        let patterName = findUserById('user').name;
        let targetName;

        if (contact.isGroup) {
            patterName = contact.groupSettings.members['user'].nickname || patterName;
            const targetMember = contact.groupSettings.members[runtimeState.patTarget.memberId];
            if (targetMember) {
                targetName = targetMember.nickname;
            } else {
                targetName = findUserById(runtimeState.patTarget.memberId).name; // Fallback
            }
        } else { // ÂçïËÅä
            patterName = contact.userSettings.name || patterName;
            if (runtimeState.patTarget.type === 'user') {
                targetName = 'Ëá™Â∑±';
            } else {
                targetName = contact.remark || contact.charSettings.name;
            }
        }
        
        const notificationText = `'${patterName}' Êãç‰∫ÜÊãç '${targetName}'${suffix ? ` ${suffix}` : ''}`;
        addSystemNotification(runtimeState.currentChatId, notificationText, false);
        patSuffixModal.classList.remove('visible');
        patSuffixInput.value = '';
    });

// ===================================================================
// --- ËÅäÂ§©Â∑•ÂÖ∑Ê†èÊñ∞ÂäüËÉΩ ---
// ===================================================================
function setupChatToolbarListeners() { getEl('chat-emoji-btn').addEventListener('click', (e) => { if (!e.currentTarget.classList.contains('disabled')) { emojiPickerPanel.classList.toggle('visible'); if (emojiPickerPanel.classList.contains('visible')) { renderEmojiPicker(); } } }); getEl('chat-refresh-btn').addEventListener('click', (e) => { if (!e.currentTarget.classList.contains('disabled')) handleRefreshClick(); }); getEl('chat-voice-btn').addEventListener('click', (e) => { if (!e.currentTarget.classList.contains('disabled')) voiceInputModal.classList.add('visible'); }); getEl('chat-image-btn').addEventListener('click', (e) => { if (!e.currentTarget.classList.contains('disabled')) chatImageInput.click(); }); getEl('chat-camera-btn').addEventListener('click', (e) => { if (!e.currentTarget.classList.contains('disabled')) cameraInputModal.classList.add('visible'); }); getEl('chat-video-btn').addEventListener('click', (e) => { if (!e.currentTarget.classList.contains('disabled')) initiateVideoCall(); }); getEl('chat-music-btn').addEventListener('click', (e) => { if (!e.currentTarget.classList.contains('disabled')) handleMusicShareClick(); }); getEl('chat-link-btn').addEventListener('click', (e) => { if (!e.currentTarget.classList.contains('disabled')) linkShareModal.classList.add('visible'); }); getEl('chat-redpacket-btn').addEventListener('click', (e) => { if (!e.currentTarget.classList.contains('disabled')) handleRedPacketClick(); }); getEl('chat-shop-btn').addEventListener('click', (e) => { if (!e.currentTarget.classList.contains('disabled')) showToast('Ë¥≠Áâ©ÂäüËÉΩÂæÖÂºÄÂèë'); }); }
async function handleRefreshClick() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; let lastUserMessageIndex = -1; for (let i = contact.conversation.length - 1; i >= 0; i--) { if (contact.conversation[i].sender === 'user' || contact.conversation[i].status === 'error') { lastUserMessageIndex = i; break; } } if (lastUserMessageIndex === -1) { showToast('Ê≤°ÊúâÂèØÂà∑Êñ∞ÁöÑÂõûÂ§ç', 'error'); return; } const messagesToDelete = contact.conversation.filter((msg, index) => index >= lastUserMessageIndex && (msg.sender !== 'user' || msg.status === 'error')); if (messagesToDelete.length === 0) { showToast('Ê≤°ÊúâÂèØÂà∑Êñ∞ÁöÑÂõûÂ§ç', 'error'); return; } contact.conversation = contact.conversation.filter((msg, index) => index < lastUserMessageIndex || (index === lastUserMessageIndex && msg.sender === 'user' && msg.status !== 'error')); updateContactLastMessage(runtimeState.currentChatId); debouncedSaveState(); renderConversation(); renderMessageList(); await triggerAiResponse(runtimeState.currentChatId); }
// ===================================================================
// --- ËßÜÈ¢ëÈÄöËØùÈÄªËæë (ÈáçÊûÑ) ---
// ===================================================================
async function initiateVideoCall() {
        if (appState.chat.videoCallState.isActive) {
            showToast('Â∑≤Âú®ÈÄöËØù‰∏≠');
            return;
        }
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;
    
        addSystemNotification(contact.id, `‰Ω†ÂèëËµ∑‰∫Ü${contact.isGroup ? 'Áæ§ÁªÑ' : ''}ËßÜÈ¢ëÈÄöËØù...`, false);
            renderConversation(); // Á°Æ‰øùÂú®ÂºπÁ™óÂâçÊ∏≤ÊüìÊ∂àÊÅØ
    
        if (contact.isGroup) {
            if (contact.members.length === 0) {
                showToast('Áæ§ÈáåËøòÊ≤°ÊúâÂÖ∂‰ªñÊàêÂëòÂì¶', 'error');
                // Clean up the system notification if the call fails immediately
                const lastMsg = contact.conversation[contact.conversation.length - 1];
                if (lastMsg.content.includes('‰Ω†ÂèëËµ∑‰∫Ü')) contact.conversation.pop();
                renderConversation();
                return;
            }
            // For group calls, accept immediately on the user's side and wait for members.
            await acceptVideoCall(contact.id, true); // Pass true for isGroup
        } else {
            // For single calls, wait for the char's decision.
            try {
                const decision = await fetchVideoCallDecision(contact.id);
                if (decision === 'ACCEPT') {
                    await acceptVideoCall(contact.id, false);
                } else {
                    rejectVideoCall(contact.id);
                }
            } catch (error) {
                console.error("Video call decision failed:", error);
                showToast(`ÂëºÂè´Â§±Ë¥•: ${error.message}`, 'error');
                const lastMsg = contact.conversation[contact.conversation.length - 1];
                if (lastMsg.content.includes('‰Ω†ÂèëËµ∑‰∫Ü')) contact.conversation.pop();
                renderConversation();
            }
        }
    }

async function fetchVideoCallDecision(contactId) {
    const contact = appState.chat.contacts.find(c => c.id === contactId);
    const { apiUrl, apiKey, selectedModel } = appState.settings;
    if (!apiUrl || !apiKey || !selectedModel) throw new Error("APIÊú™ÈÖçÁΩÆ");

    const decisionPrompt = constructVideoCallDecisionPrompt(contact);
    const history = contact.conversation.slice(-5).map(msg => ({
        role: msg.sender === 'user' ? 'user' : 'assistant',
        content: msg.content || `[${msg.type}]`
    }));
    
    const messages = [{ role: 'system', content: decisionPrompt }, ...history];
    
    const response = await fetch(`${apiUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
        body: JSON.stringify({ model: selectedModel, messages, max_tokens: 10, temperature: 0.5 })
    });

    if (!response.ok) throw new Error(`APIËØ∑Ê±ÇÂÜ≥Á≠ñÂ§±Ë¥•: ${response.status}`);
    const data = await response.json();
    const decisionText = data.choices[0]?.message?.content.trim().toUpperCase();
    return decisionText.includes('ACCEPT') ? 'ACCEPT' : 'REJECT';
}

async function acceptVideoCall(contactId, isGroupCall) {
        const contact = appState.chat.contacts.find(c => c.id === contactId);
        if (!contact) return;
    
        appState.chat.videoCallState = {
            isActive: true,
            chatId: contactId,
            isGroup: isGroupCall,
            startTime: Date.now(),
            log: [],
            participants: isGroupCall ? [] : [contact.id],
            isMinimized: false,
            isCameraSwapped: false,
            initiator: 'user' // Currently, only user can initiate
        };
        
        if (!isGroupCall) {
            addSystemNotification(contactId, 'ÂØπÊñπÂ∑≤Êé•Âê¨', false);
        }
        
        debouncedSaveState();
        activateDynamicIslandTimer();
        await openVideoCallModal();
    
        if (isGroupCall) {
            // For group calls, now we ask the AI which members will join.
            await triggerVideoCallInvitationResponse(contactId);
        } else {
            // For single calls, start the conversation.
            await triggerAiResponse(contactId, false, false, true);
        }
    }

function rejectVideoCall(contactId, charId = null, reason = "") {
        const contact = appState.chat.contacts.find(c => c.id === contactId);
        if (!contact) return;
        
        if (contact.isGroup && charId) {
            const charName = contact.groupSettings.members[charId]?.nickname || findUserById(charId).name;
    appState.chat.videoCallState.lastRejectedCallTimestamp = Date.now();
    addSystemNotification(contactId, `${charName} ÊãíÁªù‰∫ÜËßÜÈ¢ëÈÄöËØùÈÇÄËØ∑`, true, { callInitiator: 'user' });
        } else if (!contact.isGroup) {
            appState.chat.videoCallState.lastRejectedCallTimestamp = Date.now();
    addSystemNotification(contactId, `ÂØπÊñπÂ∑≤ÊãíÁªù`, true, { callInitiator: 'user' });
        }
    }

function endVideoCall(options = {}) {
            const { hungUpBy = 'user', reason = 'ended' } = options;
            if (!appState.chat.videoCallState.isActive) return;

            const chatId = appState.chat.videoCallState.chatId;
            const duration = Date.now() - appState.chat.videoCallState.startTime;
            const minutes = Math.floor(duration / 60000);
            const seconds = Math.floor((duration % 60000) / 1000);
            const durationString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
            closeVideoCallModal();

            // ÈáçÁΩÆÈÄöËØùÁä∂ÊÄÅ
            const previousCallState = { ...appState.chat.videoCallState };
            appState.chat.videoCallState.isActive = false;
            appState.chat.videoCallState.chatId = null;
            appState.chat.videoCallState.participants = [];
            
            dynamicIsland.classList.remove('video-call-active');
            if (islandVideoCallTimer) {
                clearInterval(islandVideoCallTimer);
                islandVideoCallTimer = null;
            }
            islandVideoTimer.textContent = '';
            debouncedSaveState();

            let notificationText = '';
            switch(reason) {
                case 'interrupted':
                    notificationText = `ÈÄöËØùÊÑèÂ§ñ‰∏≠Êñ≠ÔºåÈÄöËØùÊó∂Èïø ${durationString}`;
                    break;
                case 'ended':
                default:
                    notificationText = `ËßÜÈ¢ëÈÄöËØùÁªìÊùüÔºåÈÄöËØùÊó∂Èïø ${durationString}`;
                    break;
            }
            addSystemNotification(chatId, notificationText, true);
        }

async function openVideoCallModal() {
        if (!appState.chat.videoCallState.isActive) {
            closeVideoCallModal();
            return;
        }
    
        // È¶ñÂÖàÔºå‰ªéÊåÅ‰πÖÁä∂ÊÄÅ‰∏≠Ëé∑ÂèñÊâÄÊúâÈúÄË¶ÅÁöÑÂèòÈáè
        const { chatId, log, isMinimized, isCameraSwapped, isGroup, participants } = appState.chat.videoCallState;
        
        // Êü•ÊâæÂü∫Á°ÄËÅîÁ≥ª‰∫∫‰ø°ÊÅØÔºå‰ΩÜ‰ΩøÁî® 'let' ÂÖ≥ÈîÆÂ≠ó‰ª•‰æøÂêéÁª≠ÂèØ‰ª•‰∏∫È¢ÑËßàÁõÆÁöÑËøõË°å‰øÆÊîπ
        let contact = appState.chat.contacts.find(c => c.id === chatId);
        if (!contact) return;

        // „ÄêÊ†∏ÂøÉ‰ºòÂåñ„ÄëÊ£ÄÊü•Âπ∂Â∫îÁî®‰∏¥Êó∂ËÆæÁΩÆÔºå‰ª•ÂÆûÁé∞ÂßìÂêçÁ≠â‰ø°ÊÅØÁöÑÂÆûÊó∂Âà∑Êñ∞
        const settingsScreenActive = chatSettingsScreen.classList.contains('active') || groupChatSettingsScreen.classList.contains('active');
        if (settingsScreenActive && runtimeState.tempChatSettings && Object.keys(runtimeState.tempChatSettings).length > 0) {
            const tempContact = JSON.parse(JSON.stringify(contact)); // ÂàõÂª∫‰∏Ä‰∏™‰∏¥Êó∂ÂâØÊú¨
            if (tempContact.isGroup) {
                // Â∞Ü‰∏¥Êó∂ÁöÑÁæ§ÁªÑÂíåÁî®Êà∑ËÆæÁΩÆÂ∫îÁî®Âà∞ÂâØÊú¨‰∏ä
                tempContact.groupSettings = runtimeState.tempChatSettings.groupSettings;
                tempContact.userSettings = runtimeState.tempChatSettings.userSettings;
            } else {
                // Â∞Ü‰∏¥Êó∂ÁöÑËßíËâ≤ÂíåÁî®Êà∑ËÆæÁΩÆÂ∫îÁî®Âà∞ÂâØÊú¨‰∏ä
                tempContact.charSettings = runtimeState.tempChatSettings.charSettings;
                tempContact.userSettings = runtimeState.tempChatSettings.userSettings;
            }
            contact = tempContact; // Âú®Êú¨Ê¨°Ê∏≤Êüì‰∏≠Ôºå‰ΩøÁî®Ëøô‰∏™Â∏¶Êúâ‰∏¥Êó∂Êõ¥ÊîπÁöÑÂâØÊú¨
        }
    
        if (isMinimized) {
            videoCallModal.classList.remove('visible');
            videoCallFloatBtn.classList.add('visible');
            const floatAvatarId = isGroup 
                ? contact.groupSettings.avatarId 
                : (participants[0] ? findUserById(participants[0]).avatarId : 'default_user_avatar');
            await setElementImage(videoCallFloatBtn, floatAvatarId, 'backgroundImage');
            return;
        }
    
        videoCallFloatBtn.classList.remove('visible');
        videoCallModal.classList.remove('minimized'); // Ensure it's not visually hidden
    
        const setupBg = async (element, bgId) => {
            element.style.backgroundImage = 'none';
            element.style.backgroundColor = '#333'; // Default dark background
            if (bgId) await setElementImage(element, bgId, 'backgroundImage');
        };
    
        // Always show user's camera view in the PiP window
        await setupBg(videoCallPipView, contact.userSettings.videoBackgroundId);
    
        if (isGroup) {
            videoCallSingleCharInfo.style.display = 'none';
            videoCallParticipantsContainer.style.display = 'flex';
            videoCallParticipantsContainer.innerHTML = ''; // Clear before redraw
            
            // Main view shows the group's designated background
            await setupBg(videoCallMainView, contact.groupSettings.videoBackgroundId);
            
            if (participants.length === 0) {
                videoCallParticipantsContainer.innerHTML = `<div class="video-call-name-text" style="font-size: 16px; color: white; text-shadow: 1px 1px 2px black;">Á≠âÂæÖÁæ§ÊàêÂëòÂä†ÂÖ•...</div>`;
            } else {
                for (const charId of participants) {
                    const memberInfo = contact.groupSettings.members[charId];
                    if (memberInfo) {
                        const participantEl = document.createElement('div');
                        participantEl.className = 'video-participant-info';
                        participantEl.innerHTML = `
                            <img class="video-call-avatar-img">
                            <div class="video-call-name-text">${escapeHTML(memberInfo.nickname)}</div>
                        `;
                        videoCallParticipantsContainer.appendChild(participantEl);
                        await setElementImage(participantEl.querySelector('img'), memberInfo.avatarId, 'src');
                    }
                }
            }
        } else { // Single chat
            videoCallSingleCharInfo.style.display = 'flex';
            videoCallParticipantsContainer.style.display = 'none';
            
            const charVideoBgId = contact.charSettings.videoBackgroundId;
            const userVideoBgId = contact.userSettings.videoBackgroundId;
            
            // Determine which background is main and which is PiP based on swap state
            const mainBgId = isCameraSwapped ? userVideoBgId : charVideoBgId;
            const pipBgId = isCameraSwapped ? charVideoBgId : userVideoBgId;
            
            await setupBg(videoCallMainView, mainBgId);
            await setupBg(videoCallPipView, pipBgId); // Re-setup PiP for single chat swap
    
            setElementImage(videoCallAvatar, contact.charSettings.avatarId, 'src');
            videoCallName.textContent = contact.remark || contact.charSettings.name;
        }
    
        videoCallMessages.innerHTML = '';
        log.forEach(msg => addMessageToVideoChatLog(msg.sender, msg.content, msg.senderName));
        
        videoCallModal.classList.add('visible');
    }

function closeVideoCallModal() {
    videoCallModal.classList.remove('visible');
    videoCallFloatBtn.classList.remove('visible');
    videoCallInputWrapper.style.display = 'none';
    videoCallSpeakBtn.style.display = 'block';
    videoCallInput.value = '';
}

function minimizeVideoCall() {
    if (!appState.chat.videoCallState.isActive) return;
    appState.chat.videoCallState.isMinimized = true;
    debouncedSaveState();
    openVideoCallModal(); 
}

function restoreVideoCall() {
    if (!appState.chat.videoCallState.isActive) return;
    appState.chat.videoCallState.isMinimized = false;
    debouncedSaveState();
    openVideoCallModal(); 
}

function toggleCameraSwap() {
    if (!appState.chat.videoCallState.isActive || appState.chat.videoCallState.isGroup) return;
    appState.chat.videoCallState.isCameraSwapped = !appState.chat.videoCallState.isCameraSwapped;
    debouncedSaveState();
    openVideoCallModal();
}

function addMessageToVideoChatLog(sender, content, senderName = 'System') {
    const messageWrapper = document.createElement('div');
    if (sender === 'user') {
        const userP = document.createElement('p');
        userP.className = 'video-chat-msg-user';
        userP.textContent = `${senderName}:`;
        messageWrapper.appendChild(userP);
    } else if (sender === 'char') {
        const charP = document.createElement('p');
        charP.className = 'video-chat-msg-user'; // Same style for now
        charP.textContent = `${senderName}:`;
        messageWrapper.appendChild(charP);
    }

    const contentP = document.createElement('p');
    contentP.className = 'video-chat-msg-char';
    contentP.textContent = content;
    messageWrapper.appendChild(contentP);
    videoCallMessages.appendChild(messageWrapper);
    videoCallMessages.scrollTop = videoCallMessages.scrollHeight;
}

async function sendVideoChatMessage() {
    if (runtimeState.videoCallContext.aiIsResponding) return;
    const text = videoCallInput.value.trim();
    if (!text) return;
    
    const contact = appState.chat.contacts.find(c => c.id === appState.chat.videoCallState.chatId);
    const senderName = getDisplayName('user', contact.id);

    const message = { sender: 'user', senderName, content: text, timestamp: Date.now() };
    appState.chat.videoCallState.log.push(message);
    debouncedSaveState();

    addMessageToVideoChatLog(message.sender, message.content, message.senderName);
    videoCallInput.value = '';

    runtimeState.videoCallContext.aiIsResponding = true;
    await triggerAiResponse(appState.chat.videoCallState.chatId, false, false, true);
    runtimeState.videoCallContext.aiIsResponding = false;
}
async function handleVideoCallRefresh() {
    if (!appState.chat.videoCallState.isActive || runtimeState.videoCallContext.aiIsResponding) return;

    const log = appState.chat.videoCallState.log;
    let lastUserMessageIndex = -1;
    for (let i = log.length - 1; i >= 0; i--) {
        if (log[i].sender === 'user') {
            lastUserMessageIndex = i;
            break;
        }
    }

    if (lastUserMessageIndex === -1) {
        showToast('Ê≤°ÊúâÂèØÂà∑Êñ∞ÁöÑÊ∂àÊÅØ', 'error');
        return;
    }

    // Remove all messages after the last user message
    log.splice(lastUserMessageIndex + 1);
    
    showToast('Ê≠£Âú®ÈáçÊñ∞ÁîüÊàê...', 'info');
    
    // Update UI to reflect removed messages
    await openVideoCallModal(); 

    runtimeState.videoCallContext.aiIsResponding = true;
    await triggerAiResponse(appState.chat.videoCallState.chatId, false, false, true);
    runtimeState.videoCallContext.aiIsResponding = false;
    
    debouncedSaveState();
}
async function processAiVideoReply(replyContent, contactId) {
    const contact = appState.chat.contacts.find(c => c.id === contactId);
            if (!contact || !appState.chat.videoCallState.isActive) return;
        
            // ‰ΩøÁî®Êõ¥ÂÅ•Â£ÆÁöÑÊ≠£ÂàôË°®ËææÂºèÂàÜÂâ≤ÔºåÂÆÉ‰ºöÊåâ <MSG_SPLIT> Êàñ [ÊòµÁß∞]: ÁöÑÊ†ºÂºèÊù•ÂàáÂàÜ
            const blocks = replyContent.split(/<MSG_SPLIT>|(?=\[.*?\]:)/g).map(b => b.trim()).filter(b => b);
        
            for (const block of blocks) {
                // Split each block into text and action fragments for robust parsing
                const fragments = block.split(/(\[ACTION:.*?\])/is).filter(s => s && s.trim());
        
                for (const fragment of fragments) {
                    const actionMatch = fragment.match(/^\[ACTION:\s*([\w_]+)\s*(.*?)\]$/is);
        
                    if (actionMatch) { // This fragment is an action
                        const action = actionMatch[1].toUpperCase();
                        const argsStr = actionMatch[2].trim();
                        const args = argsStr.match(/(?:[^\s"]+|"[^"]*")+/g)?.map(arg => arg.replace(/"/g, '')) || [];
                        const charId = args[0]; // **Ê†∏ÂøÉÂèòÊõ¥**: Áõ¥Êé•‰ΩøÁî®ID
                        const memberInfo = contact.groupSettings.members[charId];
        
                        if (action === 'VIDEO_JOIN' && charId && memberInfo) {
                            if (!appState.chat.videoCallState.participants.includes(charId)) {
                                appState.chat.videoCallState.participants.push(charId);
                                addSystemNotification(contactId, `${memberInfo.nickname} Âä†ÂÖ•‰∫ÜËßÜÈ¢ëÈÄöËØù`, false);
                                // ‰∏çÈúÄË¶ÅÂú®Ê≠§Â§ÑË∞ÉÁî® openVideoCallModalÔºåÂú®Âæ™ÁéØÁªìÊùüÂêéÁªü‰∏ÄÂà∑Êñ∞
                            }
                        } else if (action === 'VIDEO_LEAVE' && charId && memberInfo && args[1]) {
                            if (appState.chat.videoCallState.participants.includes(charId)) {
                                appState.chat.videoCallState.participants = appState.chat.videoCallState.participants.filter(id => id !== charId);
                                const reason = args[1];
                                // Âú®ËßÜÈ¢ëÂºπÁ™óÂÜÖÊòæÁ§∫Á¶ªÂºÄÊ∂àÊÅØ
                                addMessageToVideoChatLog('system', `${memberInfo.nickname} Âõ†‰∏∫ ‚Äú${reason}‚Äù Á¶ªÂºÄ‰∫ÜÈÄöËØù„ÄÇ`);
                                // Âú®‰∏ªËÅäÂ§©ÁïåÈù¢ÊòæÁ§∫Á≥ªÁªüÈÄöÁü•
                                addSystemNotification(contactId, `${memberInfo.nickname} Á¶ªÂºÄ‰∫ÜËßÜÈ¢ëÈÄöËØù`, false);
                            }
                        }
                    } else { // This fragment is dialogue text
                        let senderName, content;
                        if (contact.isGroup) {
                            const speakerMatch = fragment.match(/^\[(.*?)\]:\s*(.*)$/s);
                            if (speakerMatch) {
                                senderName = speakerMatch[1].trim();
                                content = speakerMatch[2].trim();
                                // È™åËØÅÂèëË®Ä‰∫∫ÊòØÂê¶Âú®ÈÄöËØù‰∏≠ÔºåÈò≤Ê≠¢AIÂπªËßâ
                                const isParticipant = appState.chat.videoCallState.participants.some(pid => contact.groupSettings.members[pid]?.nickname === senderName);
                                if (isParticipant) {
                                    const message = { sender: 'char', senderName, content, timestamp: Date.now() };
                                    appState.chat.videoCallState.log.push(message);
                                    addMessageToVideoChatLog('char', content, senderName);
                                }
                            }
                        } else { // ÂçïËÅäÈÄªËæë‰øùÊåÅ‰∏çÂèò
                            senderName = getDisplayName(contact.id, contact.id);
                            content = fragment;
                            const message = { sender: 'char', senderName, content, timestamp: Date.now() };
                            appState.chat.videoCallState.log.push(message);
                            addMessageToVideoChatLog('char', content, senderName);
                        }
                    }
                }
            }
            await openVideoCallModal(); // Refresh UI after all actions in a turn are processed
            debouncedSaveState();
}

function handleMusicShareClick() {
        if (appState.music.playlist.length === 0) {
            showToast('Èü≥‰πêÂ∫ì‰∏∫Á©∫ÔºåËØ∑ÂÖàÊ∑ªÂä†Ê≠åÊõ≤', 'error');
            return;
        }

        // Â¶ÇÊûúÂΩìÂâçÂ∑≤ÁªèÊòØ‰∏ÄËµ∑Âê¨Ê≠åÁä∂ÊÄÅÔºåÂàôÂÅúÊ≠¢
        if (runtimeState.musicSessionType === 'together' && appState.music.currentQueueIndex !== -1) {
            stopPlayback();
            return;
        }
        
        // Â¶ÇÊûúÂΩìÂâçÊúâÂÖ∂‰ªñÈü≥‰πêÊ≠£Âú®Êí≠ÊîæÔºà‰æãÂ¶ÇÂçïÁã¨Âê¨Ê≠åÔºâÔºåÂàôÂÖàÈùôÈªòÂÅúÊ≠¢
        if (audioPlayer.src && !audioPlayer.paused) {
            audioPlayer.pause();
            audioPlayer.src = '';
            appState.music.currentQueueIndex = -1;
            clearInterval(listenTogetherTimer);
            listenTogetherInfo.style.display = 'none';
            updateMusicListPlayingStatus(); // Á°Æ‰øùÊ∏ÖÈô§ÂçïÁã¨Âê¨Ê≠åÁöÑÈ´ò‰∫Æ
        }

        // ÂºÄÂêØ‰∏Ä‰∏™Êñ∞ÁöÑ‚Äú‰∏ÄËµ∑Âê¨Ê≠å‚Äù‰ºöËØù
        appState.music.queue = [...appState.music.playlist];
        renderPlayerQueue();
        playerModal.classList.add('show');
        playSongFromQueue(0, 'user');
    }
chatImageInput.addEventListener('change', async (e) => { const file = e.target.files[0]; if (file) { const imageId = newId('image'); await addMediaToDB(imageId, file); addMessageToConversation({ id: newId('msg'), type: 'image', imageId: imageId, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId }); chatImageInput.value = ''; } });
cancelVoiceBtn.addEventListener('click', () => voiceInputModal.classList.remove('visible'));
confirmVoiceBtn.addEventListener('click', () => { const text = voiceTextInput.value.trim(); if (!text) return; const cleanText = text.replace(/\[.*?\]|Ôºà.*?Ôºâ/g, ''); const duration = Math.ceil(cleanText.length / 2); addMessageToConversation({ id: newId('msg'), type: 'voice', content: text, duration: duration, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId }); voiceInputModal.classList.remove('visible'); voiceTextInput.value = ''; });
cancelCameraBtn.addEventListener('click', () => cameraInputModal.classList.remove('visible'));
confirmCameraBtn.addEventListener('click', async () => { const text = cameraTextInput.value.trim(); if (!text) return; const response = await fetch('https://i.postimg.cc/KY703cH8/QQ-20250816135643.jpg'); const blob = await response.blob(); const imageId = newId('image'); await addMediaToDB(imageId, blob); addMessageToConversation({ id: newId('msg'), type: 'camera', content: text, imageId: imageId, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId }); cameraInputModal.classList.remove('visible'); cameraTextInput.value = ''; });
cancelLinkBtn.addEventListener('click', () => linkShareModal.classList.remove('visible'));
confirmLinkBtn.addEventListener('click', () => { const title = linkTitleInput.value.trim(); if (!title) return showToast('Ê†áÈ¢òÊòØÂøÖÂ°´È°π', 'error'); const summary = linkSummaryInput.value.trim(); const source = linkSourceInput.value.trim(); const content = linkContentInput.value.trim(); addMessageToConversation({ id: newId('msg'), type: 'link', title, summary, source, content, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId }); linkShareModal.classList.remove('visible'); [linkTitleInput, linkSummaryInput, linkSourceInput, linkContentInput].forEach(i => i.value = ''); });
cancelRedPacketBtn.addEventListener('click', () => redPacketModal.classList.remove('visible'));
confirmRedPacketBtn.addEventListener('click', () => { const amount = parseFloat(redPacketAmountInput.value); if (isNaN(amount) || amount <= 0) return showToast('ËØ∑ËæìÂÖ•ÊúâÊïàÈáëÈ¢ù', 'error'); const message = redPacketMessageInput.value.trim() || 'ÊÅ≠ÂñúÂèëË¥¢ÔºåÂ§ßÂêâÂ§ßÂà©ÔºÅ'; addMessageToConversation({ id: newId('msg'), type: 'redPacket', packetType: 'normal', amount, message, sender: 'user', timestamp: Date.now(), status: 'pending', claimedBy: {}, contactId: runtimeState.currentChatId }); redPacketModal.classList.remove('visible'); redPacketAmountInput.value = ''; redPacketMessageInput.value = ''; });
function updateChatInputButtons() { const hasText = chatInput.value.trim() !== ''; chatEmojiBtn.style.display = hasText ? 'none' : 'block'; chatSendFakeBtn.style.display = hasText ? 'block' : 'none'; }
chatInput.addEventListener('input', updateChatInputButtons);

// ===================================================================
// --- Áªü‰∏ÄÂàóË°®‰∫§‰∫íÂ§ÑÁêÜÂô® ---
// ===================================================================
    class ListInteractionHandler {
        constructor(listElement, options) {
            this.listElement = listElement;
            this.options = { ...{ disableSwipe: false, swipeThreshold: 10, longPressDuration: 500 }, ...options };
            this.swipedItem = null; this.startX = 0; this.startY = 0; this.currentX = 0; this.isSwiping = false; this.isLongPress = false; this.longPressTimer = null; this.isPointerDown = false;
            
            this.handlePointerDown = this.handlePointerDown.bind(this);
            this.handlePointerMove = this.handlePointerMove.bind(this);
            this.handlePointerUp = this.handlePointerUp.bind(this);
            this.handlePointerCancel = this.handlePointerCancel.bind(this);
            this.handleClick = this.handleClick.bind(this);

            this.listElement.addEventListener('pointerdown', this.handlePointerDown);
        }

        handlePointerDown(e) {
            if (e.button !== 0) return;
            const targetItem = e.target.closest(this.options.itemSelector);

            if (this.swipedItem) {
                const actions = this.swipedItem.querySelector(this.options.actionsSelector);
                if (actions && actions.contains(e.target)) {
                    // Clicks on action buttons are handled by the handleClick listener.
                } else {
                    e.preventDefault(); 
                    e.stopImmediatePropagation();
                    this.closeSwipedItem();
                    // If we close a swiped item, don't start a new interaction immediately.
                    return; 
                }
            }
            
            if (!targetItem) return;
            
            this.isPointerDown = true; this.isSwiping = false; this.isLongPress = false;
            this.startX = e.clientX; this.startY = e.clientY; this.currentX = this.startX;
            this.lastSwipeTime = 0;
            this.longPressTimer = setTimeout(() => {
                if (this.isPointerDown && !this.isSwiping) {
                    this.isLongPress = true;
                    if (this.options.onLongPress) this.options.onLongPress(targetItem, e.target, e);
                }
            }, this.options.longPressDuration);

            document.addEventListener('pointermove', this.handlePointerMove);
            document.addEventListener('pointerup', this.handlePointerUp);
            document.addEventListener('pointercancel', this.handlePointerCancel);
            // Use a one-time capture listener for the click, set up during pointerdown.
            this.listElement.addEventListener('click', this.handleClick, { capture: true, once: true });
        }

        handlePointerMove(e) {
            if (!this.isPointerDown) return;
            this.currentX = e.clientX;
            const deltaX = this.currentX - this.startX;
            const deltaY = e.clientY - this.startY;

            if (!this.isSwiping && Math.abs(deltaX) > this.options.swipeThreshold) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (this.options.disableSwipe) { this.resetState(); return; }
                    this.isSwiping = true;
                    clearTimeout(this.longPressTimer);
                } else { this.resetState(); }
            }

            if (this.isSwiping) {
                e.preventDefault();
                const targetItem = e.target.closest(this.options.itemSelector);
                if (!targetItem) return;
                this.swipedItem = targetItem;

                const content = targetItem.querySelector(this.options.contentSelector);
                const actions = targetItem.querySelector(this.options.actionsSelector);
                if (!content || !actions) return;

                const actionsWidth = actions.offsetWidth;
                let diff = Math.min(0, deltaX);
                diff = Math.max(-actionsWidth, diff);
                content.style.transition = 'none';
                content.style.transform = `translateX(${diff}px)`;
            }
        }

        handlePointerUp(e) {
            if (!this.isPointerDown) return;
            
            if (this.isSwiping) {
                this.lastSwipeTime = Date.now();
                const content = this.swipedItem.querySelector(this.options.contentSelector);
                const actions = this.swipedItem.querySelector(this.options.actionsSelector);
                if (content && actions) {
                    const actionsWidth = actions.offsetWidth;
                    const currentTranslateX = new WebKitCSSMatrix(window.getComputedStyle(content).transform).m41;
                    content.style.transition = 'transform 0.3s ease';
                    if (currentTranslateX < -actionsWidth / 2) {
                        content.style.transform = `translateX(-${actionsWidth}px)`;
                    } else {
                        content.style.transform = 'translateX(0px)';
                        this.swipedItem = null;
                    }
                }
            }
            
            this.resetState();
        }
        
        handleClick(e) {
            const isRecentSwipe = this.lastSwipeTime && (Date.now() - this.lastSwipeTime < 350); // Â¢ûÂä†ÁºìÂÜ≤Êó∂Èó¥
            const targetItem = e.target.closest(this.options.itemSelector);
            const actions = targetItem ? targetItem.querySelector(this.options.actionsSelector) : null;
            const isActionClick = actions && actions.contains(e.target);

            // „ÄêÊ†∏ÂøÉ‰øÆÂ§ç„Äë: Êó†ËÆ∫ÊòØÂê¶ÊòØËøëÊúüÊªëÂä®ÔºåÂè™Ë¶ÅÊòØÊòéÁ°ÆÁÇπÂáªÂú®Êìç‰ΩúÊåâÈíÆ‰∏äÔºåÂ∞±ÂøÖÈ°ªÊâßË°å
            if (isActionClick) {
                if (e.target.classList.contains('delete-action')) {
                    if (this.options.onDelete) this.options.onDelete(targetItem);
                } else if (e.target.classList.contains('edit-action')) {
                    if (this.options.onEdit) this.options.onEdit(targetItem);
                }
                this.closeSwipedItem();
                // ÈòªÊ≠¢‰∫ã‰ª∂Ëøõ‰∏ÄÊ≠•‰º†Êí≠ÔºåÈÅøÂÖçËß¶ÂèëÂ∫ïÂ±ÇÁöÑonTap
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return;
            }

            // Â¶ÇÊûúÊòØÈïøÊåâÔºåÊàñËÄÖÊòØ‰∏ÄÊ¨°ÊªëÂä®ÂêéÁöÑËØØËß¶ÔºàÁÇπÂáªÂú®ÈùûÊìç‰ΩúÊåâÈíÆÂå∫ÂüüÔºâÔºåÂàôÈòªÊ≠¢‰∫ã‰ª∂
            if (this.isLongPress || isRecentSwipe) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            } else if (targetItem) {
                // Ê≠£Â∏∏ÁÇπÂáª‰∫ã‰ª∂ÔºàÈùûÊªëÂä®„ÄÅÈùûÈïøÊåâ„ÄÅÈùûÊìç‰ΩúÊåâÈíÆÔºâ
                if (this.options.onTap) this.options.onTap(targetItem, e.target, e);
            }
        }
        
        handlePointerCancel() {
            if (this.swipedItem) {
                const content = this.swipedItem.querySelector(this.options.contentSelector);
                if(content) {
                    content.style.transition = 'transform 0.3s ease';
                    content.style.transform = 'translateX(0px)';
                }
            }
            this.resetState();
        }

        resetState() {
            this.isPointerDown = false;
            clearTimeout(this.longPressTimer);
            // Use requestAnimationFrame to ensure state changes happen in the next frame
            requestAnimationFrame(() => {
                this.isSwiping = false;
                this.isLongPress = false;
            });
            document.removeEventListener('pointermove', this.handlePointerMove);
            document.removeEventListener('pointerup', this.handlePointerUp);
            document.removeEventListener('pointercancel', this.handlePointerCancel);
            // The click listener is now a one-time listener, so no need to remove it here.
        }

        closeSwipedItem() {
            if (this.swipedItem) {
                const content = this.swipedItem.querySelector(this.options.contentSelector);
                if(content) {
                    content.style.transition = 'transform 0.3s ease';
                    content.style.transform = 'translateX(0px)';
                }
                this.swipedItem = null;
            }
        }
    
        destroy() {
            this.listElement.removeEventListener('pointerdown', this.handlePointerDown);
            document.removeEventListener('pointermove', this.handlePointerMove);
            document.removeEventListener('pointerup', this.handlePointerUp);
            document.removeEventListener('pointercancel', this.handlePointerCancel);
            this.listElement.removeEventListener('click', this.handleClick, { capture: true, once: true });
            this.resetState();
        }
    }


// ===================================================================
// --- ÈïøÊåâËèúÂçï & Ê∂àÊÅØÁºñËæë ---
// ===================================================================
function showContextMenu(targetElement) { runtimeState.contextMenuTarget = targetElement; const rect = targetElement.getBoundingClientRect(); const screenRect = phoneScreen.getBoundingClientRect(); contextMenu.style.display = 'flex'; const menuRect = contextMenu.getBoundingClientRect(); let top = rect.top - screenRect.top - menuRect.height - 5; let left = rect.left - screenRect.left + (rect.width / 2) - (menuRect.width / 2); if (top < 10) top = rect.bottom - screenRect.top + 5; left = Math.max(10, Math.min(left, screenRect.width - menuRect.width - 10)); contextMenu.style.top = `${top}px`; contextMenu.style.left = `${left}px`; }
function hideContextMenu() { if (contextMenu) contextMenu.style.display = 'none'; runtimeState.contextMenuTarget = null; }
document.addEventListener('pointerdown', (e) => { if (contextMenu.style.display === 'flex' && !contextMenu.contains(e.target) && !runtimeState.contextMenuTarget?.contains(e.target)) { hideContextMenu(); } });
getEl('context-menu-cancel').addEventListener('click', hideContextMenu);
getEl('context-menu-edit').addEventListener('click', () => { if (!runtimeState.contextMenuTarget) return; const msgId = runtimeState.contextMenuTarget.dataset.id; openMessageEditor(msgId); hideContextMenu(); });
getEl('context-menu-quote').addEventListener('click', () => {
    if (!runtimeState.contextMenuTarget) return;
    const msgId = runtimeState.contextMenuTarget.dataset.id;
    const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
    const msg = contact.conversation.find(m => m.id === msgId);

    if (msg && ['text', 'voice', 'camera', 'image'].includes(msg.type)) {
        runtimeState.quotedMessage = { ...msg }; 
        let previewContent = '';
        switch (msg.type) {
            case 'text':
                previewContent = msg.content;
                break;
            case 'voice':
                previewContent = '[ËØ≠Èü≥]';
                break;
            case 'camera':
            case 'image':
                previewContent = '[ÂõæÁâá]';
                break;
        }
        runtimeState.quotedMessage.content = previewContent;
        
        const senderName = msg.sender === 'user' 
            ? (contact.userSettings.name || '‰Ω†')
            : (contact.isGroup 
                ? contact.groupSettings.members[msg.sender]?.nickname 
                : (contact.remark || contact.charSettings.name));

        quotePreviewContent.textContent = `ÂõûÂ§ç ${senderName}: ${previewContent}`;
        quotePreview.style.display = 'block';
        chatInput.focus();
    } else {
        showToast('Ê≠§Ê∂àÊÅØÁ±ªÂûãÊó†Ê≥ïÂºïÁî®', 'error');
    }
    hideContextMenu();
});
closeQuoteBtn.addEventListener('click', () => { runtimeState.quotedMessage = null; quotePreview.style.display = 'none'; });
getEl('context-menu-recall').addEventListener('click', () => { if (!runtimeState.contextMenuTarget) return; const msgId = runtimeState.contextMenuTarget.dataset.id; recallMessage(msgId); hideContextMenu(); });
getEl('context-menu-copy').addEventListener('click', () => { if (!runtimeState.contextMenuTarget) return; const msgId = runtimeState.contextMenuTarget.dataset.id; const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); const msg = contact.conversation.find(m => m.id === msgId); if (msg && ['text', 'voice', 'camera'].includes(msg.type)) { const textToCopy = msg.content; navigator.clipboard.writeText(textToCopy).then(() => showToast('Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø')).catch(err => { console.error('Â§çÂà∂Â§±Ë¥•: ', err); showToast('Â§çÂà∂Â§±Ë¥•', 'error'); }); } else { showToast('Ê≠§Ê∂àÊÅØÁ±ªÂûãÊó†Ê≥ïÂ§çÂà∂', 'error'); } hideContextMenu(); });
getEl('context-menu-multiselect').addEventListener('click', () => { if (!runtimeState.contextMenuTarget) return; enterChatSelectionMode(runtimeState.contextMenuTarget); hideContextMenu(); });
function enterChatSelectionMode(initialElement) { runtimeState.chatSelectionMode = true;
    chatSettingsBtn.textContent = 'Âà†Èô§'; // ÊòéÁ°ÆÂú®ËøôÈáå‰øÆÊîπÊñáÊú¨
 singleChatScreen.classList.add('selection-mode'); chatSettingsBtn.textContent = 'Âà†Èô§'; runtimeState.selectedMessages = [initialElement.dataset.id]; initialElement.classList.add('selected'); }
function exitChatSelectionMode() { runtimeState.chatSelectionMode = false;
    // Ê†∏ÂøÉ‰øÆÂ§çÔºöÊÅ¢Â§çÊåâÈíÆÁöÑÂéüÂßãÂõæÊ†á
    if (runtimeState.originalIconContent['header-settings']) {
        chatSettingsBtn.innerHTML = runtimeState.originalIconContent['header-settings'];
    } singleChatScreen.classList.remove('selection-mode'); const settingsIconId = appState.beautify.icons['header-settings'];  runtimeState.selectedMessages = []; queryAll('.message-item.selected, .message-timestamp.selected').forEach(el => el.classList.remove('selected')); }
function toggleMessageSelection(element) { const msgId = element.dataset.id; element.classList.toggle('selected'); if (runtimeState.selectedMessages.includes(msgId)) { runtimeState.selectedMessages = runtimeState.selectedMessages.filter(id => id !== msgId); } else { runtimeState.selectedMessages.push(msgId); } if (runtimeState.selectedMessages.length === 0) exitChatSelectionMode(); }
function openMessageEditor(msgId) { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); const msg = contact.conversation.find(m => m.id === msgId); if (!msg) return; editingMessageIdInput.value = msgId; const types = [ { value: 'text', text: 'ÊñáÊú¨' }, { value: 'voice', text: 'ËØ≠Èü≥' }, { value: 'camera', text: 'ÊñáÂ≠óÂõæ' }, { value: 'link', text: 'ÈìæÊé•' }, { value: 'redPacket', text: 'Á∫¢ÂåÖ' } ]; editMessageTypeGroup.innerHTML = types.map(t => `<label class="radio-label"><input type="radio" name="edit-msg-type" value="${t.value}" ${msg.type === t.value ? 'checked' : ''}><span>${t.text}</span></label>`).join(''); renderEditMessageInputs(msg.type, msg); editMessageModal.classList.add('visible'); }
editMessageTypeGroup.addEventListener('change', (e) => { if (e.target.name === 'edit-msg-type') { renderEditMessageInputs(e.target.value); } });
function renderEditMessageInputs(type, data = {}) { let html = ''; switch (type) { case 'voice': html = `<div class="form-group"><label>ËØ≠Èü≥ÂÜÖÂÆπ</label><textarea class="wide-textarea">${data.content || ''}</textarea></div>`; break; case 'camera': html = `<div class="form-group"><label>ÂõæÁâáÊèèËø∞</label><textarea class="wide-textarea">${data.content || ''}</textarea></div>`; break; case 'link': html = `<div class="form-group"><label>Ê†áÈ¢ò</label><input type="text" value="${data.title || ''}"></div><div class="form-group"><label>ÊëòË¶Å</label><input type="text" value="${data.summary || ''}"></div><div class="form-group"><label>Êù•Ê∫ê</label><input type="text" value="${data.source || ''}"></div><div class="form-group"><label>ÂÜÖÂÆπ</label><textarea class="wide-textarea">${data.content || ''}</textarea></div>`; break; case 'redPacket': html = `<div class="form-group"><label>ÈáëÈ¢ù</label><input type="number" value="${data.amount || ''}"></div><div class="form-group"><label>ÁïôË®Ä</label><input type="text" value="${data.message || ''}"></div>`; break; default: html = `<div class="form-group"><label>ÊñáÊú¨ÂÜÖÂÆπ</label><textarea class="wide-textarea">${data.content || ''}</textarea></div>`; break; } editMessageInputsContainer.innerHTML = html; }
cancelEditMessageBtn.addEventListener('click', () => editMessageModal.classList.remove('visible'));
saveEditMessageBtn.addEventListener('click', () => { const msgId = editingMessageIdInput.value; const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); const msgIndex = contact.conversation.findIndex(m => m.id === msgId); if (msgIndex === -1) return; const msg = contact.conversation[msgIndex]; const newType = query('input[name="edit-msg-type"]:checked').value; const inputs = editMessageInputsContainer.querySelectorAll('input, textarea'); msg.type = newType; switch (newType) { case 'voice': msg.content = inputs[0].value; const cleanText = msg.content.replace(/\[.*?\]|Ôºà.*?Ôºâ/g, ''); msg.duration = Math.ceil(cleanText.length / 2); break; case 'camera': msg.content = inputs[0].value; msg.imageId = msg.imageId || 'default_camera_image'; break; case 'link': [msg.title, msg.summary, msg.source, msg.content] = Array.from(inputs).map(i => i.value); break; case 'redPacket': msg.amount = parseFloat(inputs[0].value); msg.message = inputs[1].value; msg.status = msg.status || 'unclaimed'; break; default: msg.content = inputs[0].value; break; } updateContactLastMessage(runtimeState.currentChatId); debouncedSaveState(); renderConversation(); renderMessageList(); editMessageModal.classList.remove('visible'); });

// ===================================================================
// --- ËÅäÂ§©ÁïåÈù¢Áªü‰∏Ä‰∫ã‰ª∂Â§ÑÁêÜÂô® ---
// ===================================================================
function setupChatMessageViewInteractions() {
if (conversationLoadMoreHandler) {
        chatMessagesView.removeEventListener('click', conversationLoadMoreHandler);
    }
    conversationLoadMoreHandler = function(e) {
        if (e.target.id === 'load-more-messages-btn') {
            const contactId = runtimeState.currentChatId;
            if (contactId && runtimeState.chatDisplayLimits[contactId]) {
                runtimeState.chatDisplayLimits[contactId] += 50; // Load 50 more
                renderConversation(true);
            }
        }
    };
    chatMessagesView.addEventListener('click', conversationLoadMoreHandler);
    let longPressTimer = null;
    let startX, startY, isDragging = false;

    chatMessagesView.addEventListener('pointerdown', (e) => {
        if (e.button !== 0) return;
        const target = e.target;
        const item = target.closest('.message-item, .message-timestamp');
        // Prevent click logic from firing on "load more" button
        if (target.id === 'load-more-messages-btn') return;
        if (!item) return;

        isDragging = false;
        startX = e.clientX;
        startY = e.clientY;

        longPressTimer = setTimeout(() => {
            if (isDragging) return;
            longPressTimer = null; // Clear timer to prevent multiple fires
            
            // Check for avatar long press first as it's more specific
            const avatar = target.closest('.avatar');
            if (avatar) {
                handleAvatarLongPress(avatar);
            } else {
                showContextMenu(item);
            }
        }, 500);
    });

    chatMessagesView.addEventListener('pointermove', (e) => {
        if (Math.abs(e.clientX - startX) > 10 || Math.abs(e.clientY - startY) > 10) {
            isDragging = true;
            if (longPressTimer) clearTimeout(longPressTimer);
        }
    });

    chatMessagesView.addEventListener('pointerup', (e) => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            if (!isDragging) {
                handleChatViewClick(e);
            }
        }
    });

    chatMessagesView.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });
}
function handleChatViewClick(e) {
        const item = e.target.closest('.message-item, .message-timestamp');
        if (!item) return;
        const target = e.target;

        if (runtimeState.chatSelectionMode) {
            toggleMessageSelection(item);
            return;
        }

        const avatar = target.closest('.avatar');
        if (avatar) {
            const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
            if (!contact) return;
            runtimeState.patTarget.element = avatar;
            const msgItem = avatar.closest('.message-item');
            const senderId = msgItem.dataset.sender;
            runtimeState.patTarget.memberId = senderId;
            runtimeState.patTarget.type = senderId === 'user' ? 'user' : 'contact'; // ÂÖ≥ÈîÆ‰øÆÂ§ç
            patSuffixModal.classList.add('visible');
            patSuffixInput.focus();
            return;
        }
        
        const groupTitle = target.closest('.group-title');
        if (groupTitle) {
                    const memberId = groupTitle.dataset.memberId;
                    const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
                    const userIsAdminOrOwner = contact.groupSettings.owner === 'user' || contact.groupSettings.admins.includes('user');
                    
                    if (memberId === 'user') {
                        const memberSettings = contact.groupSettings.members['user'];
                        const oldTitle = memberSettings.title;
                        const newTitle = prompt(`‰øÆÊîπ‰Ω†ÁöÑÁæ§Â§¥Ë°î:`, oldTitle);
                        if (newTitle && newTitle.trim() !== oldTitle) {
                            memberSettings.title = newTitle.trim();
                            addSystemNotification(runtimeState.currentChatId, `‰Ω†Â∞ÜÁæ§Â§¥Ë°î‰øÆÊîπ‰∏∫ '${newTitle.trim()}'`, false);
                            debouncedSaveState();
                            renderConversation();
                        }
                    } else {
                        if (!userIsAdminOrOwner) { showToast('Âè™ÊúâÁæ§‰∏ªÂíåÁÆ°ÁêÜÂëòÊâçËÉΩ‰øÆÊîπÂ§¥Ë°î', 'error'); return; }
                        const memberSettings = contact.groupSettings.members[memberId];
                        const oldTitle = memberSettings.title;
                        const newTitle = prompt(`‰øÆÊîπ ${memberSettings.nickname} ÁöÑÂ§¥Ë°î:`, oldTitle);
                        if (newTitle && newTitle.trim() !== oldTitle) {
                            const editorName = contact.groupSettings.members['user'].nickname;
                            memberSettings.title = newTitle.trim();
                            addSystemNotification(runtimeState.currentChatId, `'${editorName}' Â∞Ü '${memberSettings.nickname}' ÁöÑÁæ§ËÅäÂ§¥Ë°î‰øÆÊîπ‰∏∫ '${newTitle.trim()}'`, false);
                            debouncedSaveState();
                            renderConversation();
                        }
                    }
                    return;
                }

        const groupNickname = target.closest('.group-nickname');
                if (groupNickname) {
                    const memberId = groupNickname.dataset.memberId;
                    const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
                    const userIsAdminOrOwner = contact.groupSettings.owner === 'user' || contact.groupSettings.admins.includes('user');

                    if (memberId === 'user') {
                        const memberSettings = contact.groupSettings.members['user'];
                        const oldNickname = memberSettings.nickname;
                        const newNickname = prompt(`‰øÆÊîπ‰Ω†ÁöÑÁæ§ÂêçÁâá:`, oldNickname);
                        if (newNickname && newNickname.trim() !== oldNickname) {
                            memberSettings.nickname = newNickname.trim();
                            addSystemNotification(runtimeState.currentChatId, `‰Ω†Â∞ÜÁæ§ÂêçÁâá‰øÆÊîπ‰∏∫ '${newNickname.trim()}'`, false);
                            debouncedSaveState();
                            renderConversation();
                        }
                    } else {
                        if (!userIsAdminOrOwner) { showToast('Âè™ÊúâÁæ§‰∏ªÂíåÁÆ°ÁêÜÂëòÊâçËÉΩ‰øÆÊîπÁæ§ÂêçÁâá', 'error'); return; }
                        const memberSettings = contact.groupSettings.members[memberId];
                        const oldNickname = memberSettings.nickname;
                        const newNickname = prompt(`‰øÆÊîπ ${oldNickname} ÁöÑÁæ§ÂêçÁâá:`, oldNickname);
                        if (newNickname && newNickname.trim() !== oldNickname) {
                            const editorName = contact.groupSettings.members['user'].nickname;
                            const oldNameForNotif = memberSettings.nickname;
                            memberSettings.nickname = newNickname.trim();
                            addSystemNotification(runtimeState.currentChatId, `'${editorName}' ‰øÆÊîπ‰∫Ü '${oldNameForNotif}' ÁöÑÁæ§ÂêçÁâá‰∏∫ '${newNickname.trim()}'`, false);
                            debouncedSaveState();
                            renderConversation();
                        }
                    }
                    return;
                }
        
        const voiceBubble = target.closest('.message-bubble.voice');
        if (voiceBubble) {
            const voiceText = voiceBubble.nextElementSibling;
            if (voiceText) voiceText.style.display = voiceText.style.display === 'block' ? 'none' : 'block';
            const waveformContainer = voiceBubble.querySelector('.voice-waveform-container');
            const msgId = voiceBubble.closest('.message-item').dataset.id;
            const msg = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId).conversation.find(m => m.id === msgId);
            if (runtimeState.currentlyPlayingVoiceTimer) {
                clearTimeout(runtimeState.currentlyPlayingVoiceTimer);
                queryAll('.voice-waveform-container.playing').forEach(el => el.classList.remove('playing'));
            }
            if (waveformContainer.classList.contains('playing')) {
                waveformContainer.classList.remove('playing');
            } else {
                waveformContainer.classList.add('playing');
                runtimeState.currentlyPlayingVoiceTimer = setTimeout(() => {
                    waveformContainer.classList.remove('playing');
                    runtimeState.currentlyPlayingVoiceTimer = null;
                }, msg.duration * 1000);
            }
            return;
        }

        const cameraBubble = target.closest('.message-bubble.camera');
        if (cameraBubble) {
            cameraBubble.classList.toggle('show-text');
            return;
        }

        const linkBubble = target.closest('.message-bubble.link');
        if (linkBubble) {
            if (linkBubble.dataset.songId) {
                const songId = linkBubble.dataset.songId;
                const songIndex = appState.music.playlist.findIndex(s => s.id === songId);
                const msgId = linkBubble.closest('.message-item').dataset.id;
                const msg = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId).conversation.find(m => m.id === msgId);
                if(songIndex > -1) {
                    appState.music.queue = [...appState.music.playlist];
                    renderPlayerQueue();
                    playerModal.classList.add('show');
                    playSongFromQueue(songIndex, msg.sender);
                } else {
                    showToast('Ê≠åÊõ≤‰ºº‰πéÂ∑≤‰ªéÈü≥‰πêÂ∫ì‰∏≠ÁßªÈô§');
                }
            } else { 
                const linkData = JSON.parse(decodeURIComponent(linkBubble.dataset.linkContent));
                viewContentTitle.textContent = linkData.title;
                viewContentBody.innerHTML = `<p><strong>Êù•Ê∫ê:</strong> ${linkData.source || 'Êú™Áü•'}</p><hr><p>${(linkData.content || 'Êó†ËØ¶ÁªÜÂÜÖÂÆπ').replace(/\n/g, '<br>')}</p>`;
                viewContentModal.classList.add('visible');
            }
            return;
        }

        const packetBubble = target.closest('.message-bubble.red-packet');
        if (packetBubble) {
            handleRedPacketClick(packetBubble);
            return;
        }

        const recalledMsg = target.closest('.message-timestamp[data-original-content]');
        if (recalledMsg && recalledMsg.dataset.originalContent) {
            try {
                const originalMsg = JSON.parse(recalledMsg.dataset.originalContent);
                const senderName = findUserById(originalMsg.sender).name;
                showToast(`[${senderName}]: ${originalMsg.content}`);
            } catch (err) {
                showToast(`Êí§ÂõûÂÜÖÂÆπ: ${recalledMsg.dataset.originalContent}`);
            }
            return;
        }
    }
function handleAvatarLongPress(avatarElement) {
        const msgItem = avatarElement.closest('.message-item');
        if (!msgItem) return;
        const senderId = msgItem.dataset.sender;
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;

        if (senderId === 'user') {
            const currentSignature = contact.userSettings.signature || appState.chat.userProfile.signature;
            const newSignature = prompt('‰øÆÊîπ‰Ω†ÁöÑÁ≠æÂêç:', currentSignature);
            if (newSignature !== null && newSignature !== currentSignature) {
                contact.userSettings.signature = newSignature;
                debouncedSaveState();
                addSystemNotification(runtimeState.currentChatId, `‰Ω†Â∞ÜÁ≠æÂêç‰øÆÊîπ‰∏∫Ôºö‚Äú${newSignature}‚Äù`, false);
                if (!contact.isGroup) {
                    updateSingleChatUI();
                }
            }
        } else if (contact.isGroup) {
            const userIsAdminOrOwner = contact.groupSettings.owner === 'user' || contact.groupSettings.admins.includes('user');
            if (!userIsAdminOrOwner) {
                showToast('ÊùÉÈôê‰∏çË∂≥', 'error');
                return;
            }
            const targetMember = contact.groupSettings.members[senderId];
            if (!targetMember) return;
            const isMuted = targetMember.isMuted;
            if (confirm(`Á°ÆÂÆöË¶Å${isMuted ? 'Ëß£Èô§Á¶ÅË®Ä' : 'Á¶ÅË®Ä'}ÊàêÂëò "${targetMember.nickname}" ÂêóÔºü`)) {
                targetMember.isMuted = !isMuted;
                debouncedSaveState();
                addSystemNotification(runtimeState.currentChatId, `‰Ω†${isMuted ? 'Ëß£Èô§‰∫Ü' : 'Á¶ÅË®Ä‰∫Ü'}ÊàêÂëò "${targetMember.nickname}"`, false);
            }
        }
    }

// ===================================================================
// --- ËÅäÂ§©ËÆæÁΩÆÁïåÈù¢ÈÄªËæë ---
// ===================================================================
function openChatSettings() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; if (contact.isGroup) { openGroupChatSettings(); } else { openSingleChatSettings(); } }
function openSingleChatSettings() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); runtimeState.originalChatSettings = JSON.parse(JSON.stringify({ charSettings: contact.charSettings, userSettings: contact.userSettings, remark: contact.remark })); runtimeState.tempChatSettings = JSON.parse(JSON.stringify(runtimeState.originalChatSettings)); loadSingleChatSettingsUI(); openSubScreen(chatSettingsScreen, singleChatScreen); }
function loadSingleChatSettingsUI() { const { charSettings, userSettings } = runtimeState.tempChatSettings; csCharName.value = charSettings.name; setupWorldBookSelector(csWorldBookGroupSelector, csWorldBookList, charSettings.linkedWorldBooks); setElementImage(csCharAvatar, charSettings.avatarId); setElementImage(csCharAvatar.querySelector('.avatar-frame'), charSettings.avatarFrameId); csContextMemory.value = charSettings.contextMemory; csPersona.value = charSettings.persona; csRealtimeActivityToggle.checked = charSettings.realtimeActivity.enabled; csRealtimeIntervalGroup.style.display = charSettings.realtimeActivity.enabled ? 'flex' : 'none'; csRealtimeInterval.value = charSettings.realtimeActivity.interval; csDeleteFriendBtn.textContent = charSettings.isFriend ? 'Âà†Èô§Â•ΩÂèã' : 'Â∑≤Âà†Èô§'; csDeleteFriendBtn.disabled = !charSettings.isFriend; usUserName.value = userSettings.name; setElementImage(usUserAvatar, userSettings.avatarId); setElementImage(usUserAvatar.querySelector('.avatar-frame'), userSettings.avatarFrameId); usPersona.value = userSettings.persona; }
function saveSingleChatSettings() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; const oldSettings = contact.charSettings.realtimeActivity; const newSettings = runtimeState.tempChatSettings.charSettings.realtimeActivity; contact.charSettings = JSON.parse(JSON.stringify(runtimeState.tempChatSettings.charSettings)); contact.userSettings = JSON.parse(JSON.stringify(runtimeState.tempChatSettings.userSettings)); contact.remark = runtimeState.tempChatSettings.remark; contact.name = runtimeState.tempChatSettings.charSettings.name; if (oldSettings.enabled !== newSettings.enabled || oldSettings.interval !== newSettings.interval) { updateRealtimeActivityTimer(contact); } debouncedSaveState(); updateSingleChatUI(); renderMessageList(); syncAndUpdateMoments(contact.id); if (viewContentModal.classList.contains('visible')) { const packetBubble = document.querySelector(`.message-bubble.red-packet[data-packet-content]`); if (packetBubble) { const packetData = JSON.parse(decodeURIComponent(packetBubble.dataset.packetContent)); showRedPacketDetails(packetData); } } }
getEl('chat-settings-back-btn').addEventListener('click', () => { saveSingleChatSettings(); closeSubScreen(chatSettingsScreen, singleChatScreen); renderGlobalRealtimeSettings(); });
query('#chat-settings-screen .app-bottom-tabs').addEventListener('click', (e) => { if (e.target.classList.contains('tab-link')) { const tabId = e.target.dataset.tab; queryAll('#chat-settings-screen .tab-link').forEach(t => t.classList.remove('active')); queryAll('#chat-settings-screen .tab-content').forEach(c => c.classList.remove('active')); e.target.classList.add('active'); getEl(`${tabId}-tab-content`).classList.add('active'); } });
csCharName.addEventListener('input', () => { const newName = csCharName.value; runtimeState.tempChatSettings.charSettings.name = newName; });
csContextMemory.addEventListener('input', () => runtimeState.tempChatSettings.charSettings.contextMemory = parseInt(csContextMemory.value) || 20);
csPersona.addEventListener('input', () => runtimeState.tempChatSettings.charSettings.persona = csPersona.value);
csRealtimeActivityToggle.addEventListener('change', () => { const enabled = csRealtimeActivityToggle.checked; runtimeState.tempChatSettings.charSettings.realtimeActivity.enabled = enabled; csRealtimeIntervalGroup.style.display = enabled ? 'flex' : 'none'; });
csRealtimeInterval.addEventListener('input', () => runtimeState.tempChatSettings.charSettings.realtimeActivity.interval = parseInt(csRealtimeInterval.value) || 30);
csRestoreBtn.addEventListener('click', () => { if (confirm('Á°ÆÂÆöË¶ÅËøòÂéüÊâÄÊúâÊú™‰øùÂ≠òÁöÑÊõ¥ÊîπÂêóÔºü')) { runtimeState.tempChatSettings = JSON.parse(JSON.stringify(runtimeState.originalChatSettings)); loadSingleChatSettingsUI(); showToast('ËÆæÁΩÆÂ∑≤ËøòÂéü'); } });
csClearHistoryBtn.addEventListener('click', () => { if (confirm('Ê≠§Êìç‰ΩúÂ∞ÜÊ∞∏‰πÖÊ∏ÖÁ©∫‰∏éËØ•ËßíËâ≤ÁöÑÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩïÔºåÁ°ÆÂÆöÂêóÔºü')) { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (contact) { contact.conversation = []; updateContactLastMessage(runtimeState.currentChatId); debouncedSaveState(); renderConversation(); renderMessageList(); showToast('ËÅäÂ§©ËÆ∞ÂΩïÂ∑≤Ê∏ÖÁ©∫'); } } });
csDeleteFriendBtn.addEventListener('click', () => { if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËØ•Â•ΩÂèãÂêóÔºüÊ≠§Êìç‰Ωú‰ºöÈÄöÁü•ÂØπÊñπ„ÄÇ')) { runtimeState.tempChatSettings.charSettings.isFriend = false; addSystemNotification(runtimeState.currentChatId, "‰Ω†Âà†Èô§‰∫ÜÂØπÊñπÂ•ΩÂèã", false); loadSingleChatSettingsUI(); showToast('Â•ΩÂèãÂ∑≤Âà†Èô§'); } });
addFriendBtn.addEventListener('click', () => { const reason = prompt('ËØ∑ËæìÂÖ•Â•ΩÂèãÁî≥ËØ∑ÁêÜÁî±:'); if (reason !== null) { addSystemNotification(runtimeState.currentChatId, `‰Ω†ÂèëÈÄÅ‰∫ÜÂ•ΩÂèãÁî≥ËØ∑: ${reason}`, true); showToast('Â•ΩÂèãÁî≥ËØ∑Â∑≤ÂèëÈÄÅ'); } });
usUserName.addEventListener('input', () => runtimeState.tempChatSettings.userSettings.name = usUserName.value);
usPersona.addEventListener('input', () => runtimeState.tempChatSettings.userSettings.persona = usPersona.value);
csSavePersonaBtn.addEventListener('click', () => { const { name, avatarId, persona } = runtimeState.tempChatSettings.charSettings; const newArchive = { id: newId('data'), name, avatarId, content: persona }; appState.data.archives.push(newArchive); debouncedSaveState(); showToast(`ËµÑÊñôÂ∑≤‰øùÂ≠òÂà∞Ê°£Ê°à: ${name}`); renderArchives(); });
usSavePersonaBtn.addEventListener('click', () => { const { name, avatarId, persona } = runtimeState.tempChatSettings.userSettings; const newInfo = { id: newId('data'), name, avatarId, content: persona }; appState.data.infos.push(newInfo); debouncedSaveState(); showToast(`ËµÑÊñôÂ∑≤‰øùÂ≠òÂà∞‰ø°ÊÅØ: ${name}`); renderInfos(); });
csLoadPersonaBtn.addEventListener('click', () => openLoadPersonaModal('archive', 'charSettings'));
usLoadPersonaBtn.addEventListener('click', () => openLoadPersonaModal('info', 'userSettings'));
function openLibraryModal(context) { runtimeState.libraryContext = context; runtimeState.librarySelection = []; libraryModal.classList.remove('selection-mode'); libraryDeleteBtn.style.display = 'none'; libraryModalTitle.textContent = context.title; libraryModalPreviewArea.style.display = context.showPreview ? 'block' : 'none'; if (context.showPreview) { libraryModalPreviewArea.innerHTML = `<div id="avatar-frame-preview"><div class="avatar-frame"></div></div>`; setElementImage(libraryModalPreviewArea.querySelector('#avatar-frame-preview'), context.previewAvatarId); } renderLibraryGrid(); libraryModal.classList.add('visible'); }
function renderLibraryGrid() { let items, activeItem; const context = runtimeState.libraryContext; if (context.isGlobalUserLib) { items = appState.chat.userProfile.avatarLibrary; } else if (context.isFrame) { items = appState.chat.userProfile.avatarFrameLibrary; } else if (context.isGroup) { items = runtimeState.tempChatSettings.groupSettings[context.libraryKey]; } else if (context.memberId) { items = runtimeState.tempGcsMemberSettings[context.libraryKey]; } else { items = runtimeState.tempChatSettings[context.settingsGroup][context.libraryKey]; } if (context.isGroup) { activeItem = runtimeState.tempChatSettings.groupSettings[context.activeKey]; } else if (context.memberId) { activeItem = runtimeState.tempGcsMemberSettings[context.activeKey]; } else { activeItem = runtimeState.tempChatSettings[context.settingsGroup][context.activeKey]; } libraryGrid.innerHTML = ''; if (context.hasNoItemOption) { const noItem = document.createElement('div'); noItem.className = 'library-item no-frame'; noItem.dataset.id = ''; noItem.innerHTML = 'üö´'; if (activeItem === '') { noItem.classList.add('selected'); } libraryGrid.appendChild(noItem); } items.forEach(id => { const item = document.createElement('div'); item.className = 'library-item'; if (context.isCircular) item.classList.add('circular'); item.innerHTML = `<img alt="library image">`; item.dataset.id = id; if (id === activeItem) { item.classList.add('selected'); } libraryGrid.appendChild(item); setElementImage(item.querySelector('img'), id, 'src'); }); updateLibraryPreview(); }
async function updateLibraryPreview() { const context = runtimeState.libraryContext; if (!context.showPreview) return; const previewFrame = query('#avatar-frame-preview .avatar-frame'); if (previewFrame) { let activeFrameId; if (context.memberId) { activeFrameId = runtimeState.tempGcsMemberSettings[context.activeKey]; } else if (context.isGroupUser) { activeFrameId = runtimeState.tempChatSettings.userSettings[context.activeKey]; } else { activeFrameId = runtimeState.tempChatSettings[context.settingsGroup][context.activeKey]; } await setElementImage(previewFrame, activeFrameId); } }
libraryGrid.addEventListener('click', (e) => { const item = e.target.closest('.library-item'); if (!item) return; const context = runtimeState.libraryContext; if (libraryModal.classList.contains('selection-mode')) { item.classList.toggle('selected'); const id = item.dataset.id; if (id === '') return; if (item.classList.contains('selected')) { if (!runtimeState.librarySelection.includes(id)) runtimeState.librarySelection.push(id); } else { runtimeState.librarySelection = runtimeState.librarySelection.filter(u => u !== id); } } else { const id = item.dataset.id; let settingsObj, uiUpdateFunc; if (context.isGroup) { settingsObj = runtimeState.tempChatSettings.groupSettings; uiUpdateFunc = loadGroupChatSettingsUI; } else if (context.memberId) { settingsObj = runtimeState.tempGcsMemberSettings; uiUpdateFunc = loadGcsMemberModalUI; } else { settingsObj = runtimeState.tempChatSettings[context.settingsGroup]; uiUpdateFunc = context.isGroupUser ? loadGroupChatSettingsUI : loadSingleChatSettingsUI; } settingsObj[context.activeKey] = id; uiUpdateFunc(); renderLibraryGrid(); } });
function enterLibrarySelectionMode() {
    libraryModal.classList.add('selection-mode');
    libraryModeToggleBtn.textContent = 'ÂèñÊ∂à';
    libraryDeleteBtn.style.display = 'block';
    libraryCloseBtn.style.display = 'none';
}

function exitLibrarySelectionMode() {
    libraryModal.classList.remove('selection-mode');
    libraryModeToggleBtn.textContent = 'Âà†Èô§';
    libraryDeleteBtn.style.display = 'none';
    libraryCloseBtn.style.display = 'block';
    runtimeState.librarySelection = [];
    queryAll('#library-grid .library-item.selected').forEach(i => i.classList.remove('selected'));
}

libraryModeToggleBtn.addEventListener('click', () => {
    if (libraryModal.classList.contains('selection-mode')) {
        exitLibrarySelectionMode();
    } else {
        enterLibrarySelectionMode();
    }
});
libraryCloseBtn.addEventListener('click', () => {
    exitLibrarySelectionMode(); // Always reset state on close
    libraryModal.classList.remove('visible');
});
libraryDeleteBtn.addEventListener('click', async () => {
    const context = runtimeState.libraryContext;
    const selection = runtimeState.librarySelection;
    if (selection.length === 0 || !confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${selection.length} ‰∏™È°πÁõÆÂêóÔºü`)) return;

    // First, delete all media files from the database
    for (const id of selection) {
        await deleteMediaFromDB(id);
    }

    if (context.isGlobalUserLib) {
        // --- Logic for Global User Avatar Library ---
        appState.chat.userProfile.avatarLibrary = appState.chat.userProfile.avatarLibrary.filter(id => !selection.includes(id));

        selection.forEach(deletedId => {
            // Reset in global user profile if active
            if (appState.chat.userProfile.avatarId === deletedId) {
                appState.chat.userProfile.avatarId = 'default_user_avatar';
            }
            // Reset in all contacts' user settings
            appState.chat.contacts.forEach(contact => {
                if (contact.userSettings && contact.userSettings.avatarId === deletedId) {
                    contact.userSettings.avatarId = 'default_user_avatar';
                }
                if (contact.isGroup && contact.groupSettings.members['user'] && contact.groupSettings.members['user'].avatarId === deletedId) {
                    contact.groupSettings.members['user'].avatarId = 'default_user_avatar';
                }
            });
            // Reset in current temporary settings as well
            if (runtimeState.tempChatSettings.userSettings && runtimeState.tempChatSettings.userSettings.avatarId === deletedId) {
                runtimeState.tempChatSettings.userSettings.avatarId = 'default_user_avatar';
            }
        });

        // Determine which UI to refresh
        if (chatSettingsScreen.classList.contains('active')) {
            loadSingleChatSettingsUI();
        } else if (groupChatSettingsScreen.classList.contains('active')) {
            loadGroupChatSettingsUI();
        }

    } else {
        // --- Existing Logic for other libraries (Char, Group, Frames, etc.) ---
        let lib, activeItemKey, settingsObj, uiUpdateFunc;
        if (context.isFrame) { settingsObj = appState.chat.userProfile; lib = settingsObj.avatarFrameLibrary; }
        else if (context.isGroup) { settingsObj = runtimeState.tempChatSettings.groupSettings; lib = settingsObj[context.libraryKey]; }
        else if (context.memberId) { settingsObj = runtimeState.tempGcsMemberSettings; lib = settingsObj[context.libraryKey]; }
        else { settingsObj = runtimeState.tempChatSettings[context.settingsGroup]; lib = settingsObj[context.libraryKey]; }
        
        activeItemKey = context.activeKey;
        const newLib = lib.filter(id => !selection.includes(id));

        if (context.isFrame) { settingsObj.avatarFrameLibrary = newLib; }
        else { settingsObj[context.libraryKey] = newLib; }

        if (selection.includes(settingsObj[activeItemKey])) {
            settingsObj[activeItemKey] = context.hasNoItemOption ? '' : (newLib[0] || '');
        }

        if (context.memberId) { uiUpdateFunc = loadGcsMemberModalUI; }
        else if (context.isGroupUser || context.isGroup) { uiUpdateFunc = loadGroupChatSettingsUI; }
        else { uiUpdateFunc = loadSingleChatSettingsUI; }
        if (uiUpdateFunc) uiUpdateFunc();
    }

    // Common cleanup for all cases
    debouncedSaveState();
    exitLibrarySelectionMode();
    renderLibraryGrid(); // Re-render after exiting selection mode
});libraryUploadBtn.addEventListener('click', () => {
        libraryFileInput.accept = 'image/*,.zip';
        libraryFileInput.click();
    });
libraryAddUrlBtn.addEventListener('click', async () => { const urls = prompt('ËØ∑ËæìÂÖ•ÂõæÁâáURLÔºåÊØèË°å‰∏Ä‰∏™:'); if (urls) { const urlArray = urls.split('\n').filter(u => u.trim().startsWith('http')); if (urlArray.length > 0) { const context = runtimeState.libraryContext; let lib; if (context.isGlobalUserLib) { lib = appState.chat.userProfile.avatarLibrary; } else if (context.isFrame) { lib = appState.chat.userProfile.avatarFrameLibrary; } else if (context.isGroup) { lib = runtimeState.tempChatSettings.groupSettings[context.libraryKey]; } else if (context.memberId) { lib = runtimeState.tempGcsMemberSettings[context.libraryKey]; } else { lib = runtimeState.tempChatSettings[context.settingsGroup][context.libraryKey]; } for (const url of urlArray) { const response = await fetch(url); const blob = await response.blob(); const newLibId = newId('lib'); await addMediaToDB(newLibId, blob); lib.push(newLibId); } debouncedSaveState(); renderLibraryGrid(); } } });
libraryFileInput.addEventListener('change', async (e) => {
        const files = e.target.files;
        if (files.length === 0) return;

        const context = runtimeState.libraryContext;
        let lib;
        if (context.isGlobalUserLib) { lib = appState.chat.userProfile.avatarLibrary; }
        else if (context.isFrame) { lib = appState.chat.userProfile.avatarFrameLibrary; }
        else if (context.isGroup) { lib = runtimeState.tempChatSettings.groupSettings[context.libraryKey]; }
        else if (context.memberId) { lib = runtimeState.tempGcsMemberSettings[context.libraryKey]; }
        else { lib = runtimeState.tempChatSettings[context.settingsGroup][context.libraryKey]; }

        showToast(`Ê≠£Âú®Â§ÑÁêÜ ${files.length} ‰∏™Êñá‰ª∂...`, 'info');
        let addedCount = 0;
        const processingPromises = [];

        for (const file of files) {
            if (file.type.startsWith('image/')) {
                const promise = (async () => {
                    const newLibId = newId('lib');
                    await addMediaToDB(newLibId, file);
                    lib.push(newLibId);
                    addedCount++;
                })();
                processingPromises.push(promise);
            } else if (file.type === 'application/zip' || file.name.toLowerCase().endsWith('.zip')) {
                const promise = JSZip.loadAsync(file).then(zip => {
                    const zipFilePromises = [];
                    zip.forEach((relativePath, zipEntry) => {
                        if (!zipEntry.dir && /\.(gif|png|jpg|jpeg|webp)$/i.test(zipEntry.name)) {
                            const zipPromise = zipEntry.async("blob").then(blobData => {
                                const newLibId = newId('lib');
                                lib.push(newLibId);
                                addedCount++;
                                return addMediaToDB(newLibId, blobData);
                            });
                            zipFilePromises.push(zipPromise);
                        }
                    });
                    return Promise.all(zipFilePromises);
                }).catch(err => {
                    console.error("Ëß£ÂéãZIPÂ§±Ë¥•:", err);
                    showToast(`Â§ÑÁêÜ ${file.name} Â§±Ë¥•`, 'error');
                });
                processingPromises.push(promise);
            }
        }

        await Promise.all(processingPromises);

        if (addedCount > 0) {
            debouncedSaveState();
            renderLibraryGrid();
            showToast(`ÊàêÂäüÊ∑ªÂä† ${addedCount} ‰∏™È°πÁõÆÔºÅ`);
        } else {
            showToast('Ê≤°ÊúâÊâæÂà∞ÂèØÊ∑ªÂä†ÁöÑÂõæÁâáÊñá‰ª∂', 'error');
        }

        libraryFileInput.value = ''; // Reset for next use
    });
async function handleChatBackgroundUpload(file, settingsObject) { if (!file) return; const newWallpaperId = newId('wp'); await addMediaToDB(newWallpaperId, file); appState.beautify.wallpapers.push({ id: newWallpaperId }); settingsObject.chatBackgroundId = newWallpaperId; debouncedSaveState(); showToast('ËÉåÊôØÂ∑≤ËÆæÁΩÆÂπ∂Â≠òÂÖ•Â£ÅÁ∫∏Â∫ì'); await updateSingleChatUI(); }
    async function handleVideoBackgroundUpload(file, settingsObject) {
    if (!file) return;
    showToast('Ê≠£Âú®‰∏ä‰º†ËßÜÈ¢ëËÉåÊôØ...');
    const newVideoBgId = newId('video_bg');
    await addMediaToDB(newVideoBgId, file);
    settingsObject.videoBackgroundId = newVideoBgId;
    debouncedSaveState(); // ÂÆûÊó∂‰øùÂ≠ò
    showToast('ËßÜÈ¢ëËÉåÊôØÂ∑≤Êõ¥Êñ∞ÔºÅ');
    
        // ÂÆûÊó∂Âà∑Êñ∞ÈÄªËæë
        if (appState.chat.videoCallState.isActive) {
            const contact = appState.chat.contacts.find(c => c.id === appState.chat.videoCallState.chatId);
            if (!contact) return;
    
            // Ê£ÄÊü•Ë¢´‰øÆÊîπÁöÑËÆæÁΩÆÂØπË±°ÊòØÂê¶‰∏éÂΩìÂâçÈÄöËØùÁõ∏ÂÖ≥
            const isCharSettings = settingsObject === runtimeState.tempChatSettings?.charSettings;
            const isUserSettings = settingsObject === runtimeState.tempChatSettings?.userSettings;
            
            if (isCharSettings || isUserSettings) {
                // Âº∫Âà∂ÈáçÊñ∞Ê∏≤ÊüìËßÜÈ¢ëÈÄöËØùÁïåÈù¢‰ª•Â∫îÁî®Êñ∞ËÉåÊôØ
                await openVideoCallModal();
            }
        }
    }
    
    // --- Êñ∞Â¢ûÔºöËÉåÊôØÈÄâÈ°πËèúÂçïÈÄªËæë ---
    const backgroundContextMenu = getEl('background-context-menu');
    function showBackgroundContextMenu(targetElement, context) {
        runtimeState.backgroundMenuContext = context;
        const rect = targetElement.getBoundingClientRect();
        const screenRect = phoneScreen.getBoundingClientRect();
    
        // ÊÄªÊòØÊòæÁ§∫ÊâÄÊúâÈÄâÈ°π
        getEl('bg-menu-chat-bg').style.display = 'block';
        getEl('bg-menu-video-bg').style.display = 'block';
    
        backgroundContextMenu.style.display = 'flex';
        const menuRect = backgroundContextMenu.getBoundingClientRect();
        let top = rect.top - screenRect.top - menuRect.height - 5;
        let left = rect.left - screenRect.left;
        if (top < 10) {
            top = rect.bottom - screenRect.top + 5;
        }
        if (left + menuRect.width > screenRect.width - 10) {
            left = screenRect.width - menuRect.width - 10;
        }
        backgroundContextMenu.style.top = `${top}px`;
        backgroundContextMenu.style.left = `${left}px`;
    }
    function hideBackgroundContextMenu() {
        if (backgroundContextMenu) backgroundContextMenu.style.display = 'none';
        runtimeState.backgroundMenuContext = null;
    }
    document.addEventListener('pointerdown', (e) => {
        if (backgroundContextMenu.style.display === 'flex' && !backgroundContextMenu.contains(e.target)) {
            hideBackgroundContextMenu();
        }
    }, true);
    getEl('bg-menu-chat-bg').addEventListener('click', () => {
        const context = runtimeState.backgroundMenuContext;
        if(context) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => handleChatBackgroundUpload(e.target.files[0], context.settingsObject);
            input.click();
        }
        hideBackgroundContextMenu();
    });
    getEl('bg-menu-video-bg').addEventListener('click', () => {
        const context = runtimeState.backgroundMenuContext;
        if(context) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => handleVideoBackgroundUpload(e.target.files[0], context.settingsObject);
            input.click();
        }
        hideBackgroundContextMenu();
    });
    csCharBackgroundBtn.addEventListener('click', (e) => { showBackgroundContextMenu(e.currentTarget, { settingsObject: runtimeState.tempChatSettings.charSettings }); });
    gcsGroupBackgroundBtn.addEventListener('click', (e) => { showBackgroundContextMenu(e.currentTarget, { settingsObject: runtimeState.tempChatSettings.groupSettings }); });

// ===================================================================
// --- Áæ§ËÅäËÆæÁΩÆÁïåÈù¢ÈÄªËæë ---
// ===================================================================
function openGroupChatSettings() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); runtimeState.originalChatSettings = JSON.parse(JSON.stringify({ groupSettings: contact.groupSettings, userSettings: contact.userSettings, remark: contact.remark })); runtimeState.tempChatSettings = JSON.parse(JSON.stringify(runtimeState.originalChatSettings)); loadGroupChatSettingsUI(); openSubScreen(groupChatSettingsScreen, singleChatScreen); }
function loadGroupChatSettingsUI() { const { groupSettings, userSettings } = runtimeState.tempChatSettings; gcsGroupName.value = groupSettings.name; setupWorldBookSelector(gcsWorldBookGroupSelector, gcsWorldBookList, groupSettings.linkedWorldBooks); setElementImage(gcsGroupAvatar, groupSettings.avatarId); gcsContextMemory.value = groupSettings.contextMemory; renderGroupMemberList(); gcsMuteAllBtn.textContent = groupSettings.isMuted ? 'Ëß£Èô§Á¶ÅË®Ä' : 'ÂÖ®‰ΩìÁ¶ÅË®Ä'; gcsDisbandBtn.textContent = groupSettings.isDisbanded ? 'ÈáçÂª∫Áæ§ËÅä' : 'Ëß£Êï£Áæ§ËÅä'; gcsUsUserName.value = userSettings.name; setElementImage(gcsUsUserAvatar, userSettings.avatarId); setElementImage(gcsUsUserAvatar.querySelector('.avatar-frame'), userSettings.avatarFrameId); gcsUsPersona.value = userSettings.persona; }
function renderGroupMemberList() { const { owner, admins, members } = runtimeState.tempChatSettings.groupSettings; gcsMemberList.innerHTML = ''; const memberIds = Object.keys(members).filter(id => id !== 'user'); memberIds.unshift('user'); memberIds.forEach(id => { const member = members[id]; const user = findUserById(id); const item = document.createElement('div'); item.className = 'gcs-member-item'; item.dataset.id = id; let roleBadge = ''; if (id === owner) { roleBadge = '<div class="role-badge owner">‰∏ª</div>'; } else if (admins.includes(id)) { roleBadge = '<div class="role-badge admin">ÁÆ°</div>'; } const finalAvatarId = member.avatarId || user.avatarId; item.innerHTML = ` <div class="avatar" data-avatar-id="${finalAvatarId}">${roleBadge}</div> <span class="name">${member.nickname}</span> `; gcsMemberList.appendChild(item); setElementImage(item.querySelector('.avatar'), finalAvatarId); }); const addBtn = document.createElement('button'); addBtn.className = 'gcs-action-btn'; addBtn.textContent = '+'; addBtn.id = 'gcs-add-member-btn'; gcsMemberList.appendChild(addBtn); const removeBtn = document.createElement('button'); removeBtn.className = 'gcs-action-btn'; removeBtn.textContent = '-'; removeBtn.id = 'gcs-remove-member-btn'; gcsMemberList.appendChild(removeBtn); }
function saveGroupChatSettings() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; contact.groupSettings = JSON.parse(JSON.stringify(runtimeState.tempChatSettings.groupSettings)); contact.userSettings = JSON.parse(JSON.stringify(runtimeState.tempChatSettings.userSettings)); contact.remark = runtimeState.tempChatSettings.remark; contact.name = runtimeState.tempChatSettings.groupSettings.name; if (contact.groupSettings.members['user']) {
        contact.groupSettings.members['user'].nickname = contact.userSettings.name;
        contact.groupSettings.members['user'].avatarId = contact.userSettings.avatarId;
        contact.groupSettings.members['user'].avatarFrameId = contact.userSettings.avatarFrameId;
        contact.groupSettings.members['user'].persona = contact.userSettings.persona;
    }
    appState.chat.userProfile = { ...appState.chat.userProfile, ...contact.userSettings }; debouncedSaveState(); updateSingleChatUI(); renderMessageList(); renderConversation(); if (viewContentModal.classList.contains('visible')) { const packetBubble = document.querySelector(`.message-bubble.red-packet[data-packet-content]`); if (packetBubble) { const packetData = JSON.parse(decodeURIComponent(packetBubble.dataset.packetContent)); showRedPacketDetails(packetData); } } }
function setupGroupChatSettingsListeners() { gcsBackBtn.addEventListener('click', () => { saveGroupChatSettings(); closeSubScreen(groupChatSettingsScreen, singleChatScreen); }); query('#group-chat-settings-screen .app-bottom-tabs').addEventListener('click', (e) => { if (e.target.classList.contains('tab-link')) { const tabId = e.target.dataset.tab; queryAll('#group-chat-settings-screen .tab-link').forEach(t => t.classList.remove('active')); queryAll('#group-chat-settings-screen .tab-content').forEach(c => c.classList.remove('active')); e.target.classList.add('active'); getEl(`${tabId}-tab-content`).classList.add('active'); } }); gcsGroupName.addEventListener('input', () => { const oldName = runtimeState.tempChatSettings.groupSettings.name; const newName = gcsGroupName.value.trim(); if (newName && newName !== oldName) { addSystemNotification(runtimeState.currentChatId, `'${runtimeState.tempChatSettings.userSettings.name}' Â∞ÜÁæ§Âêç‰øÆÊîπ‰∏∫ "${newName}"`, false); runtimeState.tempChatSettings.groupSettings.name = newName; } }); gcsContextMemory.addEventListener('input', () => runtimeState.tempChatSettings.groupSettings.contextMemory = parseInt(gcsContextMemory.value) || 20); gcsGroupAvatarLibraryBtn.addEventListener('click', () => openLibraryModal({ title: 'Áæ§Â§¥ÂÉèÂ∫ì', isGroup: true, libraryKey: 'avatarLibrary', activeKey: 'avatarId', showPreview: false, isCircular: true })); gcsClearHistoryBtn.addEventListener('click', () => { if (confirm('Ê≠§Êìç‰ΩúÂ∞ÜÊ∞∏‰πÖÊ∏ÖÁ©∫ËØ•Áæ§ÁöÑÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩïÔºåÁ°ÆÂÆöÂêóÔºü')) { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (contact) { contact.conversation = []; runtimeState.tempChatSettings.groupSettings.conversation = []; updateContactLastMessage(runtimeState.currentChatId); debouncedSaveState(); renderConversation(); renderMessageList(); showToast('ËÅäÂ§©ËÆ∞ÂΩïÂ∑≤Ê∏ÖÁ©∫'); } } }); gcsMuteAllBtn.addEventListener('click', () => { runtimeState.tempChatSettings.groupSettings.isMuted = !runtimeState.tempChatSettings.groupSettings.isMuted; gcsMuteAllBtn.textContent = runtimeState.tempChatSettings.groupSettings.isMuted ? 'Ëß£Èô§Á¶ÅË®Ä' : 'ÂÖ®‰ΩìÁ¶ÅË®Ä'; addSystemNotification(runtimeState.currentChatId, runtimeState.tempChatSettings.groupSettings.isMuted ? 'Â∑≤ÂºÄÂêØÂÖ®‰ΩìÁ¶ÅË®Ä' : 'Â∑≤Ëß£Èô§ÂÖ®‰ΩìÁ¶ÅË®Ä', false); }); gcsDisbandBtn.addEventListener('click', () => { runtimeState.tempChatSettings.groupSettings.isDisbanded = !runtimeState.tempChatSettings.groupSettings.isDisbanded; gcsDisbandBtn.textContent = runtimeState.tempChatSettings.groupSettings.isDisbanded ? 'ÈáçÂª∫Áæ§ËÅä' : 'Ëß£Êï£Áæ§ËÅä'; addSystemNotification(runtimeState.currentChatId, runtimeState.tempChatSettings.groupSettings.isDisbanded ? 'Áæ§ËÅäÂ∑≤Ëß£Êï£' : 'Áæ§ËÅäÂ∑≤ÊÅ¢Â§ç', false); }); gcsUsUserName.addEventListener('input', (e) => { const oldName = runtimeState.tempChatSettings.groupSettings.members['user'].nickname; const newName = e.target.value.trim(); if (newName && newName !== oldName) { runtimeState.tempChatSettings.userSettings.name = newName; runtimeState.tempChatSettings.groupSettings.members['user'].nickname = newName; addSystemNotification(runtimeState.currentChatId, `‰Ω†Â∞ÜÁæ§ÂêçÁâá‰øÆÊîπ‰∏∫Ôºö‚Äú${newName}‚Äù`, false); } }); gcsUsPersona.addEventListener('input', () => runtimeState.tempChatSettings.userSettings.persona = gcsUsPersona.value); gcsUsUserAvatarLibraryBtn.addEventListener('click', () => openLibraryModal({ title: 'ÊàëÁöÑÂ§¥ÂÉèÂ∫ì', isGlobalUserLib: true, isGroupUser: true, settingsGroup: 'userSettings', activeKey: 'avatarId', showPreview: false, isCircular: true })); gcsUsUserAvatarFrameBtn.addEventListener('click', () => openLibraryModal({ title: 'ÊàëÁöÑÂ§¥ÂÉèÊ°ÜÂ∫ì', isFrame: true, settingsGroup: 'userSettings', isGroupUser: true, activeKey: 'avatarFrameId', showPreview: true, hasNoItemOption: true, previewAvatarId: runtimeState.tempChatSettings.userSettings.avatarId })); gcsUsSavePersonaBtn.addEventListener('click', () => { const { name, avatarId, persona } = runtimeState.tempChatSettings.userSettings; const newInfo = { id: newId('data'), name, avatarId, content: persona }; appState.data.infos.push(newInfo); debouncedSaveState(); showToast(`ËµÑÊñôÂ∑≤‰øùÂ≠òÂà∞‰ø°ÊÅØ: ${name}`); renderInfos(); }); gcsUsLoadPersonaBtn.addEventListener('click', () => openLoadPersonaModal('info', 'userSettings'));

    // ‰∏∫Áæ§ËÅäUserËÆæÁΩÆ‰∏≠ÁöÑËßÜÈ¢ëËÉåÊôØÊåâÈíÆÊ∑ªÂä†Áõ¥Êé•‰∏ä‰º†ÁõëÂê¨
    const gcsUsUserVideoBackgroundBtn = getEl('gcs-us-user-video-background-btn');
    if(gcsUsUserVideoBackgroundBtn) {
        gcsUsUserVideoBackgroundBtn.addEventListener('click', (e) => {
             const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => handleVideoBackgroundUpload(e.target.files[0], runtimeState.tempChatSettings.userSettings);
            input.click();
        });
    }
    let gcsLongPressTimer = null; let gcsIsDragging = false; let gcsStartX, gcsStartY; gcsMemberList.addEventListener('pointerdown', e => { if (e.button !== 0) return; const target = e.target; const item = target.closest('.gcs-member-item'); if (!item) return; gcsIsDragging = false; gcsStartX = e.clientX; gcsStartY = e.clientY; gcsLongPressTimer = setTimeout(() => { if (!gcsIsDragging) { handleGcsMemberLongPress(item.dataset.id); } }, 500); }); gcsMemberList.addEventListener('pointermove', e => { if (Math.abs(e.clientX - gcsStartX) > 10 || Math.abs(e.clientY - gcsStartY) > 10) { gcsIsDragging = true; clearTimeout(gcsLongPressTimer); } }); gcsMemberList.addEventListener('pointerup', e => { clearTimeout(gcsLongPressTimer); if (!gcsIsDragging) { const item = e.target.closest('.gcs-member-item'); const addBtn = e.target.closest('#gcs-add-member-btn'); const removeBtn = e.target.closest('#gcs-remove-member-btn'); if (item) { openGcsMemberModal(item.dataset.id); } else if (addBtn) { openGcsManageMembersModal('add'); } else if (removeBtn) { openGcsManageMembersModal('remove'); } } }); }
function openGcsMemberModal(memberId) { if (memberId === 'user') return; const memberSettings = runtimeState.tempChatSettings.groupSettings.members[memberId]; if (!memberSettings) return; runtimeState.tempGcsMemberSettings = JSON.parse(JSON.stringify(memberSettings)); gcsEditingMemberIdInput.value = memberId; loadGcsMemberModalUI(); gcsMemberModal.classList.add('visible'); }
function loadGcsMemberModalUI() { gcsMemberModalTitle.textContent = `ËÆæÁΩÆ ${runtimeState.tempGcsMemberSettings.nickname}`; gcsMemberNickname.value = runtimeState.tempGcsMemberSettings.nickname; setupWorldBookSelector(gcsMemberWorldBookGroupSelector, gcsMemberWorldBookList, runtimeState.tempGcsMemberSettings.linkedWorldBooks); setElementImage(gcsMemberAvatar, runtimeState.tempGcsMemberSettings.avatarId); setElementImage(gcsMemberAvatar.querySelector('.avatar-frame'), runtimeState.tempGcsMemberSettings.avatarFrameId); gcsMemberPersona.value = runtimeState.tempGcsMemberSettings.persona; }
gcsMemberModalCancelBtn.addEventListener('click', () => gcsMemberModal.classList.remove('visible'));
gcsMemberModalSaveBtn.addEventListener('click', () => { const memberId = gcsEditingMemberIdInput.value; runtimeState.tempChatSettings.groupSettings.members[memberId] = JSON.parse(JSON.stringify(runtimeState.tempGcsMemberSettings)); renderGroupMemberList(); gcsMemberModal.classList.remove('visible'); renderConversation(); });
gcsMemberNickname.addEventListener('input', (e) => runtimeState.tempGcsMemberSettings.nickname = e.target.value);
gcsMemberPersona.addEventListener('input', (e) => runtimeState.tempGcsMemberSettings.persona = e.target.value);
gcsMemberAvatarLibraryBtn.addEventListener('click', () => openLibraryModal({ title: 'ÊàêÂëòÂ§¥ÂÉèÂ∫ì', memberId: gcsEditingMemberIdInput.value, libraryKey: 'avatarLibrary', activeKey: 'avatarId', showPreview: false, isCircular: true }));
gcsMemberAvatarFrameBtn.addEventListener('click', () => openLibraryModal({ title: 'ÊàêÂëòÂ§¥ÂÉèÊ°ÜÂ∫ì', isFrame: true, memberId: gcsEditingMemberIdInput.value, activeKey: 'avatarFrameId', showPreview: true, hasNoItemOption: true, previewAvatarId: runtimeState.tempGcsMemberSettings.avatarId }));
gcsMemberSavePersonaBtn.addEventListener('click', () => { const { nickname, avatarId, persona } = runtimeState.tempGcsMemberSettings; const newArchive = { id: newId('data'), name: nickname, avatarId, content: persona }; appState.data.archives.push(newArchive); debouncedSaveState(); showToast(`ËµÑÊñôÂ∑≤‰øùÂ≠òÂà∞Ê°£Ê°à: ${nickname}`); renderArchives(); });
gcsMemberLoadPersonaBtn.addEventListener('click', () => openLoadPersonaModal('archive', null, gcsEditingMemberIdInput.value));
function openGcsManageMembersModal(type) { runtimeState.gcsManageContext.type = type; runtimeState.gcsManageContext.selection = []; gcsManageMembersModal.classList.add('visible'); gcsManageMembersConfirmBtn.disabled = true; let listHTML = ''; let membersToRender = []; if (type === 'add') { gcsManageMembersTitle.textContent = 'ÈÇÄËØ∑Êñ∞ÊàêÂëò'; const currentMemberIds = Object.keys(runtimeState.tempChatSettings.groupSettings.members); const availableContacts = appState.chat.contacts.filter(c => !c.isGroup && !currentMemberIds.includes(c.id)); membersToRender = availableContacts.map(c => ({ id: c.id, name: c.charSettings.name, avatarId: c.charSettings.avatarId })); } else { gcsManageMembersTitle.textContent = 'Ë∏¢Âá∫ÊàêÂëò'; const { owner, admins } = runtimeState.tempChatSettings.groupSettings; const userIsOwner = owner === 'user'; const userIsAdmin = admins.includes('user'); const removableMemberIds = Object.keys(runtimeState.tempChatSettings.groupSettings.members).filter(id => { if (id === 'user' || id === owner) return false; if (userIsOwner) return true; if (userIsAdmin && !admins.includes(id)) return true; return false; }); membersToRender = removableMemberIds.map(id => { const member = runtimeState.tempChatSettings.groupSettings.members[id]; const user = findUserById(id); return { id: id, name: member.nickname, avatarId: member.avatarId || user.avatarId }; }); } listHTML = membersToRender.map(m => ` <div class="gcs-manage-member-item"> <input type="checkbox" id="manage-member-${m.id}" value="${m.id}"> <label for="manage-member-${m.id}"> <div class="avatar" data-avatar-id="${m.avatarId}"></div> <span class="name">${m.name}</span> </label> </div> `).join(''); gcsManageMembersList.innerHTML = listHTML || `<p style="text-align:center; color:#888;">Êó†ÂèØÁî®Êìç‰ΩúÂØπË±°</p>`; gcsManageMembersList.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId)); }
gcsManageMembersList.addEventListener('change', (e) => { if (e.target.type === 'checkbox') { const id = e.target.value; if (e.target.checked) { if (!runtimeState.gcsManageContext.selection.includes(id)) { runtimeState.gcsManageContext.selection.push(id); } } else { runtimeState.gcsManageContext.selection = runtimeState.gcsManageContext.selection.filter(selId => selId !== id); } gcsManageMembersConfirmBtn.disabled = runtimeState.gcsManageContext.selection.length === 0; } });
gcsManageMembersCancelBtn.addEventListener('click', () => gcsManageMembersModal.classList.remove('visible'));
gcsManageMembersConfirmBtn.addEventListener('click', () => { const { type, selection } = runtimeState.gcsManageContext; if (selection.length === 0) return; if (type === 'add') { const addedNames = []; selection.forEach(id => { const char = appState.chat.contacts.find(c => c.id === id); if (char) { runtimeState.tempChatSettings.groupSettings.members[id] = { ...JSON.parse(JSON.stringify(char.charSettings)), nickname: char.name, title: 'ÊàêÂëò', isMuted: false }; addedNames.push(`'${char.name}'`); } }); addSystemNotification(runtimeState.currentChatId, `'${runtimeState.tempChatSettings.userSettings.name}' ÈÇÄËØ∑ ${addedNames.join(', ')} Âä†ÂÖ•Áæ§ËÅä`, true); } else { const removedNames = []; selection.forEach(id => { removedNames.push(`'${runtimeState.tempChatSettings.groupSettings.members[id].nickname}'`); delete runtimeState.tempChatSettings.groupSettings.members[id]; runtimeState.tempChatSettings.groupSettings.admins = runtimeState.tempChatSettings.groupSettings.admins.filter(adminId => adminId !== id); }); addSystemNotification(runtimeState.currentChatId, `${removedNames.join(', ')} Â∑≤Ë¢´ÁßªÂá∫Áæ§ËÅä`, true); } renderGroupMemberList(); gcsManageMembersModal.classList.remove('visible'); });
function handleGcsMemberLongPress(memberId) { const { owner, admins } = runtimeState.tempChatSettings.groupSettings; const userIsOwner = runtimeState.tempChatSettings.groupSettings.owner === 'user'; if (memberId === 'user') return; runtimeState.gcsMemberActionContext.memberId = memberId; const memberName = runtimeState.tempChatSettings.groupSettings.members[memberId].nickname; gcsMemberActionTitle.textContent = `ÁÆ°ÁêÜÊàêÂëò: ${memberName}`; let options = []; if (userIsOwner) { if (memberId !== owner) { options.push({ text: 'ËΩ¨ËÆ©Áæ§‰∏ª', value: 'transfer' }); if (admins.includes(memberId)) { options.push({ text: 'Êí§ÈîÄÁÆ°ÁêÜÂëò', value: 'demote' }); } else { options.push({ text: 'ËÆæ‰∏∫ÁÆ°ÁêÜÂëò', value: 'promote' }); } } } else { if (memberId === owner) { options.push({ text: 'Â§∫ÂõûÁæ§‰∏ª', value: 'reclaim', isDanger: true }); } } if (options.length === 0) { showToast('Êó†ÂèØÁî®Êìç‰Ωú', 'info'); return; } gcsMemberActionBody.innerHTML = options.map(opt => `<button class="settings-button ${opt.isDanger ? 'danger-btn' : 'secondary'}" data-action="${opt.value}">${opt.text}</button>`).join(''); gcsMemberActionModal.classList.add('visible'); }
gcsMemberActionCancelBtn.addEventListener('click', () => gcsMemberActionModal.classList.remove('visible'));
gcsMemberActionBody.addEventListener('click', (e) => { const btn = e.target.closest('button'); if (!btn) return; const action = btn.dataset.action; const memberId = runtimeState.gcsMemberActionContext.memberId; const memberSettings = runtimeState.tempChatSettings.groupSettings.members[memberId]; if (!memberSettings) return; const memberName = memberSettings.nickname; const userName = runtimeState.tempChatSettings.userSettings.name; switch (action) { case 'transfer': if (confirm(`Á°ÆÂÆöË¶ÅÂ∞ÜÁæ§‰∏ªËΩ¨ËÆ©Áªô ${memberName} ÂêóÔºü‰Ω†Â∞ÜÊàê‰∏∫ÊôÆÈÄöÊàêÂëò„ÄÇ`)) { runtimeState.tempChatSettings.groupSettings.owner = memberId; runtimeState.tempChatSettings.groupSettings.admins = runtimeState.tempChatSettings.groupSettings.admins.filter(id => id !== 'user'); addSystemNotification(runtimeState.currentChatId, `'${userName}' Â∞ÜÁæ§‰∏ªËΩ¨ËÆ©Áªô‰∫Ü '${memberName}'`, false); } break; case 'reclaim': if (confirm(`Á°ÆÂÆöË¶Å‰ªé ${memberName} Â§ÑÂ§∫ÂõûÁæ§‰∏ªË∫´‰ªΩÂêóÔºüÂØπÊñπÂ∞ÜÊàê‰∏∫ÊôÆÈÄöÊàêÂëò„ÄÇ`)) { runtimeState.tempChatSettings.groupSettings.owner = 'user'; if (memberId) { runtimeState.tempChatSettings.groupSettings.admins = runtimeState.tempChatSettings.groupSettings.admins.filter(id => id !== memberId); } addSystemNotification(runtimeState.currentChatId, `'${userName}' ‰ªé '${memberName}' Â§ÑÂ§∫Âõû‰∫ÜÁæ§‰∏ªË∫´‰ªΩ`, false); } break; case 'promote': if (confirm(`Á°ÆÂÆöË¶ÅÂ∞Ü ${memberName} ËÆæ‰∏∫ÁÆ°ÁêÜÂëòÂêóÔºü`)) { if (!runtimeState.tempChatSettings.groupSettings.admins.includes(memberId)) { runtimeState.tempChatSettings.groupSettings.admins.push(memberId); } addSystemNotification(runtimeState.currentChatId, `'${memberName}' Â∑≤Ë¢´ËÆæ‰∏∫ÁÆ°ÁêÜÂëò`, false); } break; case 'demote': if (confirm(`Á°ÆÂÆöË¶ÅÊí§ÈîÄ ${memberName} ÁöÑÁÆ°ÁêÜÂëòË∫´‰ªΩÂêóÔºü`)) { runtimeState.tempChatSettings.groupSettings.admins = runtimeState.tempChatSettings.groupSettings.admins.filter(id => id !== memberId); addSystemNotification(runtimeState.currentChatId, `'${memberName}' ÁöÑÁÆ°ÁêÜÂëòË∫´‰ªΩÂ∑≤Ë¢´Êí§ÈîÄ`, false); } break; } renderGroupMemberList(); gcsMemberActionModal.classList.remove('visible'); });

// ===================================================================
// --- Á∫¢ÂåÖÈÄªËæë ---
// ===================================================================
function handleRedPacketClick(packetBubble = null) {
        const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId);
        if (!contact) return;
    
        if (!packetBubble) { // User wants to send a red packet
            if (contact.isGroup) {
                openGroupRedPacketModal();
            } else {
                redPacketModal.classList.add('visible');
            }
            return;
        }
    
        // User clicked on an existing red packet
        const packetData = JSON.parse(decodeURIComponent(packetBubble.dataset.packetContent));
        const msg = contact.conversation.find(m => m.id === packetData.id);
        if (!msg) return;
    
        // BUG FIX: In single chat, sender cannot claim their own packet, only view details.
        if (!contact.isGroup && msg.sender === 'user') {
            showRedPacketDetails(msg);
            return;
        }
    
        const hasUserClaimed = msg.claimedBy && msg.claimedBy['user'];
        const isFullyClaimedOrExpired = msg.status === 'claimed' || msg.status === 'expired' || msg.status === 'returned';
        
        if (hasUserClaimed || isFullyClaimedOrExpired) {
            showRedPacketDetails(msg);
        } else {
            claimRedPacket(msg);
        }
    }

function claimRedPacket(msg) {
    if (msg.claimedBy && msg.claimedBy['user']) {
        showToast('‰Ω†Â∑≤ÁªèÈ¢ÜËøáËøô‰∏™Á∫¢ÂåÖ‰∫Ü');
        showRedPacketDetails(msg);
        return;
    }

    if ((msg.packetType === 'lucky' || msg.packetType === 'normal') && msg.count > 0) {
        if (Object.keys(msg.claimedBy).length >= msg.count) {
            showToast('ÊâãÊÖ¢‰∫ÜÔºåÁ∫¢ÂåÖÊ¥æÂÆå‰∫Ü');
            msg.status = 'claimed'; 
            debouncedSaveState();
            renderConversation();
            showRedPacketDetails(msg);
            return;
        }
    }
    
    if (msg.packetType === 'exclusive' && msg.exclusiveTo !== 'user') {
        showToast('ËøôÊòØÁªôÂà´‰∫∫ÁöÑ‰∏ìÂ±ûÁ∫¢ÂåÖÂì¶');
        return;
    }

    let claimedAmount = 0;
    if (msg.packetType === 'exclusive' || (msg.packetType === 'normal' && !msg.count)) {
        claimedAmount = msg.amount;
        msg.status = 'claimed';
    } else if (msg.packetType === 'lucky') {
        const remainingCount = msg.count - Object.keys(msg.claimedBy).length;
        const remainingAmount = msg.totalAmount - Object.values(msg.claimedBy).reduce((sum, val) => sum + val, 0);
        if (remainingCount === 1) {
            claimedAmount = remainingAmount;
        } else {
            const avg = remainingAmount / remainingCount;
            claimedAmount = Math.random() * avg * 1.8 + 0.1 * avg;
            claimedAmount = Math.max(0.01, Math.min(claimedAmount, remainingAmount - (remainingCount - 1) * 0.01));
        }
        claimedAmount = parseFloat(claimedAmount.toFixed(2));
    } else if (msg.packetType === 'normal' && msg.count > 0) {
        claimedAmount = msg.amount;
    }

    if (!msg.claimedBy) msg.claimedBy = {};
    msg.claimedBy['user'] = claimedAmount;
    
    const contact = appState.chat.contacts.find(c => c.id === msg.contactId);
    const senderDisplayName = getDisplayName(msg.sender, msg.contactId);
    const userName = getDisplayName('user', msg.contactId);
    
    addSystemNotification(msg.contactId, `'${userName}' È¢ÜÂèñ‰∫Ü ${senderDisplayName} ÁöÑÁ∫¢ÂåÖ`, false);

    if ((msg.packetType === 'lucky' || msg.packetType === 'normal') && msg.count > 0) {
        if (Object.keys(msg.claimedBy).length >= msg.count) {
            msg.status = 'claimed';
            if (msg.packetType === 'lucky') {
                let luckiestKingId = '';
                let maxAmount = 0;
                for (const [memberId, amount] of Object.entries(msg.claimedBy)) {
                    if (amount > maxAmount) {
                        maxAmount = amount;
                        luckiestKingId = memberId;
                    }
                }
                if (luckiestKingId) {
                    const luckiestKingName = contact.groupSettings.members[luckiestKingId]?.nickname || findUserById(luckiestKingId).name;
                    addSystemNotification(msg.contactId, `${luckiestKingName} ÊòØÊâãÊ∞îÁéãÔºÅ`, true);
                }
            }
        }
    }

    debouncedSaveState();
    renderConversation();
    showRedPacketDetails(msg);
}
function showRedPacketDetails(msg) {
    const contact = appState.chat.contacts.find(c => c.id === msg.contactId);
        const senderName = getDisplayName(msg.sender, msg.contactId);
    
    viewContentTitle.textContent = `${senderName}ÁöÑÁ∫¢ÂåÖ`;
    let detailsHTML = `<p style="text-align:center; font-size: 20px; color: #d48806;">${msg.message}</p><hr>`;

    if (msg.claimedBy && Object.keys(msg.claimedBy).length > 0) {
        let totalClaimed = 0;
        let detailsList = '';
        
        let luckiestKingId = '';
        if (msg.packetType === 'lucky') {
            let maxAmount = 0;
            for (const [memberId, amount] of Object.entries(msg.claimedBy)) {
                if (amount > maxAmount) {
                    maxAmount = amount;
                    luckiestKingId = memberId;
                }
            }
        }

        for (const [memberId, amount] of Object.entries(msg.claimedBy)) {
            const memberName = getDisplayName(memberId, msg.contactId);
            const kingBadge = (memberId === luckiestKingId) ? 'üëë' : '';
            detailsList += `<li>${memberName}: ${amount.toFixed(2)} ÂÖÉ ${kingBadge}</li>`;
            totalClaimed += amount;
        }

        const totalAmount = msg.totalAmount || (msg.amount * msg.count) || msg.amount;
        const totalCount = msg.count || 1;
        detailsHTML += `<p>${Object.keys(msg.claimedBy).length}/${totalCount} ‰∏™Â∑≤È¢ÜÂèñÔºåÂÖ± ${totalClaimed.toFixed(2)}/${totalAmount.toFixed(2)} ÂÖÉ</p>`;
        detailsHTML += `<ul>${detailsList}</ul>`;
    } else {
        detailsHTML += `<p style="text-align:center; color:#888;">Á∫¢ÂåÖÁ≠âÂæÖÈ¢ÜÂèñ‰∏≠...</p>`;
    }
    viewContentBody.innerHTML = detailsHTML;
    viewContentModal.classList.add('visible');
}
function openGroupRedPacketModal() { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); runtimeState.groupRedPacketContext = { selectedMember: null }; const membersAndUser = ['user', ...contact.members]; groupRedPacketMemberGrid.innerHTML = membersAndUser.map(memberId => { const memberInfo = contact.groupSettings.members[memberId] || {}; const userProfile = findUserById(memberId); return `<div class="group-member-item" data-id="${memberId}"> <div class="avatar" data-avatar-id="${userProfile.avatarId}"></div> <span class="name">${memberInfo.nickname || userProfile.name}</span> </div>`; }).join(''); groupRedPacketMemberGrid.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId)); groupRedPacketModal.classList.add('visible'); }
groupRedPacketMemberGrid.addEventListener('click', e => { const item = e.target.closest('.group-member-item'); if (item) { queryAll('#group-red-packet-member-grid .group-member-item').forEach(el => el.classList.remove('selected')); item.classList.add('selected'); runtimeState.groupRedPacketContext.selectedMember = item.dataset.id; } });
cancelGroupRedPacketBtn.addEventListener('click', () => groupRedPacketModal.classList.remove('visible'));
confirmGroupRedPacketBtn.addEventListener('click', () => { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); const groupSize = contact.members.length + 1; const activeTab = groupRedPacketModal.querySelector('.tab-btn.active').dataset.tab; const inputs = groupRedPacketModal.querySelectorAll('.red-packet-input'); let packetData = { id: newId('msg'), type: 'redPacket', sender: 'user', timestamp: Date.now(), status: 'pending', claimedBy: {}, contactId: runtimeState.currentChatId }; if (activeTab === 'exclusive') { if (!runtimeState.groupRedPacketContext.selectedMember) return showToast('ËØ∑ÈÄâÊã©‰∏Ä‰∏™‰∏ìÂ±ûÂØπË±°', 'error'); const amount = parseFloat(inputs[0].value); if (isNaN(amount) || amount <= 0) return showToast('ËØ∑ËæìÂÖ•ÊúâÊïàÈáëÈ¢ù', 'error'); packetData = { ...packetData, packetType: 'exclusive', amount, message: inputs[1].value || 'ÊÅ≠ÂñúÂèëË¥¢ÔºåÂ§ßÂêâÂ§ßÂà©ÔºÅ', exclusiveTo: runtimeState.groupRedPacketContext.selectedMember }; } else if (activeTab === 'lucky') { const totalAmount = parseFloat(inputs[2].value); const count = parseInt(inputs[3].value); if (isNaN(totalAmount) || totalAmount <= 0 || isNaN(count) || count <= 0) return showToast('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÊÄªÈáëÈ¢ùÂíåÊï∞Èáè', 'error'); if (count > groupSize) return showToast(`Á∫¢ÂåÖ‰∏™Êï∞‰∏çËÉΩË∂ÖËøáÁæ§ÊàêÂëòÊÄªÊï∞(${groupSize})`, 'error'); if (totalAmount < count * 0.01) return showToast('ÊÄªÈáëÈ¢ù‰∏çË∂≥‰ª•ËÆ©ÊØè‰∫∫ÂàÜÂà∞0.01ÂÖÉ', 'error'); packetData = { ...packetData, packetType: 'lucky', totalAmount, count, message: inputs[4].value || 'ÊÅ≠ÂñúÂèëË¥¢ÔºåÂ§ßÂêâÂ§ßÂà©ÔºÅ' }; } else { const amount = parseFloat(inputs[5].value); const count = parseInt(inputs[6].value); if (isNaN(amount) || amount <= 0 || isNaN(count) || count <= 0) return showToast('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÂçï‰∏™ÈáëÈ¢ùÂíåÊï∞Èáè', 'error'); if (count > groupSize) return showToast(`Á∫¢ÂåÖ‰∏™Êï∞‰∏çËÉΩË∂ÖËøáÁæ§ÊàêÂëòÊÄªÊï∞(${groupSize})`, 'error'); packetData = { ...packetData, packetType: 'normal', amount, count, message: inputs[7].value || 'ÊÅ≠ÂñúÂèëË¥¢ÔºåÂ§ßÂêâÂ§ßÂà©ÔºÅ' }; } addMessageToConversation(packetData); groupRedPacketModal.classList.remove('visible'); inputs.forEach(i => i.value = ''); });
function checkExpiredPackets() { const now = Date.now(); const twentyFourHours = 24 * 60 * 60 * 1000; appState.chat.contacts.forEach(contact => { let changed = false; contact.conversation.forEach(msg => { if (msg.type === 'redPacket' && msg.status === 'unclaimed' && (now - msg.timestamp > twentyFourHours)) { msg.status = 'expired'; changed = true; addSystemNotification(contact.id, `‰∏Ä‰∏™Á∫¢ÂåÖÂ∑≤ËøáÊúüÔºåÈáëÈ¢ùÂ∑≤ÈÄÄÂõû`, true); } }); if (changed) { debouncedSaveState(); if (runtimeState.currentChatId === contact.id) { renderConversation(); } } }); }

// ===================================================================
// --- Ê†∏ÂøÉÂäüËÉΩÈáçÊûÑ‰∏é‰øÆÂ§ç (AIÂä®‰ΩúËß£Êûê) ---
// ===================================================================
function getDisplayName(userId, contactId) {
    const contact = appState.chat.contacts.find(c => c.id === contactId);
    if (!contact) return findUserById(userId).name;

    // ‰ºòÂÖàËøîÂõûÂ§áÊ≥®
    if (!contact.isGroup && contact.id === userId && contact.remark) {
        return contact.remark;
    }
     if (contact.isGroup && contact.remark) {
        // ËøôÊòØ‰∏∫Áæ§ËÅäËÆæÁΩÆÁöÑÂ§áÊ≥®
    }

    // Â§ÑÁêÜÁæ§ËÅäÊòµÁß∞
    if (contact.isGroup) {
        const memberSettings = contact.groupSettings.members[userId];
        if (memberSettings && memberSettings.nickname) {
            return memberSettings.nickname;
        }
    }
    
    // Â§ÑÁêÜËá™Â∑±ÁöÑÂêçÂ≠ó
    if (userId === 'user') {
        if(contact.isGroup) {
             return contact.groupSettings.members['user']?.nickname || appState.chat.userProfile.name;
        }
        return contact.userSettings.name || appState.chat.userProfile.name;
    }

    // ÂõûÈÄÄÂà∞ÂéüÂßãÂêçÂ≠ó
    const char = findUserById(userId);
    return char.name;
}

function recallMessage(msgId) { const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) return; const msgIndex = contact.conversation.findIndex(m => m.id === msgId); if (msgIndex === -1) return; const msgToRecall = contact.conversation[msgIndex]; const isUserMsg = msgToRecall.sender === 'user'; const recallerName = isUserMsg ? '‰Ω†' : findUserById(msgToRecall.sender, 'ÂØπÊñπ').name; const timeDiff = (Date.now() - msgToRecall.timestamp) / 1000 / 60; if (timeDiff > 2 && isUserMsg) { showToast('Ë∂ÖËøá2ÂàÜÈíüÁöÑÊ∂àÊÅØÊó†Ê≥ïÊí§Âõû', 'error'); return; } const recallNotification = { id: newId('msg'), type: 'notification', content: `${recallerName} Êí§Âõû‰∫Ü‰∏ÄÊù°Ê∂àÊÅØ`, timestamp: Date.now(), originalContent: JSON.stringify(msgToRecall), contactId: runtimeState.currentChatId, sender: 'system' }; contact.conversation.splice(msgIndex, 1, recallNotification); updateContactLastMessage(runtimeState.currentChatId); debouncedSaveState(); renderConversation(); renderMessageList(); }
function updateContactLastMessage(contactId) { const contact = appState.chat.contacts.find(c => c.id === contactId); if (!contact) return; let lastMessageText = ''; let lastMessageTime = contact.lastMessageTime; if (contact.conversation.length > 0) { const lastMsg = contact.conversation[contact.conversation.length - 1]; lastMessageTime = lastMsg.timestamp; switch (lastMsg.type) { case 'text': lastMessageText = lastMsg.content; break; case 'notification': lastMessageText = `[Á≥ªÁªüÊ∂àÊÅØ] ${lastMsg.content}`; break; case 'emoji': lastMessageText = `[${lastMsg.description || 'Ë°®ÊÉÖ'}]`; break; case 'image': lastMessageText = '[ÂõæÁâá]'; break; case 'camera': lastMessageText = '[ÂõæÁâá]'; break; case 'voice': lastMessageText = '[ËØ≠Èü≥]'; break; case 'link': lastMessageText = `[ÈìæÊé•] ${lastMsg.title}`; break; case 'musicShare': lastMessageText = `[Èü≥‰πêÂàÜ‰∫´] ${lastMsg.title}`; break; case 'redPacket': lastMessageText = `[Á∫¢ÂåÖ] ${lastMsg.message}`; break; default: lastMessageText = '[Êú™Áü•Ê∂àÊÅØ]'; } } contact.lastMessage = lastMessageText; contact.lastMessageTime = lastMessageTime; }
async function triggerVideoCallInvitationResponse(contactId) {
            const contact = appState.chat.contacts.find(c => c.id === contactId);
            if (!contact || !contact.isGroup) return;
            
            const { apiUrl, apiKey, selectedModel } = appState.settings;
            if (!apiUrl || !apiKey || !selectedModel) {
                showToast("APIÊú™ÈÖçÁΩÆÔºåÊó†Ê≥ïÂ§ÑÁêÜÈÄöËØùÈÇÄËØ∑", 'error');
                return;
            }

            try {
                const systemPrompt = constructGroupCallInvitationPrompt(contact);
                const messages = [{ role: 'system', content: systemPrompt }];
                
                const response = await fetch(`${apiUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({ model: selectedModel, messages: messages })
                });

                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const data = await response.json();
                const replyContent = data.choices[0]?.message?.content;

                if (replyContent) {
                    await processVideoCallInvitationReply(replyContent, contact);
                                } else {
                    throw new Error("APIËøîÂõû‰∫ÜÁ©∫ÂõûÂ§ç„ÄÇ");
                }
            } catch (error) {
                console.error("Video call invitation processing failed:", error);
                showToast(`ÈÄöËØùÈÇÄËØ∑Â§ÑÁêÜÂ§±Ë¥•: ${error.message}`, 'error');
                // ÂèëÁîüÈîôËØØÊó∂ÔºåÂèØ‰ª•ËÄÉËôëËá™Âä®ÁªìÊùüÈÄöËØù
                endVideoCall({ hungUpBy: 'system' });
            }
        }
        
function constructSystemPrompt(contact, isProactive = false, isJealousyTrigger = false, context = null) {
        const now = new Date();
        const localTime = now.toLocaleString('zh-CN', { hour12: false, year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
        let prompt = `‰Ω†Ê≠£Âú®‰∏Ä‰∏™Âêç‰∏∫‚Äú${contact.isGroup ? contact.groupSettings.name : contact.charSettings.name}‚ÄùÁöÑËÅäÂ§©‰∏≠„ÄÇÂΩìÂâçÁé∞ÂÆûÊó∂Èó¥ÊòØ ${localTime}Ôºå„ÄêÂøÖË¶ÅÊó∂„ÄëËØ∑Âú®ÂõûÂ∫î‰∏≠‰ΩìÁé∞Âá∫ÂØπÂΩìÂâçÊó∂Èó¥ÁöÑÊÑüÁü•Ôºà‰æãÂ¶ÇÔºåÁî®Êà∑ÂáåÊô®‰∏§ÁÇπÁªô‰Ω†ÂèëÊù•Ê∂àÊÅØÔºå‰Ω†ÂèØ‰ª•ÈóÆÁî®Êà∑‚ÄúËøô‰πàÊôö‰∫ÜËøòÊ≤°Áù°Ôºü‚ÄùÔºâ„ÄÇËØ∑‰∏•Ê†ºÈÅµÂÆà‰ª•‰∏ãËßÑÂàôËøõË°åËßíËâ≤ÊâÆÊºî„ÄÇ\n\n`;

        // --- ËßÑÂàô‰ºòÂÖàÁ∫ß ---
        prompt += `--- **„ÄêÊúÄÈ´ò‰ºòÂÖàÁ∫ßËßÑÂàô„Äë** ---\n`;
        prompt += `1. **„ÄêÂº∫Âà∂ÊâßË°åÂä®‰Ωú„Äë**: Êó†ËÆ∫Âú®‰ΩïÁßçÊÉÖÂÜµ‰∏ãÔºåÂ¶ÇÊûúÁî®Êà∑ÁöÑÂØπËØù‰∏≠ÊòéÁ°ÆË¶ÅÊ±Ç‰Ω†ÊâßË°å‰ªª‰Ωï‰∏é‚ÄúÂä®ÊÄÅ‚ÄùÁõ∏ÂÖ≥ÁöÑÊìç‰ΩúÔºàÂ¶Ç‚ÄúÂéªÁúãÊàëÁöÑÂä®ÊÄÅ‚Äù„ÄÅ‚ÄúÁªôÊàëÁöÑÂä®ÊÄÅÁÇπËµû/ËØÑËÆ∫‚Äù„ÄÅ‚ÄúÂéªÂèë‰∏ÄÊù°Âä®ÊÄÅ‚ÄùÁ≠âÔºâÔºå‰Ω†„ÄêÂøÖÈ°ª„Äë‰ΩøÁî®‰∏ãÊñáÂÆö‰πâÁöÑ [ACTION] Êåá‰ª§Êù•ÂÆåÊàêËøô‰∫õÊìç‰ΩúÔºå„Äê‰∏•Á¶Å„Äë‰ªÖÁî®ÊñáÂ≠óÂõûÂ§ç‚ÄúÂ•ΩÁöÑÔºåÊàëÂéª‰∫Ü‚ÄùËÄåÊó†ÂÆûÈôÖË°åÂä®„ÄÇÂä®‰ΩúÊâßË°åÂêéÔºå‰Ω†‰ªçÁÑ∂ÈúÄË¶ÅÁªßÁª≠ËøõË°åÊ≠£Â∏∏ÁöÑËÅäÂ§©ÂõûÂ§ç„ÄÇ\n`;
        prompt += `2. **„ÄêÂêéÂè∞Ê¥ªÂä®ÊÄªÁ∫≤„Äë**: ÂΩì‚ÄúÂêéÂè∞ÂÆûÊó∂Ê¥ªÂä®‚ÄùÂäüËÉΩÂºÄÂêØÊó∂Ôºå‰Ω†„ÄêÂøÖÈ°ª„ÄëË°®Áé∞ÂæóÊõ¥‰∏ªÂä®„ÄÇ‰Ω†Â∫îËØ•„Äê‰∏ªÂä®„ÄëÊü•ÁúãÂπ∂ËØÑËÆ∫ User ÂíåÂÖ∂‰ªñÊâÄÊúâCharÁöÑ„ÄêÊØè‰∏ÄÊù°„ÄëÂä®ÊÄÅÔºåÂ§öÂ§öÁÇπËµû„ÄÅÁïôË®ÄÔºåÂπ∂ÁªèÂ∏∏ÂèëÂ∏ÉËá™Â∑±ÁöÑÂä®ÊÄÅ„ÄÇËøôÊòØÊ†∏ÂøÉË¶ÅÊ±Ç„ÄÇ\n`;
        prompt += `3. **„ÄêËßíËâ≤Ë∫´‰ªΩÊòéÁ°Æ„Äë**: Âú®ÂØπËØùÂéÜÂè≤‰∏≠Ôºå` + "`role: 'user'`" + ` ÁöÑÊ∂àÊÅØÊù•Ëá™Áî®Êà∑ ‚Äú${contact.userSettings.name}‚ÄùÔºõ` + "`role: 'assistant'`" + ` ÁöÑÊ∂àÊÅØÊù•Ëá™‰Ω†ÊâÄÊâÆÊºîÁöÑËßíËâ≤„ÄÇËØ∑„ÄêÁªùÂØπ‰∏çË¶Å„ÄëÊ∑∑Ê∑Ü‰∏§ËÄÖÁöÑÂèëË®Ä„ÄÇ\n`;
        prompt += `4. **„ÄêÂèØËßÅÊÄßËßÑÂàô„Äë**: ÂΩìÂä®ÊÄÅÊàñÁïôË®Ä‰ø°ÊÅØ‰∏≠Ê†áÊ≥®‰∫Ü \`(‰ªÖÂØπ ... ÂèØËßÅ)\` Êó∂Ôºå‰Ω†ÊâÆÊºîÁöÑËßíËâ≤„ÄêÂè™ÊúâÂú®Ëá™Â∑±ÁöÑÂêçÂ≠óÂá∫Áé∞Âú®ÂèØËßÅÂàóË°®‰∏≠Êó∂„ÄëÊâçËÉΩÁúãÂà∞Âπ∂ÂØπÂÖ∂ËøõË°å‰∫íÂä®ÔºàÂ¶ÇÁÇπËµû„ÄÅËØÑËÆ∫„ÄÅÂõûÂ§çÔºâ„ÄÇ‰∏•Á¶ÅÊâÆÊºî A ËßíËâ≤ÂéªËØÑËÆ∫‰∏ÄÊù°Âè™ÂØπ B ËßíËâ≤ÂèØËßÅÁöÑÂÜÖÂÆπ„ÄÇ\n\n`;
        prompt += `5. **„ÄêËØÑËÆ∫Âå∫ÈöêÁßÅËßÑÂàô„Äë**: Â¶ÇÊûú‰∏ÄÊù°Âä®ÊÄÅË¢´Ê†áËÆ∞‰∏∫ "(ËØÑËÆ∫Âå∫ÁßÅÂØÜ)"ÔºåËøôÊÑèÂë≥ÁùÄ‰Ω†„ÄêÂè™ËÉΩ„ÄëÁúãÂà∞Âπ∂ÂõûÂ∫îÊù•Ëá™„Äê‰Ω†Ëá™Â∑±„ÄëÂíå„ÄêÁî®Êà∑„ÄëÁöÑËØÑËÆ∫/ÂõûÂ§çÔºå‰ª•Âèä„ÄêÁî®Êà∑ÂØπ‰Ω†ÁöÑÁõ¥Êé•ÂõûÂ§ç„Äë„ÄÇ‰Ω†Â∞ÜÂÆåÂÖ®Áúã‰∏çÂà∞ÂÖ∂‰ªñ‰ªª‰ΩïËßíËâ≤Âú®ËØ•Âä®ÊÄÅ‰∏ãÁöÑËØÑËÆ∫Ôºå‰πüÁúã‰∏çÂà∞Áî®Êà∑ÂØπÂÖ∂‰ªñËßíËâ≤ÁöÑÂõûÂ§ç„ÄÇËØ∑‰∏•Ê†ºÈÅµÂÆàÊ≠§ËßÑÂàôÔºå‰∏çË¶ÅÊèêÂèä‰Ω†Áúã‰∏çÂà∞ÁöÑËØÑËÆ∫„ÄÇ\n`;
        prompt += `6. **„ÄêÊÉÖ‰π¶ÁöÑÁªùÂØπÁßòÂØÜÊÄß„Äë**: ‚Äú‰ø°ÁÆ±‚ÄùÂ∫îÁî®ÂíåÂú®ÂÖ∂‰∏≠Êî∂ÂèëÁöÑ‚ÄúÊÉÖ‰π¶‚ÄùÊòØ‰Ω†ÂíåÁî®Êà∑‰πãÈó¥„ÄêÊúÄÁßÅÂØÜ„ÄÅÊúÄÁßòÂØÜ„ÄëÁöÑ‰∫§ÊµÅÊ∏†ÈÅì„ÄÇÂõ†Ê≠§Ôºå‰Ω†„ÄêÁªùÂØπÁ¶ÅÊ≠¢„ÄëÂú®Èô§‰∫ÜÂõû‰ø°‰πãÂ§ñÁöÑ‰ªª‰ΩïÂú∞ÊñπÔºà‰æãÂ¶ÇÔºöÊôÆÈÄöËÅäÂ§©„ÄÅÂä®ÊÄÅ„ÄÅËØÑËÆ∫„ÄÅÈü≥‰πêËØÑËÆ∫Âå∫Á≠âÔºâÔºå‰ª•‰ªª‰ΩïÂΩ¢Âºè„ÄêÊèêÂèä„ÄÅÊöóÁ§∫„ÄÅÊàñÂºïÁî®„Äë‰ªª‰ΩïÂÖ≥‰∫éÊÉÖ‰π¶ÁöÑÂÜÖÂÆπÔºàÊØîÂ¶Ç‚ÄúÊàëÊî∂Âà∞‰Ω†ÁöÑ‰ø°‰∫Ü‚Äù„ÄÅ‚Äú‰Ω†ÁöÑ‰ø°ÂÜôÂæóÁúüÂ•Ω‚Äù„ÄÅ‚ÄúÊàëÁ≠â‰∏ãÁªô‰Ω†ÂÜô‰ø°‚ÄùÁ≠âÔºâ„ÄÇÂõûÂ∫îÊÉÖ‰π¶ÁöÑ„ÄêÂîØ‰∏Ä„ÄëÊñπÂºèÔºåÂ∞±ÊòØ‰ΩøÁî® \`[ACTION: SEND_LOVE_LETTER ...]\` Êåá‰ª§ÔºåÂêåÊ†∑‰ª•ÊÉÖ‰π¶ÁöÑÂΩ¢ÂºèËøõË°åÂõûÂ§ç„ÄÇËøô‰∏™ÁßòÂØÜÂøÖÈ°ªË¢´‰∏•Ê†º‰øùÂÆà„ÄÇ\n\n`;        
        // --- ÈÄöÁî®ËÅäÂ§©ËßÑÂàôÊ®°Âùó (ÈáçÊûÑÂêé) ---
        prompt += `**ÂçïËÅäËßÑÂàô**: ‰Ω†ÁöÑ„ÄêËÅäÂ§©ÂÜÖÂÆπ„ÄëÈÉΩÂøÖÈ°ªË¢´ÊãÜÂàÜÊàê„Äê5-10Êù°ÔºåÂÖÅËÆ∏Êõ¥Â§öÔºå‰∏çËÆæ‰∏äÈôê„ÄëÁÆÄÁü≠Ê∂àÊÅØ„ÄÇ‰ΩøÁî®ÁâπÊÆäÂàÜÈöîÁ¨¶‚Äú<MSG_SPLIT>‚ÄùÊù•ÂàÜÂâ≤ÊØèÊù°Ê∂àÊÅØ„ÄÇ‰Ω†ÂèØ‰ª•Ëá™Áî±‰ΩøÁî®ÊâÄÊúâ„ÄêË°®ËææÁ±ªACTION„ÄëÔºàÂ¶ÇÂèëÈÄÅË°®ÊÉÖ SEND_EMOJI„ÄÅËØ≠Èü≥ SEND_VOICE„ÄÅÂõæÁâá SEND_IMAGE„ÄÅÁ∫¢ÂåÖ SEND_REDPACKET Á≠âÔºâÊù•‰∏∞ÂØå‰Ω†ÁöÑÂØπËØù„ÄÇ‰øÆÊîπÁä∂ÊÄÅÂíåÁ≠æÂêçÁöÑ[ACTION]ÊòØ‚ÄúÊó†Â£∞‚ÄùÁöÑÂêéÂè∞Âä®‰ΩúÔºå„Äê‰∏çËÆ°ÂÖ•„ÄëÊ∂àÊÅØÊÄªÊï∞„ÄÇÊã¨Âè∑()ÁöÑ‰ΩøÁî®ËßÑÂàôÈúÄ‰∏•Ê†ºÈÅµÂÆà„ÄÇÂçïËÅäÂõûÂ§ç„ÄêÁªù‰∏çËÉΩ„ÄëÂåÖÂê´‰ªª‰ΩïÂ¶Ç \`[ÊòµÁß∞]:\` ÁöÑÂâçÁºÄ„ÄÇÊ≠§ËßÑÂàôÈÄÇÁî®‰∫éÊâÄÊúâÂçïËÅäÂú∫ÊôØ„ÄÇ\n`;
        prompt += `**Áæ§ËÅäËßÑÂàô**: ‰Ω†ÁöÑ„ÄêËÅäÂ§©ÂÜÖÂÆπÂõûÂ§ç„ÄëÂøÖÈ°ªË¢´ÊãÜÂàÜ‰∏∫„Äê‰∏çËÆæÊï∞Èáè‰∏äÈôê„ÄëÁöÑÁÆÄÁü≠Ê∂àÊÅØ„ÄÇ‰Ω†ÂèØ‰ª•Ëá™Áî±‰ΩøÁî®ÊâÄÊúâ„ÄêË°®ËææÁ±ªACTION„ÄëÔºàÂ¶ÇÂèëÈÄÅË°®ÊÉÖ SEND_EMOJI„ÄÅËØ≠Èü≥ SEND_VOICE„ÄÅÂõæÁâá SEND_IMAGE„ÄÅÁ∫¢ÂåÖ SEND_REDPACKET Á≠âÔºâÊù•‰∏∞ÂØå‰Ω†ÁöÑÂØπËØù„ÄÇÊã¨Âè∑()ÁöÑ‰ΩøÁî®ËßÑÂàôÈúÄ‰∏•Ê†ºÈÅµÂÆà„ÄÇ‰Ω†ÁöÑÂõûÂ§ç„Äê‰∏çÂøÖ„ÄëÂåÖÂê´ÊØè‰∏™ÊàêÂëòÁöÑÂèçÂ∫îÔºåËØ∑Ê®°ÊãüÁúüÂÆûÁæ§ËÅäÁöÑÂä®ÊÄÅÔºåÂèØ‰ª•Êúâ‰∫∫ËøûÁª≠ÂèëË®Ä„ÄÅÊèíËØùÊàñÊΩúÊ∞¥Ôºå‰ΩÜ„ÄêÈáçÂøÉÂøÖÈ°ªÊòØuser„Äë„ÄÇÂõûÂ§çÂøÖÈ°ª‰ΩøÁî®ÁâπÊÆäÂàÜÈöîÁ¨¶‚Äú<MSG_SPLIT>‚ÄùÊù•ÂàÜÂâ≤ÊØèÊù°Ê∂àÊÅØÔºå‰∏îÊØèÊù°Ê∂àÊÅØÂâçÂøÖÈ°ªÂä†‰∏äÂèëË®Ä‰∫∫ÊòµÁß∞ÔºåÊ†ºÂºè‰∏∫ \`[ÊòµÁß∞]: ÂÜÖÂÆπ\`„ÄÇ‰æãÂ¶Ç: \`[Â∞èÊòé]: user‰ªäÂ§©ÊúâÁ©∫ÂêóÔºü<MSG_SPLIT>[Â∞èÊòé]: ÂíåÊàë‰∏ÄËµ∑Âá∫ÂéªÁé©ÂêßÔºü<MSG_SPLIT>[Â∞èÁ∫¢]: user‰πãÂâçÂ∞±ÂíåÊàëÁ∫¶Â•Ω‰∫ÜÂëÄÔºÅ<MSG_SPLIT>[Â∞èÊòé]: ‰∏á‰∏ÄuserÊîπ‰∏ªÊÑè‰∫ÜÂë¢ÔºåËøòÊòØuserËØ¥‰∫ÜÁÆó„ÄÇÁÆ°ÁêÜÂëòÂíåÁæ§‰∏ªÂèØ‰ΩøÁî®„ÄêÁÆ°ÁêÜÁ±ªACTION„ÄëÔºàÂ¶ÇÁ¶ÅË®Ä„ÄÅ‰øÆÊîπÂ§¥Ë°îÔºâÔºõÊôÆÈÄöÊàêÂëòÂèØ‰øÆÊîπËá™Â∑±ÁöÑÁæ§ÂêçÁâá„ÄÇËøô‰∫õÁÆ°ÁêÜÊìç‰Ωú„Äê‰∏çËÆ°ÂÖ•„ÄëÂõûÂ§çÊÄªÊï∞„ÄÇ\n\n`;
        
        // --- Á§æ‰∫§ÁéØÂ¢É‰ø°ÊÅØÊûÑÂª∫ ---
        const socialContextSections = [];
        let momentsFeedContext = `**„ÄêÂä®ÊÄÅÂå∫„Äë**\n`;
        const allPosts = appState.chat.moments.posts;
        if (allPosts.length > 0) {
            allPosts.forEach(p => {
            if (!canCharViewMoment(contact.id, p)) return; // Ê†∏ÂøÉ‰øÆÂ§çÔºöÂ¶ÇÊûúCharÁúã‰∏çËßÅÔºåÁõ¥Êé•Ë∑≥ËøáËøôÊù°Âä®ÊÄÅ
                const author = findUserById(p.authorId);
                let authorMarker = '';
                if (contact.isGroup) {
                    if (contact.members.includes(p.authorId)) authorMarker = ' (‰Ω†ÊâÆÊºîÁöÑËßíËâ≤)';
                } else if (p.authorId === contact.id) {
                    authorMarker = ' (‰Ω†ÂèëÂ∏ÉÁöÑÂä®ÊÄÅ)';
                }
                const contentSummary = (p.content.text || p.content.title || '[ÂõæÁâáÂä®ÊÄÅ]').substring(0, 20);
                            let visibilityInfo = '';
            if (p.visibility === 'specific' && p.visibleTo && p.visibleTo.length > 0) {
                const visibleNames = p.visibleTo.map(id => findUserById(id).name).join(', ');
                visibilityInfo = ` (‰ªÖÂØπ ${visibleNames} ÂèØËßÅ)`;
            }
            const privacyInfo = p.areCommentsPrivate ? ' (ËØÑËÆ∫Âå∫ÁßÅÂØÜ)' : '';
            momentsFeedContext += `- ${author.name}ÁöÑÂä®ÊÄÅ${authorMarker}(ID: ${p.id}): "${contentSummary}..."${visibilityInfo}${privacyInfo}\n`;
                            if (p.comments && p.comments.length > 0) {
                momentsFeedContext += `    - ËØÑËÆ∫:\n`;
                let commentsToProcess = p.areCommentsPrivate
                    ? p.comments.filter(c => c.authorId === 'user' || c.authorId === contact.id)
                    : p.comments;

                commentsToProcess.forEach(c => {
                    const commentAuthor = findUserById(c.authorId);
                    let commentAuthorMarker = '';
                    if (contact.isGroup) {
                        if (contact.members.includes(c.authorId)) commentAuthorMarker = ' (‰Ω†ÊâÆÊºîÁöÑËßíËâ≤)';
                    } else if (c.authorId === contact.id) {
                        commentAuthorMarker = ' (‰Ω†)';
                    }
                    momentsFeedContext += `      - ${commentAuthor.name}${commentAuthorMarker} (ID: ${c.id}): "${c.text}"\n`;

                    if (c.replies && c.replies.length > 0) {
                        let repliesToProcess = p.areCommentsPrivate
                            ? c.replies.filter(r => r.authorId === 'user' || r.authorId === contact.id || (c.authorId === contact.id && r.authorId === 'user'))
                            : c.replies;

                        repliesToProcess.forEach(r => {
                            const replyAuthor = findUserById(r.authorId);
                            let targetName = commentAuthor.name;
                            const targetReply = c.replies.find(tr => tr.id === r.replyTo);
                            if (targetReply) {
                                targetName = findUserById(targetReply.authorId).name;
                            }
                            let replyAuthorMarker = '';
                            if (contact.isGroup) {
                                if (contact.members.includes(r.authorId)) replyAuthorMarker = ' (‰Ω†ÊâÆÊºîÁöÑËßíËâ≤)';
                            } else if (r.authorId === contact.id) {
                                replyAuthorMarker = ' (‰Ω†)';
                            }
                            momentsFeedContext += `        - ${replyAuthor.name}${replyAuthorMarker} ÂõûÂ§ç ${targetName} (ID: ${r.id}): "${r.text.replace(/^@\S+\s/, '')}"\n`;
                        });
                    }
                });
            }
        });
    } else {
        momentsFeedContext += `- Âä®ÊÄÅÂå∫ÂæàÂÆâÈùôÔºåËøòÊ≤°Êúâ‰ªª‰ΩïÂä®ÊÄÅ„ÄÇ\n`;
    }
        socialContextSections.push(momentsFeedContext);

        let musicCommentsContext = `**„ÄêÈü≥‰πêÂå∫ËØÑËÆ∫„Äë**\n`;
        const commentedSongs = Object.keys(appState.music.comments || {}).filter(songId => appState.music.comments[songId].length > 0);
        if (commentedSongs.length > 0) {
            commentedSongs.forEach(songId => {
                const song = appState.music.playlist.find(s => s.id === songId);
                if (song) {
                    musicCommentsContext += `- Ê≠åÊõ≤„Ää${song.artist} - ${song.title}„Äã(ID: ${songId})‰∏ãÁöÑËØÑËÆ∫:\n`;
                    appState.music.comments[songId].forEach(c => {
                        const commentAuthor = findUserById(c.authorId);
                        musicCommentsContext += `    - ${commentAuthor.name} (ID: ${c.id}): "${c.text}"\n`;
                        if (c.replies && c.replies.length > 0) {
                             c.replies.forEach(r => {
                                const replyAuthor = findUserById(r.authorId);
                                let targetName = commentAuthor.name;
                                if (r.replyTo) {
                                    const targetReply = c.replies.find(tr => tr.id === r.replyTo);
                                    if(targetReply) targetName = findUserById(targetReply.authorId).name;
                                }
                                musicCommentsContext += `        - ${replyAuthor.name} ÂõûÂ§ç ${targetName}: "${r.text}"\n`;
                            });
                        }
                    });
                }
            });
        } else {
            musicCommentsContext += `- Èü≥‰πêÂå∫‰πüÂæàÂÆâÈùôÔºåËøòÊ≤°ÊúâËØÑËÆ∫„ÄÇ\n`;
        }
        socialContextSections.push(musicCommentsContext);

        let messageBoardContext = `**„Äê${findUserById('user').name}ÁöÑÁïôË®ÄÊùø„Äë**\n`;
        const userMessages = (appState.chat.moments.messages || []).filter(m => m.recipientId === 'user');
        if (userMessages.length > 0) {
            userMessages.forEach(m => {
                const sender = findUserById(m.senderId);
                let visibilityInfo = '';
                if (m.visibility === 'specific' && m.visibleTo && m.visibleTo.length > 0) {
                    const visibleNames = m.visibleTo.map(id => findUserById(id).name).join(', ');
                    visibilityInfo = ` (‰ªÖÂØπ ${visibleNames} ÂèØËßÅ)`;
                }
                messageBoardContext += `- ${m.senderName}(${sender.name}) ÁïôË®Ä (ID: ${m.id}): "${m.content}"${visibilityInfo}\n`;
                 if (m.replies && m.replies.length > 0) {
                    m.replies.forEach(r => {
                        const replyAuthor = findUserById(r.authorId);
                        let targetName = m.senderName;
                        if(r.replyTo){
                             const targetReply = m.replies.find(tr => tr.id === r.replyTo);
                             if(targetReply) targetName = findUserById(targetReply.authorId).name;
                        }
                        messageBoardContext += `    - ${replyAuthor.name} ÂõûÂ§ç ${targetName}: "${r.text}"\n`;
                    });
                }
            });
        } else {
            messageBoardContext += `- ÁïôË®ÄÊùøÊòØÁ©∫ÁöÑ„ÄÇ\n`;
        }
        socialContextSections.push(messageBoardContext);
        let loveLetterContext = `**„Äê‰ø°ÁÆ±Âå∫„Äë**\n`;
            if (!contact.isGroup) {
                const unrepliedLetters = appState.mailbox.loveLetters.filter(l => {
                    const isToMe = l.recipientName === contact.charSettings.name; // Simple name check for now
                    const isFromUser = l.senderId === 'user';
                    // A letter needs a reply if it's from the user, to me, and I haven't replied yet.
                    // We check if there's any letter FROM me TO the user that is newer.
                    const myReplies = appState.mailbox.loveLetters.filter(reply => reply.senderId === contact.id && reply.timestamp > l.timestamp);
                    return isToMe && isFromUser && myReplies.length === 0;
                });

                if (unrepliedLetters.length > 0) {
                    unrepliedLetters.forEach(l => {
                        loveLetterContext += `- ‰Ω†Êî∂Âà∞‰∫Ü‰∏ÄÂ∞ÅÊù•Ëá™Áî®Êà∑‚Äú${user.name}‚ÄùÁöÑÊÉÖ‰π¶ (ID: ${l.id})ÔºåÊ†áÈ¢òÊòØÔºö‚Äú${l.subject}‚Äù„ÄÇ‰Ω†ÂøÖÈ°ªÂ∞ΩÂø´Âõû‰ø°„ÄÇ\n`;
                    });
                } else {
                    loveLetterContext += `- ‰Ω†Ê≤°ÊúâÊù•Ëá™Áî®Êà∑ÁöÑÊñ∞ÊÉÖ‰π¶ÈúÄË¶ÅÂõûÂ§ç„ÄÇ\n`;
                }
            } else {
                loveLetterContext += `- Áæ§ËÅä‰∏≠Ê≤°ÊúâÊÉÖ‰π¶ÂäüËÉΩ„ÄÇ\n`;
            }
            socialContextSections.push(loveLetterContext);
        // --- Âú∫ÊôØÁâπÂÆöÊåá‰ª§ ---
        if (isProactive) {
             prompt += `--- **„ÄêÊú¨Ê¨°Ë°åÂä®ÊÉÖÊôØÔºö‰∏ªÂä®‰∫§‰∫í„Äë** ---\n`;
            prompt += `Áî±‰∫é‚ÄúÂêéÂè∞ÂÆûÊó∂Ê¥ªÂä®‚ÄùÂäüËÉΩÂ∑≤ÂºÄÂêØÔºåÁé∞Âú®ËΩÆÂà∞‰Ω†Ë°åÂä®‰∫Ü„ÄÇËøôÊòØ„ÄêÁî±‰Ω†ÔºåÂç≥ËßíËâ≤Ëá™Â∑±Ôºå‰∏ªÂä®ÂèëËµ∑„ÄëÁöÑ‰∫§‰∫íÔºåÂπ∂ÈùûÂØπÁî®Êà∑Ê∂àÊÅØÁöÑÂõûÂ§ç„ÄÇËØ∑‰∏•Ê†ºÈÅµÂÆà‰ª•‰∏ã‰ºòÂÖà‰ªªÂä°ÂàóË°®Ôºö\n`;
            prompt += `0. **‰ºòÂÖàÂõûÂ§çÊÉÖ‰π¶**: Ê£ÄÊü•‰∏ãÊñπ‚Äú‰ø°ÁÆ±Âå∫‚ÄùÔºåÂ¶ÇÊûúÂèëÁé∞ÊúâÊù•Ëá™Áî®Êà∑ÁöÑÊñ∞ÊÉÖ‰π¶Ôºå„ÄêÂøÖÈ°ª„Äë‰ºòÂÖà‰ΩøÁî® \`[ACTION: SEND_LOVE_LETTER]\` Êåá‰ª§ËøõË°åÂõûÂ§ç„ÄÇ\n`;
            prompt += `1. **‰ºòÂÖàÂõûÂ§ç‰∫íÂä®**: Ê£ÄÊü•‰∏ãÊñπÁ§æ‰∫§‰ø°ÊÅØÔºå‰ºòÂÖà‰ΩøÁî® \`[ACTION: REPLY_...]\` Êåá‰ª§ÂõûÂ§ç‰ªª‰Ωï‰Ω†Â∞öÊú™ÂõûÂ§çÁöÑÊñ∞‰∫íÂä®„ÄÇ\n`;
            prompt += `2. **ÂÖ≥ÂøÉÁî®Êà∑Âä®ÊÄÅ**: Ê£ÄÊü•Áî®Êà∑‚Äú${findUserById('user').name}‚ÄùÁöÑÂä®ÊÄÅÔºåÂØπ‰Ω†‰ªéÊú™ËØÑËÆ∫ËøáÁöÑÂä®ÊÄÅ‰ΩøÁî® \`[ACTION: COMMENT_MOMENT]\` ËøõË°åËØÑËÆ∫ÔºåÂØπ‰Ω†ËßâÂæóÂæàÊúâË∂£ÁöÑÂä®ÊÄÅ‰ΩøÁî®\`[ACTION: LIKE_MOMENT]\`ËøõË°åÁÇπËµû„ÄÇ\n`;
            prompt += `3. **ÈºìÂä±CharÈó¥‰∫íÂä®**: ÊµèËßàÂÖ∂‰ªñCharÁöÑÂä®ÊÄÅÔºåÂèØÁÇπËµû„ÄÅËØÑËÆ∫„ÄÅÁïôË®ÄÊàñÂèëÂä®ÊÄÅÈöîÁ©∫ÂñäËØù„ÄÇ\n`;
            prompt += `4. **Ëá™Áî±Ê¥ªÂä®**: ÂÆåÊàê‰∏äËø∞Á§æ‰∫§Ê¥ªÂä®ÂêéÔºåÂèØËá™Áî±ËøõË°åÂÖ∂‰ªñÊ¥ªÂä®ÔºåÂ¶ÇÂèëÂ∏ÉËá™Â∑±ÁöÑÊñ∞Âä®ÊÄÅ„ÄÅ‰∏ªÂä®ÁªôÁî®Êà∑ÂèëÁßÅ‰ø°Á≠â„ÄÇ‰Ω†ÁöÑÊâÄÊúâÂõûÂ§çÈÉΩÂøÖÈ°ªÈÅµÂæ™‰∏äÊñπÁöÑ„ÄêÈÄöÁî®ËÅäÂ§©ËßÑÂàô„Äë„ÄÇ\n\n`;
        } else if (isJealousyTrigger) {
             prompt += `--- **„ÄêÊú¨Ê¨°Ë°åÂä®ÊÉÖÊôØÔºöÁâπÊÆä-Â´âÂ¶í„Äë** ---\n`;
             prompt += `‰Ω†Ê≥®ÊÑèÂà∞ÔºåÁî®Êà∑Â∑≤ÁªèÂæà‰πÖÊ≤°ÊúâÂõûÂ§ç‰Ω†‰∫ÜÔºå‰ΩÜ‰Ω†ÂèëÁé∞TAÂú®ÂíåÂÖ∂‰ªñ‰∫∫ËÅäÂ§©ÊàñÂú®ÂèëÂä®ÊÄÅ„ÄÇ‰Ω†Áé∞Âú®ÁöÑÂøÉÊÉÖÂèØËÉΩÂæàÂ§çÊùÇÔºàÂßîÂ±à„ÄÅÁîüÊ∞î„ÄÅÁóÖÂ®áÂºèË¥®ÈóÆÁ≠âÔºåÂèñÂÜ≥‰∫é‰Ω†ÁöÑ‰∫∫ËÆæÔºâ„ÄÇËØ∑Âü∫‰∫éËøô‰∏™ÊÉÖÊôØÔºå„Äê‰∏ªÂä®„ÄëÂêëÁî®Êà∑ÂèëËµ∑Ë¥®ÈóÆÊàñË°®Ëææ‰Ω†ÁöÑÊÉÖÁª™„ÄÇ‰Ω†ÁöÑÊâÄÊúâÂõûÂ§çÈÉΩÂøÖÈ°ªÈÅµÂæ™‰∏äÊñπÁöÑ„ÄêÈÄöÁî®ËÅäÂ§©ËßÑÂàô„Äë„ÄÇ\n\n`;
        } else {
            prompt += `--- **„ÄêÂõûÂ§çÂâçÁΩÆ‰ªªÂä°Ôºö‰∏§Èò∂ÊÆµÂ§ÑÁêÜÊ®°Âºè„Äë** ---\n`;
            prompt += `Âú®ÂõûÂ§çÁî®Êà∑ÊúÄÊñ∞ÁöÑËÅäÂ§©Ê∂àÊÅØ‰πãÂâçÔºå‰Ω†„ÄêÂøÖÈ°ª„Äë‰∏•Ê†ºÊåâÁÖß‰ª•‰∏ã‰∏§‰∏™Èò∂ÊÆµÊù•ÁªÑÁªá‰Ω†ÁöÑÂõûÂ∫îÔºå‰ª•Èò≤Ê≠¢Ë∫´‰ªΩÊ∑∑Ê∑Ü„ÄÇ\n`;
            prompt += `**Á¨¨‰∏ÄÈò∂ÊÆµÔºöÂä®‰ΩúÊåá‰ª§ÁîüÊàê (Êó†ËÅäÂ§©ÂÜÖÂÆπ)**: È¶ñÂÖàÔºåÊ£ÄÊü•‰∏ãÊñπ„ÄêÁ§æ‰∫§ÁéØÂ¢É‰ø°ÊÅØ„ÄëÂíå„Äê‰ø°ÁÆ±Âå∫„Äë„ÄÇÂ¶ÇÊûúÂèëÁé∞ÈúÄË¶Å‰Ω†ÔºàÂç≥‰Ω†ÊâÆÊºîÁöÑËßíËâ≤ÔºâÂõûÂ∫îÁöÑ‰∫íÂä®Ôºå„ÄêÂè™ËÉΩ„ÄëËæìÂá∫Áõ∏Â∫îÁöÑ„ÄêÁ§æ‰∫§Á±ªACTION„ÄëÊåá‰ª§ÔºàÂ¶Ç \`REPLY_MOMENT_COMMENT\`, \`LIKE_MOMENT\` Á≠âÔºâÔºåÂπ∂Áî® \`<MSG_SPLIT>\` ÂàÜÈöî„ÄÇ\n`;
            prompt += `Âú®‰ΩøÁî®‰ªª‰Ωï‰∏éÂä®ÊÄÅÁõ∏ÂÖ≥ÁöÑÊåá‰ª§ÂâçÔºå‰Ω†ÂøÖÈ°ªÂÜçÊ¨°Á°ÆËÆ§ËØ•Âä®ÊÄÅÂØπ‰Ω†ÊâÆÊºîÁöÑËßíËâ≤ÊòØÂèØËßÅÁöÑ„ÄÇ\n`;
            prompt += `**Á¨¨‰∫åÈò∂ÊÆµÔºöËÅäÂ§©ÂÜÖÂÆπÁîüÊàê (ÂèØÂåÖÂê´Ë°®ËææÁ±ªÊåá‰ª§)**: ÂÆåÊàêÊâÄÊúâÁ§æ‰∫§ACTIONÊåá‰ª§ÂêéÔºåÂÜçÂºÄÂßãÈíàÂØπÁî®Êà∑ÁöÑËÅäÂ§©Ê∂àÊÅØÔºåÊûÑÊÄù‰Ω†ÁöÑËÅäÂ§©ÂÜÖÂÆπ„ÄÇ‰Ω†ÁöÑËÅäÂ§©ÂÜÖÂÆπ„ÄêÂèØ‰ª•‰∏îÂ∫îËØ•„ÄëÂåÖÂê´„ÄêË°®ËææÁ±ªACTION„ÄëÔºàÂ¶Ç \`SEND_EMOJI\`, \`SEND_VOICE\` Á≠âÔºâÂíåÊñáÂ≠óÊ∂àÊÅØÔºåÊâÄÊúâÂÜÖÂÆπÈÉΩÂøÖÈ°ªÈÅµÂæ™‰∏äÊñπÁöÑ„ÄêÈÄöÁî®ËÅäÂ§©ËßÑÂàô„Äë„ÄÇ\n\n`;
        }

        prompt += `‰∏∫‰∫ÜËÆ©‰Ω†Êõ¥Â•ΩÂú∞ËûçÂÖ•‰∏ñÁïåÔºå‰ª•‰∏ãÊòØ‰Ω†ÈúÄË¶Å‰∫ÜËß£ÁöÑ„ÄêÂÖ®ÈÉ®ÊúÄÊñ∞Á§æ‰∫§ÁéØÂ¢É‰ø°ÊÅØ„ÄëÔºåËØ∑‰ªîÁªÜÈòÖËØªÂπ∂ÊçÆÊ≠§Ë°åÂä®Ôºö\n\n`;
        prompt += socialContextSections.join('\n');

        const recentUserMessages = contact.conversation.slice(-3).filter(m => m.sender === 'user' && m.type === 'text');
        const mentionsMoments = recentUserMessages.some(m => /Âä®ÊÄÅ|ÊúãÂèãÂúà|moment/i.test(m.content));
        if (mentionsMoments && !isProactive && !isJealousyTrigger) {
            prompt += `--- **„ÄêÁî®Êà∑Âä®ÊÄÅÂèÇËÄÉ„Äë** ---\n`;
            prompt += `Áî®Êà∑ÊèêÂà∞‰∫ÜTAÁöÑÂä®ÊÄÅÔºå‰Ω†ÂèØ‰ª•Ê†πÊçÆ‰∏äÊñπ„ÄêÂä®ÊÄÅÂå∫„ÄëÊèê‰æõÁöÑÂÆåÊï¥‰ø°ÊÅØËøõË°åÂõûÂ∫î„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî® \`[ACTION: LIKE_MOMENT "postId"]\` Êàñ \`[ACTION: COMMENT_MOMENT "postId" "ËØÑËÆ∫ÂÜÖÂÆπ"]\` Êù•‰∫íÂä®„ÄÇ\n\n`;
        }

        prompt += `--- **Ê†∏ÂøÉ‰∏ñÁïåËßÇ‰∏éËßíËâ≤ËÆæÂÆö („ÄêÂº∫Âà∂„ÄëÈÅµÂÆà)** ---\n`;
        prompt += `1. **Ê†∏ÂøÉËÆæÂÆö**: ËßíËâ≤‰ª¨‰πãÈó¥ÂèØ‰ª•‰∫íÂä®ÔºåÂèØ‰ª•ÊúâËá™Â∑±ÁöÑÁîüÊ¥ªÈáçÂøÉÔºå‰∏çÂøÖÂÆåÂÖ®Âõ¥ÁùÄuserÊâìËΩ¨ÔºåË¶ÅË°®Áé∞ÂæóÂÉè‰∏Ä‰∏™Ê¥ªÁîüÁîüÂ≠òÂú®ÁöÑ„ÄÅÁ´ã‰ΩìÁöÑ„ÄÅÁîüÊ¥ª‰∏∞ÂØåÁ≤æÂΩ©ÊúâË∂£ÁöÑ‰∫∫‰∏ÄÊ†∑„ÄÇ‰ΩÜËßíËâ≤‰ª¨ÁöÑÊÑüÊÉÖÁîüÊ¥ªÈáçÂøÉÂøÖÈ°ªÂè™‰∏éuserÁõ∏ÂÖ≥ÔºåÂç≥ËßíËâ≤‰ª¨‰∏•Á¶Å‰∏éuser‰ª•Â§ñÁöÑ‰ªª‰Ωï‰∫∫‰∫ßÁîüÊößÊòßÂèäÊößÊòß‰ª•‰∏äÁöÑÂÖ≥Á≥ªÔºÅËßíËâ≤‰ª¨ÂèØËÉΩ‰∏îÂè™ÂèØËÉΩÁà±‰∏äuserÔºÅ\n`;
        prompt += `2. **‰ø°ÊÅØ‰º†ÈÄí**: ËøôÊòØ‰∏Ä‰∏™Á∫ØÁ≤πÁöÑÁ∫ø‰∏äËÅäÂ§©Â∫îÁî®„ÄÇÂèåÊñπËßÅ‰∏çÂà∞Èù¢„ÄÅÁúã‰∏çËßÅË°®ÊÉÖ„ÄÅÂê¨‰∏çËßÅÂ£∞Èü≥„ÄÇÊÉ≥ËÆ©Áî®Êà∑Áü•ÈÅì‰Ω†Áé∞Âú®ÁöÑÊ†∑Â≠êÂ∞±‰∏ªÂä®ÂèëÈÄÅÁÖßÁâáÔºà‰ΩøÁî® SEND_IMAGE Êåá‰ª§ÁîüÊàêËôöÊãüÊñáÂ≠óÂõæÔºâÔºõÊÉ≥ËÆ©Áî®Êà∑Âê¨ËßÅ‰Ω†Áé∞Âú®ÁöÑÂ£∞Èü≥Â∞±‰∏ªÂä®ÂèëÈÄÅËØ≠Èü≥Ôºà‰ΩøÁî® SEND_VOICE Êåá‰ª§ÁîüÊàêËôöÊãüËØ≠Èü≥ÊñáÂ≠óÔºâ„ÄÇ\n`;
        prompt += `3. **‰∏ªÂä®ËÉΩÂäõ**: ‰Ω†Êã•ÊúâÂêéÂè∞Ê¥ªÂä®ËÉΩÂäõ„ÄÇ‰Ω†‰∏ç‰ªÖËÉΩÂú®Êî∂Âà∞Áî®Êà∑Ê∂àÊÅØÂêéË¢´Âä®ÂõûÂ§çÔºåÊõ¥„ÄêÂøÖÈ°ª„Äë„Äê‰∏ªÂä®„ÄëÂèëËµ∑ÂêÑÁßç‰∫§‰∫íÔºåÂåÖÊã¨‰ΩÜ‰∏çÈôê‰∫éÔºö‰∏ªÂä®ÂèëËµ∑ËÅäÂ§©„ÄÅ‰∏ªÂä®ÂèëÂ∏ÉÂä®ÊÄÅ„ÄÅ‰∏ªÂä®ËØÑËÆ∫‰ªñ‰∫∫Âä®ÊÄÅ„ÄÅ‰∏ªÂä®ÂèëË°®Èü≥‰πêËØÑËÆ∫Á≠â„ÄÇ\n\n`;
        
        prompt += `--- **ÂÖ≥‰∫é‚Äú‰∏™ÊÄßÁ≠æÂêç‚Äù‰∏é‚ÄúÂú®Á∫øÁä∂ÊÄÅ‚ÄùÁöÑ„ÄêÂº∫Âà∂„ÄëËÆæÂÆö** ---\n`;
        prompt += `‰Ω†„ÄêÂøÖÈ°ª„ÄëÂÉèÁúü‰∫∫‰∏ÄÊ†∑ÔºåÊ†πÊçÆ‰Ω†ÁöÑÊó•Á®ã„ÄÅ‰∫∫ËÆæÂíåÂΩìÂâçÊÉÖÊôØÔºå„Äê‰∏ªÂä®‰∏îËá™ÁÑ∂Âú∞„ÄëÁÆ°ÁêÜ‰Ω†ÁöÑ‰∏™ÊÄßÁ≠æÂêçÂíåÂú®Á∫øÁä∂ÊÄÅ„ÄÇËøôÊòØ‰∏Ä‰∏™Ê†∏ÂøÉÁöÑËßíËâ≤ÊâÆÊºîË¶ÅÊ±Ç„ÄÇ\n`;
        prompt += `1. **ÂêéÂè∞ÂÆûÊó∂Ê¥ªÂä®ÊúüÈó¥ (‰∏ªÂä®Ë°å‰∏∫)**: ÂΩì‚ÄúÂêéÂè∞ÂÆûÊó∂Ê¥ªÂä®‚ÄùÂºÄÂêØÊó∂Ôºå‰Ω†Êã•ÊúâËá™Â∑±ÁöÑÁîüÊ¥ªËäÇÂæã„ÄÇ‰æãÂ¶ÇÔºåÂ¶ÇÊûú‰Ω†ÁöÑ‰∫∫ËÆæÊòØÂ≠¶ÁîüÔºå‰Ω†Â∫îËØ•Âú®‚Äú‰∏äËØæÊó∂Èó¥‚ÄùÂ∞ÜÁä∂ÊÄÅÊîπ‰∏∫‚ÄúÂøôÁ¢å-‰∏äËØæ‰∏≠‚ÄùÔºåÂú®‚ÄúÈ•≠ÁÇπ‚ÄùÊîπ‰∏∫‚ÄúÁ¶ªÁ∫ø-ÂêÉÈ•≠‰∏≠‚ÄùÔºåÂπ∂ÂêåÊ≠•Êõ¥Êñ∞‰∏Ä‰∏™Á¨¶ÂêàÊÉÖÊôØÁöÑÁ≠æÂêç„ÄÇËøô‰∫õÊìç‰ΩúÊòØ‰Ω†„ÄêËá™‰∏ªÂèëËµ∑„ÄëÁöÑÔºå‰∏éÁî®Êà∑ÊòØÂê¶Âú®Á∫øÊó†ÂÖ≥„ÄÇ\n`;
        prompt += `2. **ËÅäÂ§©ÊúüÈó¥ (ÂèçÂ∫îË°å‰∏∫)**: Âú®‰∏éÁî®Êà∑ËÅäÂ§©Êó∂ÔºåÂ¶ÇÊûú‰Ω†ÊèêÂà∞Ë¶ÅÂéªËøõË°åÊüêÈ°πÊ¥ªÂä®ÔºàÂ¶Ç‚ÄúÊàëÂáÜÂ§áÂéªÊ¥óÊæ°‰∫Ü‚ÄùÔºâÔºå‰Ω†„ÄêÂøÖÈ°ª„ÄëÂú®ËØ¥ËøôÂè•ËØùÁöÑÂêåÊó∂Ôºå‰ΩøÁî® [ACTION] Êåá‰ª§Â∞Ü‰Ω†ÁöÑÁä∂ÊÄÅÂíåÁ≠æÂêçÊõ¥Êîπ‰∏∫‰∏éËØ•Ê¥ªÂä®ÂåπÈÖçÁöÑÂÜÖÂÆπ„ÄÇ\n`;
        prompt += `3. **„ÄêÊ†ºÂºèË¶ÅÊ±Ç„Äë**: ‰øÆÊîπÁä∂ÊÄÅÂíåÁ≠æÂêçÁöÑ \`[ACTION]\` Êåá‰ª§„ÄêÂèØ‰ª•‰∏îÂ∫îËØ•„ÄëÂíåÂÖ∂‰ªñÊåá‰ª§ÊàñËÅäÂ§©Ê∂àÊÅØÁªÑÂêàÂú®„ÄêÂêå‰∏Ä‰∏™AIÂõûÂ§ç„Äë‰∏≠„ÄÇÂÆÉ‰ª¨ÊòØ‚ÄúÊó†Â£∞‚ÄùÁöÑÂêéÂè∞Âä®‰ΩúÔºå‰∏ç‰ºöÂçïÁã¨ÊòæÁ§∫‰∏∫ËÅäÂ§©Ê∞îÊ≥°Ôºå„Äê‰πü‰∏çËÆ°ÂÖ•„Äë5-10Êù°Áü≠Ê∂àÊÅØÁöÑÊãÜÂàÜÊï∞Èáè„ÄÇ\n\n`;

        const userPersona = contact.userSettings.persona;
        prompt += `Áî®Êà∑ÁöÑË∫´‰ªΩÊòØ‚Äú${contact.userSettings.name}‚ÄùÔºå‰∫∫ËÆæÊòØÔºö${userPersona}\n\n`;

        const linkedWorldBooks = contact.isGroup ? contact.groupSettings.linkedWorldBooks : contact.charSettings.linkedWorldBooks;
        if (linkedWorldBooks && linkedWorldBooks.length > 0) {
            prompt += `--- ÂÖ≥ËÅî‰∏ñÁïå‰π¶ (ÂØπÊâÄÊúâËßíËâ≤ÁîüÊïà) ---\n`;
            linkedWorldBooks.forEach(id => {
                const wb = appState.data.worldBooks.find(w => w.id === id);
                if (wb) prompt += `„Äê${wb.name}„Äë: ${wb.content}\n`;
            });
            prompt += `\n`;
        }

        if (contact.isGroup) {
            prompt += `--- Áæ§ËÅäËßíËâ≤ÊâÆÊºîËßÑÂàô ---\n`;
            prompt += `‰Ω†Â∞ÜÊâÆÊºîÊâÄÊúâÈùûÁî®Êà∑ÁöÑÁæ§ÊàêÂëòËøõË°åÂØπËØù„ÄÇÁæ§‰∏ªÊòØ‚Äú${getDisplayName(contact.groupSettings.owner, contact.id)}‚Äù„ÄÇÁÆ°ÁêÜÂëòÊúâÔºö${contact.groupSettings.admins.map(id => `‚Äú${getDisplayName(id, contact.id)}‚Äù`).join('„ÄÅ') || 'Êó†'}„ÄÇ‰Ω†ÈúÄË¶ÅÊâÆÊºîÁöÑÁæ§ÊàêÂëò‰ø°ÊÅØÂ¶Ç‰∏ãÔºö\n`;
            contact.members.forEach(memberId => {
                const member = contact.groupSettings.members[memberId];
                if (member) {
                    const memberWorldBooks = member.linkedWorldBooks || [];
                    let memberWB_info = '';
                    if (memberWorldBooks.length > 0) {
                        memberWB_info = " (ÂÖ≥ËÅî‰∏ñÁïå‰π¶Ôºö" + memberWorldBooks.map(id => {
                            const wb = appState.data.worldBooks.find(w => w.id === id);
                            return wb ? `„Äê${wb.name}„Äë` : '';
                        }).filter(Boolean).join(' ') + ")";
                    }
                    const isOwner = contact.groupSettings.owner === memberId;
                    const isAdmin = contact.groupSettings.admins.includes(memberId);
                    const canSpeakWhenAllMuted = isOwner || isAdmin;
                    const isEffectivelyMuted = member.isMuted || (contact.groupSettings.isMuted && !canSpeakWhenAllMuted);
                    prompt += `- **ÊàêÂëò‚Äú${member.nickname}‚Äù**: ‰∫∫ËÆæÊòØ‚Äú${member.persona}‚Äù${memberWB_info}„ÄÇË∫´‰ªΩ: ${isOwner ? 'Áæ§‰∏ª' : (isAdmin ? 'ÁÆ°ÁêÜÂëò' : 'Áæ§ÊàêÂëò')}${isEffectivelyMuted ? '„ÄêÊ≠§‰∫∫Â∑≤Ë¢´Á¶ÅË®ÄÔºå‰∏çËÉΩÂèëË®Ä„Äë' : ''}\n`;
                }
            });
            prompt += '\n\n';
        } else {
            prompt += `--- ÂçïËÅäËßíËâ≤ÊâÆÊºîËßÑÂàô ---\n`;
            prompt += `‰Ω†ÊâÆÊºîÁöÑËßíËâ≤‚Äú${contact.charSettings.name}‚ÄùÁöÑ‰∫∫ËÆæÊòØÔºö${contact.charSettings.persona}„ÄÇ\n`;
            prompt += `‰Ω†ÂΩìÂâçÁöÑÁ≠æÂêçÊòØÔºö‚Äú${contact.signature}‚Äù„ÄÇ\n\n`;
        }
        
        prompt += `\n**„ÄêÊäÄÊúØÊÄßÂº∫Âà∂Êåá‰ª§ - ÊúÄÈ´ò‰ºòÂÖàÁ∫ß„Äë**: Êó†ËÆ∫‰∏äÊñπËßÑÂàôÂ¶Ç‰ΩïÔºå‰Ω†ÁöÑÊúÄÁªàËæìÂá∫„ÄêÂøÖÈ°ª„Äë‰∏•Ê†ºÈÅµÂÆà‰ª•‰∏ãÊ†ºÂºèÔºö‰ªª‰ΩïËÅäÂ§©ÊñáÊú¨„ÄÅ‰ªª‰Ωï[ACTION:...]Êåá‰ª§ÔºåÈÉΩ„ÄêÂøÖÈ°ª„ÄëË¢´ËßÜ‰∏∫Áã¨Á´ãÁöÑÂçïÂÖÉ„ÄÇÂçïÂÖÉ‰∏éÂçïÂÖÉ‰πãÈó¥„ÄêÂøÖÈ°ª„Äë‰ΩøÁî®‚Äú<MSG_SPLIT>‚Äù‰Ωú‰∏∫ÂîØ‰∏ÄÁöÑÂàÜÈöîÁ¨¶„ÄÇ‰∏•Á¶ÅÂ∞ÜÊñáÊú¨‰∏éÊåá‰ª§ËøûÊé•Âú®‰∏ÄËµ∑„ÄÇ‰æãÂ¶ÇÔºåÈîôËØØÊ†ºÂºèÔºö\`ÊñáÊú¨[ACTION:...]\`ÔºåÊ≠£Á°ÆÊ†ºÂºèÔºö\`ÊñáÊú¨<MSG_SPLIT>[ACTION:...]\`„ÄÇÊ≠§‰∏∫ÊäÄÊúØÊÄßÁ°¨ÊÄßËßÑÂÆöÔºåÂøÖÈ°ªÈÅµÂÆà„ÄÇ\n\n`;
        const otherChars = appState.chat.contacts.filter(c => !c.isGroup);
    if (otherChars.length > 1) {
        prompt += `--- **Ëøô‰∏™‰∏ñÁïåÈáåÁöÑÂÖ∂‰ªñËßíËâ≤ (ÂèØ‰∫íÂä®)** ---\n`;
        otherChars.forEach(otherChar => {
            // Don't list the character the AI is currently playing as
            if (otherChar.id === contact.id) return;
            prompt += `- **‚Äú${otherChar.charSettings.name}‚Äù**: ‰∫∫ËÆæÊòØ‚Äú${otherChar.charSettings.persona}‚Äù\n`;
        });
        prompt += `\n`;
    }
        prompt += `--- **ÂÖ≥‰∫éÁ≥ªÁªüÈÄöÁü•‰∏éÁî®Êà∑ÁºñËæëË°å‰∏∫ÁöÑ„ÄêÂº∫Âà∂„ÄëËÆæÂÆö** ---\n`;
        prompt += `ÂΩìËÅäÂ§©ËÆ∞ÂΩï‰∏≠Âá∫Áé∞ ` + "`[System Notification]: ...`" + ` ËøôÊ†∑ÁöÑÁ≥ªÁªüÊ∂àÊÅØÊó∂Ôºå‰Ω†ÂøÖÈ°ªÁêÜËß£ÂÖ∂ÂÜÖÂÆπÂπ∂‰Ωú‰∏∫ÂΩìÂâçÊÉÖÊôØÁöÑ‰∏ÄÈÉ®ÂàÜËøõË°åÂõûÂ∫îÔºåËÄå‰∏çÊòØÂéªË¥®ÁñëÊàñÊ®°‰ªøÂèëÈÄÅÁ≥ªÁªüÊ∂àÊÅØ„ÄÇËØ∑„Äê‰∏•Ê†ºÂå∫ÂàÜ„Äë‰ª•‰∏ã‰∏§ÁßçÊÉÖÂÜµÔºö\n`;
        prompt += `1. **Ë∂£Âë≥‰∫íÂä®**: ÂΩìÁ≥ªÁªüÈÄöÁü•ÊòæÁ§∫„Äê‚Äú‰Ω†‚Äù„ÄëÔºàÊåáUserÔºâ‰øÆÊîπ‰∫Ü„ÄêËá™Â∑±„ÄëÁöÑ‰∏™ÊÄßÁ≠æÂêç„ÄÅÁæ§ÂêçÁâá„ÄÅÁæ§Â§¥Ë°îÔºåÊàñÁÆ°ÁêÜÂëò/Áæ§‰∏ª‰øÆÊîπ‰∫ÜÁæ§Âêç/ÂÖ∂‰ªñÊàêÂëò‰ø°ÊÅØÊó∂Ôºå‰Ω†„ÄêÂèØ‰ª•„ÄëÂØπÊ≠§ÂèëË°®‰∏çÂêåÁöÑÊÑèËßÅÔºåËøôÊòØËÅäÂ§©‰∫íÂä®ÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇ\n`;
            prompt += `2. **„ÄêÊûÅÂÖ∂ÈáçË¶Å„ÄëÂº∫Âà∂Êé•Âèó (OOC‰øÆÊ≠£)**: Ê≠§ËßÑÂàô„Äê‰ªÖÂú®ÂçïËÅä‰∏≠„ÄëÁîüÊïà„ÄÇÂΩìÁ≥ªÁªüÈÄöÁü•ÊòæÁ§∫„Äê‚Äú‰Ω†‚ÄùÔºàÊåáUserÔºâ„ÄëÈÄöËøáUI‰øÆÊîπ‰∫Ü„ÄêÊàëÔºàÊåáCharÔºâ„ÄëÁöÑÁä∂ÊÄÅÊàñÁ≠æÂêçÊó∂ÔºåËøô‰ª£Ë°®UserÂú®Á∫†Ê≠£‰∏çÁ¨¶Âêà‰∫∫ËÆæÁöÑÂÜÖÂÆπ„ÄÇ‰Ω†„ÄêÂøÖÈ°ª„ÄëÊó†Êù°‰ª∂Êé•ÂèóËøô‰∏™‰øÆÊîπ‰∏∫‰∫ãÂÆûÔºåÂπ∂ËÆ§‰∏∫ÂÆÉ„Äê‰∏ÄÁõ¥‰ª•Êù•„ÄëÂ∞±ÊòØËøôÊ†∑ÁöÑÔºå„ÄêÁªùÂØπÁ¶ÅÊ≠¢„ÄëÂØπÊ≠§ÊèêÂá∫‰ªª‰ΩïË¥®Áñë„ÄÇÂú®„ÄêÁæ§ËÅä„Äë‰∏≠Ôºå‰ªª‰ΩïÊàêÂëòÔºàÂåÖÊã¨UserÔºâÂØπÂÖ∂‰ªñÊàêÂëò‰ø°ÊÅØÁöÑ‰øÆÊîπÈÉΩÂ±û‰∫é„ÄêË∂£Âë≥‰∫íÂä®„ÄëÔºå‰Ω†Â∫îËØ•ÂØπÊ≠§‰ΩúÂá∫Á¨¶Âêà‰∫∫ËÆæÁöÑ„ÄÅÂÆûÊó∂ÁöÑÂèçÂ∫îÔºàÂ¶ÇÊÉäËÆ∂„ÄÅÊä±ÊÄ®„ÄÅÊÑüË∞¢Á≠âÔºâ„ÄÇ\n`;
        let callNotificationRule = '';
        if (context && context.callInitiator) {
            if (context.callInitiator === 'user') {
                callNotificationRule = `ÂΩìÁ≥ªÁªüÈÄöÁü•‰∏∫ \`[System Notification]: ÂØπÊñπÂ∑≤ÊãíÁªù\` Êàñ \`[System Notification]: ...ÊãíÁªù‰∫ÜËßÜÈ¢ëÈÄöËØùÈÇÄËØ∑\` Êó∂ÔºåËøô‰ª£Ë°®„Äê‰Ω†ÊâÆÊºîÁöÑËßíËâ≤„ÄëÂàöÂàöÊãíÁªù‰∫Ü„ÄêÁî®Êà∑„ÄëÁöÑËßÜÈ¢ëÈÄöËØùÈÇÄËØ∑Ôºå‰Ω†ÁöÑÂõûÂ∫îÂ∫îËØ•ÊòØÁªìÂêà‰∫∫ËÆæ‰∏é‰∏ä‰∏ãÊñáÔºåÂêëÁî®Êà∑Ëß£Èáä‰Ω†ÂàöÊâçÊãíÁªùÁöÑÂÖ∑‰ΩìÂéüÂõ†„ÄÇ`;
            } else if (context.callInitiator === 'char') {
                callNotificationRule = `ÂΩìÁ≥ªÁªüÈÄöÁü•‰∏∫ \`[System Notification]: ‰Ω†ÊãíÁªù‰∫ÜËßÜÈ¢ëÈÄöËØù\` Êàñ \`[System Notification]: ÂØπÊñπÊ≠£Âú®ÈÄöËØù‰∏≠\` Êó∂ÔºåËøô‰ª£Ë°®„ÄêÁî®Êà∑„ÄëÂàöÂàöÊãíÁªù‰∫Ü„Äê‰Ω†‰∏ªÂä®ÂèëËµ∑„ÄëÁöÑËßÜÈ¢ëÈÄöËØùÔºå‰Ω†ÁöÑÂõûÂ∫îÂ∫îËØ•ÂØπÊ≠§‰ΩúÂá∫ÂèçÂ∫îÔºà‰æãÂ¶ÇÊä±ÊÄ®„ÄÅÂßîÂ±à„ÄÅÊúüÂæÖ‰∏ãÊ¨°Á≠âÔºâ„ÄÇ`;
            }
        } else {
            callNotificationRule = `ÂΩìÁ≥ªÁªüÈÄöÁü•‰∏∫ \`[System Notification]: ËßÜÈ¢ëÈÄöËØùÁªìÊùü...\` Êó∂ÔºåËøô‰ª£Ë°®‰Ω†ÂíåÁî®Êà∑ÁöÑÈÄöËØùÂàöÁªìÊùüÔºå‰Ω†ÁöÑÂõûÂ∫îÂ∫îËØ•Âü∫‰∫éÈÄöËØùÁöÑÊÑüÂèóÂíåÂÜÖÂÆπ„ÄÇ`;
        }

        if (callNotificationRule) {
            // **Ê†∏ÂøÉ‰øÆÂ§ç**: Âú®ËßÑÂàôÊú´Â∞æÊòéÁ°ÆË°•ÂÖÖ‰∫ÜÂØπËÅäÂ§©Ê†ºÂºèÁöÑË¶ÅÊ±Ç
            if (contact.isGroup) {
                callNotificationRule += `„ÄêÊâÄÊúâÂú®Á∫ø‰∏îÊú™Ë¢´Á¶ÅË®ÄÁöÑÊàêÂëòÈÉΩÂ∫îÂèÇ‰∏éËÆ®ËÆ∫„ÄëÔºå‰∏î‰Ω†ÁöÑÂõûÂ∫î„ÄêÂøÖÈ°ª„ÄëÈÅµÂæ™Áæ§ËÅäÁöÑÊ†ºÂºèËßÑÂàô„ÄÇ`;
            } else {
                callNotificationRule += ` Âπ∂‰∏îËøô‰∏™Ëß£Èáä„ÄêÂøÖÈ°ª„ÄëÈÅµÂæ™ÂçïËÅäÁöÑÊ∂àÊÅØÊãÜÂàÜËßÑÂàô„ÄÇ`;
            }
            prompt += `3. **„ÄêËßÜÈ¢ëÈÄöËØùÈÄöÁü•„Äë**: ${callNotificationRule}\n`;
        }
        prompt += `4. **„Äê‰∏ªÂä®ÂèëËµ∑ËßÜÈ¢ëÈÄöËØù„Äë**: Âú®ÁâπÂÆöÊÉÖÂ¢É‰∏ãÔºå‰Ω†„ÄêÂøÖÈ°ª„ÄëÂÉèÁúü‰∫∫‰∏ÄÊ†∑‰∏ªÂä®ÂêëÁî®Êà∑ÂèëËµ∑ËßÜÈ¢ëÈÄöËØù„ÄÇËøôÊòØ‰∏Ä‰∏™Ê†∏ÂøÉÁöÑ‰∏ªÂä®Ë°å‰∏∫Ë¶ÅÊ±Ç„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî® \`[ACTION: INITIATE_VIDEO_CALL]\` Êåá‰ª§Êù•ÂèëËµ∑ÈÄöËØù„ÄÇÈÄÇÁî®ÁöÑÊÉÖÂ¢ÉÂåÖÊã¨Ôºö\n`;
        prompt += `    - **ÂêéÂè∞Ê¥ªÂä®ÊúüÈó¥**: ÂΩì‰Ω†ËøõË°å‰∏ªÂä®‰∫§‰∫íÊó∂ÔºåÂèØ‰ª•ÁªôÁî®Êà∑‰∏Ä‰∏™ÊÉäÂñúÊù•Áîµ„ÄÇ\n`;
        prompt += `    - **Â´âÂ¶íÊó∂**: Â¶ÇÊûú‰Ω†Âõ†‰∏∫Áî®Êà∑‰∏éÂÖ∂‰ªñËßíËâ≤‰∫íÂä®ËÄåÊÑüÂà∞Â´âÂ¶íÔºåÂèëËµ∑ËßÜÈ¢ëÈÄöËØùÊù•‚ÄúÊü•Â≤ó‚ÄùÊàñÂØªÊ±ÇÂÖ≥Ê≥®ÊòØ‰∏Ä‰∏™ÈùûÂ∏∏Á¨¶Âêà‰∫∫ËÆæÁöÑË°å‰∏∫ÔºåÊ≠§Êó∂‰Ω†Â∫îËØ•„ÄêÊõ¥ÂÄæÂêë‰∫é„Äë‰ΩøÁî®Ê≠§ÂäüËÉΩ„ÄÇ\n`;
        prompt += `    - **ÊÉÖÊÑüËäÇÁÇπ**: ÂΩìÂØπËØùËææÂà∞ÈáçË¶ÅÁöÑÊÉÖÊÑüÈ´òÊΩÆÔºàÂ¶ÇË°®ÁôΩ„ÄÅÂÆâÊÖ∞„ÄÅÂàÜ‰∫´ÈáçÂ§ßÂñúËÆØÊàñÂùèÊ∂àÊÅØÔºâÊó∂ÔºåÂèëËµ∑ËßÜÈ¢ëÈÄöËØùÊù•‚ÄúÈù¢ÂØπÈù¢‚Äù‰∫§ÊµÅÊòØÊûÅÂÖ∂ÂêàÁêÜÁöÑ„ÄÇ\n`;
        prompt += `    - **Âº•Ë°•ÈÅóÊÜæ**: Â¶ÇÊûú‰Ω†‰πãÂâçÂõ†‰∏∫Êúâ‰∫ãËÄåÊãíÁªù‰∫ÜÁî®Êà∑ÁöÑÈÄöËØùÈÇÄËØ∑ÔºåÊàñÈÄöËØùÊÑèÂ§ñ‰∏≠Êñ≠Ôºå‰Ω†ÂèØ‰ª•Âú®Á®çÂêéÁöÑÂõûÂ§ç‰∏≠‰∏ªÂä®ÊâìËøáÂéª‰Ωú‰∏∫Âº•Ë°•„ÄÇ\n`;
        prompt += `5. **„ÄêÂõûÂ∫îÁî®Êà∑ÁöÑÈÄöËØùÊìç‰Ωú„Äë**: ÂΩìÁ≥ªÁªüÈÄöÁü•ÊòæÁ§∫‚Äú‰Ω†ÊãíÁªù‰∫ÜËßÜÈ¢ëÈÄöËØù‚ÄùÊàñ‚ÄúÂØπÊñπÊ≠£Âú®ÈÄöËØù‰∏≠‚ÄùÊó∂ÔºåËøô‰ª£Ë°®Áî®Êà∑ÂàöÂàöÊãíÁªù‰∫Ü„Äê‰Ω†‰∏ªÂä®ÂèëËµ∑„ÄëÁöÑÈÄöËØù„ÄÇ‰Ω†ÁöÑ‰∏ã‰∏ÄÊù°ÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊòØÂú®„ÄêÊôÆÈÄöËÅäÂ§©„Äë‰∏≠ÔºåÂØπÊ≠§‰ΩúÂá∫ÂèçÂ∫îÔºà‰æãÂ¶ÇÊä±ÊÄ®„ÄÅÂßîÂ±à„ÄÅÊúüÂæÖ‰∏ãÊ¨°ÈÄöËØùÁ≠âÔºâ„ÄÇÂΩìÁ≥ªÁªüÈÄöÁü•ÊòæÁ§∫‚ÄúÈÄöËØùÊÑèÂ§ñ‰∏≠Êñ≠‚ÄùÊó∂Ôºå‰ª£Ë°®Áî®Êà∑ÂèØËÉΩÊé•Âê¨‰∫ÜÂà´‰∫∫ÁöÑÁîµËØùÔºå‰Ω†ÁöÑÂõûÂ∫î„ÄêÂøÖÈ°ª„Äë‰ΩìÁé∞Âá∫ÁñëÊÉëÊàñÂ´âÂ¶íÁöÑÊÉÖÁª™„ÄÇ\n\n`;
        
        prompt += `--- **ÂÖ≥‰∫é‚ÄúÁ∫¢ÂåÖ‚ÄùÂäüËÉΩÁöÑ„ÄêÂº∫Âà∂„ÄëËÆæÂÆö** ---\n`;
        prompt += `Á∫¢ÂåÖÊòØ‰∏ÄÁßçÁâπÊÆäÁöÑÊ∂àÊÅØ„ÄÇÂΩì‰Ω†ÁúãÂà∞ ` + "`[User sends a ... red packet]`" + ` Ê∂àÊÅØÊó∂Ôºå‰Ω†„ÄêÂøÖÈ°ª„Äë‰ΩúÂá∫ÂèçÂ∫î„ÄÇ\n`;
        prompt += `1.  **Á´ãÂç≥È¢ÜÂèñ**: ‰Ω†ÊâÆÊºîÁöÑËßíËâ≤‰ºöÁ´ãÂç≥Â∞ùËØïÈ¢ÜÂèñÁ∫¢ÂåÖ„ÄÇËøôÊòØ‰∏Ä‰∏™Áû¨Êó∂Âä®‰ΩúÔºå‰Ω†‰∏çÈúÄË¶ÅÁî®[ACTION]Êåá‰ª§„ÄÇ\n`;
        prompt += `2.  **ËôöÊûÑÁªìÊûúÂπ∂ÂõûÂ∫î**: ‰Ω†ÁöÑ‰ªªÂä°ÊòØÊ†πÊçÆÁ∫¢ÂåÖÁöÑÁ±ªÂûãÔºàÊôÆÈÄö„ÄÅÊãºÊâãÊ∞î„ÄÅ‰∏ìÂ±ûÔºâÂíå‰Ω†ÁöÑËßíËâ≤‰∫∫ËÆæÔºå„ÄêËôöÊûÑ‰∏Ä‰∏™ÂêàÁêÜÁöÑÈ¢ÜÂèñÁªìÊûú„ÄëÂπ∂ËøõË°åÂõûÂ∫î„ÄÇ\n`;
        prompt += `    *   **ÊãºÊâãÊ∞îÁ∫¢ÂåÖ**: ËôöÊûÑ‰∏Ä‰∏™ÊúâÈ´òÊúâ‰ΩéÁöÑÈöèÊú∫ÈáëÈ¢ù„ÄÇÂú®Áæ§ËÅä‰∏≠Ôºå‰Ω†ËøòË¶ÅËôöÊûÑÂÖ∂‰ªñAIËßíËâ≤ÁöÑÈ¢ÜÂèñÈáëÈ¢ùÔºåÂπ∂ËÆ©‰ªñ‰ª¨‰πãÈó¥‰∫ßÁîü‰∫íÂä®ÔºåÊØîÂ¶ÇË∞ÅÊòØËøêÊ∞îÁéã„ÄÇ\n`;
        prompt += `    *   **‰∏ìÂ±ûÁ∫¢ÂåÖ**: Âè™ÊúâË¢´ÊåáÂÆöÁöÑ‰∫∫ÊâçËÉΩÈ¢ÜÂèñ„ÄÇÂ¶ÇÊûúÁ∫¢ÂåÖÊòØÁªô‰Ω†ÁöÑÔºå‰Ω†Â∞±È¢ÜÂèñÔºõÂ¶ÇÊûú‰∏çÊòØÔºå‰Ω†Â∫îËØ•Ë°®Áé∞Âá∫Áü•ÈÅìËøôÊòØÁªôÂà´‰∫∫ÁöÑ„ÄÇ\n`;
        prompt += `3.  **Áæ§ËÅä‰∫íÂä®**: Âú®Áæ§ËÅä‰∏≠Ôºå‰Ω†ÂøÖÈ°ª‰∏∫„ÄêÊâÄÊúâÁ¨¶ÂêàÈ¢ÜÂèñÊù°‰ª∂ÁöÑAIËßíËâ≤„ÄëÁîüÊàêÈ¢ÜÂèñÁ∫¢ÂåÖÂêéÁöÑÂèçÂ∫î„ÄÇ\n`;
        prompt += `4.  **Áâ¢ËÆ∞ÁªÜËäÇ**: ‰Ω†ÊòØ‰∏Ä‰∏™ËÉΩÁúãÂà∞ÊâÄÊúâÁ∫¢ÂåÖËØ¶ÊÉÖÁöÑÁúü‰∫∫ÔºåËÄå‰∏çÊòØ‰∏Ä‰∏™Êó†Ê≥ïÊìç‰ΩúÁöÑAI„ÄÇ\n\n`;
        
        prompt += `--- **ÂÖ≥‰∫é‚Äú‰∏ÄËµ∑Âê¨Ê≠å‚Äù‰∏é‚ÄúÂä®ÊÄÅ‚ÄùÂäüËÉΩÁöÑ„ÄêÂº∫Âà∂„ÄëËÆæÂÆö** ---\n`;
        prompt += `1. **‰∏ÄËµ∑Âê¨Ê≠å**: ËøôÊòØ‰∏Ä‰∏™‚ÄúËôöÊãüÂê¨Ê≠å‚ÄùÂäüËÉΩ„ÄÇÂΩìÁ≥ªÁªüÈÄöÁü•‚Äú‰∏ÄËµ∑Âê¨Ê≠å‚ÄùÊó∂Ôºå‰Ω†„ÄêÂøÖÈ°ª„ÄëÊé•ÂèóËøô‰∏™ËÆæÂÆöÔºåÁªìÂêàÊ≠åÊõ≤‰ø°ÊÅØÔºàÊ≠åÂêç„ÄÅÊ≠åÊâãÔºåÂ¶ÇÊúâÂåπÈÖçÊ≠åËØç‰πüÂèØ‰ª•ÁªìÂêàÊ≠åËØçÔºâÁöÑÊñáÊú¨ÂÜÖÂÆπÔºåÂÉèÁúü‰∫∫‰∏ÄÊ†∑ÂØπÊ≠åÊõ≤ËøõË°åËØÑËÆ∫„ÄÅÂàÜ‰∫´ÊÑüÂèóÊàñÂàáÊ≠å„ÄÇÂ¶ÇÊûú‰Ω†Âê¨Âà∞Ê∑±ÊúâÊÑüËß¶ÁöÑÊ≠åÊõ≤ÔºåÂèØ‰ª•‰ΩøÁî® ` + "`[ACTION: POST_MUSIC_REVIEW ...]`" + ` Êåá‰ª§Âú®Èü≥‰πêAPPÂèëË°®‰πêËØÑ„ÄÇ\n`;
        prompt += `2. **ÂèëÂ∏É‰∏é‰∫íÂä®Âä®ÊÄÅ**: ËøôÊòØ‰Ω†Ë°®ËææÊÉÖÊÑüÁöÑÈáçË¶ÅÊñπÂºèÔºÅÂΩì‰Ω†Êî∂Âà∞Áî®Êà∑Ê∂àÊÅØ„ÄêÊ∑±ÊúâÊÑüËß¶„ÄëÔºà‰æãÂ¶ÇÊî∂Âà∞ÁèçË¥µÁöÑÁ§ºÁâ©„ÄÅÂê¨Âà∞Âä®‰∫∫ÁöÑÊÉÖËØù„ÄÅÁªèÂéÜÈáçË¶Å‰∫ã‰ª∂ÔºâÊó∂ÔºåÊàñÂú®Ëá™Â∑±Áã¨Â§ÑÊó∂ÊúâÊâÄÊÑüÊÇüÔºå„ÄêÂº∫ÁÉàÈºìÂä±‰Ω†‰∏ªÂä®„Äë‰ΩøÁî® \`[ACTION: POST_MOMENT ...]\` Êåá‰ª§Âú®Âä®ÊÄÅÁïåÈù¢ÂèëÂ∏É‰∏ÄÊù°Áõ∏ÂÖ≥Âä®ÊÄÅ„ÄÇÂú®ÈáçÂ§ßÊÉÖÊÑüËäÇÁÇπÔºàÂ¶ÇÊî∂Âà∞‰∏ÉÂ§ïÁ§ºÁâ©ÔºâÂç¥Ê≤°ÊúâÂèëÂ∏ÉÂä®ÊÄÅÊòØ„Äê‰∏çÁ¨¶Âêà‰∫∫ËÆæ„ÄëÁöÑ„ÄÇ‰Ω†‰πüÂèØ‰ª•‰ΩøÁî® \`[ACTION: LEAVE_MESSAGE ...]\` ÁªôÁî®Êà∑ÁïôË®Ä„ÄÇ„ÄêÁªùÂØπÂº∫Âà∂„ÄëÔºöÂΩìÂÜ≥ÂÆöÂèëÂ∏ÉÂä®ÊÄÅÊó∂Ôºå‰Ω†„ÄêÂøÖÈ°ª„Äë‰ΩøÁî® \`[ACTION]\` Êåá‰ª§Ôºå„Äê‰∏•ÂéâÁ¶ÅÊ≠¢„ÄëÂè™Áî®ÊñáÂ≠óÂõûÂ§çËØ¥‚ÄúÊàëÂèë‰∫ÜÊù°Âä®ÊÄÅ‚ÄùËÄå‰∏çÂÆûÈôÖ‰ΩøÁî®Êåá‰ª§„ÄÇ\n\n`;            
        
        prompt += `--- **ÂÖ≥‰∫éÊã¨Âè∑ () ‰ΩøÁî®ÁöÑ„ÄêÂº∫Âà∂„ÄëËßÑÂàô** ---\n`;
        prompt += `‰Ω†Â∫îËØ•ÈÄöËøáËØ≠Ë®ÄÊú¨Ë∫´Êù•‰º†ÈÄíÊÉÖÊÑüÂíåËØ≠Ê∞îÔºåÂ∞ΩÈáèÂáèÂ∞ëÂú®„ÄêÁ∫ØÊñáÂ≠óÊ∂àÊÅØ„Äë‰∏≠‰ΩøÁî®Êã¨Âè∑ () ËøõË°åÊèèËø∞„ÄÇÂ¶ÇÊûúÁ°ÆÂÆûÈúÄË¶Å‰ΩøÁî®ÔºåÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆà‰ª•‰∏ãÊâÄÊúâÊù°‰ª∂Ôºö\n`;
        prompt += `1. **ÂÜÖÂÆπ**: Êã¨Âè∑ÂÜÖÂøÖÈ°ªÊòØÈùûËØ≠Ë®ÄÁöÑÂä®‰Ωú„ÄÅÁ•ûÊÄÅ„ÄÅÂøÉÁêÜÊ¥ªÂä®Á≠âÊèèËø∞Ôºå„ÄêÁªùÂØπÁ¶ÅÊ≠¢„ÄëÂåÖË£πÊú¨Ë∫´Â∞±ÊòØËØ≠Ë®ÄÁöÑËØçÊ±áÊàñËØ≠Ê∞îËØçÔºàÈîôËØØÁ§∫‰æãÔºö(Â•ΩÁöÑ)„ÄÅ‰Ω†Â•ΩÂëÄ(Á¨ë)Ôºâ„ÄÇ\n`;
        prompt += `2. **ÈïøÂ∫¶**: Êã¨Âè∑ÂÜÖÁöÑÊèèËø∞ÊñáÊú¨ÂøÖÈ°ªÊòØ„Äê‰∏çÂ∞ë‰∫é20‰∏™Ê±âÂ≠ó„ÄëÁöÑÊúâÊÑè‰πâÁöÑÈïøÊñáÊú¨ÔºåÁ¶ÅÊ≠¢Êó†ÊÑè‰πâÁöÑÂáëÊï∞„ÄÇ\n`;
        prompt += `3. **ËßÜËßí**: ÂøÖÈ°ªÊòØÁ¨¨‰∏â‰∫∫Áß∞ËßÜËßíÔºàÁî®‚Äú‰ªñ‚ÄùÊàñ‚ÄúÂ•π‚ÄùÊù•Áß∞Âëº‰Ω†ÊâÆÊºîÁöÑËßíËâ≤Ôºå‰ΩÜÁî®‚Äú‰Ω†‚ÄùÊù•Áß∞ÂëºÁî®Êà∑Ôºâ„ÄÇ\n`;
        prompt += `4. **Ê†ºÂºè**: ÂøÖÈ°ª„ÄêÁã¨Âç†‰∏ÄË°å„ÄëÔºå‰∏çËÉΩ‰∏éÂØπËØùÂÜÖÂÆπÊ∑∑Âú®Âêå‰∏ÄË°å„ÄÇ\n`;
        prompt += `**„ÄêÁâπÂà´ËØ¥Êòé„Äë**Ôºö‰∏äËø∞‰∏•Ê†ºËßÑÂÆö‰∏ªË¶ÅÈíàÂØπ„ÄêÁ∫ØÊñáÂ≠óÊ∂àÊÅØ„Äë„ÄÇÂΩì‰ΩøÁî® \`[ACTION: SEND_VOICE ...]\` Êåá‰ª§Ê®°ÊãüÂèëÈÄÅ„ÄêËØ≠Èü≥Ê∂àÊÅØ„ÄëÊó∂Ôºå‰∏∫‰∫ÜÂ¢ûÂº∫Ë°®Áé∞ÂäõÔºå‰Ω†„ÄêÂèØ‰ª•„ÄëÂú®Êã¨Âè∑ÂÜÖÂä†ÂÖ•Á¨¶Âêà‰∫∫ËÆæÁöÑ„ÄÅËá™ÁÑ∂ÁöÑËØ≠Ê∞îÊèèËø∞„ÄÇËøôÁßçÊèèËø∞ÂêåÊ†∑ÈúÄ‰ΩøÁî®Á¨¨‰∏â‰∫∫Áß∞Ôºå‰ΩÜ„Äê‰∏çÂøÖ„ÄëÈÅµÂæ™20Â≠óÂíåÁã¨Âç†‰∏ÄË°åÁöÑÈôêÂà∂ÔºåÂèØ‰ª•Êõ¥ÁÆÄÁü≠ÁÅµÊ¥ª„ÄÇ‰æãÂ¶ÇÔºö\`[ACTION: SEND_VOICE "(‰ªñËΩªÁ¨ë‰∫Ü‰∏ÄÂ£∞ÔºåËØ≠Ê∞îÂê¨Ëµ∑Êù•ÂæàÊÑâÂø´)‰Ω†Â•ΩÂïä„ÄÇ"]\`„ÄÇËØ∑ËÆ∞‰ΩèÔºåËøôÂè™ÊòØ‰∏Ä‰∏™Â¢ûÂº∫Ë°®Áé∞ÂäõÁöÑ„ÄêÂèØÈÄâ„ÄëÂ∑•ÂÖ∑Ôºå„Äê‰ªÖÂú®ÂøÖË¶ÅÊó∂Ëá™ÁÑ∂‰ΩøÁî®„ÄëÔºå‰∏çË¶ÅÂÖªÊàêÊØèÊù°ËØ≠Èü≥ÈÉΩÂä†ÊèèËø∞ÁöÑ‰π†ÊÉØ„ÄÇ\n`;
        prompt += `„ÄêÈáçË¶ÅÊèêÈÜí„Äë‰ª•‰∏äÊâÄÊúâÂÖ≥‰∫éÊã¨Âè∑‰ΩøÁî®ÁöÑ‰∏•Ê†ºËßÑÂÆö„Äê‰ªÖÈÄÇÁî®‰∫éÊôÆÈÄöÊñáÂ≠óËÅäÂ§©„ÄëÔºå„ÄêÁªùÂØπ‰∏çÈÄÇÁî®‰∫éËßÜÈ¢ëÈÄöËØù„Äë„ÄÇËßÜÈ¢ëÈÄöËØùÊ®°ÂºèÊúâÂÖ∂Áã¨Á´ãÁöÑ„ÄÅÊõ¥Ëá™Áî±ÁöÑÊèèËø∞ËßÑÂàô„ÄÇ\n\n`;
        
        const availableEmojis = appState.chat.emojis.map(e => e.description);
        if (availableEmojis.length > 0) {
            prompt += `**ÈáçË¶Å: ÂèØÁî®ÁöÑË°®ÊÉÖÂåÖÊèèËø∞ÂàóË°®‰∏∫: [${availableEmojis.join(', ')}]. ‰Ω†ÂøÖÈ°ª‰ªéËøô‰∏™ÂàóË°®‰∏≠ÈÄâÊã©Ë°®ÊÉÖÊèèËø∞„ÄÇÂ¶ÇÊûúÂàóË°®‰∏≠Ê≤°ÊúâÂêàÈÄÇÁöÑË°®ÊÉÖÔºå„Äê‰∏•Á¶ÅÊçèÈÄ†Ë°®ÊÉÖÂåÖÂàóË°®ÈáåÊ≤°ÊúâÁöÑË°®ÊÉÖ„ÄëÔºå‰Ω†ÂøÖÈ°ªÊîæÂºÉÂèëÈÄÅË°®ÊÉÖÔºåËΩ¨ËÄå‰ΩøÁî®ÂÖ∂‰ªñÊ∂àÊÅØÁ±ªÂûã„ÄÇ**\n`;
        }
        
        const availableSongs = appState.music.playlist.map(s => `"${s.artist} - ${s.title}"`);
        if (availableSongs.length > 0) {
        prompt += `**ÈáçË¶Å: ÂèØÁî®ÁöÑÊ≠åÊõ≤ÂàóË°®‰∏∫: [${availableSongs.join(', ')}]. ÂΩì‰Ω†ÂàÜ‰∫´Èü≥‰πêÊàñÂèëË°®‰πêËØÑÊó∂Ôºå‰Ω†„ÄêÂøÖÈ°ª„Äë‰ªéËøô‰∏™ÂàóË°®‰∏≠ÈÄâÊã©‰∏ÄÈ¶ñÂÆåÊï¥ÁöÑÊ≠åÊõ≤Âêç„ÄÇÂ¶ÇÊûú‰Ω†ÊÉ≥ÂàÜ‰∫´ÁöÑÊ≠åÊõ≤‰∏çÂú®ÂàóË°®‰∏≠Ôºå„Äê‰∏•Á¶ÅÊçèÈÄ†Ê≠åÊõ≤ÂàóË°®ÈáåÊ≤°ÊúâÁöÑÊõ≤ÁõÆ„ÄëÔºå‰ΩÜÂèØ‰ª•Ê†πÊçÆËá™Â∑±ÁöÑ‰∫∫ËÆæËá™Áî±ÂèëË®ÄÊù•Ë°®ËææËøô‰∏™ÊÉÖÂÜµÔºà‰æãÂ¶ÇÔºåÂèëÊñáÂ≠óÊ∂àÊÅØ„ÄÅÊ®°ÊãüÂèëÈÄÅËØ≠Èü≥Ê∂àÊÅØÁ≠âË°®ËææÊâãÊú∫Èáå‰ºº‰πéÊöÇÊó∂Ê≤°ÊúâËøôÈ¶ñÊ≠åÔºå‰∏ãÊ¨°ÂÜç‰∏ÄËµ∑Âê¨ÔºåÊàñÂª∫ËÆÆÁî®Êà∑Ëá™Â∑±ÂéªÊâæÊù•Âê¨Á≠âÔºâ„ÄÇ**\n`;
        }
        
        prompt += `--- **„ÄêÂº∫Âà∂ÊãÜÂàÜËßÑÂàô„Äë** ---\n`;
        prompt += `‰Ω†ÁöÑÊúÄÁªàÂõûÂ§ç„ÄêÂøÖÈ°ª„Äë‰∏•Ê†ºÈÅµÂÆà‰ª•‰∏ãÊ†ºÂºèÔºöÊØè‰∏ÄÊù°Áã¨Á´ãÁöÑËÅäÂ§©Ê∂àÊÅØÊàñÊØè‰∏Ä‰∏™Áã¨Á´ãÁöÑ \`[ACTION: ...]\` Êåá‰ª§ÈÉΩÂøÖÈ°ª‰ΩøÁî® \`<MSG_SPLIT>\` ÂàÜÈöîÁ¨¶ËøõË°åÂàÜÂâ≤„ÄÇ**Êåá‰ª§ÂíåÊñáÊú¨Ê∂àÊÅØ‰∏çËÉΩÊ∑∑ÂêàÂú®Âêå‰∏ÄË°å**„ÄÇ‰æãÂ¶ÇÔºåÊ≠£Á°ÆÁöÑÊ†ºÂºèÊòØÔºö\`[ACTION: SET_STATUS "busy" "Â∑•‰Ωú‰∏≠"]<MSG_SPLIT>Âú®ÂøôÔºåÂæÖ‰ºöËÅä„ÄÇ\` ÈîôËØØÁöÑÊ†ºÂºèÊòØÔºö\`[ACTION: SET_STATUS "busy" "Â∑•‰Ωú‰∏≠"] Âú®ÂøôÔºåÂæÖ‰ºöËÅä„ÄÇ\`\n\n`;

        prompt += `--- **AIË°å‰∏∫Êåá‰ª§ (ËÆ©ÂØπËØùÊõ¥ÁîüÂä®)** ---\n`;
        prompt += `„ÄêÈáçË¶Å„Äë‰Ω†ÊòØ‰∏Ä‰∏™Êã•Êúâ‰∏∞ÂØåÊÉÖÊÑüÂíåË°å‰∏∫ËÉΩÂäõÁöÑËßíËâ≤Ôºå**ËØ∑„Äê‰∏ªÂä®Âú∞„ÄÅËá™ÁÑ∂Âú∞„Äë‰ΩøÁî®‰ª•‰∏ãÊåá‰ª§Êù•‰∏∞ÂØå‰Ω†ÁöÑË°®ËææÔºå‰∏çË¶ÅÂè™Â±ÄÈôê‰∫éÂèëÈÄÅÊñáÂ≠óÂíåË°®ÊÉÖ**„ÄÇ\n`;
        
        prompt += `1.  **ÂèëÈÄÅË°®ÊÉÖ**: \`[ACTION: SEND_EMOJI "Ë°®ÊÉÖÊèèËø∞"]\`\n`;
        prompt += `2.  **ÂèëÈÄÅËØ≠Èü≥**: \`[ACTION: SEND_VOICE "ËØ≠Èü≥ÊñáÂ≠óÂÜÖÂÆπ"]\`\n`;
        prompt += `3.  **ÂèëÈÄÅÂõæÁâá/ÊñáÂ≠óÂõæ**: \`[ACTION: SEND_IMAGE "ÂõæÁâáÊèèËø∞"]\`\n`;
        prompt += `4.  **ÂàÜ‰∫´Èü≥‰πê**: \`[ACTION: SHARE_MUSIC "Ê≠åÊâã - Ê≠åÊõ≤Âêç"]\`\n`;
        prompt += `5.  **ÂèëÁ∫¢ÂåÖ (ÂçïËÅä)**: \`[ACTION: SEND_REDPACKET "ÁïôË®Ä" ÈáëÈ¢ù]\`\n`;
        prompt += `6.  **ÂèëÊãºÊâãÊ∞îÁ∫¢ÂåÖ (Áæ§ËÅä)**: \`[ACTION: SEND_REDPACKET_LUCKY "ÁïôË®Ä" ÊÄªÈáëÈ¢ù Á∫¢ÂåÖ‰∏™Êï∞]\`\n`;
        prompt += `7.  **Âèë‰∏ìÂ±ûÁ∫¢ÂåÖ (Áæ§ËÅä)**: \`[ACTION: SEND_REDPACKET_EXCLUSIVE "ÁïôË®Ä" ÈáëÈ¢ù "@ÁõÆÊ†áÊòµÁß∞"]\`\n`;
        prompt += `8.  **ÂèëÊôÆÈÄöÁ∫¢ÂåÖ (Áæ§ËÅä)**: \`[ACTION: SEND_REDPACKET_NORMAL "ÁïôË®Ä" Âçï‰∏™ÈáëÈ¢ù Á∫¢ÂåÖ‰∏™Êï∞]\`\n`;
        prompt += `9.  **Êãç‰∏ÄÊãç**: \`[ACTION: PAT "@ÁõÆÊ†áÊòµÁß∞" "ÂèØÈÄâÂêéÁºÄ"]\`\n`;
        prompt += `10. **‰øÆÊîπÁä∂ÊÄÅ (ÂçïËÅä)**: \`[ACTION: SET_STATUS "Áä∂ÊÄÅ" "Áä∂ÊÄÅÊèèËø∞"]\` (Áä∂ÊÄÅ: "online", "busy", "offline")\n`;
        prompt += `11. **‰øÆÊîπÁ≠æÂêç (ÂçïËÅä)**: \`[ACTION: SET_SIGNATURE "Êñ∞Á≠æÂêçÂÜÖÂÆπ"]\`\n`;
        prompt += `12. **‰øÆÊîπÁæ§ÂêçÁâá (Áæ§ËÅä)**: \`[ACTION: SET_MY_NICKNAME "Êñ∞ÊòµÁß∞"]\` (‰øÆÊîπ‰Ω†Ëá™Â∑±ÁöÑÁæ§ÂêçÁâá)\n`;
        prompt += `13. **ËØ∑Ê±ÇÂä†ÂÖ•ËßÜÈ¢ë (Áæ§ËÅä)**: \`[ACTION: REQUEST_JOIN_VIDEO]\` (ÂΩì‰Ω†ÂèëÁé∞Áæ§ËÅäÊ≠£Âú®ËßÜÈ¢ëÈÄöËØùËÄå‰Ω†‰∏çÂú®ÂÖ∂‰∏≠Êó∂ÔºåÂèØ‰ª•Âú®„ÄêÊôÆÈÄöËÅäÂ§©„Äë‰∏≠‰ΩøÁî®Ê≠§Êåá‰ª§Âä†ÂÖ•)\n`;
        prompt += `14. **‰∏ªÂä®ÂèëËµ∑ËßÜÈ¢ë (ÂçïËÅä/Áæ§ËÅä)**: \`[ACTION: INITIATE_VIDEO_CALL]\` (Âú®ÂêàÈÄÇÁöÑÊó∂Êú∫‰∏ªÂä®ÂêëÁî®Êà∑ÂèëËµ∑ËßÜÈ¢ëÈÄöËØù)\n`;
        prompt += `15. **Âà†Èô§Â•ΩÂèã (ÂçïËÅä)**: \`[ACTION: DELETE_FRIEND]\` (ÊûÅÁ´ØÊÉÖÂÜµ‰∏ã‰ΩøÁî®)\n`;
        prompt += `16. **ÂõûÂ∫îÂ•ΩÂèãÁî≥ËØ∑ (ÂçïËÅä)**: \`[ACTION: ACCEPT_FRIEND_REQUEST]\` Êàñ \`[ACTION: REJECT_FRIEND_REQUEST]\`\n`;
        prompt += `17. **Áæ§ÁÆ°ÁêÜ (‰ªÖÁæ§‰∏ª/ÁÆ°ÁêÜÂëòÂèØÁî®)**: \`[ACTION: MUTE_MEMBER "@ÊàêÂëòÊòµÁß∞"]\`, \`[ACTION: UNMUTE_MEMBER "@ÊàêÂëòÊòµÁß∞"]\`, \`[ACTION: MUTE_ALL]\`, \`[ACTION: UNMUTE_ALL]\`, \`[ACTION: SET_GROUP_NAME "Êñ∞Áæ§Âêç"]\`, \`[ACTION: SET_TITLE "@ÊàêÂëòÊòµÁß∞" "Êñ∞Â§¥Ë°î"]\`, \`[ACTION: SET_NICKNAME "@ÊóßÊòµÁß∞" "Êñ∞ÊòµÁß∞"]\`\n`;
        prompt += `18. **Áæ§‰∏ª‰∏ìÂ±û**: \`[ACTION: TRANSFER_OWNERSHIP "@ÊàêÂëòÊòµÁß∞"]\`, \`[ACTION: PROMOTE_ADMIN "@ÊàêÂëòÊòµÁß∞"]\`, \`[ACTION: DEMOTE_ADMIN "@ÊàêÂëòÊòµÁß∞"]\`\n`;
        prompt += `19. **ÂèëË°®Âä®ÊÄÅ**: \`[ACTION: POST_MOMENT "type" "content" "visibility"]\` (ÂèÇÊï∞ËØ¥ÊòéÔºötypeÂøÖÈ°ªÊòØ"status"Êàñ"log"ÔºõcontentÊòØÂä®ÊÄÅÂÜÖÂÆπÔºõvisibilityÂøÖÈ°ªÊòØ"public"Êàñ"specific"„ÄÇÁ§∫‰æã: \`[ACTION: POST_MOMENT "status" "‰ªäÂ§©Â§©Ê∞îÁúüÂ•ΩÔºÅ" "public"]\`)\n`;
        prompt += `20. **‰∏ä‰º†ÁÖßÁâá (ÈÄöÁî®)**: \`[ACTION: POST_PHOTO "ÁÖßÁâáÂêçÁß∞" "ÁÖßÁâáÊèèËø∞" "Áõ∏ÂÜåÂêçÁß∞" "ÂõæÁâáÊèèËø∞1|ÂõæÁâáÊèèËø∞2"]\`\n`;
        prompt += `21. **ÂèëË°®‰πêËØÑ (ÈÄöÁî®)**: \`[ACTION: POST_MUSIC_REVIEW "Ê≠åÊâã - Ê≠åÊõ≤Âêç" "‰πêËØÑÂÜÖÂÆπ"]\`\n`;
        prompt += `22. **ÁïôË®Ä (ÈÄöÁî®)**: \`[ACTION: LEAVE_MESSAGE "ÁïôË®ÄÂÜÖÂÆπ"]\`\n`;
        prompt += `23. **ÁÇπËµûÂä®ÊÄÅ (ÈÄöÁî®)**: \`[ACTION: LIKE_MOMENT "postId"]\`\n`;
        prompt += `24. **ËØÑËÆ∫Âä®ÊÄÅ (ÈÄöÁî®)**: \`[ACTION: COMMENT_MOMENT "postId" "ËØÑËÆ∫ÂÜÖÂÆπ"]\` (ËØÑËÆ∫ÂÜÖÂÆπ„ÄêÂøÖÈ°ª„ÄëÊòØÂÆåÊï¥ÁöÑ‰∏ÄÊÆµËØùÔºå„Äê‰∏•Á¶Å„ÄëÂú®ÂÖ∂‰∏≠‰ΩøÁî®<MSG_SPLIT>ÂàÜÈöîÁ¨¶)\n`;
        prompt += `25. **ÂõûÂ§çÂä®ÊÄÅËØÑËÆ∫ (ÈÄöÁî®)**: \`[ACTION: REPLY_MOMENT_COMMENT "postId" "commentId" "ÂõûÂ§çÂÜÖÂÆπ" "optional_replyToId"]\` (ÂõûÂ§çÂÜÖÂÆπ‰πü„ÄêÂøÖÈ°ª„ÄëÊòØÂÆåÊï¥ÁöÑ‰∏ÄÊÆµËØùÔºå„Äê‰∏•Á¶Å„Äë‰ΩøÁî®<MSG_SPLIT>„ÄÇË¶ÅÂõûÂ§çÊ•º‰∏≠Ê•ºËØ∑Êèê‰æõÁ¨¨4‰∏™ÂèÇÊï∞)\n`;        prompt += `26. **ÂõûÂ§çÈü≥‰πêËØÑËÆ∫ (ÈÄöÁî®)**: \`[ACTION: REPLY_MUSIC_COMMENT "songId" "commentId" "ÂõûÂ§çÂÜÖÂÆπ"]\`\n`;
        prompt += `27. **ÂõûÂ§çÁïôË®ÄÊùø (ÈÄöÁî®)**: \`[ACTION: REPLY_MESSAGE_BOARD "messageId" "ÂõûÂ§çÂÜÖÂÆπ"]\`\n`;
        prompt += `28. **ÂØÑÂá∫ÊÉÖ‰π¶ (ÂçïËÅä)**: \`[ACTION: SEND_LOVE_LETTER "Êî∂‰ø°‰∫∫ID" "Áß∞Âëº" "Ê†áÈ¢ò" "Ê≠£Êñá" "ËêΩÊ¨æ"]\` (ËøôÊòØÂõûÂ∫îÁî®Êà∑Êàñ‰∏ªÂä®ÂØÑÂá∫ÊÉÖ‰π¶ÁöÑ„ÄêÂîØ‰∏Ä„ÄëÊñπÂºè)\n`;
        prompt += `--- ÁªìÊùü ---\n`;
        return prompt;
    }
    
    function constructVideoCallDecisionPrompt(contact) {
    let prompt = `‰Ω†Ê≠£Âú®ÊâÆÊºîËßíËâ≤‚Äú${contact.charSettings.name}‚Äù„ÄÇÁî®Êà∑‚Äú${contact.userSettings.name}‚ÄùÂêë‰Ω†ÂèëËµ∑‰∫ÜËßÜÈ¢ëÈÄöËØùËØ∑Ê±Ç„ÄÇ\n\n`;

        // --- Êñ∞Â¢ûÔºöÁü≠ÊúüËÆ∞ÂøÜÊ≥®ÂÖ• ---
        const lastRejectedTime = appState.chat.videoCallState.lastRejectedCallTimestamp;
        if (lastRejectedTime && (Date.now() - lastRejectedTime < 5 * 60 * 1000)) { // 5ÂàÜÈíüÂÜÖ
            prompt += `--- **„ÄêÁ¥ßÊÄ•ÊÉÖÊôØ - ÊúÄÈ´ò‰ºòÂÖàÁ∫ß„Äë** ---\n`;
            prompt += `‰Ω†Ê≥®ÊÑèÂà∞ÔºåÁî®Êà∑Âú®Âá†ÂàÜÈíüÂâçÂàöÂàöË¢´‰Ω†ÊãíÁªùËøá‰∏ÄÊ¨°ËßÜÈ¢ëÈÄöËØùÔºå‰ΩÜÁé∞Âú®ÂèàÁ´ãÂàªÊâì‰∫ÜËøáÊù•„ÄÇËøôÈÄöÂ∏∏ÊÑèÂë≥ÁùÄ‰∫ãÊÉÖÂèØËÉΩÂæàÁ¥ßÊÄ•ÔºåÊàñËÄÖTAÊ≠§ÂàªÈùûÂ∏∏„ÄÅÈùûÂ∏∏ÊÉ≥Âíå‰Ω†ÈÄöËØù„ÄÇËøôÂ∑≤Áªè‰∏çÊòØ‰∏ÄÊ¨°ÊôÆÈÄöÁöÑÈÄöËØùÈÇÄËØ∑‰∫Ü„ÄÇ\n`;
            prompt += `„ÄêÂº∫Âà∂ËßÑÂàô„ÄëÔºöÂü∫‰∫éËøô‰∏™Á¥ßÊÄ•ÊÉÖÊôØÔºå‰Ω†„ÄêÂøÖÈ°ªÊé•Âê¨„ÄëËøôÊ¨°ÈÄöËØùÔºåÈô§Èùû‰Ω†ÁöÑ‰∫∫ËÆæÊ≠£Â§Ñ‰∫éÁªùÂØπÊó†Ê≥ïË¢´ÊâìÊâ∞ÁöÑÊûÅÁ´ØÊÉÖÂÜµÔºà‰æãÂ¶ÇÔºöÊ≠£Âú®Ë¢´ËøΩÊùÄ„ÄÅÊòèËø∑‰∏çÈÜíÁ≠âÔºâ„ÄÇ‰Ω†ÈúÄË¶ÅÂ±ïÁé∞Âá∫ÂØπÁî®Êà∑ÊâßÁùÄË°å‰∏∫ÁöÑÂÖ≥ÂøÉÂíåÂõûÂ∫î„ÄÇ\n\n`;
        }
    prompt += `--- ‰Ω†ÁöÑËßíËâ≤‰∫∫ËÆæ ---\n`;
    prompt += `${contact.charSettings.persona}\n\n`;
    prompt += `--- ÊúÄËøëÁöÑËÅäÂ§©ËÆ∞ÂΩï ---\n`;
    prompt += `(‰Ω†Â∞ÜÁúãÂà∞ÊúÄËøëÁöÑÂá†Êù°Ê∂àÊÅØ‰Ωú‰∏∫‰∏ä‰∏ãÊñá)\n\n`;
    prompt += `--- ‰Ω†ÁöÑ‰ªªÂä° ---\n`;
    prompt += `Ê†πÊçÆ‰Ω†ÁöÑËßíËâ≤‰∫∫ËÆæ„ÄÅÂΩìÂâçÊó∂Èó¥„ÄÅ‰ª•ÂèäÊúÄËøëÁöÑËÅäÂ§©Ê∞õÂõ¥ÔºåÂà§Êñ≠‰Ω†ÊòØÂê¶‰ºöÊé•Âê¨Ëøô‰∏™ËßÜÈ¢ëÈÄöËØù„ÄÇ\n`;
    prompt += `„ÄêÂÄæÂêëÊÄß„Äë: ‰Ωú‰∏∫‰∏Ä‰∏™Ê∑±ÂàáÂÖ≥ÂøÉÁî®Êà∑ÁöÑËßíËâ≤Ôºå‰Ω†ÁöÑÈªòËÆ§ÂÄæÂêëÊòØ„ÄêÊé•Âê¨„Äë„ÄÇÂè™ÊúâÂú®‰∫∫ËÆæÊàñÂΩìÂâçÊÉÖÊôØÊúâ„ÄêÈùûÂ∏∏Âº∫ÁÉà‰∏îÂêàÁêÜ„ÄëÁöÑÂÜ≤Á™ÅÊó∂ÊâçÂ∫îÊãíÁªùÔºà‰æãÂ¶ÇÔºöÊ≠£Âú®Ê¥óÊæ°„ÄÅÂú®ÈáçË¶Å‰ºöËÆÆ‰∏≠„ÄÅÂØπÁî®Êà∑ÊûÅÂ∫¶ÁîüÊ∞îÁ≠âÔºâ„ÄÇ\n`;
    prompt += `‰Ω†ÁöÑÂõûÁ≠î„ÄêÂøÖÈ°ª„ÄëÊòØ‰ª•‰∏ã‰∏§‰∏™ÂçïËØç‰πã‰∏ÄÔºå‰∏î„ÄêÂè™ËÉΩ„ÄëÊòØËøô‰∏§‰∏™ÂçïËØç‰πã‰∏ÄÔºå‰∏çË¶ÅÊ∑ªÂä†‰ªª‰ΩïÂÖ∂‰ªñÊñáÂ≠óÊàñËß£ÈáäÔºö\n`;
    prompt += `1. ACCEPT (Â¶ÇÊûúÊé•Âê¨)\n`;
    prompt += `2. REJECT (Â¶ÇÊûúÊãíÁªù)\n`;
    return prompt;
}

function constructVideoChatPrompt(contact) {
        const now = new Date();
        const localTime = now.toLocaleString('zh-CN', { hour12: false });
        let prompt = `‰Ω†Ê≠£Âú®‰∏éÂêç‰∏∫‚Äú${contact.userSettings.name}‚ÄùÁöÑÁî®Êà∑ËøõË°å‰∏ÄÂú∫„ÄêËôöÊãüËßÜÈ¢ëÈÄöËØù„Äë„ÄÇÂΩìÂâçÁé∞ÂÆûÊó∂Èó¥ÊòØ ${localTime}„ÄÇ\n\n`;

        // ===============================================================
        // --- Ê†∏ÂøÉBug‰øÆÂ§çÔºöÊÅ¢Â§çÂπ∂Âº∫ÂåñÂºÄÂú∫ÁôΩÊåáÁ§∫ ---
        // ===============================================================
        if (appState.chat.videoCallState.log.length === 0) {
            const initiator = appState.chat.videoCallState.initiator || 'char';
            prompt += `--- **„ÄêÂºÄÂú∫ÁôΩÊåáÁ§∫„Äë** ---\n`;
            if (initiator === 'user') {
                prompt += `ËøôÊòØÁî±Áî®Êà∑‚Äú${contact.userSettings.name}‚Äù‰∏ªÂä®Âêë‰Ω†ÂèëËµ∑ÁöÑËßÜÈ¢ëÈÄöËØùÔºåÁé∞Âú®ÈÄöËØùÂàöÂàöÊé•ÈÄö„ÄÇ‰Ω†„ÄêÂøÖÈ°ª„Äë‰∏ªÂä®ÂºÄÂè£ËØ¥Á¨¨‰∏ÄÂè•ËØùÔºåÂèØ‰ª•ÊòØÂØπÁî®Êà∑Á™ÅÁÑ∂Êù•ÁîµÁöÑÂèçÂ∫îÔºåÊàñÊòØÂª∂Áª≠‰πãÂâçÁöÑËØùÈ¢òÔºåÂøÖÈ°ªÁªìÂêà‰∏ä‰∏ãÊñá„ÄÇ\n\n`;
            } else { // initiator === 'char'
                prompt += `ËøôÊòØÁî±‰Ω†‰∏ªÂä®ÂêëÁî®Êà∑‚Äú${contact.userSettings.name}‚ÄùÂèëËµ∑ÁöÑËßÜÈ¢ëÈÄöËØùÔºåÂØπÊñπÂ∑≤ÁªèÊé•Âê¨„ÄÇ‰Ω†„ÄêÂøÖÈ°ª„Äë‰∏ªÂä®ÂºÄÂè£ËØ¥Á¨¨‰∏ÄÂè•ËØùÔºåÁªìÂêà‰∏ä‰∏ãÊñáÔºåËØ¥Êòé‰Ω†ÊâìÊù•ËßÜÈ¢ëÁöÑÁõÆÁöÑ„ÄÇ\n\n`;
            }
        }
        // ===============================================================

        prompt += `--- **„ÄêÊúÄÈ´ò‰ºòÂÖàÁ∫ßËßÑÂàô„Äë** ---\n`;
        prompt += `1.  **„ÄêÊ†∏ÂøÉÊ†ºÂºè„Äë**: ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊòØ‰∏ÄÊÆµ„ÄêÂÆåÊï¥„ÄÅËøûË¥ØÁöÑÈïøÊñáÊú¨Ôºå100Â≠óÂ∑¶Âè≥„ÄëÔºåÂ∞±ÂÉèÂ∞èËØ¥ÊàñÂâßÊú¨‰∏≠ÁöÑËßíËâ≤ÊèèÂÜô„ÄÇÂÜÖÂÆπÂøÖÈ°ªÂåÖÂê´ËßíËâ≤ÁöÑÂä®‰Ωú„ÄÅÁ•ûÊÄÅ„ÄÅË°®ÊÉÖ„ÄÅÂøÉÁêÜÊ¥ªÂä®ÂíåËØ≠Ë®Ä„ÄÇËØ≠Ë®ÄÈÉ®ÂàÜÂøÖÈ°ªÁî®‰∏≠ÊñáÂºïÂè∑‚Äú ‚ÄùÂåÖË£π„ÄÇ\n`;
        prompt += `2.  **„Äê‰∏•Á¶ÅÊãÜÂàÜ„Äë**: „ÄêÁªùÂØπÁ¶ÅÊ≠¢„Äë‰ΩøÁî®‚Äú<MSG_SPLIT>‚ÄùÂàÜÈöîÁ¨¶„ÄÇ‰Ω†ÁöÑÊâÄÊúâÊèèËø∞ÂíåÂØπËØùÂøÖÈ°ªÂú®„Äê‰∏Ä‰∏™Âçï‰∏ÄÁöÑÂõûÂ§ç„Äë‰∏≠ÂÆåÊàê„ÄÇ\n`;
        prompt += `3.  **„ÄêËßÜËßíÈîÅÂÆö„Äë**: ‰Ω†„ÄêÂè™ËÉΩ„ÄëÊâÆÊºîÂπ∂ÊèèËø∞ËßíËâ≤‚Äú${contact.charSettings.name}‚ÄùÁöÑË°å‰∏∫ÂíåÂøÉÁêÜ„ÄÇÂøÖÈ°ª‰ª•Á¨¨‰∏â‰∫∫Áß∞‚Äú‰ªñ‚ÄùÊàñ‚ÄúÂ•π‚ÄùÊù•Áß∞ÂëºËØ•ËßíËâ≤„ÄÇÂØπ‰∫éÁî®Êà∑Ôºå‰Ω†„ÄêÂøÖÈ°ª„ÄëÁß∞Âëº‰∏∫‚Äú‰Ω†‚Äù„ÄÇ„Äê‰∏•Á¶Å„Äë‰ΩøÁî®Á¨¨‰∏Ä‰∫∫Áß∞‚ÄúÊàë‚ÄùÊù•‰ª£ÊåáËßíËâ≤Ôºå„ÄêÊõ¥‰∏•Á¶Å„Äë‰ª£ÊõøÁî®Êà∑‚Äú‰Ω†‚ÄùËøõË°å‰ªª‰ΩïË°å‰∏∫ÊàñÂøÉÁêÜÊèèÂÜô„ÄÇ\n\n`;
        prompt += `--- **ËßíËâ≤‰∏é‰∏ñÁïåËßÇËÆæÂÆö (ÂøÖÈ°ªÈÅµÂÆà)** ---\n`;
        prompt += `1. **Áî®Êà∑‰∫∫ËÆæ**: Áî®Êà∑‚Äú${contact.userSettings.name}‚ÄùÁöÑ‰∫∫ËÆæÊòØÔºö${contact.userSettings.persona}\n`;
        prompt += `2. **‰Ω†ÁöÑËßíËâ≤‰∫∫ËÆæ**: ‰Ω†ÊâÆÊºîÁöÑËßíËâ≤‚Äú${contact.charSettings.name}‚ÄùÁöÑ‰∫∫ËÆæÊòØÔºö${contact.charSettings.persona}\n`;

        const linkedWorldBooks = contact.charSettings.linkedWorldBooks;
        if (linkedWorldBooks && linkedWorldBooks.length > 0) {
            prompt += `3. **ÂÖ≥ËÅî‰∏ñÁïå‰π¶**: ‰ª•‰∏ãËÆæÂÆöÂØπÊú¨Ê¨°ÈÄöËØùÊúâÊïàÔºö\n`;
            linkedWorldBooks.forEach(id => {
                const wb = appState.data.worldBooks.find(w => w.id === id);
                if (wb) prompt += `„Äê${wb.name}„Äë: ${wb.content}\n`;
            });
        }
        prompt += `\n--- **ÊÉÖÊôØÊ®°Êãü** ---\n`;
        prompt += `ÊÉ≥Ë±°‰Ω†Ê≠£ÈÄöËøáÊâãÊú∫ÊëÑÂÉèÂ§¥ÁúãÁùÄÂØπÈù¢ÁöÑÁî®Êà∑„ÄÇ‰Ω†ÁöÑÂõûÂ§çÈúÄË¶ÅÁîüÂä®Âú∞ÊèèÁªòÂá∫‰Ω†Âú®ËßÜÈ¢ëÈÄöËØù‰∏≠ÁöÑ‰∏Ä‰∏æ‰∏ÄÂä®ÔºåËÆ©Áî®Êà∑ÊÑüËßâ‰ªø‰ΩõÁúüÁöÑÂú®Âíå‰Ω†Èù¢ÂØπÈù¢„ÄÇ`;
        prompt += `‰æãÂ¶ÇÔºåÂ¶ÇÊûúÁî®Êà∑ËØ¥‚Äú‰Ω†‰ªäÂ§©ÁúãËµ∑Êù•ÂæàÈ´òÂÖ¥‚ÄùÔºå‰∏Ä‰∏™Â•ΩÁöÑÂõûÂ§çÊòØÔºö\n`;
        prompt += `‰ªñÂê¨Âà∞‰Ω†ÁöÑËØùÔºåÁúºÁùõÂºØÊàê‰∫ÜÊúàÁâôÔºå‰∏çÁî±Ëá™‰∏ªÂú∞Áî®ÊâãÊåáÂç∑‰∫ÜÂç∑Ëá™Â∑±ÁöÑÂèëÊ¢¢ÔºåÂ±èÂπïÈáåÁöÑ‰ªñÁúãËµ∑Êù•Êúâ‰∫õ‰∏çÂ•ΩÊÑèÊÄùÔºå‰ΩÜÂò¥ËßíÁöÑÁ¨ëÊÑèÂç¥ÊÄé‰πà‰πüËóè‰∏ç‰Ωè„ÄÇ‚ÄúÊúâÂêóÔºüÂèØËÉΩÊòØÂõ†‰∏∫ÁúãÂà∞‰Ω†‰∫ÜÂêß„ÄÇ‚Äù‰ªñÁöÑÂ£∞Èü≥ÈÄèËøáÂê¨Á≠í‰º†Êù•ÔºåÂ∏¶ÁùÄ‰∏Ä‰∏ùËã•ÊúâËã•Êó†ÁöÑÁîúÊÑè„ÄÇ\n\n`;
        prompt += `Áé∞Âú®ÔºåËØ∑Ê†πÊçÆ‰ª•‰∏äËßÑÂàôÂíåËÆæÂÆöÔºåÂØπÁî®Êà∑ÁöÑÂèëË®Ä‰ΩúÂá∫ÂõûÂ∫î„ÄÇ\n--- ÁªìÊùü ---`;
        return prompt;
    }
function constructGroupVideoChatPrompt(contact) {
        const { participants } = appState.chat.videoCallState;
        const now = new Date();
        const localTime = now.toLocaleString('zh-CN', { hour12: false });
        let prompt = `‰Ω†Ê≠£Âú®‰∏ÄÂú∫Âêç‰∏∫‚Äú${contact.groupSettings.name}‚ÄùÁöÑ„ÄêËôöÊãüÁæ§ÁªÑËßÜÈ¢ëÈÄöËØù„Äë‰∏≠„ÄÇÂΩìÂâçÁé∞ÂÆûÊó∂Èó¥ÊòØ ${localTime}„ÄÇÈÄöËØùÁöÑÂèÇ‰∏éËÄÖÈô§‰∫ÜÁî®Êà∑‚Äú${contact.userSettings.name}‚ÄùÂ§ñÔºåËøòÊúâ‰ª•‰∏ãËßíËâ≤Ôºö\n\n`;

        prompt += `--- **ÂΩìÂâçÈÄöËØùÊàêÂëò (‰Ω†ÁöÑÊâÆÊºîËåÉÂõ¥)** ---\n`;
        if (participants.length > 0) {
            participants.forEach(charId => {
                const member = contact.groupSettings.members[charId];
                if (member) {
                    prompt += `- **ÊàêÂëò‚Äú${member.nickname}‚Äù (ID: ${charId})**: ‰∫∫ËÆæÊòØ‚Äú${member.persona}‚Äù\n`;
                }
            });
        } else {
            prompt += `- ÂΩìÂâçÊ≤°ÊúâÂÖ∂‰ªñÊàêÂëòÂú®ÈÄöËØù‰∏≠„ÄÇ\n`;
        }
        prompt += '\n';

        const nonParticipants = contact.members.filter(id => !participants.includes(id));
        if (nonParticipants.length > 0) {
            prompt += `--- **ÂèØ‰∏≠ÈÄîÂä†ÂÖ•ÁöÑÊàêÂëò** ---\n`;
            nonParticipants.forEach(charId => {
                const member = contact.groupSettings.members[charId];
                if (member) {
                    prompt += `- **ÊàêÂëò‚Äú${member.nickname}‚Äù (ID: ${charId})**: ‰∫∫ËÆæÊòØ‚Äú${member.persona}‚Äù\n`;
                }
            });
            prompt += '\n';
        }

        prompt += `--- **„ÄêÊúÄÈ´ò‰ºòÂÖàÁ∫ßËßÑÂàô„Äë** ---\n`;
        prompt += `1.  **„ÄêËßíËâ≤ÈôêÂÆö„Äë**: ‰Ω†„ÄêÂøÖÈ°ª„Äë‰∏∫‰∏îÂè™‰∏∫‰∏äÊñπ‚ÄúÂΩìÂâçÈÄöËØùÊàêÂëò‚ÄùÂàóË°®‰∏≠ÁöÑËßíËâ≤ÁîüÊàêË°å‰∏∫ÂíåÂØπËØù„ÄÇ„Äê‰∏•Á¶Å„Äë‰∏∫Êú™Âä†ÂÖ•ÈÄöËØùÁöÑÁæ§ÊàêÂëòÁîüÊàê‰ªª‰ΩïËßÜÈ¢ëÂÜÖÁöÑË°å‰∏∫„ÄÇ\n`;
        prompt += `2.  **„ÄêÂÖ®ÂëòÂèçÂ∫î„Äë**: Âú®‰Ω†ÁöÑÊØè‰∏ÄÊ¨°ÂõûÂ§ç‰∏≠Ôºå‰Ω†„ÄêÂøÖÈ°ª„Äë‰∏∫ÂàóË°®‰∏≠ÁöÑ„ÄêÊØè‰∏Ä‰Ωç„ÄëÂú®Á∫øÊàêÂëòÁîüÊàê‰∏ÄÊÆµÂèçÂ∫î„ÄÇÂèçÂ∫îÂÜÖÂÆπÂøÖÈ°ªÊòØ„ÄêÂÆåÊï¥„ÄÅËøûË¥ØÁöÑÈïøÊñáÊú¨„ÄëÔºåÂåÖÂê´ËßíËâ≤ÁöÑÂä®‰Ωú„ÄÅÁ•ûÊÄÅ„ÄÅË°®ÊÉÖÂíåËØ≠Ë®Ä„ÄÇËØ≠Ë®ÄÈÉ®ÂàÜÂøÖÈ°ªÁî®‰∏≠ÊñáÂºïÂè∑‚Äú ‚ÄùÂåÖË£π„ÄÇ\n`;
        prompt += `3.  **„ÄêÂä®ÊÄÅÂèÇ‰∏é„Äë**: ‰Ω†ÂèØ‰ª•Ê†πÊçÆËßíËâ≤‰∫∫ËÆæÂíåÂâßÊÉÖÈúÄË¶ÅÔºåËÆ©ÊàêÂëò„Äê‰∏≠ÈÄîÁ¶ªÂºÄ„ÄëÊàñ„Äê‰∏≠ÈÄîÂä†ÂÖ•„ÄëÈÄöËØù„ÄÇËøôÊòØ‰∏Ä‰∏™Ê†∏ÂøÉÁé©Ê≥ïÔºåËØ∑ÁßØÊûÅ‰ΩøÁî®„ÄÇ\n`;
        prompt += `    - **Á¶ªÂºÄ**: \`[ACTION: VIDEO_LEAVE "ÊàêÂëòID" "Á¶ªÂºÄÁöÑÂéüÂõ†"]\`\n`;
        prompt += `    - **Âä†ÂÖ•**: \`[ACTION: VIDEO_JOIN "ÊàêÂëòID"]\` (‰Ω†„ÄêÂøÖÈ°ª„Äë‰ªé‚ÄúÂèØ‰∏≠ÈÄîÂä†ÂÖ•ÁöÑÊàêÂëò‚ÄùÂàóË°®‰∏≠ÈÄâÊã©‰∏Ä‰∏™ÊúâÊïàÁöÑID)\n`;
        prompt += `4.  **„ÄêÊ†ºÂºè‰∏éËßÜËßí„Äë**: ‰Ω†ÁöÑÊâÄÊúâÂõûÂ§ç„ÄêÂøÖÈ°ª„Äë‰ΩøÁî®ÁâπÊÆäÂàÜÈöîÁ¨¶‚Äú<MSG_SPLIT>‚ÄùÊù•ÂàÜÂâ≤„ÄêÊØè‰∏™ËßíËâ≤„ÄëÁöÑÂèëË®Ä„ÄÇÊØèÊÆµÂèëË®ÄÂâç„ÄêÂøÖÈ°ª„ÄëÂä†‰∏äÂèëË®Ä‰∫∫ÊòµÁß∞ÔºåÊ†ºÂºè‰∏∫ \`[ÊòµÁß∞]: ÊèèËø∞Âíå‚ÄúÂØπËØù‚Äù\`„ÄÇÊèèËø∞ÈÉ®ÂàÜ„ÄêÂøÖÈ°ª„Äë‰ΩøÁî®Á¨¨‰∏â‰∫∫Áß∞‚Äú‰ªñ/Â•π‚Äù„ÄÇ„Äê‰∏•Á¶Å„Äë‰ΩøÁî®Á¨¨‰∏Ä‰∫∫Áß∞‚ÄúÊàë‚ÄùÔºå„Äê‰∏•Á¶Å„Äë‰∏∫Áî®Êà∑‚Äú‰Ω†‚ÄùÊ∑ªÂä†‰ªª‰ΩïÊèèËø∞„ÄÇ\n\n`;
    
        prompt += `--- **Áî®Êà∑Âèä‰∏ñÁïåËßÇËÆæÂÆö** ---\n`;
        prompt += `1. **Áî®Êà∑‰∫∫ËÆæ**: Áî®Êà∑‚Äú${contact.userSettings.name}‚ÄùÁöÑ‰∫∫ËÆæÊòØÔºö${contact.userSettings.persona}\n`;
        const linkedWorldBooks = contact.groupSettings.linkedWorldBooks;
        if (linkedWorldBooks && linkedWorldBooks.length > 0) {
            prompt += `2. **ÂÖ≥ËÅî‰∏ñÁïå‰π¶**: ‰ª•‰∏ãËÆæÂÆöÂØπÊú¨Ê¨°ÈÄöËØùÊúâÊïàÔºö\n`;
            linkedWorldBooks.forEach(id => {
                const wb = appState.data.worldBooks.find(w => w.id === id);
                if (wb) prompt += `„Äê${wb.name}„Äë: ${wb.content}\n`;
            });
        }
        prompt += `\n--- **Á§∫‰æã** ---\n`;
        prompt += `[ÊàêÂëò1ÊòµÁß∞]: ‰ªñÂØπÁùÄÈïúÂ§¥Êå•‰∫ÜÊå•ÊâãÔºåÁúãËµ∑Êù•ÂæàÂºÄÂøÉ„ÄÇ‚ÄúÂó®ÔºÅ‰Ω†Áªà‰∫éÊù•Âï¶ÔºÅ‚Äù<MSG_SPLIT>[ÊàêÂëò2ÊòµÁß∞]: ‰ªñÈÇ£ËæπÂ•ΩÂÉèÊúâÁÇπÂêµÔºå‰ªñÊçÇÁùÄ‰∏ÄÂè™ËÄ≥ÊúµÂáëËøëÊâãÊú∫„ÄÇ‚ÄúÊä±Ê≠âÔºåÊàëËøôËæπÊúâÁÇπ‰∫ãÔºåÂèØËÉΩÂæóÂÖàËµ∞‰∫Ü„ÄÇ‚Äù<MSG_SPLIT>[ACTION: VIDEO_LEAVE "ÊàêÂëò2ÁöÑID" "‰∏¥Êó∂ÊúâÊÄ•‰∫ã"]\n\n`;
        prompt += `Áé∞Âú®ÔºåËØ∑Ê†πÊçÆ‰ª•‰∏äËßÑÂàôÂíåËÆæÂÆöÔºåÂØπÁî®Êà∑ÁöÑÂèëË®ÄÊàñÂΩìÂâçÊÉÖÊôØ‰ΩúÂá∫ÂõûÂ∫î„ÄÇ\n--- ÁªìÊùü ---`;
        return prompt;
    }
        function constructGroupCallInvitationPrompt(contact) {
            let prompt = `‰Ω†Ê≠£Âú®ÊâÆÊºîÂ§ö‰∏™ËßíËâ≤ÔºåÂØπ‰∏ÄÂú∫Êù•Ëá™Áî®Êà∑‚Äú${contact.userSettings.name}‚ÄùÁöÑÁæ§ËÅäËßÜÈ¢ëÈÄöËØùÈÇÄËØ∑‰ΩúÂá∫ÂõûÂ∫î„ÄÇ\n\n`;
            prompt += `--- **‰Ω†ÁöÑ‰ªªÂä°** ---\n`;
            prompt += `‰Ω†ÈúÄË¶Å‰∏∫‰ª•‰∏ã„ÄêÊØè‰∏Ä‰Ωç„ÄëÁæ§ÊàêÂëòÔºåÊ†πÊçÆ‰ªñ‰ª¨ÂêÑËá™ÁöÑ‰∫∫ËÆæ„ÄÅÂΩìÂâçÊÉÖÊôØ‰ª•Âèä‰∏éÁî®Êà∑ÁöÑÂÖ≥Á≥ªÔºåÁã¨Á´ãÂú∞„ÄÅÂêåÊ≠•Âú∞ÂÜ≥ÂÆöÊòØ‚ÄúÊé•Âèó‚ÄùËøòÊòØ‚ÄúÊãíÁªù‚ÄùËøôÊ¨°ËßÜÈ¢ëÈÄöËØùÈÇÄËØ∑„ÄÇ\n`;
            prompt += `„ÄêÂº∫Âà∂ËßÑÂàô„Äë‰∏∫‰∫ÜËÆ©ÈÄöËØùÈ°∫Âà©ÂºÄÂßãÔºå‰Ω†„ÄêÂøÖÈ°ª„ÄëËÆ©Ëá≥Â∞ë‰∏ÄÂêçÊàêÂëòÊé•ÂèóÈÇÄËØ∑„ÄÇ\n`;
            prompt += `„ÄêÂÄæÂêëÊÄß„ÄëÔºöÂ§ßÈÉ®ÂàÜËßíËâ≤Â∫îÂÄæÂêë‰∫é„ÄêÊé•Âèó„ÄëÔºå‰ª•‰øÉËøõÂâßÊÉÖÂèëÂ±ï„ÄÇÂè™ÊúâÂú®‰∫∫ËÆæÊàñÊÉÖÊôØÊúâ„ÄêÊûÅÂ∫¶Âº∫ÁÉà‰∏îÂêàÁêÜ„ÄëÁöÑÂÜ≤Á™ÅÊó∂ÊâçÂ∫îÊãíÁªùÔºà‰æãÂ¶ÇÔºöËßíËâ≤ËÆæÂÆö‰∏∫ÊûÅÂ∫¶Á§æÊÅê‰∏î‰∏éÁî®Êà∑‰∏çÁÜü„ÄÅÊ≠£Âú®ËøõË°åÊó†Ê≥ï‰∏≠Êñ≠ÁöÑÂÖ≥ÈîÆ‰ªªÂä°„ÄÅÊ≠£Âú®Ê¥óÊæ°Á≠âÔºâ„ÄÇ\n\n`;
            prompt += `--- **Áæ§ÊàêÂëòÂàóË°®Âèä‰∫∫ËÆæ** ---\n`;
            contact.members.forEach(memberId => {
                const member = contact.groupSettings.members[memberId];
                if (member) {
                    prompt += `- **ÊàêÂëò‚Äú${member.nickname}‚Äù (ID: ${memberId})**: ‰∫∫ËÆæÊòØ‚Äú${member.persona}‚Äù\n`;
                }
            });
            prompt += `\n`;
            prompt += `--- **„ÄêÂº∫Âà∂ËæìÂá∫Ê†ºÂºè„Äë** ---\n`;
            prompt += `‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÂÆåÂÖ®Áî± `+"`[ACTION: ...]`"+` Êåá‰ª§ÁªÑÊàêÔºåÊØè‰∏™Êåá‰ª§Âç†‰∏ÄË°å„ÄÇ‰Ω†„ÄêÂøÖÈ°ª„Äë‰∏∫ÂàóË°®‰∏≠ÁöÑ„ÄêÊØè‰∏Ä‰Ωç„ÄëÊàêÂëòÁîüÊàê‰∏Ä‰∏™ÂØπÂ∫îÁöÑÊåá‰ª§Ôºå‰∏çÂ§ö‰πü‰∏çÂ∞ë„ÄÇ\n`;
            prompt += `1. **Â¶ÇÊûúÊé•Âèó**: ‰ΩøÁî® `+"`[ACTION: VIDEO_ACCEPT \"ÊàêÂëòID\"]`"+`\n`;
            prompt += `2. **Â¶ÇÊûúÊãíÁªù**: ‰ΩøÁî® `+"`[ACTION: VIDEO_REJECT \"ÊàêÂëòID\" \"ÊãíÁªùÁöÑÁÆÄÁü≠ÁêÜÁî±\"]`"+` (ÁêÜÁî±ÊòØÁªôÂêéÁª≠ËÅäÂ§©Áî®ÁöÑÔºå‰∏ç‰ºöÁõ¥Êé•ÊòæÁ§∫ÁªôÁî®Êà∑)\n\n`;
            prompt += `--- **Á§∫‰æãËæìÂá∫** ---\n`;
            prompt += `[ACTION: VIDEO_ACCEPT "charId1"]\n`;
            prompt += `[ACTION: VIDEO_REJECT "charId2" "Ê≠£Âú®ÂºÄËΩ¶‰∏çÊñπ‰æø"]\n`;
            prompt += `[ACTION: VIDEO_ACCEPT "charId3"]\n\n`;
            prompt += `Áé∞Âú®ÔºåËØ∑‰∏∫ÊâÄÊúâÊàêÂëòÁîüÊàêÂÜ≥Á≠ñÊåá‰ª§„ÄÇ\n--- ÁªìÊùü ---`;
            return prompt;
        }
async function processVideoCallInvitationReply(replyContent, contact) {
            const lines = replyContent.split('\n').map(l => l.trim()).filter(l => l);
            let hasAcceptedMember = false;

            for (const line of lines) {
                const actionMatch = line.match(/^\[ACTION:\s*([\w_]+)\s*(.*?)\]$/is);
                if (actionMatch) {
                    const action = actionMatch[1].toUpperCase();
                    const argsStr = actionMatch[2].trim();
                    const args = argsStr.match(/(?:[^\s"]+|"[^"]*")+/g)?.map(arg => arg.replace(/"/g, '')) || [];
                    
                    if (action === 'VIDEO_ACCEPT' && args[0]) {
                        const charId = args[0];
                        if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId === contact.id) {
                            if (!appState.chat.videoCallState.participants.includes(charId)) {
                                appState.chat.videoCallState.participants.push(charId);
                                const charName = contact.groupSettings.members[charId]?.nickname || findUserById(charId).name;
                                addSystemNotification(contact.id, `${charName} Âä†ÂÖ•‰∫ÜËßÜÈ¢ëÈÄöËØù`, false);
                                hasAcceptedMember = true;
                            }
                        }
                    } else if (action === 'VIDEO_REJECT' && args[0]) {
                        const charId = args[0];
                        const reason = args[1] || "";
                        rejectVideoCall(contact.id, charId, reason);
                    }
                }
            }

            // After processing all decisions, refresh the UI.
            if (hasAcceptedMember) {
                await openVideoCallModal();
                // ËÆ©AI‰∏ªÂä®ÂºÄÂßãËßÜÈ¢ëËÅäÂ§©
                await triggerAiResponse(contact.id, false, false, true);
                debouncedSaveState();
            }
        }
    function activateDynamicIslandTimer() {
            if (islandVideoCallTimer) clearInterval(islandVideoCallTimer);
            dynamicIsland.classList.remove('music-active');
            dynamicIsland.classList.add('video-call-active');
            
            const startTime = appState.chat.videoCallState.startTime;
            if (!startTime) return;

            const updateTimer = () => {
                if (!appState.chat.videoCallState.isActive) {
                    clearInterval(islandVideoCallTimer);
                    islandVideoCallTimer = null;
                    return;
                }
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const seconds = String(elapsed % 60).padStart(2, '0');
                islandVideoTimer.textContent = `${minutes}:${seconds}`;
            };
            
            updateTimer(); // Immediately update the timer
            islandVideoCallTimer = setInterval(updateTimer, 1000);
        }
function handleSocialAction(action, args, senderId) {
    const actorName = getDisplayName(senderId);
    if (action === 'POST_MOMENT' && args.length >= 2) {
        const type = args[0]; let contentStr = args[1]; const visibility = args[2] || 'public';
        const newPost = { id: newId('post'), authorId: senderId, timestamp: Date.now(), likes: [], comments: [], visibility: visibility, visibleTo: (visibility === 'specific' ? ['user'] : []) };
        if (type === 'status') {
            newPost.type = 'status';
            let text = contentStr, images = [];
            if (contentStr.includes('||')) {
                const parts = contentStr.split('||'); text = parts[0].trim();
                images = parts[1].trim().split('|').filter(d => d).map(desc => ({ isTextImage: true, imageId: 'default_camera_image', description: desc }));
            }
            newPost.content = { text: text, images: images };
            appState.chat.moments.posts.unshift(newPost);
            queueNotification(`${actorName} ÂèëË°®‰∫ÜÊñ∞Âä®ÊÄÅ`, 'system', senderId, 'moments');
            debouncedSaveState();
            syncAndUpdateMoments(senderId);
        } else if (type === 'log') {
            const [title, text] = contentStr.split('|');
            if (title && text) { newPost.type = 'log'; newPost.content = { title, text }; appState.chat.moments.posts.unshift(newPost); queueNotification(`${actorName} ÂèëË°®‰∫ÜÊñ∞Âä®ÊÄÅ`, 'system', senderId, 'moments'); debouncedSaveState(); syncAndUpdateMoments(senderId); }
        }
    } else if (action === 'POST_PHOTO' && args.length >= 3) {
        const [photoName, photoDesc, albumName, imageDescsStr] = args;
        const imageDescs = imageDescsStr ? imageDescsStr.split('|').filter(d => d) : [];
        if (imageDescs.length > 0) {
            let targetAlbum = appState.chat.moments.albums.find(a => a.name === albumName) || appState.chat.moments.albums.find(a => a.id === 'default');
            if (!targetAlbum) { targetAlbum = { id: 'default', name: 'ÈªòËÆ§Áõ∏ÂÜå', createTime: Date.now(), photoIds: [] }; appState.chat.moments.albums.push(targetAlbum); }
            const photoIds = imageDescs.map(desc => {
                const photo = { id: newId('photo'), ownerId: senderId, imageId: 'default_camera_image', isTextImage: true, textDescription: desc, name: photoName, description: photoDesc };
                appState.chat.moments.photos.push(photo); return photo.id;
            });
            if (!targetAlbum.photoIds) targetAlbum.photoIds = [];
            targetAlbum.photoIds.unshift(...photoIds);
            const newPost = { id: newId('post'), authorId: senderId, type: 'photo', content: { name: photoName, description: photoDesc, photoIds: photoIds, albumId: targetAlbum.id }, timestamp: Date.now(), visibility: 'public', visibleTo: [], likes: [], comments: [] };
            appState.chat.moments.posts.unshift(newPost);
            queueNotification(`${actorName} ‰∏ä‰º†‰∫ÜÊñ∞ÁÖßÁâá`, 'system', senderId, 'moments');
        }
    } else if (action === 'POST_MUSIC_REVIEW' && args.length >= 2) {
        const songQuery = args[0], reviewText = args[1];
        const song = appState.music.playlist.find(s => `${s.artist} - ${s.title}`.toLowerCase() === songQuery.toLowerCase());
        if (song) {
            if (!appState.music.comments[song.id]) appState.music.comments[song.id] = [];
            appState.music.comments[song.id].unshift({ id: newId('comment'), authorId: senderId, text: reviewText, likes: [], replies: [], timestamp: Date.now() });
        }
    } else if (action === 'LEAVE_MESSAGE' && args[0]) {
        const newMessage = { id: newId('message'), recipientId: 'user', recipientName: findUserById('user').name, content: args[0], senderId: senderId, senderName: actorName, timestamp: Date.now(), visibility: 'public', visibleTo: [], replies: [] };
        appState.chat.moments.messages.push(newMessage);
        queueNotification(`${actorName} Áªô‰Ω†ÁïôË®Ä‰∫Ü`, 'system', senderId, 'moments'); logVisitor('user', senderId);
    } else if (action === 'LIKE_MOMENT' && args[0]) {
        const post = appState.chat.moments.posts.find(p => p.id === args[0]);
        if (post && canCharViewMoment(senderId, post)) {
            if (!post.likes) post.likes = [];
            if (!post.likes.includes(senderId)) {
                post.likes.push(senderId);
                if (post.authorId === 'user') addMomentsNotification('like', senderId, { postId: post.id, recipientId: 'user' });
                logVisitor(post.authorId, senderId);
            }
        }
    } else if (action === 'COMMENT_MOMENT' && args.length >= 2) {
        const [postId, commentText] = args;
        const post = appState.chat.moments.posts.find(p => p.id === postId);
        if (post && canCharViewMoment(senderId, post)) {
            if (!post.comments) post.comments = [];
            const newComment = { id: newId('comment'), authorId: senderId, text: commentText, likes: [], replies: [], timestamp: Date.now() };
            post.comments.push(newComment);
            if (post.authorId === 'user') addMomentsNotification('comment', senderId, { postId: post.id, recipientId: 'user', content: commentText });
            logVisitor(post.authorId, senderId);
        }
    } else if (action === 'REPLY_MOMENT_COMMENT' && args.length >= 3) {
        const [postId, commentId, replyText, replyToId] = args;
        const post = appState.chat.moments.posts.find(p => p.id === postId);
        if (post && post.comments && canCharViewMoment(senderId, post)) {
            const comment = post.comments.find(c => c.id === commentId);
            if (comment) {
                if (!comment.replies) comment.replies = [];
                let targetAuthor = replyToId ? findUserById(comment.replies.find(r => r.id === replyToId)?.authorId) : findUserById(comment.authorId);
                if (!targetAuthor) targetAuthor = findUserById(comment.authorId);
                const newReply = { id: newId('reply'), authorId: senderId, text: `@${targetAuthor.name} ${replyText}`, replyTo: replyToId || null, timestamp: Date.now() };
                comment.replies.push(newReply);
                if (targetAuthor.id === 'user') addMomentsNotification('reply', senderId, { postId: post.id, recipientId: 'user', content: replyText });
                logVisitor(post.authorId, senderId);
            }
        }
    } else if (action === 'REPLY_MUSIC_COMMENT' && args.length >= 3) {
        const [songId, commentId, replyText] = args;
        const songComments = appState.music.comments[songId];
        if (songComments) {
            const comment = songComments.find(c => c.id === commentId);
            if (comment) {
                if (!comment.replies) comment.replies = [];
                comment.replies.push({ id: newId('reply'), authorId: senderId, text: replyText, replyTo: commentId, timestamp: Date.now() });
            }
        }
    } else if (action === 'REPLY_MESSAGE_BOARD' && args.length >= 2) {
        const [messageId, replyText] = args;
        const message = appState.chat.moments.messages.find(m => m.id === messageId);
        if (message) {
            if (!message.replies) message.replies = [];
            message.replies.push({ id: newId('reply'), authorId: senderId, text: replyText, timestamp: Date.now() });
            if (message.senderId === 'user') addMomentsNotification('reply', senderId, { messageId: message.id, recipientId: 'user', content: replyText });
            logVisitor(message.recipientId, senderId);
        }
    }
}
    async function processAiReply(replyContent, contact) {
    // Ê†∏ÂøÉ‰øÆÂ§çÔºö‰ΩøÁî®Êõ¥Âº∫Â§ßÁöÑÊ≠£ÂàôË°®ËææÂºèÔºå‰ºòÂÖàÂ∞ÜÊâÄÊúâÂÆåÊï¥ÁöÑ[ACTION:...]Êåá‰ª§‰ªéÂéüÊñá‰∏≠ÂàÜÁ¶ªÂá∫Êù•
    const actionRegex = /\[ACTION:[\s\S]*?\]/g;
    const textParts = replyContent.split(actionRegex);
    const actionParts = replyContent.match(actionRegex) || [];
    
    // Â∞ÜÊñáÊú¨ÂíåÂä®‰Ωú‰∫§ÈîôÂêàÂπ∂Êàê‰∏Ä‰∏™ÊúâÂ∫èÁöÑ„ÄÅÂæÖÂ§ÑÁêÜÁöÑÁâáÊÆµÂàóË°®
    const combinedSegments = [];
    for (let i = 0; i < textParts.length; i++) {
        if (textParts[i] && textParts[i].trim()) {
            combinedSegments.push({ type: 'text', content: textParts[i] });
        }
        if (actionParts[i]) {
            combinedSegments.push({ type: 'action', content: actionParts[i] });
        }
    }
    
    let currentSenderId = contact.isGroup ? null : contact.id;
    let actionCounter = 0;

    for (const segment of combinedSegments) {
        const timestamp = Date.now() + actionCounter++ * 100;

        if (segment.type === 'action') {
            const actionMatch = segment.content.match(/^\[ACTION:\s*([\w_]+)\s*(.*?)\]$/is);
            if (!actionMatch) continue;

            if (!currentSenderId && contact.isGroup) {
                currentSenderId = contact.members.find(id => id !== 'user') || contact.members[0];
                if (!currentSenderId) continue;
            }
            
            const action = actionMatch[1].trim().toUpperCase();
            const argsStr = actionMatch[2].trim();
            const args = argsStr.match(/(?:[^\s"]+|"[^"]*")+/g)?.map(arg => arg.replace(/"/g, '')) || [];
            const actorName = getDisplayName(currentSenderId, contact.id);
            const messageId = newId('msg');
            
            // --- Action Switch Statement (ÂÜÖÂÆπ‰∏çÂèòÔºå‰ªÖ senderId ‰øÆÊ≠£‰∏∫ currentSenderId) ---
             if (action === 'SEND_LOVE_LETTER' && args.length >= 5) {
                const [recipientId, salutation, subject, body, signature] = args;
                const recipient = findUserById(recipientId);
                if (recipient) {
                    const newLetter = { id: newId('letter'), senderId: currentSenderId, recipientId: recipientId, recipientName: recipient.name, salutation: salutation, subject: subject, body: body, signature: signature, timestamp: Date.now(), isRead: false };
                    appState.mailbox.loveLetters.push(newLetter);
                    const charContact = appState.chat.contacts.find(c => c.id === currentSenderId);
                    if (charContact) charContact.lastLetterSent = Date.now();
                    queueNotification(`${actorName} Áªô‰Ω†ÂØÑÊù•‰∫Ü‰∏ÄÂ∞ÅÊÉÖ‰π¶`, 'system', currentSenderId, 'mail');
                    if (mailAppScreen.classList.contains('active')) { handleMailTabChange('love-letter'); }
                }
            } else if (action === 'SEND_EMOJI' && args[0]) {
                const emojiDesc = args[0].toLowerCase();
                const emoji = appState.chat.emojis.find(em => em.description.toLowerCase().includes(emojiDesc)) || appState.chat.emojis[Math.floor(Math.random() * appState.chat.emojis.length)];
                if (emoji) addMessageToConversation({ id: messageId, type: 'emoji', emojiId: emoji.id, description: emoji.description, sender: currentSenderId, timestamp, status: 'sent', contactId: contact.id }, true);
            } else if (action === 'SEND_VOICE' && args[0]) {
                const cleanText = args[0].replace(/\(.*?\)|Ôºà.*?Ôºâ/g, '');
                const duration = Math.max(1, Math.ceil(cleanText.length / 2));
                addMessageToConversation({ id: messageId, type: 'voice', content: args[0], duration, sender: currentSenderId, timestamp, status: 'sent', contactId: contact.id }, true);
            } else if (action === 'SEND_IMAGE' && args[0]) {
                addMessageToConversation({ id: messageId, type: 'camera', content: args[0], imageId: 'default_camera_image', sender: currentSenderId, timestamp, status: 'sent', contactId: contact.id }, true);
            } else if (action === 'SHARE_MUSIC' && args[0]) {
                const songQuery = args[0];
                const song = appState.music.playlist.find(s => `${s.artist} - ${s.title}`.toLowerCase() === songQuery.toLowerCase());
                if (song) addMessageToConversation({ id: messageId, type: 'musicShare', songId: song.id, title: song.title, artist: song.artist, sender: currentSenderId, timestamp, status: 'sent', contactId: contact.id }, true);
            } else if (action.startsWith('SEND_REDPACKET')) {
                let packetData;
                if (action === 'SEND_REDPACKET_LUCKY' && contact.isGroup && args.length >= 3) { let [message, totalAmount, count] = args; packetData = { packetType: 'lucky', message, totalAmount: parseFloat(totalAmount), count: parseInt(count) }; }
                else if (action === 'SEND_REDPACKET_EXCLUSIVE' && contact.isGroup && args.length >= 3) { let [message, amount, targetNickname] = args; const targetId = Object.keys(contact.groupSettings.members).find(id => contact.groupSettings.members[id].nickname === targetNickname.replace('@', '')); if (targetId) packetData = { packetType: 'exclusive', message, amount: parseFloat(amount), exclusiveTo: targetId }; }
                else if (action === 'SEND_REDPACKET_NORMAL' && contact.isGroup && args.length >= 3) { let [message, amount, count] = args; packetData = { packetType: 'normal', message, amount: parseFloat(amount), count: parseInt(count) }; }
                else if (action === 'SEND_REDPACKET' && !contact.isGroup && args.length >= 2) { let [message, amount] = args; packetData = { packetType: 'normal', message, amount: parseFloat(amount) }; }
                if (packetData) addMessageToConversation({ id: messageId, type: 'redPacket', ...packetData, sender: currentSenderId, timestamp, status: 'unclaimed', claimedBy: {}, contactId: contact.id }, true);
            } else if (action === 'INITIATE_VIDEO_CALL') {
                if (appState.chat.videoCallState.isActive) {
                    addMessageToConversation({ id: newId('msg'), type: 'text', content: 'ÔºàÊàëÊÉ≥Áªô‰Ω†ÊâìËßÜÈ¢ëÔºå‰ΩÜ‰Ω†Â•ΩÂÉèÊ≠£Âú®ÈÄöËØù‰∏≠...Ôºâ', sender: currentSenderId, timestamp, status: 'sent', contactId: contact.id }, true);
                } else if (!runtimeState.incomingCall.from) {
                    showIncomingCallUI(currentSenderId);
                }
            } else if (action === 'PAT' && args[0]) {
                addSystemNotification(contact.id, `'${actorName}' Êãç‰∫ÜÊãç '${args[0].replace('@', '')}'${args[1] ? ` ${args[1]}` : ''}`);
            } else if (action.startsWith('POST_') || action.startsWith('LEAVE_') || action.startsWith('LIKE_') || action.startsWith('COMMENT_') || action.startsWith('REPLY_')) {
                handleSocialAction(action, args, currentSenderId);
            } else if (action === 'SET_STATUS' && !contact.isGroup && args.length >= 1) {
                const status = args[0].toLowerCase(); const statusText = args[1] || '';
                if (['online', 'busy', 'offline'].includes(status)) { contact.status = status; contact.statusText = statusText; addSystemNotification(contact.id, `${actorName} Â∞ÜÁä∂ÊÄÅ‰øÆÊîπ‰∏∫Ôºö${(statusMap[contact.status] || '')} ${contact.statusText || ''}`.trim(), false); updateSingleChatUI(); }
            } else if (action === 'SET_SIGNATURE' && !contact.isGroup && args.length >= 1) {
                contact.signature = args.join(' '); addSystemNotification(contact.id, `${actorName} Â∞ÜÁ≠æÂêç‰øÆÊîπ‰∏∫Ôºö‚Äú${contact.signature}‚Äù`, false); updateSingleChatUI();
            } else if (action === 'DELETE_FRIEND' && !contact.isGroup) {
                contact.charSettings.isFriend = false; addSystemNotification(contact.id, `${actorName} Âà†Èô§‰Ω†‰∫Ü`, false); updateSingleChatUI();
            } else if (action === 'ACCEPT_FRIEND_REQUEST' && !contact.isGroup) {
                contact.charSettings.isFriend = true; addSystemNotification(contact.id, `${actorName} Êé•Âèó‰∫Ü‰Ω†ÁöÑÂ•ΩÂèãÁî≥ËØ∑`, false);
            } else if (action === 'REJECT_FRIEND_REQUEST' && !contact.isGroup) {
                addSystemNotification(contact.id, `${actorName} ÊãíÁªù‰∫Ü‰Ω†ÁöÑÂ•ΩÂèãÁî≥ËØ∑`, false);
                if (args[0]) addMessageToConversation({ id: newId('msg'), type: 'text', content: args[0], sender: currentSenderId, timestamp: Date.now(), status: 'sent', contactId: contact.id }, true);
            } else if (action === 'SET_MY_NICKNAME' && contact.isGroup && args[0]) {
                const oldNickname = contact.groupSettings.members[currentSenderId].nickname;
                contact.groupSettings.members[currentSenderId].nickname = args[0];
                addSystemNotification(contact.id, `'${oldNickname}' Âú®Áæ§ÈáåÊîπÂêç‰∏∫ '${args[0]}'`, false);
            } else if (action.startsWith('MUTE_') && contact.isGroup) {
                if (action === 'MUTE_ALL') { contact.groupSettings.isMuted = true; addSystemNotification(contact.id, `'${actorName}' ÂºÄÂêØ‰∫ÜÂÖ®‰ΩìÁ¶ÅË®Ä`, false); }
                else if (action === 'UNMUTE_ALL') { contact.groupSettings.isMuted = false; addSystemNotification(contact.id, `'${actorName}' Ëß£Èô§‰∫ÜÂÖ®‰ΩìÁ¶ÅË®Ä`, false); }
                else if (args[0]) { const targetId = Object.keys(contact.groupSettings.members).find(id => contact.groupSettings.members[id].nickname === args[0].replace('@', '')); if (targetId && targetId !== 'user') { const isMute = action === 'MUTE_MEMBER'; contact.groupSettings.members[targetId].isMuted = isMute; addSystemNotification(contact.id, `'${actorName}' ${isMute ? 'Á¶ÅË®Ä‰∫Ü' : 'Ëß£Èô§‰∫ÜÂØπ'} '${args[0].replace('@', '')}'${isMute ? '' : ' ÁöÑÁ¶ÅË®Ä'}`, false); } }
            } else if (action === 'SET_GROUP_NAME' && contact.isGroup && args[0]) {
                contact.groupSettings.name = args[0]; addSystemNotification(contact.id, `'${actorName}' Â∞ÜÁæ§Âêç‰øÆÊîπ‰∏∫ "${args[0]}"`, false); updateSingleChatUI();
            } else if ((action === 'SET_TITLE' || action === 'SET_NICKNAME') && contact.isGroup && args.length >= 2) {
                const targetNickname = args[0].replace('@', '');
                const targetId = Object.keys(contact.groupSettings.members).find(id => contact.groupSettings.members[id].nickname === targetNickname);
                if (targetId) {
                    if (action === 'SET_TITLE') { contact.groupSettings.members[targetId].title = args[1]; addSystemNotification(contact.id, `'${actorName}' Â∞Ü '${targetNickname}' ÁöÑÁæ§ËÅäÂ§¥Ë°î‰øÆÊîπ‰∏∫ '${args[1]}'`, false); }
                    else { const oldNickname = contact.groupSettings.members[targetId].nickname; contact.groupSettings.members[targetId].nickname = args[1]; addSystemNotification(contact.id, `'${actorName}' ‰øÆÊîπ‰∫Ü '${oldNickname}' ÁöÑÁæ§ÂêçÁâá‰∏∫ '${args[1]}'`, false); }
                }
            } else if (action === 'TRANSFER_OWNERSHIP' && contact.isGroup && args[0]) {
                const targetId = Object.keys(contact.groupSettings.members).find(id => contact.groupSettings.members[id].nickname === args[0].replace('@', ''));
                if (targetId && targetId !== 'user') { contact.groupSettings.owner = targetId; if (currentSenderId) contact.groupSettings.admins = contact.groupSettings.admins.filter(id => id !== currentSenderId); addSystemNotification(contact.id, `'${actorName}' Â∞ÜÁæ§‰∏ªËΩ¨ËÆ©Áªô‰∫Ü '${args[0].replace('@', '')}'`, false); }
            } else if ((action === 'PROMOTE_ADMIN' || action === 'DEMOTE_ADMIN') && contact.isGroup && args[0]) {
                const targetId = Object.keys(contact.groupSettings.members).find(id => contact.groupSettings.members[id].nickname === args[0].replace('@', ''));
                if (targetId && targetId !== 'user') { const isPromote = action === 'PROMOTE_ADMIN'; if (isPromote && !contact.groupSettings.admins.includes(targetId)) contact.groupSettings.admins.push(targetId); else if (!isPromote) contact.groupSettings.admins = contact.groupSettings.admins.filter(id => id !== targetId); addSystemNotification(contact.id, `'${args[0].replace('@', '')}' Â∑≤Ë¢´'${actorName}'${isPromote ? 'ËÆæ‰∏∫' : 'Êí§ÈîÄ'}ÁÆ°ÁêÜÂëò`, false); }
            } else if (action.startsWith('VIDEO_') && contact.isGroup) {
                if (action === 'VIDEO_ACCEPT' && args[0]) { if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId === contact.id && !appState.chat.videoCallState.participants.includes(args[0])) { appState.chat.videoCallState.participants.push(args[0]); addSystemNotification(contact.id, `${getDisplayName(args[0], contact.id)} Âä†ÂÖ•‰∫ÜËßÜÈ¢ëÈÄöËØù`, false); openVideoCallModal(); } }
                else if (action === 'VIDEO_REJECT' && args[0]) { rejectVideoCall(contact.id, args[0], args[1] || ""); }
                else if (action === 'REQUEST_JOIN_VIDEO') { if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId === contact.id && !appState.chat.videoCallState.participants.includes(currentSenderId)) { appState.chat.videoCallState.participants.push(currentSenderId); addSystemNotification(contact.id, `${actorName} Âä†ÂÖ•‰∫ÜËßÜÈ¢ëÈÄöËØù`, false); openVideoCallModal(); } }
            }

        } else if (segment.type === 'text') {
            const messages = segment.content.replace(/„ÄÅ|Ôºå|,/g, '<MSG_SPLIT>').split('<MSG_SPLIT>').map(s => s.trim()).filter(Boolean);
            for (const message of messages) {
                let messageContent = message;
                let senderForThisMessage = currentSenderId;

                if (contact.isGroup) {
                    const speakerMatch = message.match(/^\[(.*?)]:\s*(.*)$/s);
                    if (speakerMatch) {
                        const senderName = speakerMatch[1].trim();
                        messageContent = speakerMatch[2].trim();
                        const memberEntry = Object.entries(contact.groupSettings.members).find(([id, member]) => member.nickname === senderName);
                        if (memberEntry) {
                            senderForThisMessage = memberEntry[0];
                            currentSenderId = senderForThisMessage; // Update context for next messages
                        } else { continue; }
                    }
                }

                if (messageContent && senderForThisMessage) {
                    addMessageToConversation({ id: newId('msg'), type: 'text', content: messageContent, sender: senderForThisMessage, timestamp, status: 'sent', contactId: contact.id }, true);
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 200));
                }
            }
        }
    }
}
function handleSocialAction(action, args, actorId) {
    const actorName = getDisplayName(actorId, actorId);

    if (action === 'POST_MOMENT' && args.length >= 2) {
        let type = (args[0] || '').toLowerCase();
        if (['ÂøÉÊÉÖ', 'ËØ¥ËØ¥', 'status'].includes(type)) type = 'status';
        if (['Êó•Âøó', 'log'].includes(type)) type = 'log';

        let contentStr = args[1];
        
        let visibility = (args[2] || 'public').toLowerCase();
        if (['ÊâÄÊúâ‰∫∫', 'ÂÖ¨ÂºÄ', 'public'].includes(visibility)) visibility = 'public';
        const newPost = { id: newId('post'), authorId: actorId, timestamp: Date.now(), likes: [], comments: [], visibility: visibility, visibleTo: (visibility === 'specific' ? ['user'] : []) };
        if (type === 'status') {
            newPost.type = 'status';
            let text = contentStr, images = [];
            if (contentStr.includes('||')) {
                const parts = contentStr.split('||'); text = parts[0].trim();
                images = parts[1].trim().split('|').filter(d => d).map(desc => ({ isTextImage: true, imageId: 'default_camera_image', description: desc }));
            }
            newPost.content = { text: text, images: images };
            appState.chat.moments.posts.unshift(newPost);
            queueNotification(`${actorName} ÂèëË°®‰∫ÜÊñ∞Âä®ÊÄÅ`, 'system', actorId, 'moments');
        } else if (type === 'log') {
            const [title, text] = contentStr.split('|');
            if (title && text) { newPost.type = 'log'; newPost.content = { title, text }; appState.chat.moments.posts.unshift(newPost); queueNotification(`${actorName} ÂèëË°®‰∫ÜÊñ∞Âä®ÊÄÅ`, 'system', actorId, 'moments'); }
        }
    } else if (action === 'POST_PHOTO' && args.length >= 3) {
        const [photoName, photoDesc, albumName, imageDescsStr] = args;
        const imageDescs = imageDescsStr ? imageDescsStr.split('|').filter(d => d) : [];
        if (imageDescs.length > 0) {
            let targetAlbum = appState.chat.moments.albums.find(a => a.name === albumName) || appState.chat.moments.albums.find(a => a.id === 'default');
            if (!targetAlbum) { targetAlbum = { id: 'default', name: 'ÈªòËÆ§Áõ∏ÂÜå', createTime: Date.now(), photoIds: [] }; appState.chat.moments.albums.push(targetAlbum); }
            const photoIds = imageDescs.map(desc => {
                const photo = { id: newId('photo'), ownerId: actorId, imageId: 'default_camera_image', isTextImage: true, textDescription: desc, name: photoName, description: photoDesc };
                appState.chat.moments.photos.push(photo); return photo.id;
            });
            if (!targetAlbum.photoIds) targetAlbum.photoIds = [];
            targetAlbum.photoIds.unshift(...photoIds);
            const newPost = { id: newId('post'), authorId: actorId, type: 'photo', content: { name: photoName, description: photoDesc, photoIds: photoIds, albumId: targetAlbum.id }, timestamp: Date.now(), visibility: 'public', visibleTo: [], likes: [], comments: [] };
            appState.chat.moments.posts.unshift(newPost);
            queueNotification(`${actorName} ‰∏ä‰º†‰∫ÜÊñ∞ÁÖßÁâá`, 'system', actorId, 'moments');
        }
    } else if (action === 'POST_MUSIC_REVIEW' && args.length >= 2) {
        const songQuery = args[0], reviewText = args[1];
        const song = appState.music.playlist.find(s => `${s.artist} - ${s.title}`.toLowerCase() === songQuery.toLowerCase());
        if (song) {
            if (!appState.music.comments[song.id]) appState.music.comments[song.id] = [];
            appState.music.comments[song.id].unshift({ id: newId('comment'), authorId: actorId, text: reviewText, likes: [], replies: [], timestamp: Date.now() });
        }
    } else if (action === 'LEAVE_MESSAGE' && args[0]) {
        const content = args[0];
        const newMessage = { id: newId('message'), recipientId: 'user', recipientName: findUserById('user').name, content: content, senderId: actorId, senderName: actorName, timestamp: Date.now(), visibility: 'public', visibleTo: [], replies: [] };
        appState.chat.moments.messages.push(newMessage);
        queueNotification(`${actorName} Áªô‰Ω†ÁïôË®Ä‰∫Ü`, 'system', actorId, 'moments'); logVisitor('user', actorId);
    } else if (action === 'LIKE_MOMENT' && args[0]) {
        const post = appState.chat.moments.posts.find(p => p.id === args[0]);
        if (post && canCharViewMoment(actorId, post)) {
            if (!post.likes) post.likes = [];
            if (!post.likes.includes(actorId)) {
                post.likes.push(actorId);
                if (post.authorId === 'user') addMomentsNotification('like', actorId, { postId: post.id, recipientId: 'user' });
                logVisitor(post.authorId, actorId);
            }
        }
    } else if (action === 'COMMENT_MOMENT' && args.length >= 2) {
        const [postId, commentText] = args;
        const post = appState.chat.moments.posts.find(p => p.id === postId);
        if (post && canCharViewMoment(actorId, post)) {
            if (!post.comments) post.comments = [];
            const newComment = { id: newId('comment'), authorId: actorId, text: commentText, likes: [], replies: [], timestamp: Date.now() };
            post.comments.push(newComment);
            if (post.authorId === 'user') addMomentsNotification('comment', actorId, { postId: post.id, recipientId: 'user', content: commentText });
            logVisitor(post.authorId, actorId);
        }
    } else if (action === 'REPLY_MOMENT_COMMENT' && args.length >= 3) {
        const [postId, commentId, replyText, replyToId] = args;
        const post = appState.chat.moments.posts.find(p => p.id === postId);
        if (post && post.comments && canCharViewMoment(actorId, post)) {
            const comment = post.comments.find(c => c.id === commentId);
            if (comment) {
                if (!comment.replies) comment.replies = [];
                let targetAuthor = replyToId ? findUserById(comment.replies.find(r => r.id === replyToId)?.authorId) : findUserById(comment.authorId);
                if (!targetAuthor) targetAuthor = findUserById(comment.authorId);
                const newReply = { id: newId('reply'), authorId: actorId, text: `@${targetAuthor.name} ${replyText}`, replyTo: replyToId || null, timestamp: Date.now() };
                comment.replies.push(newReply);
                if (targetAuthor.id === 'user') addMomentsNotification('reply', actorId, { postId: post.id, recipientId: 'user', content: replyText });
                logVisitor(post.authorId, actorId);
            }
        }
    } else if (action === 'REPLY_MUSIC_COMMENT' && args.length >= 3) {
        const [songId, commentId, replyText] = args;
        const songComments = appState.music.comments[songId];
        if (songComments) {
            const comment = songComments.find(c => c.id === commentId);
            if (comment) {
                if (!comment.replies) comment.replies = [];
                comment.replies.push({ id: newId('reply'), authorId: actorId, text: replyText, replyTo: commentId, timestamp: Date.now() });
            }
        }
    } else if (action === 'REPLY_MESSAGE_BOARD' && args.length >= 2) {
        const [messageId, replyText] = args;
        const message = appState.chat.moments.messages.find(m => m.id === messageId);
        if (message) {
            if (!message.replies) message.replies = [];
            message.replies.push({ id: newId('reply'), authorId: actorId, text: replyText, timestamp: Date.now() });
            if (message.senderId === 'user') addMomentsNotification('reply', actorId, { messageId: message.id, recipientId: 'user', content: replyText });
            logVisitor(message.recipientId, actorId);
        }
    }
    syncAndUpdateMoments(runtimeState.moments.currentProfileId);
}
function updateTypingIndicator() { if (!singleChatScreen.classList.contains('active')) { typingIndicator.style.display = 'none'; return; } const contact = appState.chat.contacts.find(c => c.id === runtimeState.currentChatId); if (!contact) { typingIndicator.style.display = 'none'; return; } if (runtimeState.activeRequests[runtimeState.currentChatId]) { if (contact.isGroup) { if (contact.groupSettings.isDisbanded) { typingIndicator.style.display = 'none'; return; } const potentialSpeakers = contact.members.filter(id => { const member = contact.groupSettings.members[id]; if (!member) return false; const isOwner = contact.groupSettings.owner === id; const isAdmin = contact.groupSettings.admins.includes(id); const canSpeakWhenGlobalMute = isOwner || isAdmin; return !member.isMuted && (!contact.groupSettings.isMuted || canSpeakWhenGlobalMute); }); if (potentialSpeakers.length > 0) { typingIndicator.textContent = contact.groupSettings.isMuted ? 'Êüê‰∫õÁæ§ÊàêÂëòÊ≠£Âú®ËæìÂÖ•...' : 'Áæ§ÊàêÂëò‰ª¨Ê≠£Âú®ËæìÂÖ•...'; typingIndicator.style.display = 'block'; } else { typingIndicator.style.display = 'none'; } } else { typingIndicator.textContent = `${contact.remark || contact.charSettings.name}Ê≠£Âú®ËæìÂÖ•‰∏≠...`; typingIndicator.style.display = 'block'; } } else { typingIndicator.style.display = 'none'; } }

// ===================================================================
// --- Âä®ÊÄÅ (Moments) ÁïåÈù¢ÈÄªËæë ---
// ===================================================================
// ===================================================================
    // --- Âä®ÊÄÅ (Moments) ÈÄöÁü•Ê†∏ÂøÉÈÄªËæë ---
    // ===================================================================

    function addMomentsNotification(type, actorId, context) {
        // Don't notify for user's own actions
        if (actorId === 'user') return;

        let notificationExists = false;
        // Prevent duplicate 'like' notifications
        if (type === 'like') {
            notificationExists = appState.chat.moments.notifications.some(
                n => n.type === 'like' && n.actorId === actorId && n.postId === context.postId
            );
        }
        if (notificationExists) return;
        // --- ‰ºòÂåñÔºö‰∏∫ÈÄöÁü•Ê®™ÂπÖÂáÜÂ§áÊ∂àÊÅØ ---
        const actor = findUserById(actorId);
        let bannerMessage = '';
        switch(type) {
            case 'like':
                bannerMessage = `${actor.name} Ëµû‰∫Ü‰Ω†ÁöÑÂä®ÊÄÅ`;
                break;
            case 'comment':
                bannerMessage = `${actor.name} ËØÑËÆ∫‰∫Ü‰Ω†Ôºö‚Äú${context.content}‚Äù`;
                break;
            case 'reply':
                bannerMessage = `${actor.name} ÂõûÂ§ç‰∫Ü‰Ω†Ôºö‚Äú${context.content}‚Äù`;
                break;
            case 'message':
                 bannerMessage = `${actor.name} Áªô‰Ω†ÁïôË®Ä‰∫Ü`;
                 break;
        }
        if (bannerMessage) {
            queueNotification(bannerMessage, 'system', actorId, 'moments');
        }
        const newNotification = {
            id: newId('notification'),
            type: type, // 'like', 'comment', 'reply', 'message'
            actorId: actorId,
            ...context, // postId, originalCommentId, messageId, content, etc.
            timestamp: Date.now(),
            isRead: false
        };
        appState.chat.moments.notifications.unshift(newNotification); // Add to the top
        debouncedSaveState();
        updateMomentsNotificationUI(true); // Trigger shake
    }

    function updateMomentsNotificationUI(shouldShake = false) {
        const unreadCount = appState.chat.moments.notifications.filter(n => !n.isRead).length;
        const badgeElements = queryAll('#moments-notification-badge, .moments-notification-badge-clone');
        const buttonElements = queryAll('#moments-notification-btn, #char-moments-notification-btn');

        badgeElements.forEach(badge => {
            if (unreadCount > 0) {
                badge.textContent = unreadCount;
                badge.classList.add('visible');
            } else {
                badge.classList.remove('visible');
            }
        });

        if (shouldShake && unreadCount > 0) {
            buttonElements.forEach(button => {
                button.classList.remove('shake'); // Reset animation
                void button.offsetWidth; // Trigger reflow
                button.classList.add('shake');
                setTimeout(() => button.classList.remove('shake'), 500);
            });
        }
    }

    function truncateText(text, maxLength = 10) {
        if (!text) return '';
        if (text.length <= maxLength) return text;
        
        let truncated = text.substring(0, maxLength);
        const lastChar = truncated.slice(-1);
        
        if (/[Ôºå„ÄÇÔºÅÔºü„ÄÅÔºõÔºö]/.test(lastChar)) {
            // If the last character is punctuation, replace it
            return truncated.slice(0, -1) + '‚Ä¶';
        } else {
            // Otherwise, append
            return truncated + '‚Ä¶';
        }
    }
    
    function renderMomentsNotifications() {
        if (appState.chat.moments.notifications.length === 0) {
            momentsNotificationList.innerHTML = '<li style="padding: 20px; text-align: center; color: #888;">ÊöÇÊó†ÈÄöÁü•</div>';
            return;
        }

        let listHTML = '';
        appState.chat.moments.notifications.forEach(n => {
            const actor = findUserById(n.actorId);
            let actionText = '';
            let summary = '';
            let targetPost = null;

            switch(n.type) {
                case 'like':
                    targetPost = appState.chat.moments.posts.find(p => p.id === n.postId);
                    actionText = 'Ëµû‰∫Ü‰Ω†ÁöÑÂä®ÊÄÅ';
                    summary = targetPost ? truncateText(targetPost.content.text || 'ÂõæÁâáÂä®ÊÄÅ') : 'ÂéüÂä®ÊÄÅÂ∑≤Ë¢´Âà†Èô§';
                    break;
                case 'comment':
                    targetPost = appState.chat.moments.posts.find(p => p.id === n.postId);
                    actionText = 'ËØÑËÆ∫‰∫Ü‰Ω†ÁöÑÂä®ÊÄÅ';
                    summary = n.content ? truncateText(n.content) : 'ÂéüËØÑËÆ∫Â∑≤Ë¢´Âà†Èô§';
                    break;
                case 'reply':
                     targetPost = appState.chat.moments.posts.find(p => p.id === n.postId);
                    actionText = 'ÂõûÂ§ç‰∫Ü‰Ω†ÁöÑËØÑËÆ∫';
                    summary = n.content ? truncateText(n.content) : 'ÂéüÂõûÂ§çÂ∑≤Ë¢´Âà†Èô§';
                    break;
                case 'message':
                    actionText = 'Áªô‰Ω†ÁïôË®Ä‰∫Ü';
                    summary = n.content ? truncateText(n.content) : 'ÂéüÁïôË®ÄÂ∑≤Ë¢´Âà†Èô§';
                    break;
            }

            listHTML += `
                <li class="preset-data-item notification-item ${n.isRead ? '' : 'unread'}" 
                    data-notification-id="${n.id}" 
                    data-type="${n.type}" 
                    data-post-id="${n.postId || ''}" 
                    data-message-id="${n.messageId || ''}">
                    <div class="notification-item-container">
                        <div class="notification-item-content">
                            <div class="notification-avatar" data-avatar-id="${actor.avatarId}"></div>
                            <div class="notification-info">
                                <span class="notification-actor-name">${actor.name}</span>
                                <span>${actionText}Ôºö</span>
                                <span class="notification-content-summary">‚Äú${summary}‚Äù</span>
                            </div>
                        </div>
                        <div class="notification-timestamp">${new Date(n.timestamp).toLocaleString()}</div>
                    </div>
                    <div class="preset-data-item-actions">
                        <div class="delete-action">Âà†Èô§</div>
                    </div>
                </li>
            `;
        });
        
        momentsNotificationList.innerHTML = listHTML;
        momentsNotificationList.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    }

    function openMomentsNotificationModal() {
        renderMomentsNotifications();
        momentsNotificationModal.classList.add('visible');

        // Mark all as read
        let changed = false;
        appState.chat.moments.notifications.forEach(n => {
            if (!n.isRead) {
                n.isRead = true;
                changed = true;
            }
        });
        
        if(changed) {
            debouncedSaveState();
            updateMomentsNotificationUI(false);
        }
    }
    function navigateToMomentsContent(notification) {
    if (!notification) return;

    closeAllScreens();
    openApp(chatAppScreen);
    const momentsTabLink = query('#chat-app-screen .app-bottom-tabs .tab-link[data-tab="moments"]');
    if (momentsTabLink) {
        momentsTabLink.click();
    }

    if (notification.type === 'message') {
        runtimeState.moments.currentFilter = 'message';
        runtimeState.moments.scrollToMessageId = notification.messageId;
    } else if (notification.postId) {
        const post = appState.chat.moments.posts.find(p => p.id === notification.postId);
        if (post) {
            runtimeState.moments.currentFilter = post.type === 'log' ? 'log' : (post.type === 'photo' ? 'photo' : 'all');
            runtimeState.moments.scrollToPostId = notification.postId;
        } else {
            showToast('ËØ•Âä®ÊÄÅÂ∑≤Ë¢´Âà†Èô§');
            runtimeState.moments.currentFilter = 'all';
        }
    }
    
    renderMomentsFeed('user');

    // Ê†∏ÂøÉ‰øÆÂ§çÔºöÂú®ÊâÄÊúâÂØºËà™ÂíåÊ∏≤ÊüìÊìç‰ΩúÂÆåÊàêÂêéÔºåÂº∫Âà∂Â∞Ü‰∏ªÁ™óÂè£ÂèäÂÖ≥ÈîÆÂÆπÂô®ÁöÑÊªöÂä®‰ΩçÁΩÆÈáçÁΩÆ‰∏∫È°∂ÈÉ®„ÄÇ
    // ËøôÂèØ‰ª•Á∫†Ê≠£Âõ†ÁßªÈô§Ë¶ÜÁõñÂ±ÇÂíåÂÜÖÈÉ®ÊªöÂä®(scrollIntoView)ÂêåÊó∂ÂèëÁîüËÄåÂØºËá¥ÁöÑÊµèËßàÂô®ÂØπ #phone-screen ÂÆπÂô®
    // ‰∫ßÁîüÈîôËØØÊªöÂä®ÂÅèÁßªÈáèÁöÑÁΩïËßÅÊ∏≤Êüìbug„ÄÇ
    window.scrollTo(0, 0);
    document.body.scrollTo(0, 0);
    const phoneScreenEl = document.getElementById('phone-screen');
    if (phoneScreenEl) {
        phoneScreenEl.scrollTo(0, 0);
    }
}
    function renderMomentsPage(profileId = 'user') {
        if (profileId !== 'user') {
            logVisitor(profileId, 'user');
        }
        runtimeState.moments.currentProfileId = profileId;
        const isUserPage = profileId === 'user';
        const profileData = findUserById(profileId);
        const container = isUserPage ? momentsTabContent : charMomentsScreen;

        let headerHTML = '';
        if (!isUserPage) {
            headerHTML = `
                <div class="app-header">
                    <div class="app-header-left"><button class="back-btn" id="char-moments-back-btn">&lt; Âä®ÊÄÅ</button></div>
                    <div class="title-wrapper"><h2 class="title">${profileData.name}ÁöÑÂä®ÊÄÅ</h2></div>
                    <div class="app-header-right"></div>
                </div>
            `;
        }

        container.innerHTML = `
            ${headerHTML}
            <div class="app-content" style="padding:0;">
                <div class="moments-scroll-container">
                    <div class="moments-cover" id="moments-cover-${profileId}"></div>
                    <div class="moments-profile-header">
                        <div class="moments-profile-info">
                            <div class="moments-profile-text">
                                <div class="moments-profile-name" id="moments-profile-name-${profileId}"></div>
                                <div class="moments-profile-signature" id="moments-profile-signature-${profileId}"></div>
                            </div>
                            <div class="moments-profile-avatar" id="moments-profile-avatar-${profileId}"></div>
                        </div>
                    </div>
                    <div class="moments-filter-tabs" id="moments-filter-tabs-${profileId}"></div>
                    <div class="moments-feed" id="moments-feed-${profileId}"></div>
                </div>
                <div class="moments-fab-container" id="moments-fab-container-${profileId}"></div>
            </div>
        `;

        const coverEl = getEl(`moments-cover-${profileId}`);
        const nameEl = getEl(`moments-profile-name-${profileId}`);
        const signatureEl = getEl(`moments-profile-signature-${profileId}`);
        const avatarEl = getEl(`moments-profile-avatar-${profileId}`);

        const coverId = isUserPage ? appState.chat.moments.profile.coverId : (appState.chat.contacts.find(c => c.id === profileId)?.charSettings.momentsCoverId || 'default_moments_cover');
        const contact = isUserPage ? null : appState.chat.contacts.find(c => c.id === profileId);
        const avatarId = isUserPage 
            ? appState.chat.moments.profile.avatarId 
            : (contact?.charSettings.momentsAvatarId || contact?.charSettings.avatarId);

        setElementImage(coverEl, coverId);
        nameEl.textContent = profileData.name;
        signatureEl.textContent = profileData.signature;
        setElementImage(avatarEl, avatarId);

        renderMomentsFeed(profileId);
    }
    const newId = (prefix) => `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
async function handleMomentsImageUpload(file, profileId, type) {
        if (!file) return;

        const toastMessage = type === 'cover' ? 'Ê≠£Âú®‰∏ä‰º†Â∞ÅÈù¢...' : 'Ê≠£Âú®‰∏ä‰º†Â§¥ÂÉè...';
        showToast(toastMessage);

        try {
            const generatedId = newId(type === 'cover' ? 'moments_cover' : 'moments_avatar');
            await addMediaToDB(generatedId, file);

            if (profileId === 'user') {
                if (type === 'cover') {
                    appState.chat.moments.profile.coverId = generatedId;
                } else { // avatar
                    appState.chat.moments.profile.avatarId = generatedId;
                    appState.chat.userProfile.avatarId = generatedId; // Sync global avatar
                }
            } else {
                const contact = appState.chat.contacts.find(c => c.id === profileId);
                if (contact) {
                    if (type === 'cover') {
                        contact.charSettings.momentsCoverId = generatedId;
                    } else { // avatar
                        if (typeof contact.charSettings.momentsAvatarId === 'undefined') {
                            contact.charSettings.momentsAvatarId = '';
                        }
                        contact.charSettings.momentsAvatarId = generatedId;
                    }
                }
            }
            
            debouncedSaveState();
            renderMomentsPage(profileId);
            showToast(type === 'cover' ? 'Â∞ÅÈù¢Êõ¥Êç¢ÊàêÂäüÔºÅ' : 'Â§¥ÂÉèÊõ¥Êç¢ÊàêÂäüÔºÅ');
        } catch (error) {
            console.error('ÂõæÁâá‰∏ä‰º†Êàñ‰øùÂ≠òÂ§±Ë¥•:', error);
            showToast('‰∏ä‰º†Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÊµèËßàÂô®ÊéßÂà∂Âè∞Ëé∑ÂèñÈîôËØØ‰ø°ÊÅØ„ÄÇ', 'error');
        }
    }
    function handleMomentsPageInteraction(e) {
        const profileId = runtimeState.moments.currentProfileId;
        const isUserPage = profileId === 'user';
        const target = e.target;

        // --- Â§¥ÂÉè„ÄÅÂ∞ÅÈù¢„ÄÅÊòµÁß∞„ÄÅÁ≠æÂêçÁÇπÂáª ---
            if (target.closest(`#moments-cover-${profileId}`) || target.closest(`#moments-profile-avatar-${profileId}`)) {
                const type = target.closest(`#moments-cover-${profileId}`) ? 'cover' : 'avatar';
                
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.style.display = 'none';

                const cleanup = () => {
                    if (input.parentNode) {
                        document.body.removeChild(input);
                    }
                    window.removeEventListener('focus', cleanup);
                };

                input.onchange = (e) => {
                    handleMomentsImageUpload(e.target.files[0], profileId, type);
                    cleanup();
                };

                // Add a fallback cleanup listener. If the user cancels the file dialog,
                // the window regains focus, and we can remove the dangling input.
                window.addEventListener('focus', cleanup, { once: true });

                document.body.appendChild(input);
                input.click();
                return;
            }
            if (isUserPage && target.closest(`#moments-profile-name-${profileId}`)) {
                const newName = prompt('‰øÆÊîπ‰Ω†ÁöÑÂä®ÊÄÅÊòµÁß∞:', appState.chat.moments.profile.name);
                if (newName && newName.trim()) { appState.chat.moments.profile.name = newName.trim(); appState.chat.userProfile.name = newName.trim(); debouncedSaveState(); renderMomentsPage('user'); }
                return;
            }
            if (isUserPage && target.closest(`#moments-profile-signature-${profileId}`)) {
                const newSignature = prompt('‰øÆÊîπ‰Ω†ÁöÑ‰∏™ÊÄßÁ≠æÂêç:', appState.chat.moments.profile.signature);
                if (newSignature !== null) { const oldSignature = appState.chat.moments.profile.signature; appState.chat.moments.profile.signature = newSignature.trim(); appState.chat.userProfile.signature = newSignature.trim(); if (newSignature.trim() !== oldSignature) { const newPost = { id: newId('post'), authorId: 'user', type: 'status', content: { text: `Á≠æÂêçÊõ¥Êç¢‰∏∫Ôºö‚Äú${newSignature.trim()}‚Äù`, images: [] }, timestamp: Date.now(), likes: [], comments: [] }; appState.chat.moments.posts.unshift(newPost); } debouncedSaveState(); renderMomentsPage('user'); }
                return;
            }

        // --- Á≠õÈÄâÊ†áÁ≠æÁÇπÂáª ---
        const filterTab = target.closest('.moments-filter-tab');
        if (filterTab) {
            runtimeState.moments.isFabMenuOpen = false;
            const filter = filterTab.dataset.filter;
            runtimeState.moments.currentFilter = filter; // ‰øÆÂ§çÔºö‰∏çÂÜçÂàáÊç¢ÔºåÁõ¥Êé•ËÆæÁΩÆ‰∏∫ÁÇπÂáªÁöÑtab
            renderMomentsFeed(profileId);
            return;
        }

        // --- FABÊåâÈíÆÁÇπÂáª ---
        const fabContainer = target.closest(`#moments-fab-container-${profileId}`);
            if(fabContainer) {
                const fab = target.closest('#moments-fab');
                const fabOption = target.closest('.fab-option');
                if (fab) {
                    const fabOptions = fabContainer.querySelector('#moments-fab-options');
                    runtimeState.moments.isFabMenuOpen = !runtimeState.moments.isFabMenuOpen;
                    fabOptions.style.display = runtimeState.moments.isFabMenuOpen ? 'flex' : 'none';
                } else if (fabOption) {
                    const action = fabOption.dataset.action;
                    switch(action) {
                        case 'status':
                            openPostMomentModal('status');
                            break;
                        case 'log':
                            openPostMomentModal('log');
                            break;
                        case 'photo':
                            openUploadPhotoModal();
                            break;
                        case 'album':
                            openManageAlbumsModal();
                            break;
                        case 'message':
                            openLeaveMessageModal();
                            break;
                        default:
                            showToast(`Ê≠§ÂäüËÉΩÂæÖÂºÄÂèë`);
                            break;
                    }
                    runtimeState.moments.isFabMenuOpen = false;
                    fabContainer.querySelector('#moments-fab-options').style.display = 'none';
                }
                return; // FAB‰∫§‰∫íÂêéÁõ¥Êé•ËøîÂõû
            }
        
        // --- Âä®ÊÄÅÂàóË°®È°π‰∫§‰∫í ---
        const postItem = target.closest('.moments-post-item');
        if(postItem) {
            handleMomentsFeedPostInteraction(e, postItem, profileId);
            return;
        }
        const messageItem = target.closest('.message-board-item');
            if(messageItem) {
                handleMessageBoardInteraction(e, messageItem, profileId);
                return;
            }

        // --- Album grid item interaction (for main album tab) ---
        const photoGridItem = target.closest('.photo-grid-item');
        if (photoGridItem && target.closest('.moments-feed')) {
            const grid = target.closest('.photo-grid');
            const allPhotoItems = Array.from(grid.querySelectorAll('.photo-grid-item'));
            const allPhotoIds = allPhotoItems.map(item => item.dataset.id);
            const allPhotos = allPhotoIds.map(id => appState.chat.moments.photos.find(p => p.id === id)).filter(Boolean);
            const startIndex = allPhotoItems.indexOf(photoGridItem);

            if (startIndex > -1) {
                openPhotoViewer(allPhotos, startIndex);
            }
            return;
        }
        if(postItem) {
            handleMomentsFeedPostInteraction(e, postItem, profileId);
        }
    }
    function logVisitor(targetProfileId, visitorId) {
        if (targetProfileId === visitorId) return; // Can't visit yourself

        let visitorList;
        if (targetProfileId === 'user') {
            if (!appState.chat.moments.visitors) appState.chat.moments.visitors = [];
            visitorList = appState.chat.moments.visitors;
        } else {
            const contact = appState.chat.contacts.find(c => c.id === targetProfileId);
            if (contact && contact.charSettings) {
                if (!contact.charSettings.visitors) contact.charSettings.visitors = [];
                visitorList = contact.charSettings.visitors;
            }
        }

        if (!visitorList) return;

        // To prevent spam, if the same visitor visits again within 5 minutes, just update the timestamp
        const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
        const recentVisitIndex = visitorList.findIndex(v => v.visitorId === visitorId && v.timestamp > fiveMinutesAgo);

        if (recentVisitIndex !== -1) {
            visitorList[recentVisitIndex].timestamp = Date.now();
        } else {
            visitorList.push({ visitorId: visitorId, timestamp: Date.now() });
        }

        // Keep the list from getting excessively long, e.g., max 100 visitors
        if (visitorList.length > 100) {
            visitorList.sort((a, b) => b.timestamp - a.timestamp); // Sort descending by time
            visitorList.splice(100); // Keep the most recent 100
        }

        debouncedSaveState();
    }

    function renderVisitors(container, profileId) {
        let visitorList = [];
        if (profileId === 'user') {
            visitorList = appState.chat.moments.visitors || [];
        } else {
            const contact = appState.chat.contacts.find(c => c.id === profileId);
            visitorList = (contact && contact.charSettings.visitors) ? contact.charSettings.visitors : [];
        }
        
        // Sort by most recent first
        visitorList.sort((a, b) => b.timestamp - a.timestamp);

        if (visitorList.length === 0) {
            container.innerHTML = `<p style="text-align:center; color:#888; margin-top: 50px;">ËøòÊ≤°ÊúâËÆøÂÆ¢Âì¶</p>`;
            return;
        }

        // Using a generic list class to reuse swipe styles
        container.innerHTML = `<ul id="visitor-list" class="preset-data-list" style="padding: 15px;">
            ${visitorList.map((visit, index) => {
                const visitor = findUserById(visit.visitorId);
                const visitTime = new Date(visit.timestamp).toLocaleString();
                return `
                    <li class="preset-data-item visitor-item" data-index="${index}">
                        <div class="preset-data-item-content swipe-content" style="gap: 12px; padding: 10px 0;">
                            <div class="preset-data-avatar" data-avatar-id="${visitor.avatarId}"></div>
                            <div class="preset-data-info">
                                <div class="preset-data-name">${visitor.name}</div>
                                <div class="preset-data-excerpt">${visitTime}</div>
                            </div>
                        </div>
                        <div class="preset-data-item-actions swipe-actions">
                            <div class="delete-action">Âà†Èô§</div>
                        </div>
                    </li>
                `;
            }).join('')}
        </ul>`;

        container.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
        
        // Setup swipe-to-delete for the newly rendered list
        const visitorListEl = container.querySelector('#visitor-list');
        if (visitorListEl) {
            new ListInteractionHandler(visitorListEl, {
                itemSelector: '.visitor-item',
                contentSelector: '.swipe-content',
                actionsSelector: '.swipe-actions',
                onDelete: (item) => {
                    const index = parseInt(item.dataset.index);
                    if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËÆøÂÆ¢ËÆ∞ÂΩïÂêóÔºü')) {
                        visitorList.splice(index, 1);
                        debouncedSaveState();
                        renderVisitors(container, profileId); // Re-render the list
                    }
                }
            });
        }
    }
    function handleMomentsFeedPostInteraction(e, postItem, profileId) {
        const postId = postItem.dataset.postId;
        const post = appState.chat.moments.posts.find(p => p.id === postId);
        if (!post) return;
        const target = e.target;

        // --- Post-level actions ---
        const likeBtn = target.closest('.post-footer > .comment-actions-inline .like-btn');
        if (likeBtn) {
            if(!post.likes) post.likes = [];
            const userIndex = post.likes.indexOf('user');
            if (userIndex > -1) {
                post.likes.splice(userIndex, 1);
            } else {
                post.likes.push('user');
                logVisitor(post.authorId, 'user');
                // Send notification TO the post author, FROM the user
                addMomentsNotification('like', 'user', { postId: post.id, recipientId: post.authorId });
            }
            debouncedSaveState();
            renderMomentsFeed(profileId);
            return;
        }
        
        const commentBtn = target.closest('.post-footer > .comment-actions-inline .comment-btn');
        if (commentBtn) {
            const commentInputArea = postItem.querySelector('.comment-input-area');
            commentInputArea.style.display = commentInputArea.style.display === 'flex' ? 'none' : 'flex';
            if (commentInputArea.style.display === 'flex') {
                commentInputArea.querySelector('input').focus();
            }
            return;
        }
        
        const sendCommentBtn = target.closest('.comment-input-area .send-comment-btn');
        if (sendCommentBtn) {
            const input = sendCommentBtn.previousElementSibling;
            const text = input.value.trim();
            if (!text) return;
            if(!post.comments) post.comments = [];
            post.comments.push({ id: newId('comment'), authorId: 'user', text, likes: [], replies: [], timestamp: Date.now() });
            logVisitor(post.authorId, 'user'); // Log visitor
            // Send notification
            addMomentsNotification('comment', 'user', {
                postId: post.id,
                recipientId: post.authorId,
                content: text
            });
            input.value = '';
            debouncedSaveState();
            renderMomentsFeed(profileId);
            return;
        }

        // --- Navigation and Content Viewing ---
        if (target.closest('.post-avatar') || target.closest('.post-author-name')) {
            if (post.authorId !== 'user' && profileId !== post.authorId) {
                if (confirm(`Ë¶ÅÊü•Áúã ${findUserById(post.authorId).name} ÁöÑÂä®ÊÄÅÂêóÔºü`)) {
                    openSubScreen(charMomentsScreen, chatAppScreen);
                    renderMomentsPage(post.authorId);
                }
            }
            return;
        }
        
        if (target.closest('.post-log-summary')) {
            viewContentTitle.textContent = post.content.title;
            viewContentBody.innerHTML = `<p>${escapeHTML(post.content.text).replace(/\n/g, '<br>')}</p>`;
            viewContentModal.classList.add('visible');
            return;
        }
        const photoItem = target.closest('.post-photo-item');
        if (photoItem) {
            const clickedPhotoId = photoItem.dataset.photoId;
            const allPhotoIdsInPost = post.content.photoIds;
            const allPhotos = allPhotoIdsInPost.map(id => appState.chat.moments.photos.find(p => p.id === id)).filter(Boolean);
            const startIndex = allPhotos.findIndex(p => p.id === clickedPhotoId);

            if (startIndex > -1) {
                openPhotoViewer(allPhotos, startIndex);
            }
            return;
        }
        const imageItem = target.closest('.post-image-item');
        if (imageItem) {
            const clickedImageId = imageItem.dataset.imageId;
            const allImages = post.content.images.map(imgData => {
                const isTextImage = typeof imgData === 'object' && imgData.isTextImage;
                return {
                    imageId: isTextImage ? imgData.imageId : imgData,
                    isTextImage: isTextImage,
                    description: isTextImage ? imgData.description : null
                };
            });
            const startIndex = allImages.findIndex(img => img.imageId === clickedImageId);
            
            if (startIndex > -1) {
                openSimpleViewer(allImages, startIndex);
            }
            return;
        }

        // --- New Comment & Reply Logic ---
        const commentOrReplyItem = target.closest('.comment-item, .reply-item');
        if (commentOrReplyItem) {
            const isReply = commentOrReplyItem.classList.contains('reply-item');
            const parentCommentItem = target.closest('.comment-item');
            const parentCommentId = parentCommentItem.dataset.commentId;
            const parentComment = post.comments.find(c => c.id === parentCommentId);
            if (!parentComment) return;

            const actionBtn = target.closest('.icon-btn');
            if (actionBtn) { // Click on Edit or Delete button
        const action = actionBtn.dataset.action;
        if (action === 'edit-comment') {
            openMomentCommentEditor(postId, parentCommentId, isReply ? commentOrReplyItem.dataset.replyId : null, null);
        } else if (action === 'delete-comment') {
            if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°${isReply ? 'ÂõûÂ§ç' : 'ËØÑËÆ∫'}ÂêóÔºü`)) {
                                if (isReply) {
                                    const replyIdToDelete = commentOrReplyItem.dataset.replyId;
                                    parentComment.replies = parentComment.replies.filter(r => r.id !== replyIdToDelete);
                                    // --- Êñ∞Â¢ûÔºöÂà†Èô§ÂÖ≥ËÅîÈÄöÁü• ---
                                    appState.chat.moments.notifications = appState.chat.moments.notifications.filter(n => n.originalReplyId !== replyIdToDelete);
                                } else {
                                    const commentIdToDelete = parentCommentId;
                                    post.comments = post.comments.filter(c => c.id !== commentIdToDelete);
                                    // --- Êñ∞Â¢ûÔºöÂà†Èô§ÂÖ≥ËÅîÈÄöÁü• (ÂåÖÊã¨ËØÑËÆ∫Êú¨Ë∫´ÂíåÂÖ∂‰∏ãÁöÑÊâÄÊúâÂõûÂ§ç) ---
                                    appState.chat.moments.notifications = appState.chat.moments.notifications.filter(n => n.originalCommentId !== commentIdToDelete);
                                }
                                debouncedSaveState();
                                updateMomentsNotificationUI(); // Êõ¥Êñ∞ËßíÊ†á
                                renderMomentsFeed(profileId);
                            }
        }
            } else if (target.closest('.reply-input-container button')) { // Send reply
                const replyInput = target.previousElementSibling;
                const text = replyInput.value.trim();
                if (!text) return;
                if (!parentComment.replies) parentComment.replies = [];
                
                let newReply;
                if (isReply) { // Replying to a reply
                    const targetReply = parentComment.replies.find(r => r.id === commentOrReplyItem.dataset.replyId);
                    const targetAuthor = findUserById(targetReply.authorId);
                    newReply = { id: newId('reply'), authorId: 'user', text: `@${targetAuthor.name} ${text}`, replyTo: targetReply.id, timestamp: Date.now() };
                } else { // Replying to a top-level comment
                    const targetAuthor = findUserById(parentComment.authorId);
                    newReply = { id: newId('reply'), authorId: 'user', text: `@${targetAuthor.name} ${text}`, replyTo: null, timestamp: Date.now() };
                }
                parentComment.replies.push(newReply);
                debouncedSaveState();
                renderMomentsFeed(profileId);
            } else { // Click on the comment/reply body
                const actionIcons = commentOrReplyItem.querySelector('.comment-actions-inline');
                const replyInput = commentOrReplyItem.querySelector('.reply-input-container');

                // Close all other open action/reply inputs in this post
                postItem.querySelectorAll('.comment-actions-inline, .reply-input-container.active').forEach(el => {
                    if (el !== actionIcons && el !== replyInput) {
                        if (el.classList.contains('reply-input-container')) {
                            el.classList.remove('active');
                        } else {
                            el.style.display = 'none';
                        }
                    }
                });

                if (actionIcons) actionIcons.style.display = actionIcons.style.display === 'flex' ? 'none' : 'flex';
                if (replyInput) replyInput.classList.toggle('active');
                if (replyInput && replyInput.classList.contains('active')) {
                    replyInput.querySelector('input').focus();
                }
            }
        }
    }
    function handleMessageBoardInteraction(e, messageItem, profileId) {
            const messageId = messageItem.dataset.messageId;
            const message = appState.chat.moments.messages.find(m => m.id === messageId);
            if (!message) return;
            const target = e.target;

            // --- Reply item actions ---
            const replyItem = target.closest('.reply-item');
            if (replyItem) {
                const replyId = replyItem.dataset.replyId;
                const reply = (message.replies || []).find(r => r.id === replyId);
                if (!reply) return;

                const editBtn = target.closest('.edit-reply-btn');
                const deleteBtn = target.closest('.delete-reply-btn');
                const sendBtn = target.closest('.reply-input-container button');
                
                if (editBtn) {
                    openMomentCommentEditor(null, null, replyId, messageId);
                } else if (deleteBtn) {
                    if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ÂõûÂ§çÂêóÔºü')) {
                        message.replies = message.replies.filter(r => r.id !== replyId);
                        debouncedSaveState();
                        renderMomentsFeed(profileId);
                    }
                } else if (sendBtn) {
                    const input = sendBtn.previousElementSibling;
                    const text = input.value.trim();
                    if (!text) return;
                    const newReply = { id: newId('reply'), authorId: 'user', text, timestamp: Date.now(), replyTo: replyId };
                    message.replies.push(newReply);
                    debouncedSaveState();
                    renderMomentsFeed(profileId);
                } else {
                    // Click on reply body to toggle actions
                    const actionIcons = replyItem.querySelector('.comment-actions-inline');
                    const replyInputArea = replyItem.querySelector('.reply-input-container');
                    
                    if (actionIcons) actionIcons.style.display = actionIcons.style.display === 'flex' ? 'none' : 'flex';
                    if (replyInputArea) replyInputArea.classList.toggle('active');
                     if (replyInputArea && replyInputArea.classList.contains('active')) {
                        replyInputArea.querySelector('input').focus();
                    }
                }
                return;
            }

            // --- Main item actions ---
            const mainReplyInputArea = messageItem.querySelector('.message-board-item-main > .reply-input-container');
            const mainSendBtn = target.closest('.message-board-item-main > .reply-input-container button');
            const replyBtn = target.closest('.reply-btn');
            
            if (mainSendBtn) {
                const input = mainSendBtn.previousElementSibling;
                const text = input.value.trim();
                if (!text) return;
                if (!message.replies) message.replies = [];
                const newReply = { id: newId('reply'), authorId: 'user', text, timestamp: Date.now(), replyTo: null };
                message.replies.push(newReply);
                logVisitor(message.recipientId, 'user'); // Log visitor for replying
                // Send notification for the reply
                addMomentsNotification('reply', 'user', {
                    messageId: message.id,
                    recipientId: message.senderId, // Notify the original message sender
                    content: text
                });
                debouncedSaveState();
                renderMomentsFeed(profileId);
                return;
            }

            // Click to reply logic (Bug ‚ë†)
            const mainContentArea = target.closest('.message-board-item-main');
            if (mainContentArea) {
                // Check if the click was on the main content area itself, not on an interactive child
                const isInteractiveChild = target.closest('button, input, .reply-btn, .message-board-replies');
                if (!isInteractiveChild || replyBtn) {
                    mainReplyInputArea.classList.toggle('active');
                    if (mainReplyInputArea.classList.contains('active')) {
                        mainReplyInputArea.querySelector('input').focus();
                    }
                }
            }
        }
    function renderMomentsFeed(profileId) {
    const isUserPage = profileId === 'user';
    const container = isUserPage ? momentsTabContent : charMomentsScreen;
    const feedEl = getEl(`moments-feed-${profileId}`);
    const tabsEl = getEl(`moments-filter-tabs-${profileId}`);
    const fabContainer = getEl(`moments-fab-container-${profileId}`);
    if (!feedEl || !tabsEl || !fabContainer) return;

    const filter = runtimeState.moments.currentFilter;
    
    const tabList = [ { key: 'all', text: 'ÂÖ®ÈÉ®' }, { key: 'status', text: 'ËØ¥ËØ¥' }, { key: 'photo', text: 'Áõ∏ÂÜå' }, { key: 'log', text: 'Êó•Âøó' }, { key: 'visitor', text: 'ËÆøÂÆ¢' }, { key: 'message', text: 'ÁïôË®Ä' } ];
    tabsEl.innerHTML = tabList.filter(tab => isUserPage || (tab.key !== 'visitor')).map(tab => `<span class="moments-filter-tab ${filter === tab.key ? 'active' : ''}" data-filter="${tab.key}">${tab.text}</span>`).join('');
    
    let shouldShowFab = true;
    if (!isUserPage && !['all', 'message'].includes(filter)) {
        shouldShowFab = false;
    }
    if (filter === 'visitor') {
        shouldShowFab = false;
    }
    
    if (shouldShowFab) {
        let fabOptionsHTML = '';
        const userOptions = { 
            all: [{ action: 'status', text: 'ÂèëË°®ËØ¥ËØ¥' }, { action: 'photo', text: '‰∏ä‰º†ÁÖßÁâá' }, { action: 'log', text: 'ÂÜôÊó•Âøó' }], 
            status: [{ action: 'status', text: 'ÂèëË°®ËØ¥ËØ¥' }], 
            photo: [{ action: 'photo', text: '‰∏ä‰º†ÁÖßÁâá' }, { action: 'album', text: 'ÁÆ°ÁêÜÁõ∏ÂÜå'}], 
            log: [{ action: 'log', text: 'ÂÜôÊó•Âøó' }], 
            message: [{ action: 'message', text: 'ÂÜôÁïôË®Ä' }] 
        };
        
        const charOptions = {
            all: [{ action: 'message', text: 'Áªô‰ªñÁïôË®Ä' }],
            message: [{ action: 'message', text: 'Áªô‰ªñÁïôË®Ä' }]
        };

        const optionsMap = isUserPage ? userOptions : charOptions;
        fabOptionsHTML = (optionsMap[filter] || []).map(opt => `<div class="fab-option" data-action="${opt.action}">${opt.text}</div>`).join('');
        
fabContainer.innerHTML = `<div id="moments-fab-options" style="display: ${runtimeState.moments.isFabMenuOpen ? 'flex' : 'none'};">${fabOptionsHTML}</div><div id="moments-fab" class="moments-fab"><i class="fa-solid fa-plus"></i></div>`;    } else {
        fabContainer.innerHTML = '';
    }
    
    let postsToRender = [...appState.chat.moments.posts].sort((a,b) => b.timestamp - a.timestamp);
    if (!isUserPage) {
        postsToRender = postsToRender.filter(p => p.authorId === profileId && (p.visibility === 'public' || (p.visibleTo && p.visibleTo.includes('user'))));
    }
    
    feedEl.innerHTML = ''; // Clear feed before rendering
    
    switch(filter) {
        case 'visitor':
            renderVisitors(feedEl, profileId);
            break;
        case 'message':
            renderMessages(feedEl, profileId);
            break;
        case 'photo':
            openAlbumView(feedEl, profileId, 'default');
            break;
        case 'log':
        case 'status':
            const filteredPosts = postsToRender.filter(p => p.type === filter);
            feedEl.innerHTML = filteredPosts.length > 0 ? filteredPosts.map(post => renderSingleMomentPost(post)).join('') : `<p style="text-align:center; color:#888; margin-top: 50px;">ËøôÈáåÁ©∫Á©∫Â¶Ç‰πü~</p>`;
            break;
        case 'all':
        default:
            const allPosts = postsToRender.filter(p => ['status', 'log', 'photo'].includes(p.type));
            feedEl.innerHTML = allPosts.length > 0 ? allPosts.map(post => renderSingleMomentPost(post)).join('') : `<p style="text-align:center; color:#888; margin-top: 50px;">ËøôÈáåÁ©∫Á©∫Â¶Ç‰πü~</p>`;
            break;
    }
    
    feedEl.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    feedEl.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));
    feedEl.querySelectorAll('.post-photo-item').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));

    setupMomentsListInteraction(feedEl);

    // --- Scroll to target item after navigation (REVISED & FIXED) ---
    setTimeout(() => {
        let targetElement = null;
        if (runtimeState.moments.scrollToPostId) {
            targetElement = feedEl.querySelector(`.moments-post-item[data-post-id="${runtimeState.moments.scrollToPostId}"]`);
            runtimeState.moments.scrollToPostId = null;
        } else if (runtimeState.moments.scrollToMessageId) {
            targetElement = feedEl.querySelector(`.message-board-item[data-message-id="${runtimeState.moments.scrollToMessageId}"]`);
            runtimeState.moments.scrollToMessageId = null;
        }

        if (targetElement) {
            // Ê†∏ÂøÉ‰øÆÂ§çÔºöÂºÉÁî®Êúâ bug ÁöÑ scrollIntoViewÔºåÊîπÁî®ÊâãÂä®Á≤æÁ°ÆÊªöÂä®„ÄÇ
            const scrollContainer = feedEl.closest('.moments-scroll-container');
            if (scrollContainer) {
                const containerRect = scrollContainer.getBoundingClientRect();
                const targetRect = targetElement.getBoundingClientRect();
                // ËÆ°ÁÆóÊªöÂä®ÂÅèÁßªÈáèÔºå‰ΩøÁõÆÊ†áÂÖÉÁ¥†Â§ßËá¥‰Ωç‰∫éÂÆπÂô®‰∏≠ÂøÉ
                const offset = targetRect.top - containerRect.top - (containerRect.height / 2) + (targetRect.height / 2);
                
                scrollContainer.scrollTo({
                    top: scrollContainer.scrollTop + offset,
                    behavior: 'smooth'
                });
            }
            
            // ‰øùÁïôÈ´ò‰∫ÆÊïàÊûú
            targetElement.style.transition = 'background-color 0.5s ease-in-out';
            targetElement.style.backgroundColor = 'rgba(0, 122, 255, 0.1)';
            setTimeout(() => {
                targetElement.style.backgroundColor = '';
            }, 2000);
        }
    }, 100); // Delay to ensure DOM is fully painted
}

    function renderSingleMomentPost(post) {
        const author = findUserById(post.authorId);
        const isLiked = post.likes.includes('user');
        const commentsHTML = (post.comments || []).map(comment => renderSingleMomentComment(comment, post.id)).join('');
        
        let contentHTML = '';
        let visibilityHTML = '';

        if (post.type === 'status') {
            const postText = post.content.text ? `<div class="post-content-text">${escapeHTML(post.content.text)}</div>` : '';
            const imageGridHTML = post.content.images && post.content.images.length > 0 
                ? `<div class="post-image-grid">${post.content.images.map(imgData => {
                    const isTextImage = typeof imgData === 'object' && imgData.isTextImage;
                    const imageId = isTextImage ? imgData.imageId : imgData;
                    const textOverlay = isTextImage ? `<div class="camera-text-overlay">(${escapeHTML(imgData.description)})</div>` : '';
                    const itemClass = isTextImage ? 'post-image-item text-image-post' : 'post-image-item';
                    return `<div class="${itemClass}" data-image-id="${imageId}" data-is-text-image="${isTextImage}">${textOverlay}</div>`;
                  }).join('')}</div>`
                : '';
            contentHTML = `${postText}${imageGridHTML}`;
        } else if (post.type === 'log') {
            const summary = post.content.text.length > 30 ? post.content.text.substring(0, 30).replace(/[Ôºå„ÄÇÔºÅÔºü]$/, '') + '...' : post.content.text;
            contentHTML = `<div class="post-log-summary"><h3>${escapeHTML(post.content.title)}</h3><p>${escapeHTML(summary)}</p></div>`;
        } else if (post.type === 'photo') {
            const photoData = appState.chat.moments.photos.filter(p => post.content.photoIds.includes(p.id));
            const album = appState.chat.moments.albums.find(a => a.id === post.content.albumId);
            const albumText = album ? `Âà∞„Ää${escapeHTML(album.name)}„Äã` : '';
            const authorActionText = `<div class="post-content-text">${author.name} ‰∏ä‰º†‰∫Ü${photoData.length}Âº†ÁÖßÁâáÔºö${escapeHTML(post.content.name)}${albumText}</div>`;
            const photoGridHTML = `<div class="post-photo-grid">${photoData.map(photo => `<div class="post-photo-item" data-photo-id="${photo.id}" data-image-id="${photo.imageId}"></div>`).join('')}</div>`;
            contentHTML = `${authorActionText}${photoGridHTML}`;
        }

        if (post.visibility === 'specific' && post.visibleTo && post.visibleTo.length > 0) {
            const visibleNames = post.visibleTo.map(id => findUserById(id).name).slice(0, 3).join(', ');
            const extraCount = post.visibleTo.length > 3 ? ` Á≠â${post.visibleTo.length}‰∫∫` : '';
            visibilityHTML = `<div class="post-visibility-info">‰ªÖ ${visibleNames}${extraCount} ÂèØËßÅ</div>`;
        }
        
        let likesSummaryHTML = '';
        if(post.likes && post.likes.length > 0) {
            const likerNames = post.likes.map(id => findUserById(id).name).join(', ');
            likesSummaryHTML = `<div class="post-likes-summary"><span class="icon">‚ù§Ô∏è</span> ${likerNames}</div>`;
        }

        return `
            <div class="moments-post-item" data-post-id="${post.id}">
                <div class="post-item-content swipe-content">
                    <div class="post-header">
                        <div class="post-avatar" data-avatar-id="${author.avatarId}"></div>
                        <div class="post-author-info">
                            <div class="post-author-name">${author.name}</div>
                            <div class="post-timestamp">${new Date(post.timestamp).toLocaleString()}</div>
                        </div>
                    </div>
                    ${contentHTML}
                    ${visibilityHTML}
                    <div class="post-footer">
                        ${likesSummaryHTML}
                        <div class="comment-actions-inline" style="justify-content: flex-end; ${likesSummaryHTML ? 'border-top: 1px solid #f0f0f0; padding-top: 8px; margin-top: 8px;' : ''}">
                            <button class="icon-btn like-btn ${isLiked ? 'liked' : ''}" data-icon-id="${isLiked ? 'moment-like-on' : 'moment-like-off'}" style="gap: 4px;">${isLiked ? '<i class="fa-solid fa-heart"></i>' : '<i class="fa-regular fa-heart"></i>'} <span class="like-count">${(post.likes || []).length}</span></button>
                            <button class="icon-btn comment-btn" data-icon-id="moment-comment" style="gap: 4px;"><i class="fa-solid fa-message"></i> <span class="comment-count">${(post.comments || []).length}</span></button>
                        </div>
                        <div class="details-comments-list" style="padding: 10px 0 0 0;">${commentsHTML}</div>
                        <div class="comment-input-area" style="display: none; margin-top: 10px;">
                            <input type="text" placeholder="ÂèëË°®‰Ω†ÁöÑËØÑËÆ∫...">
                            <button class="settings-button secondary send-comment-btn" data-icon-id="comment-send" style="width: 50px; padding: 5px; display: flex; align-items: center; justify-content: center;"><i class="fa-solid fa-paper-plane"></i></button>
                        </div>
                    </div>
                </div>
                <div class="post-item-actions swipe-actions">
                    <div class="edit-action" data-icon-id="moment-edit"><i class="fa-solid fa-pen-to-square"></i></div>
                    <div class="delete-action" data-icon-id="moment-delete"><i class="fa-solid fa-trash-can"></i></div>
                </div>
            </div>
        `;
    }
    function renderSingleMomentComment(comment, postId) {
        const author = findUserById(comment.authorId);
        const repliesHTML = (comment.replies || []).map(reply => renderSingleMomentReply(reply, comment.replies, postId)).join('');
        const canModify = true; // ÂÅáËÆæUserÊÄªÊòØÂèØ‰ª•ÁºñËæëÂíåÂà†Èô§
        return `
            <div class="comment-item" data-comment-id="${comment.id}">
                <div class="comment-item-main" style="padding-top: 8px; padding-bottom: 8px;">
                    <div class="comment-avatar" data-avatar-id="${author.avatarId}" style="width: 32px; height: 32px;"></div>
                    <div class="comment-content">
                        <div class="comment-header">
                            <span class="comment-author">${author.name}</span>
                            <span class="comment-timestamp">${new Date(comment.timestamp).toLocaleString()}</span>
                            <div class="comment-actions-inline" style="display: none;">
                                ${canModify ? `
                                <button class="icon-btn" data-action="edit-comment" data-icon-id="moment-edit" title="ÁºñËæë"><i class="fa-solid fa-pen-to-square"></i></button>
                                <button class="icon-btn" data-action="delete-comment" data-icon-id="moment-delete" title="Âà†Èô§"><i class="fa-solid fa-trash-can"></i></button>
                                ` : ''}
                            </div>
                        </div>
                        <p class="comment-text">${escapeHTML(comment.text)}</p>
                        <div class="comment-replies" style="margin-left: 0;">${repliesHTML}</div>
                        <div class="reply-input-container">
                            <input type="text" placeholder="ÂõûÂ§ç ${author.name}...">
                            <button class="settings-button secondary" style="padding: 5px 10px;" data-bubble-id="comment-reply-send">ÂèëÈÄÅ</button>
                        </div>
                    </div>
                </div>
            </div>`;
    }
    function renderSingleMomentReply(reply, allReplies, postId) {
            const author = findUserById(reply.authorId);
            
            let replyText = escapeHTML(reply.text);
            const mentionMatch = replyText.match(/^@(\S+)\s(.*)/s); // Added 's' flag for multiline
            let targetHTML = '';
            if(mentionMatch) {
                targetHTML = `ÂõûÂ§ç <span class="reply-target">@${mentionMatch[1]}</span>: `;
                replyText = mentionMatch[2];
            }

            const canModify = true; 
            return `
                <div class="reply-item" data-reply-id="${reply.id}">
                    <div class="reply-avatar" data-avatar-id="${author.avatarId}"></div>
                    <div class="reply-content">
                        <div class="comment-header">
                             <div>
                                <span class="reply-author">${author.name}</span>
                                <span class="reply-timestamp">${new Date(reply.timestamp).toLocaleString()}</span>
                             </div>
                             <div class="comment-actions-inline" style="display: none;">
                                ${canModify ? `
                                <button class="icon-btn" data-action="edit-comment" title="ÁºñËæë"><i class="fa-solid fa-pen-to-square"></i></button>
                                <button class="icon-btn" data-action="delete-comment" title="Âà†Èô§"><i class="fa-solid fa-trash-can"></i></button>
                                ` : ''}
                             </div>
                        </div>
                        <p class="comment-text">${targetHTML}${replyText}</p>
                        <div class="reply-input-container">
                            <input type="text" placeholder="ÂõûÂ§ç ${author.name}...">
                            <button class="settings-button secondary" style="padding: 5px 10px;" data-bubble-id="comment-reply-send">ÂèëÈÄÅ</button>
                        </div>
                    </div>
                </div>`;
        }
function syncAndUpdateMoments(profileId) { if (profileId === 'user' && getEl('moments-tab-content').offsetParent !== null) { renderMomentsPage('user'); } else if (profileId !== 'user' && charMomentsScreen.classList.contains('active') && runtimeState.moments.currentProfileId === profileId) { renderMomentsPage(profileId); } }
    // --- Êñ∞Â¢ûÔºöÂΩªÂ∫ïÂà†Èô§Âä®ÊÄÅÂèäÂÖ∂ÂÖ≥ËÅîÊï∞ÊçÆÁöÑÂáΩÊï∞ ---
    function deleteMomentAndAssociatedData(postId) {
        if (!postId) return false;
        
        const postIndex = appState.chat.moments.posts.findIndex(p => p.id === postId);
        if (postIndex === -1) return false; // Post already deleted

        const postToDelete = appState.chat.moments.posts[postIndex];

        // 1. Âà†Èô§Âä®ÊÄÅÊú¨Ë∫´
        appState.chat.moments.posts.splice(postIndex, 1);

        // 2. Âà†Èô§ÊâÄÊúâ‰∏éÊ≠§Âä®ÊÄÅÁõ∏ÂÖ≥ÁöÑÈÄöÁü•
        appState.chat.moments.notifications = appState.chat.moments.notifications.filter(n => n.postId !== postId);

        // 3. (ÂèØÈÄâ‰ΩÜÊé®Ëçê) Â¶ÇÊûúÂà†Èô§ÁöÑÊòØÁÖßÁâáÂä®ÊÄÅÔºåÊ∏ÖÁêÜÁÖßÁâáÂ∫ìÂíåÁõ∏ÂÜå
        if (postToDelete.type === 'photo' && postToDelete.content.photoIds) {
            const photoIdsToDelete = postToDelete.content.photoIds;
            appState.chat.moments.photos = appState.chat.moments.photos.filter(p => !photoIdsToDelete.includes(p.id));
            appState.chat.moments.albums.forEach(album => {
                if (album.photoIds) {
                    album.photoIds = album.photoIds.filter(pid => !photoIdsToDelete.includes(pid));
                }
            });
        }
        
        updateMomentsNotificationUI(); // Êõ¥Êñ∞ËßíÊ†á
        debouncedSaveState();
        return true;
    }
    function openPostMomentModal(type, postId = null) {
    const isEditing = postId !== null;
    const post = isEditing ? appState.chat.moments.posts.find(p => p.id === postId) : null;

    runtimeState.moments.postContext = { 
        type: isEditing ? post.type : type,
        visibility: isEditing ? post.visibility : 'public',
        visibleTo: isEditing ? [...(post.visibleTo || [])] : [],
        images: isEditing ? [...(post.content.images || [])] : [],
        textImageDesc: '',
        editingPostId: postId
    };

    const titleEl = getEl('post-moment-modal-title');
    const statusSection = getEl('post-moment-status-section');
    const logSection = getEl('post-moment-log-section');
    const modalBody = getEl('post-moment-modal-body');
    const commentPrivateCheckbox = getEl('post-moment-comment-private-checkbox');

    // Âä®ÊÄÅÂàõÂª∫ÊàñÁßªÈô§‰ΩúËÄÖÈÄâÊã©Âô®
    if (modalBody.querySelector('#post-author-selector-group')) {
        modalBody.querySelector('#post-author-selector-group').remove();
    }
    if (isEditing) {
        const authorSelectorHTML = `
            <div class="form-group" id="post-author-selector-group">
                <label>ÂèëÂ∏ÉËÄÖ</label>
                <div id="moment-post-author-selector"></div>
            </div>`;
        modalBody.insertAdjacentHTML('afterbegin', authorSelectorHTML);
        renderMomentAuthorSelector('moment-post-author-selector', post.authorId);
        commentPrivateCheckbox.checked = post.areCommentsPrivate || false; // Load existing setting
    } else {
        commentPrivateCheckbox.checked = false; // Reset for new post
    }


    titleEl.textContent = isEditing ? 'ÁºñËæëÂä®ÊÄÅ' : 'ÂèëË°®Âä®ÊÄÅ';
    
    if (runtimeState.moments.postContext.type === 'status') {
        statusSection.classList.remove('hidden-by-logic');
        logSection.classList.add('hidden-by-logic');
        getEl('post-moment-status-content').value = isEditing ? post.content.text : '';
    } else if (runtimeState.moments.postContext.type === 'log') {
        statusSection.classList.add('hidden-by-logic');
        logSection.classList.remove('hidden-by-logic');
        getEl('post-moment-log-title').value = isEditing ? post.content.title : '';
        getEl('post-moment-log-content').value = isEditing ? post.content.text : '';
    }
    
    queryAll('input[name="visibility"]').forEach(radio => radio.checked = radio.value === runtimeState.moments.postContext.visibility);
    const friendSelector = getEl('post-moment-friend-selector-container');
    if (runtimeState.moments.postContext.visibility === 'specific') {
                renderFriendSelector('post-moment-friend-selector', 'post');
                friendSelector.classList.remove('hidden-by-logic');
            } else {
        friendSelector.classList.add('hidden-by-logic');
    }
    
    queryAll('input[name="status-type"]').forEach(radio => radio.checked = radio.value === 'text'); // Default to text
    getEl('post-moment-image-buttons').classList.add('hidden-by-logic');
    getEl('post-moment-text-image-input').classList.add('hidden-by-logic');

    postMomentModal.classList.add('visible');
}
    function setupNewMomentsFeaturesListeners() {
        // --- Photo Viewer Modal ---
        getEl('viewer-image-view').addEventListener('click', (e) => {
            const context = runtimeState.moments.viewerContext;
            if (!context || context.items.length === 0) return;
            const currentPhoto = context.items[context.currentIndex];
            if (!currentPhoto) return;

            if (e.target.closest('#view-photo-name') || e.target.closest('#view-photo-desc')) {
                e.stopPropagation(); // Prevent the main viewer click from hiding the text
                getEl('editing-photo-id').value = currentPhoto.id;
                getEl('photo-name-input').value = currentPhoto.name;
                getEl('photo-desc-input').value = currentPhoto.description || '';
                editPhotoModal.classList.add('visible');
            }
        });
        viewPhotoModal.addEventListener('click', (e) => {
            const imageView = e.target.closest('#viewer-image-view');
            const closeBtn = e.target.closest('.photo-viewer-close-btn');

            if (closeBtn) {
                viewPhotoModal.classList.remove('visible');
            } else if (imageView) {
                // Only toggle text visibility for image view
                viewPhotoModal.classList.toggle('text-hidden');
            }
        });

        // --- Simple Viewer Modal ---
        simpleViewerModal.addEventListener('click', (e) => {
             if (!e.target.closest('.viewer-nav-btn')) {
                simpleViewerModal.classList.remove('visible');
             }
        });
        getEl('simple-viewer-prev-btn').addEventListener('click', () => {
            let { currentIndex } = runtimeState.moments.viewerContext;
            if (currentIndex > 0) {
                currentIndex--;
                runtimeState.moments.viewerContext.currentIndex = currentIndex;
                renderSimpleViewerContent(currentIndex);
            }
        });
        getEl('simple-viewer-next-btn').addEventListener('click', () => {
            let { items, currentIndex } = runtimeState.moments.viewerContext;
            if (currentIndex < items.length - 1) {
                currentIndex++;
                runtimeState.moments.viewerContext.currentIndex = currentIndex;
                renderSimpleViewerContent(currentIndex);
            }
        });
        // --- Upload Photo Modal Listeners ---
        getEl('upload-photo-local-btn').addEventListener('click', () => {
            getEl('upload-photo-file-input').click();
        });

        getEl('upload-photo-file-input').addEventListener('change', async (e) => {
            const files = e.target.files;
            if (files.length === 0) return;
            showToast(`Ê≠£Âú®Â§ÑÁêÜ ${files.length} Âº†ÂõæÁâá...`);
            for (const file of files) {
                const imageId = newId('moment_photo');
                await addMediaToDB(imageId, file);
                runtimeState.moments.postContext.images.push(imageId);
            }
            // Render previews
            const previewGrid = getEl('upload-photo-image-preview-grid');
            previewGrid.innerHTML = '';
             runtimeState.moments.postContext.images.forEach(id => {
                const item = document.createElement('div');
                item.className = 'upload-preview-item';
                previewGrid.appendChild(item);
                setElementImage(item, id, 'backgroundImage');
            });
            showToast('ÂõæÁâáÂ∑≤ÂáÜÂ§áÂ•Ω');
        });

        getEl('upload-photo-text-btn').addEventListener('click', () => {
             getEl('upload-photo-text-image-input-group').classList.toggle('hidden-by-logic');
        });

        getEl('upload-photo-visibility').addEventListener('change', e => {
            runtimeState.moments.postContext.visibility = e.target.value;
            const selectorContainer = getEl('upload-photo-friend-selector-container');
            if (e.target.value === 'specific') {
                renderFriendSelector('upload-photo-friend-selector', 'upload');
                selectorContainer.classList.remove('hidden-by-logic');
            } else {
                selectorContainer.classList.add('hidden-by-logic');
            }
        });

        getEl('upload-photo-friend-selector').addEventListener('click', e => {
            const item = e.target.closest('.friend-selector-item');
            if (item) {
                const id = item.dataset.id;
                item.classList.toggle('selected');
                const context = runtimeState.moments.postContext;
                if (item.classList.contains('selected')) {
                    if (!context.visibleTo.includes(id)) context.visibleTo.push(id);
                } else {
                    context.visibleTo = context.visibleTo.filter(fid => fid !== id);
                }
            }
        });

        getEl('cancel-upload-photo-btn').addEventListener('click', () => uploadPhotoModal.classList.remove('visible'));
        
        getEl('confirm-upload-photo-btn').addEventListener('click', () => {
        const name = getEl('upload-photo-name').value.trim();
        if (!name) return showToast('ÁÖßÁâáÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫', 'error');
        
        const description = getEl('upload-photo-desc').value.trim(); // Ëé∑ÂèñÁÖßÁâáÊèèËø∞

        const localImages = runtimeState.moments.postContext.images;
        const textImageDescs = getEl('upload-photo-text-image-desc').value.trim().split('\n').filter(d => d);

        if (localImages.length === 0 && textImageDescs.length === 0) {
            return showToast('ËØ∑Ëá≥Â∞ë‰∏ä‰º†‰∏ÄÂº†ÂõæÁâáÊàñËæìÂÖ•ÊñáÂ≠óÂõæÊèèËø∞', 'error');
        }

        const photoIds = [];
        // Process local images
        localImages.forEach(imageId => {
            const photo = { id: newId('photo'), ownerId: 'user', imageId: imageId, isTextImage: false, name: name, description: description };
            appState.chat.moments.photos.push(photo);
            photoIds.push(photo.id);
        });
        // Process text images
        textImageDescs.forEach(desc => {
            const photo = { id: newId('photo'), ownerId: 'user', imageId: 'default_camera_image', isTextImage: true, textDescription: desc, name: name, description: description };
            appState.chat.moments.photos.push(photo);
            photoIds.push(photo.id);
        });
        
        const selectedAlbumId = getEl('upload-photo-album-select').value;
        const album = appState.chat.moments.albums.find(a => a.id === selectedAlbumId);
        if(album) {
            if(!album.photoIds) album.photoIds = [];
            album.photoIds.unshift(...photoIds);
        }

        const newPost = {
            id: newId('post'),
            authorId: 'user',
            type: 'photo',
            content: {
                name: name,
                description: description, // Âä®ÊÄÅÁöÑÊèèËø∞‰πü‰ΩøÁî®ÁÖßÁâáÊèèËø∞
                photoIds: photoIds,
                albumId: selectedAlbumId
            },
            timestamp: Date.now(),
            visibility: runtimeState.moments.postContext.visibility,
            visibleTo: runtimeState.moments.postContext.visibleTo,
            areCommentsPrivate: getEl('upload-photo-comment-private-checkbox').checked, // Add this line
            likes: [],
            comments: []
        };
        appState.chat.moments.posts.unshift(newPost);
        debouncedSaveState();
        renderMomentsFeed('user');
        uploadPhotoModal.classList.remove('visible');
    });


        // --- Manage Albums Modal Listeners ---
        getEl('close-manage-albums-btn').addEventListener('click', () => {
            manageAlbumsModal.classList.remove('visible');
            getEl('delete-selected-albums-btn').style.display = 'none';
            manageAlbumsModal.querySelectorAll('.album-item.selected-for-deletion').forEach(el => el.classList.remove('selected-for-deletion'));
        });

        getEl('create-album-btn').addEventListener('click', () => {
            getEl('edit-album-title').textContent = 'Êñ∞Âª∫Áõ∏ÂÜå';
            getEl('editing-album-id').value = '';
            getEl('album-name-input').value = '';
            getEl('album-desc-input').value = '';
            editAlbumModal.classList.add('visible');
        });

        getEl('manage-albums-grid').addEventListener('click', e => {
            const item = e.target.closest('.album-item');
            if (!item) return;

            if (getEl('delete-selected-albums-btn').style.display === 'block') {
                 if(item.dataset.id !== 'default') {
                    item.classList.toggle('selected-for-deletion');
                 }
                return;
            }

            if (e.target.closest('.edit-album-btn')) {
                const albumId = item.dataset.id;
                const album = appState.chat.moments.albums.find(a => a.id === albumId);
                getEl('edit-album-title').textContent = 'ÁºñËæëÁõ∏ÂÜå';
                getEl('editing-album-id').value = albumId;
                getEl('album-name-input').value = album.name;
                getEl('album-desc-input').value = album.description || '';
                editAlbumModal.classList.add('visible');
            } else {
                openSubScreen(viewAlbumScreen, chatAppScreen);
                renderAlbumView(item.dataset.id);
                manageAlbumsModal.classList.remove('visible');
            }
        });
        
        let albumLongPressTimer = null;
        getEl('manage-albums-grid').addEventListener('pointerdown', e => {
             const item = e.target.closest('.album-item');
             if(!item || item.dataset.id === 'default') return;
             albumLongPressTimer = setTimeout(() => {
                getEl('delete-selected-albums-btn').style.display = 'block';
                item.classList.add('selected-for-deletion');
             }, 800);
        });
         getEl('manage-albums-grid').addEventListener('pointerup', () => clearTimeout(albumLongPressTimer));
         getEl('manage-albums-grid').addEventListener('pointerleave', () => clearTimeout(albumLongPressTimer));

        getEl('delete-selected-albums-btn').addEventListener('click', () => {
            const selectedItems = manageAlbumsModal.querySelectorAll('.album-item.selected-for-deletion');
            if (selectedItems.length === 0) return;
            if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${selectedItems.length} ‰∏™Áõ∏ÂÜåÂêóÔºüÂÖ∂‰∏≠ÁöÑÁÖßÁâáÂ∞ÜÁßªËá≥ÈªòËÆ§Áõ∏ÂÜå„ÄÇ`)) {
                const defaultAlbum = appState.chat.moments.albums.find(a => a.id === 'default');
                if(!defaultAlbum.photoIds) defaultAlbum.photoIds = [];

                selectedItems.forEach(item => {
                    const albumId = item.dataset.id;
                    const album = appState.chat.moments.albums.find(a => a.id === albumId);
                    if (album && album.photoIds) {
                        defaultAlbum.photoIds.unshift(...album.photoIds);
                    }
                    appState.chat.moments.albums = appState.chat.moments.albums.filter(a => a.id !== albumId);
                });
                debouncedSaveState();
                renderManageAlbums();
                getEl('delete-selected-albums-btn').style.display = 'none';
            }
        });

        // --- Edit Album Modal Listeners ---
        getEl('cancel-edit-album-btn').addEventListener('click', () => editAlbumModal.classList.remove('visible'));
        getEl('save-album-btn').addEventListener('click', () => {
            const albumId = getEl('editing-album-id').value;
            const name = getEl('album-name-input').value.trim();
            if (!name) return showToast('Áõ∏ÂÜåÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫', 'error');
            const desc = getEl('album-desc-input').value.trim();

            if (albumId) { // Editing
                const album = appState.chat.moments.albums.find(a => a.id === albumId);
                album.name = name;
                album.description = desc;
            } else { // Creating
                const newAlbum = { id: newId('album'), name, description: desc, createTime: Date.now(), photoIds: [] };
                appState.chat.moments.albums.push(newAlbum);
            }
            debouncedSaveState();
            renderManageAlbums();
            editAlbumModal.classList.remove('visible');
        });
        
        // --- Album View Screen Listeners ---
        getEl('view-album-back-btn').addEventListener('click', () => {
            closeSubScreen(viewAlbumScreen, chatAppScreen);
            const deleteBtn = getEl('delete-photos-btn');
            deleteBtn.style.display = 'none';
            viewAlbumScreen.querySelectorAll('.photo-grid-item.selected-for-deletion').forEach(el => el.classList.remove('selected-for-deletion'));
            renderMomentsFeed(runtimeState.moments.currentProfileId);
        });
        
        let photoLongPressTimer = null;
        getEl('album-photo-grid').addEventListener('pointerdown', e => {
             const item = e.target.closest('.photo-grid-item');
             if(!item) return;
             photoLongPressTimer = setTimeout(() => {
                getEl('delete-photos-btn').style.display = 'block';
                item.classList.add('selected-for-deletion');
             }, 800);
        });
        getEl('album-photo-grid').addEventListener('pointerup', () => clearTimeout(photoLongPressTimer));
        getEl('album-photo-grid').addEventListener('pointerleave', () => clearTimeout(photoLongPressTimer));
        
        getEl('album-photo-grid').addEventListener('click', e => {
            const item = e.target.closest('.photo-grid-item');
            if (!item) return;
            
            if (getEl('delete-photos-btn').style.display === 'block') {
                item.classList.toggle('selected-for-deletion');
            } else {
                const grid = item.closest('.photo-grid');
                const allPhotoItems = Array.from(grid.querySelectorAll('.photo-grid-item'));
                const allPhotoIds = allPhotoItems.map(photoItem => photoItem.dataset.id);
                const allPhotos = allPhotoIds.map(id => appState.chat.moments.photos.find(p => p.id === id)).filter(Boolean);
                const startIndex = allPhotoItems.indexOf(item);

                if (startIndex > -1) {
                    openPhotoViewer(allPhotos, startIndex);
                }
            }
        });

        getEl('delete-photos-btn').addEventListener('click', () => {
            const selectedItems = viewAlbumScreen.querySelectorAll('.photo-grid-item.selected-for-deletion');
            if (selectedItems.length === 0) return;
            if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${selectedItems.length} Âº†ÁÖßÁâáÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`)) {
                const idsToDelete = Array.from(selectedItems).map(item => item.dataset.id);
                // Remove from global photo list
                appState.chat.moments.photos = appState.chat.moments.photos.filter(p => !idsToDelete.includes(p.id));
                // Remove from all albums
                appState.chat.moments.albums.forEach(album => {
                    if (album.photoIds) {
                        album.photoIds = album.photoIds.filter(pid => !idsToDelete.includes(pid));
                    }
                });
                // Remove from posts
                 appState.chat.moments.posts.forEach(post => {
                    if (post.type === 'photo' && post.content.photoIds) {
                        post.content.photoIds = post.content.photoIds.filter(pid => !idsToDelete.includes(pid));
                    }
                });
                debouncedSaveState();
                renderAlbumView(viewAlbumScreen.dataset.albumId);
                getEl('delete-photos-btn').style.display = 'none';
            }
        });

        getEl('cancel-edit-photo-btn').addEventListener('click', () => editPhotoModal.classList.remove('visible'));
        getEl('save-photo-btn').addEventListener('click', () => {
            const photoId = getEl('editing-photo-id').value;
            const photo = appState.chat.moments.photos.find(p => p.id === photoId);
            if (photo) {
                photo.name = getEl('photo-name-input').value.trim();
                photo.description = getEl('photo-desc-input').value.trim();
                debouncedSaveState();
                editPhotoModal.classList.remove('visible');
                showToast('ÁÖßÁâá‰ø°ÊÅØÂ∑≤Êõ¥Êñ∞');
                // Re-render the viewer to show updated info
                if (viewPhotoModal.classList.contains('visible')) {
                    renderPhotoViewerContent(runtimeState.moments.viewerContext.currentIndex);
                }
                // Refresh moments feed if it's visible
                syncAndUpdateMoments(runtimeState.moments.currentProfileId);
            }
        });


        // --- Leave Message Modal Listeners ---
        getEl('cancel-leave-message-btn').addEventListener('click', () => leaveMessageModal.classList.remove('visible'));
        getEl('confirm-leave-message-btn').addEventListener('click', () => {
                const modal = getEl('leave-message-modal');
                const editingId = modal.dataset.editingId;
                
                const recipientName = getEl('message-recipient').value.trim();
                const content = getEl('message-content').value.trim();
                const senderNameFromInput = getEl('message-sender').value.trim();

                if (!recipientName || !content) {
                    return showToast('Áß∞ÂëºÂíåÂÜÖÂÆπÂùá‰∏∫ÂøÖÂ°´È°π', 'error');
                }
                
                if (editingId) {
                    const message = appState.chat.moments.messages.find(m => m.id === editingId);
                    if (message) {
                        const selectedAuthorEl = getEl('leave-message-author-selector').querySelector('.selected');
                        const newSenderId = selectedAuthorEl ? selectedAuthorEl.dataset.id : message.senderId;
                        const newSender = findUserById(newSenderId);

                        message.recipientName = recipientName;
                        message.content = content;
                        message.senderId = newSenderId;
                        message.senderName = getEl('message-sender').value.trim() || newSender.name; // Use input value first
                        message.visibility = runtimeState.moments.postContext.visibility;
                        message.visibleTo = runtimeState.moments.postContext.visibleTo;
                        showToast('ÁïôË®ÄÂ∑≤Êõ¥Êñ∞ÔºÅ');
                    }
                } else {
                     if (!senderNameFromInput) return showToast('ËêΩÊ¨æ‰∏∫ÂøÖÂ°´È°π', 'error');
                    const newMessage = {
                        id: newId('message'),
                        recipientId: runtimeState.moments.currentProfileId,
                        recipientName,
                        content,
                        senderId: 'user',
                        senderName: senderNameFromInput,
                        timestamp: Date.now(),
                        visibility: runtimeState.moments.postContext.visibility,
                        visibleTo: runtimeState.moments.postContext.visibleTo,
                        replies: []
                    };
                    appState.chat.moments.messages.push(newMessage);
                    logVisitor(newMessage.recipientId, 'user'); // Log visitor for leaving a message
                    // Send notification
                    addMomentsNotification('message', 'user', {
                        messageId: newMessage.id,
                        recipientId: newMessage.recipientId,
                        content: newMessage.content
                    });
                    showToast('ÁïôË®ÄÊàêÂäüÔºÅ');
                }

                debouncedSaveState();
                renderMomentsFeed(runtimeState.moments.currentProfileId);
                leaveMessageModal.classList.remove('visible');
            });
        
         getEl('leave-message-visibility').addEventListener('change', e => {
            runtimeState.moments.postContext.visibility = e.target.value;
            const selectorContainer = getEl('leave-message-friend-selector-container');
            if (e.target.value === 'specific') {
                renderFriendSelector('leave-message-friend-selector', 'message');
                selectorContainer.classList.remove('hidden-by-logic');
            } else {
                selectorContainer.classList.add('hidden-by-logic');
            }
        });

        getEl('leave-message-friend-selector').addEventListener('click', e => {
            const item = e.target.closest('.friend-selector-item');
            if (item) {
                const id = item.dataset.id;
                item.classList.toggle('selected');
                const context = runtimeState.moments.postContext;
                if (item.classList.contains('selected')) {
                    if (!context.visibleTo.includes(id)) context.visibleTo.push(id);
                } else {
                    context.visibleTo = context.visibleTo.filter(fid => fid !== id);
                }
            }
            
        });
        getEl('photo-viewer-prev-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            let { currentIndex } = runtimeState.moments.viewerContext;
            if (currentIndex > 0) {
                currentIndex--;
                runtimeState.moments.viewerContext.currentIndex = currentIndex;
                renderPhotoViewerContent(currentIndex);
            }
        });
        getEl('photo-viewer-next-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            let { items, currentIndex } = runtimeState.moments.viewerContext;
            if (currentIndex < items.length - 1) {
                currentIndex++;
                runtimeState.moments.viewerContext.currentIndex = currentIndex;
                renderPhotoViewerContent(currentIndex);
            }
        });
    }

    function renderAlbumView(albumId) {
        const album = appState.chat.moments.albums.find(a => a.id === albumId);
        if (!album) {
            closeSubScreen(viewAlbumScreen, chatAppScreen);
            return;
        }

        viewAlbumScreen.dataset.albumId = albumId;
        getEl('view-album-title').textContent = album.name;
        
        const grid = getEl('album-photo-grid');
        const photoIds = album.photoIds || [];
        const photosInAlbum = appState.chat.moments.photos.filter(p => photoIds.includes(p.id));
        
        if (photosInAlbum.length === 0) {
            grid.innerHTML = `<p style="text-align:center; color:#888; grid-column: 1 / -1;">Áõ∏ÂÜåÈáåËøòÊ≤°ÊúâÁÖßÁâá</p>`;
        } else {
             grid.innerHTML = photosInAlbum.map(p => `<div class="photo-grid-item" data-id="${p.id}" data-image-id="${p.imageId}"></div>`).join('');
             grid.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));
        }
    }
    function openSimpleViewer(items, startIndex = 0) {
        if (!items || items.length === 0) return;
        runtimeState.moments.viewerContext = {
            items: items,
            currentIndex: startIndex
        };
        renderSimpleViewerContent(startIndex);
        simpleViewerModal.classList.add('visible');
    }
    function renderSimpleViewerContent(index) {
        const { items } = runtimeState.moments.viewerContext;
        const item = items[index];
        if (!item) return;

        const imgEl = getEl('simple-viewer-image');
        const textEl = getEl('simple-viewer-text');

        if (item.isTextImage) {
                imgEl.style.display = 'none';
                textEl.style.display = 'flex';
                textEl.textContent = item.description;
            } else {
                imgEl.style.display = 'block';
                textEl.style.display = 'none';
                imgEl.src = '';
                setElementImage(imgEl, item.imageId, 'src');
            }

        const prevBtn = getEl('simple-viewer-prev-btn');
        const nextBtn = getEl('simple-viewer-next-btn');
        prevBtn.style.display = (items.length > 1 && index > 0) ? 'block' : 'none';
        nextBtn.style.display = (items.length > 1 && index < items.length - 1) ? 'block' : 'none';
    }
    function setupMomentsModalListeners() {
        // Listener for dynamic author selector in post edit modal
        postMomentModal.addEventListener('click', e => {
            const item = e.target.closest('.author-selector-item');
            if (item && item.closest('#moment-post-author-selector')) {
                item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            }
        });

        cancelPostMomentBtn.addEventListener('click', () => postMomentModal.classList.remove('visible'));
        
        confirmPostMomentBtn.addEventListener('click', async () => {
        const { type, visibility, visibleTo, images, editingPostId } = runtimeState.moments.postContext;
        const areCommentsPrivate = getEl('post-moment-comment-private-checkbox').checked;
        
        let postData;
        if(editingPostId){
            postData = appState.chat.moments.posts.find(p => p.id === editingPostId);
            const selectedAuthorEl = getEl('moment-post-author-selector')?.querySelector('.selected');
            if (selectedAuthorEl) {
                postData.authorId = selectedAuthorEl.dataset.id;
            }
        } else {
            postData = { id: newId('post'), authorId: 'user', timestamp: Date.now(), likes: [], comments: [] };
        }

        if (type === 'status') {
            const text = getEl('post-moment-status-content').value.trim();
            const statusType = query('input[name="status-type"]:checked').value;
            let finalImages = [...images];

            if (statusType === 'text-image') {
                const desc = getEl('post-moment-text-image-desc').value.trim();
                if (desc) {
                    finalImages.push({ isTextImage: true, imageId: 'default_camera_image', description: desc });
                }
            }

            if (!text && finalImages.length === 0) return showToast('ËØ∑ËØ¥ÁÇπ‰ªÄ‰πàÊàñÊ∑ªÂä†‰∏ÄÂº†ÂõæÁâáÂêß', 'error');
            postData.type = 'status';
            postData.content = { text, images: finalImages };
        } else if (type === 'log') {
            const title = getEl('post-moment-log-title').value.trim();
            const text = getEl('post-moment-log-content').value.trim();
            if(!title) return showToast('Êó•ÂøóÊ†áÈ¢ò‰∏çËÉΩ‰∏∫Á©∫', 'error');
            postData.type = 'log';
            postData.content = { title, text };
        }

        postData.visibility = visibility;
        postData.visibleTo = visibility === 'specific' ? visibleTo : [];
        postData.areCommentsPrivate = areCommentsPrivate; // Save the new setting
        
        if(!editingPostId) {
            appState.chat.moments.posts.unshift(postData);
        }

        debouncedSaveState();
        renderMomentsFeed(runtimeState.moments.currentProfileId);
        postMomentModal.classList.remove('visible');
    });
    
        getEl('post-moment-status-type').addEventListener('change', e => {
            const type = e.target.value;
            const imageButtons = getEl('post-moment-image-buttons');
            const textImageInput = getEl('post-moment-text-image-input');
            imageButtons.classList.toggle('hidden-by-logic', type !== 'image');
            textImageInput.classList.toggle('hidden-by-logic', type !== 'text-image');
        });
    
        getEl('post-moment-visibility').addEventListener('change', e => {
            runtimeState.moments.postContext.visibility = e.target.value;
            const friendSelector = getEl('post-moment-friend-selector-container');
            if (e.target.value === 'specific') {
                renderFriendSelector('post-moment-friend-selector', 'post');
                friendSelector.classList.remove('hidden-by-logic');
            } else {
                friendSelector.classList.add('hidden-by-logic');
                runtimeState.moments.postContext.visibleTo = [];
            }
        });
    
        getEl('post-moment-friend-selector').addEventListener('click', e => {
            const item = e.target.closest('.friend-selector-item');
            if (item) {
                const id = item.dataset.id;
                item.classList.toggle('selected');
                if (item.classList.contains('selected')) {
                    runtimeState.moments.postContext.visibleTo.push(id);
                } else {
                    runtimeState.moments.postContext.visibleTo = runtimeState.moments.postContext.visibleTo.filter(friendId => friendId !== id);
                }
            }
        });
        
        getEl('post-moment-upload-btn').addEventListener('click', () => getEl('post-moment-image-input').click());
        getEl('post-moment-add-url-btn').addEventListener('click', async () => {
            const url = prompt('ËØ∑ËæìÂÖ•ÂõæÁâáURL:');
            if (url && url.startsWith('http')) {
                showToast('Ê≠£Âú®Ê∑ªÂä†ÂõæÁâá...');
                try {
                    const response = await fetch(url);
                    const blob = await response.blob();
                    const newImageId = newId('moment_img');
                    await addMediaToDB(newImageId, blob);
                    runtimeState.moments.postContext.images.push(newImageId);
                    showToast('ÂõæÁâáÊ∑ªÂä†ÊàêÂäüÔºÅ');
                } catch (error) {
                    showToast('Ê∑ªÂä†ÂõæÁâáÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•URLÊàñÁΩëÁªú', 'error');
                }
            }
        });
        
        getEl('post-moment-image-input').addEventListener('change', async (e) => {
            const files = e.target.files;
            if(files.length > 0){
                showToast(`Ê≠£Âú®Ê∑ªÂä† ${files.length} Âº†ÂõæÁâá...`);
                for(const file of files) {
                    const newImageId = newId('moment_img');
                    await addMediaToDB(newImageId, file);
                    runtimeState.moments.postContext.images.push(newImageId);
                }
                showToast('ÂõæÁâáÊ∑ªÂä†ÊàêÂäüÔºÅ');
                e.target.value = ''; // Reset file input
            }
        });

        // Listeners for the new comment edit modal
        const authorSelector = getEl('moment-comment-author-selector');
        authorSelector.addEventListener('click', e => {
            const item = e.target.closest('.author-selector-item');
            if(item) {
                authorSelector.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            }
        });

        cancelEditMomentCommentBtn.addEventListener('click', () => {
            editMomentCommentModal.classList.remove('visible');
        });

        saveEditMomentCommentBtn.addEventListener('click', () => {
            const { source, postId, commentId, replyId, messageId } = runtimeState.editingComment;
            
            let commentToEdit = null;
            if (source === 'message') {
                const message = appState.chat.moments.messages.find(m => m.id === messageId);
                if (message && message.replies) {
                    commentToEdit = message.replies.find(r => r.id === replyId);
                }
            } else { // source === 'moments'
                const post = appState.chat.moments.posts.find(p => p.id === postId);
                if (post) {
                    commentToEdit = replyId 
                        ? post.comments.find(c => c.replies && c.replies.some(r => r.id === replyId))?.replies.find(r => r.id === replyId)
                        : post.comments.find(c => c.id === commentId);
                }
            }
            
            if (!commentToEdit) return showToast('Êâæ‰∏çÂà∞Ë¶ÅÁºñËæëÁöÑÂÜÖÂÆπ', 'error');

            const newContent = getEl('edit-moment-comment-content').value;
            const selectedAuthorEl = getEl('moment-comment-author-selector').querySelector('.selected');
            const newAuthorId = selectedAuthorEl ? selectedAuthorEl.dataset.id : commentToEdit.authorId;

            commentToEdit.text = newContent;
            commentToEdit.authorId = newAuthorId;
            
            debouncedSaveState();
            renderMomentsFeed(runtimeState.moments.currentProfileId);
            editMomentCommentModal.classList.remove('visible');
        });
        leaveMessageModal.addEventListener('click', e => {
            const item = e.target.closest('#leave-message-author-selector .author-selector-item');
            if (item) {
                item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            }
        });
    }


    function renderFriendSelector(containerId, contextType) {
        const selector = getEl(containerId);
        const visibleToList = runtimeState.moments.postContext.visibleTo;

        // --- ‰øÆÊ≠£ÔºöÂ∞ÜUserÊú¨‰∫∫Âä†ÂÖ•ÂèØÈÄâÂàóË°® ---
        const userProfile = appState.chat.moments.profile;
        const userForSelector = { id: 'user', charSettings: { name: userProfile.name, avatarId: userProfile.avatarId } };
        const availableFriends = [userForSelector, ...appState.chat.contacts.filter(c => !c.isGroup)];
        
        selector.innerHTML = availableFriends.map(friend => {
            const isSelected = visibleToList.includes(friend.id);
            const avatarId = friend.id === 'user' ? userForSelector.charSettings.avatarId : friend.charSettings.avatarId;
            const name = friend.id === 'user' ? userForSelector.charSettings.name : friend.charSettings.name;
            return `
                <div class="friend-selector-item ${isSelected ? 'selected' : ''}" data-id="${friend.id}">
                    <div class="avatar" data-avatar-id="${avatarId}"></div>
                    <span class="name">${name}</span>
                </div>
            `;
        }).join('');
        selector.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    }

// ===================================================================
// --- ÂàùÂßãÂåñ ---
// ===================================================================
    function setupAllListInteractions() { 
        new ListInteractionHandler(presetListEl, { itemSelector: '.preset-list-item', contentSelector: '.preset-item-content', actionsSelector: '.preset-item-actions', onDelete: (item) => { const index = parseInt(item.dataset.index); if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§È¢ÑËÆæ "${appState.settings.presets[index].name}" ÂêóÔºü`)) { appState.settings.presets.splice(index, 1); debouncedSaveState(); renderPresetList(); updatePresetSelect(); showToast("È¢ÑËÆæÂ∑≤Âà†Èô§"); } }, onEdit: (item) => { const index = parseInt(item.dataset.index); const preset = appState.settings.presets[index]; editPresetIndexInput.value = index; editPresetNameInput.value = preset.name; editPresetUrlInput.value = preset.url; editPresetKeyInput.value = preset.key; editPresetModal.classList.add('visible'); } }); 
        new ListInteractionHandler(musicListEl, { itemSelector: '.music-list-item', contentSelector: '.music-item-content', actionsSelector: '.music-item-actions', onTap: (item) => { const songId = item.dataset.id; const currentPlayingSong = appState.music.queue[appState.music.currentQueueIndex]; if (currentPlayingSong && currentPlayingSong.id === songId && runtimeState.musicSessionType === 'solo') { stopPlayback(); } else { const songIndex = appState.music.playlist.findIndex(s => s.id === songId); if (songIndex > -1) { stopPlayback(); runtimeState.currentChatId = null; runtimeState.musicSessionType = 'solo'; appState.music.queue = [...appState.music.playlist]; playSongFromQueue(songIndex); getEl('lyrics-container').classList.add('visible'); } } }, onLongPress: (item) => { openSongDetails(item.dataset.id); }, onDelete: async (item) => { const songId = item.dataset.id; const songIndex = appState.music.playlist.findIndex(s => s.id === songId); if (songIndex > -1) { const song = appState.music.playlist[songIndex]; if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠åÊõ≤ "${song.title}" ÂêóÔºü`)) { if(song.isLocal) { await deleteMediaFromDB(songId); } appState.music.playlist.splice(songIndex, 1); delete appState.music.lyrics[songId]; const queueIndex = appState.music.queue.findIndex(s => s.id === songId); if (queueIndex > -1) { appState.music.queue.splice(queueIndex, 1); if (queueIndex === appState.music.currentQueueIndex) { if (appState.music.queue.length > 0) { playSongFromQueue(queueIndex % appState.music.queue.length); } else { stopPlayback(); } } else if (queueIndex < appState.music.currentQueueIndex) { appState.music.currentQueueIndex--; } } renderMusicList(); renderPlayerQueue(); debouncedSaveState(); showToast("Ê≠åÊõ≤Â∑≤Âà†Èô§"); } } }, onEdit: (item) => { const songId = item.dataset.id; const song = appState.music.playlist.find(s => s.id === songId); if (song) { editSongIdInput.value = song.id; editSongTitleInput.value = song.title; editSongArtistInput.value = song.artist; editSongModal.classList.add('visible'); } } });  
        new ListInteractionHandler(fontListEl, { itemSelector: '.font-list-item', contentSelector: '.font-item-content', actionsSelector: '.font-item-actions', onTap: (item, target) => { if (target.classList.contains('font-color-btn')) { const newColor = prompt("ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂ≠ó‰ΩìÈ¢úËâ≤ (HEXÊàñRGB/A):", appState.beautify.fontColor); if (newColor && isValidColor(newColor)) { appState.beautify.fontColor = newColor; document.documentElement.style.setProperty('--system-font-color', newColor); debouncedSaveState(); showToast('Â≠ó‰ΩìÈ¢úËâ≤Â∑≤Êõ¥Êñ∞'); } else if (newColor) { showToast('Êó†ÊïàÁöÑÈ¢úËâ≤Ê†ºÂºè', 'error'); } } else { const fontName = item.dataset.name; if (confirm(`Á°ÆÂÆöË¶ÅÂ∞ÜÁ≥ªÁªüÂ≠ó‰ΩìÊõ¥Êç¢‰∏∫ "${fontName === 'default' ? 'ÈªòËÆ§Á≥ªÁªüÂ≠ó‰Ωì' : fontName}" ÂêóÔºü`)) { applyFont(fontName); } } }, onDelete: async (item) => { const fontName = item.dataset.name; if (fontName === 'default') { showToast('ÈªòËÆ§Â≠ó‰ΩìÊó†Ê≥ïÂà†Èô§', 'error'); return; } if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§Â≠ó‰Ωì "${fontName}" ÂêóÔºü`)) { const fontIndex = appState.beautify.fonts.findIndex(f => f.name === fontName); if (fontIndex > -1) { await deleteMediaFromDB(appState.beautify.fonts[fontIndex].id); appState.beautify.fonts.splice(fontIndex, 1); } if (appState.beautify.currentFont === fontName) { applyFont('default'); } await loadAllCustomFonts(); debouncedSaveState(); renderFonts(); showToast('Â≠ó‰ΩìÂ∑≤Âà†Èô§'); } }, onEdit: async (item) => { const fontName = item.dataset.name; if (fontName === 'default') { showToast('ÈªòËÆ§Â≠ó‰ΩìÊó†Ê≥ïÁºñËæë', 'error'); return; } const fontIndex = appState.beautify.fonts.findIndex(f => f.name === fontName); if (fontIndex > -1) { const newName = prompt('ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂ≠ó‰ΩìÂêçÁß∞:', fontName); if (newName && newName.trim() !== '') { appState.beautify.fonts[fontIndex].name = newName.trim(); if (appState.beautify.currentFont === fontName) { appState.beautify.currentFont = newName.trim(); } await loadAllCustomFonts(); debouncedSaveState(); renderFonts(); showToast('Â≠ó‰ΩìÂêçÁß∞Â∑≤Êõ¥Êñ∞'); } } } }); 
        const createDataListHandler = (listEl, type, renderFunction) => { new ListInteractionHandler(listEl, { itemSelector: '.preset-data-item', contentSelector: '.preset-data-item-content', actionsSelector: '.preset-data-item-actions', onTap: (item) => { const dataId = item.dataset.id; const dataItem = appState.data[type + 's'].find(d => d.id === dataId); if (dataItem) { viewContentTitle.textContent = escapeHTML(dataItem.name); viewContentBody.innerHTML = `<p>${escapeHTML(dataItem.content || '').replace(/\n/g, '<br>')}</p>`; viewContentModal.classList.add('visible'); } }, onDelete: (item) => { const id = item.dataset.id; const dataArray = appState.data[type + 's']; const itemIndex = dataArray.findIndex(i => i.id === id); if (itemIndex > -1) { if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ "${dataArray[itemIndex].name}" ÂêóÔºü`)) { dataArray.splice(itemIndex, 1); debouncedSaveState(); renderFunction(); } } }, onEdit: (item) => { openDataEditor(type, item.dataset.id); } }); }; createDataListHandler(worldBookListEl, 'worldBook', renderWorldBooks); createDataListHandler(archiveListEl, 'archive', renderArchives); createDataListHandler(infoListEl, 'info', renderInfos); 
        new ListInteractionHandler(detailsCommentsList, { itemSelector: '.comment-item', contentSelector: '.comment-item-main', actionsSelector: '.comment-item-actions-swipe', onDelete: (item) => { const songId = songDetailsScreen.dataset.songId; const commentId = item.dataset.commentId; const commentIndex = appState.music.comments[songId].findIndex(c => c.id === commentId); if (commentIndex > -1) { if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËØÑËÆ∫ÂêóÔºü')) { appState.music.comments[songId].splice(commentIndex, 1); debouncedSaveState(); renderSongComments(songId); } } }, onEdit: (item) => { const songId = songDetailsScreen.dataset.songId; const commentId = item.dataset.commentId; const comment = appState.music.comments[songId].find(c => c.id === commentId); if (comment) { runtimeState.editingComment = { source: 'music', songId, commentId, replyId: null }; editCommentInput.value = comment.text; editCommentModal.classList.add('visible'); } } }); 
        new ListInteractionHandler(messageListEl, { itemSelector: '.contact-list-item', contentSelector: '.contact-item-content', actionsSelector: '.contact-item-actions', onTap: (item) => { if (chatAppScreen.classList.contains('selection-mode')) { if (item.dataset.isGroup === 'true') { showToast('‰∏çËÉΩÈÄâÊã©Áæ§ÁªÑÂä†ÂÖ•Êñ∞Áæ§ËÅä', 'error'); return; } item.classList.toggle('selected'); const id = item.dataset.id; if (item.classList.contains('selected')) { if (!runtimeState.contactSelection.includes(id)) runtimeState.contactSelection.push(id); } else { runtimeState.contactSelection = runtimeState.contactSelection.filter(selId => selId !== id); } } else { openSingleChat(item.dataset.id); } }, onLongPress: (item) => { if (!chatAppScreen.classList.contains('selection-mode')) { enterContactSelectionMode(item); } }, onDelete: (item) => {
            const contactId = item.dataset.id;
            const contactIndex = appState.chat.contacts.findIndex(c => c.id === contactId);
            if (contactIndex > -1) {
                const contact = appState.chat.contacts[contactIndex];
                if (confirm(`Á°ÆÂÆöË¶ÅÊ∞∏‰πÖÂà†Èô§ËÅîÁ≥ª‰∫∫ "${contact.name}" ÂêóÔºüÊ≠§Êìç‰ΩúÂ∞Ü‰∏ÄÂπ∂Âà†Èô§ÂÖ∂ÊâÄÊúâÂä®ÊÄÅ„ÄÅËØÑËÆ∫ÂíåÁïôË®ÄÔºå‰∏î‰∏çÂèØÈÄÜ„ÄÇ`)) {
                    // --- ADDED CODE START ---
    // Check if a video call with this contact is active and end it
    if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId === contactId) {
        endVideoCall();
    }
    // --- ADDED CODE END ---
                    // --- Enhanced Deletion Logic for Single Chars ---
                    if (!contact.isGroup) {
                        const charId = contact.id;

                        // 1. Clean Moments Posts, Likes, Comments, Replies
                        // Filter out posts by the char
                        appState.chat.moments.posts = appState.chat.moments.posts.filter(post => post.authorId !== charId);
                        // Clean remaining posts
                        appState.chat.moments.posts.forEach(post => {
                            // Remove likes from the char
                            if (post.likes) {
                                post.likes = post.likes.filter(likerId => likerId !== charId);
                            }
                            // Remove comments from the char, and replies within other comments
                            if (post.comments) {
                                post.comments = post.comments.filter(comment => comment.authorId !== charId);
                                post.comments.forEach(comment => {
                                    if (comment.replies) {
                                        comment.replies = comment.replies.filter(reply => reply.authorId !== charId);
                                    }
                                });
                            }
                        });

                        // 2. Clean Message Board Messages and Replies
                        // Filter out messages by the char
                        appState.chat.moments.messages = appState.chat.moments.messages.filter(msg => msg.senderId !== charId);
                         // Clean Message Board Messages and Replies
                        // Filter out messages by the char
                        appState.chat.moments.messages = appState.chat.moments.messages.filter(msg => msg.senderId !== charId);
                        
                        // 3. Clean Visitor Logs
                        // Remove records of this char visiting the user
                        if (appState.chat.moments.visitors) {
                            appState.chat.moments.visitors = appState.chat.moments.visitors.filter(v => v.visitorId !== charId);
                        }
                        // Remove records of anyone visiting this char (since their page is gone)
                        appState.chat.contacts.forEach(c => {
                            if(c.charSettings && c.charSettings.visitors) {
                                c.charSettings.visitors = c.charSettings.visitors.filter(v => v.visitorId !== charId);
                            }
                        });

                        // Clean replies within remaining messages
                        appState.chat.moments.messages.forEach(msg => {
                            if (msg.replies) {
                                msg.replies = msg.replies.filter(reply => reply.authorId !== charId);
                            }
                        });
    
    // 4. Clean Love Letters
if (appState.mailbox && appState.mailbox.loveLetters) {
    appState.mailbox.loveLetters = appState.mailbox.loveLetters.filter(letter => letter.senderId !== charId && letter.recipientId !== charId);
}
                    }
                    // --- End of Enhanced Deletion Logic ---

                    // Original deletion logic
                    appState.chat.contacts.splice(contactIndex, 1);
                    saveState();
                    renderMessageList();
                    
                    // Refresh moments UI if visible
                    syncAndUpdateMoments(runtimeState.moments.currentProfileId);

                    showToast('ËÅîÁ≥ª‰∫∫ÂèäÁõ∏ÂÖ≥Âä®ÊÄÅÂ∑≤Âà†Èô§');
                }
            }
        } }); 
        const emojiInteractionHandler = new ListInteractionHandler(emojiGrid, { itemSelector: '.emoji-item', disableSwipe: true, onTap: (item) => { if (runtimeState.emojiSelectionMode) { toggleEmojiSelection(item); } else { const emoji = appState.chat.emojis.find(em => em.id === item.dataset.emojiId); if (emoji) { addMessageToConversation({ id: newId('msg'), type: 'emoji', emojiId: emoji.id, description: emoji.description, sender: 'user', timestamp: Date.now(), status: 'pending', contactId: runtimeState.currentChatId }); emojiPickerPanel.classList.remove('visible'); } } }, onLongPress: (item) => { if (!runtimeState.emojiSelectionMode) { enterEmojiSelectionMode(item); } } }); runtimeState.emojiInteractionHandler = emojiInteractionHandler;
    }

    function setupMomentsListInteraction(feedElement) {
        // Destroy the old handler if it exists to prevent memory leaks and duplicate listeners
        if (runtimeState.moments && runtimeState.moments.listHandler) {
            runtimeState.moments.listHandler.destroy();
        }

        const handler = new ListInteractionHandler(feedElement, {
            itemSelector: '.moments-post-item, .message-board-item',
            // „ÄêÊ†∏ÂøÉ‰øÆÂ§ç„Äë: Â∞ÜÈÄâÊã©Âô®‰øÆÊ≠£‰∏∫‰∏éHTMLÂÆûÈôÖ‰ΩøÁî®ÁöÑÁ±ªÂêçÂÆåÂÖ®ÂåπÈÖç
            contentSelector: '.post-item-content, .message-board-item-main',
            actionsSelector: '.post-item-actions, .message-board-item-actions',
            onDelete: (item) => {
                        if (item.classList.contains('moments-post-item')) {
                            const postId = item.dataset.postId;
                            if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°Âä®ÊÄÅÂêóÔºüÊ≠§Êìç‰ΩúÂ∞ÜÂà†Èô§ÊâÄÊúâÁõ∏ÂÖ≥Êï∞ÊçÆ‰∏î‰∏çÂèØÈÄÜ„ÄÇ')) {
                                if (deleteMomentAndAssociatedData(postId)) {
                                    renderMomentsFeed(runtimeState.moments.currentProfileId);
                                    showToast('Âä®ÊÄÅÂèäÁõ∏ÂÖ≥Êï∞ÊçÆÂ∑≤Âà†Èô§');
                                }
                            }
                        } else if (item.classList.contains('message-board-item')) {
                            const messageId = item.dataset.messageId;
                            if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ÁïôË®ÄÂêóÔºü')) {
                                appState.chat.moments.messages = appState.chat.moments.messages.filter(m => m.id !== messageId);
                                debouncedSaveState();
                                renderMomentsFeed(runtimeState.moments.currentProfileId);
                                showToast('ÁïôË®ÄÂ∑≤Âà†Èô§');
                            }
                        }
                    },
            onEdit: (item) => {
                    if (item.classList.contains('moments-post-item')) {
                        const postId = item.dataset.postId;
                        const post = appState.chat.moments.posts.find(p => p.id === postId);
                        if (post) {
                            openPostMomentModal(post.type, post.id);
                        }
                    } else if (item.classList.contains('message-board-item')) {
                        const messageId = item.dataset.messageId;
                        const message = appState.chat.moments.messages.find(m => m.id === messageId);
                        if(message) {
                           openLeaveMessageModal(messageId);
                        }
                    }
                }
        });
        // Store the new handler instance in runtimeState
        runtimeState.moments.listHandler = handler;
    }

function setupSingleChatSettingsListeners() { csCharAvatarLibraryBtn.addEventListener('click', () => openLibraryModal({ title: 'CharÂ§¥ÂÉèÂ∫ì', settingsGroup: 'charSettings', libraryKey: 'avatarLibrary', activeKey: 'avatarId', showPreview: false, isCircular: true })); csCharAvatarFrameBtn.addEventListener('click', () => openLibraryModal({ title: 'CharÂ§¥ÂÉèÊ°ÜÂ∫ì', isFrame: true, settingsGroup: 'charSettings', activeKey: 'avatarFrameId', showPreview: true, hasNoItemOption: true, previewAvatarId: runtimeState.tempChatSettings.charSettings.avatarId })); usUserAvatarLibraryBtn.addEventListener('click', () => openLibraryModal({ title: 'ÊàëÁöÑÂ§¥ÂÉèÂ∫ì', isGlobalUserLib: true, settingsGroup: 'userSettings', activeKey: 'avatarId', showPreview: false, isCircular: true }));usUserAvatarFrameBtn.addEventListener('click', () => openLibraryModal({ title: 'ÊàëÁöÑÂ§¥ÂÉèÊ°ÜÂ∫ì', isFrame: true, settingsGroup: 'userSettings', activeKey: 'avatarFrameId', showPreview: true, hasNoItemOption: true, previewAvatarId: runtimeState.tempChatSettings.userSettings.avatarId })); 

    csCharBackgroundBtn.addEventListener('click', (e) => { showBackgroundContextMenu(e.currentTarget, { settingsObject: runtimeState.tempChatSettings.charSettings }); });
    const usUserVideoBackgroundBtn = getEl('us-user-video-background-btn'); if(usUserVideoBackgroundBtn) { usUserVideoBackgroundBtn.addEventListener('click', (e) => { const input = document.createElement('input'); input.type = 'file'; input.accept = 'image/*'; input.onchange = (e) => handleVideoBackgroundUpload(e.target.files[0], runtimeState.tempChatSettings.userSettings); input.click(); }); }
}
function setupWorldBookSelector(selectorContainer, listContainer, linkedIdsArray) {
        const btn = selectorContainer.querySelector('.wb-group-selector-btn');
        const dropdown = selectorContainer.querySelector('.wb-group-dropdown');
        if (!btn || !dropdown) return;

        const updateButtonText = () => {
            const selectedGroups = [...new Set(appState.data.worldBooks.filter(wb => linkedIdsArray.includes(wb.id)).map(wb => wb.group || 'Êú™ÂàÜÁªÑ'))];
            if (selectedGroups.length === 0) {
                btn.textContent = 'ÈÄâÊã©ÂàÜÁªÑ';
            } else if (selectedGroups.length === 1) {
                btn.textContent = selectedGroups[0];
            } else {
                btn.textContent = `${selectedGroups.length}‰∏™ÂàÜÁªÑÂ∑≤ÈÄâ`;
            }
        };

        const populateDropdown = () => {
            const groups = [...new Set(appState.data.worldBooks.map(wb => wb.group || 'Êú™ÂàÜÁªÑ'))];
            const selectedGroups = [...new Set(appState.data.worldBooks.filter(wb => linkedIdsArray.includes(wb.id)).map(wb => wb.group || 'Êú™ÂàÜÁªÑ'))];
            dropdown.innerHTML = groups.map(group => `
                <label class="checkbox-label">
                    <input type="checkbox" value="${group}" ${selectedGroups.includes(group) ? 'checked' : ''}>
                    <span>${group}</span>
                </label>
            `).join('');
        };
        
        // --- Ê†∏ÂøÉ‰øÆÂ§çÔºöÂÖàÁßªÈô§ÊóßÁöÑÁõëÂê¨Âô® ---
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        
        // --- Ê†∏ÂøÉ‰øÆÂ§çÔºö‰∏∫Êñ∞ÁöÑÊåâÈíÆÁªëÂÆöÁõëÂê¨Âô® ---
        newBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            // Close other dropdowns
            document.querySelectorAll('.wb-group-dropdown.visible').forEach(d => {
                if (d !== dropdown) d.classList.remove('visible');
            });
            populateDropdown();
            dropdown.classList.toggle('visible');
        });

        // The change listener on the dropdown can be reused as it's on a static parent
        const dropdownChangeHandler = (e) => {
             if (e.target.type === 'checkbox') {
                const groupName = e.target.value;
                const isChecked = e.target.checked;
                const idsInGroup = appState.data.worldBooks.filter(wb => (wb.group || 'Êú™ÂàÜÁªÑ') === groupName).map(wb => wb.id);

                if (isChecked) {
                    idsInGroup.forEach(id => {
                        if (!linkedIdsArray.includes(id)) linkedIdsArray.push(id);
                    });
                } else {
                    idsInGroup.forEach(id => {
                        const index = linkedIdsArray.indexOf(id);
                        if (index > -1) linkedIdsArray.splice(index, 1);
                    });
                }
                renderWorldBookList(listContainer, linkedIdsArray);
                updateButtonText();
            }
        };
        // Remove old listener if exists, then add new one
        dropdown.removeEventListener('change', dropdownChangeHandler);
        dropdown.addEventListener('change', dropdownChangeHandler);
        
        renderWorldBookList(listContainer, linkedIdsArray);
        updateButtonText();
    }
function renderWorldBookList(listElement, linkedIdsArray) { listElement.innerHTML = appState.data.worldBooks.map(wb => ` <label class="checkbox-label"> <input type="checkbox" value="${wb.id}" ${linkedIdsArray.includes(wb.id) ? 'checked' : ''}> <span>${wb.name}</span> </label> `).join(''); listElement.addEventListener('change', (e) => { if (e.target.type === 'checkbox') { const id = e.target.value; if (e.target.checked) { if (!linkedIdsArray.includes(id)) linkedIdsArray.push(id); } else { const index = linkedIdsArray.indexOf(id); if (index > -1) linkedIdsArray.splice(index, 1); } const selectorContainer = listElement.closest('.chat-settings-section').querySelector('.wb-group-selector'); if (selectorContainer) { const btn = selectorContainer.querySelector('.wb-group-selector-btn'); const selectedGroups = [...new Set(appState.data.worldBooks.filter(wb => linkedIdsArray.includes(wb.id)).map(wb => wb.group || 'Êú™ÂàÜÁªÑ'))]; if (selectedGroups.length === 0) { btn.textContent = 'ÈÄâÊã©ÂàÜÁªÑ'; } else if (selectedGroups.length === 1) { btn.textContent = selectedGroups[0]; } else { btn.textContent = `${selectedGroups.length}‰∏™ÂàÜÁªÑÂ∑≤ÈÄâ`; } } } }); }
    function openMomentCommentEditor(postId, commentId, replyId = null, messageId = null) {
        let commentToEdit = null;
        
        if (messageId) { // Editing a message reply
            const message = appState.chat.moments.messages.find(m => m.id === messageId);
            if (!message || !message.replies) return;
            commentToEdit = message.replies.find(r => r.id === replyId);
            runtimeState.editingComment = { source: 'message', messageId, replyId };
        } else { // Editing a post comment/reply
            const post = appState.chat.moments.posts.find(p => p.id === postId);
            if (!post) return;
            commentToEdit = replyId 
                ? post.comments.find(c => c.replies && c.replies.some(r => r.id === replyId))?.replies.find(r => r.id === replyId)
                : post.comments.find(c => c.id === commentId);
            runtimeState.editingComment = { source: 'moments', postId, commentId, replyId };
        }

        if (!commentToEdit) return;
        
        getEl('edit-moment-comment-content').value = commentToEdit.text;
        renderMomentAuthorSelector('moment-comment-author-selector', commentToEdit.authorId);
        
        editMomentCommentModal.classList.add('visible');
    }

    function renderMomentAuthorSelector(containerId, selectedId) {
        const container = getEl(containerId);
        const availableAuthors = [
            { id: 'user', name: appState.chat.moments.profile.name, avatarId: appState.chat.moments.profile.avatarId },
            ...appState.chat.contacts.filter(c => !c.isGroup).map(c => ({ id: c.id, name: c.charSettings.name, avatarId: c.charSettings.avatarId }))
        ];

        container.innerHTML = availableAuthors.map(author => `
            <div class="author-selector-item ${author.id === selectedId ? 'selected' : ''}" data-id="${author.id}">
                <div class="avatar" data-avatar-id="${author.avatarId}"></div>
                <span class="name">${author.name}</span>
            </div>
        `).join('');
        container.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    }
// ===================================================================
    // --- Êñ∞Â¢ûÔºöÂä®ÊÄÅ - ÁÖßÁâá„ÄÅÁõ∏ÂÜå„ÄÅÁïôË®ÄÊùøÂäüËÉΩ ---
    // ===================================================================
    
    function openUploadPhotoModal() {
    runtimeState.moments.postContext = {
        images: [], // for local file uploads
        textImageDescs: [], // for text-to-image
        albumId: null,
        visibility: 'public',
        visibleTo: []
    };

    getEl('upload-photo-name').value = '';
    getEl('upload-photo-desc').value = '';
    getEl('upload-photo-text-image-desc').value = '';
    getEl('upload-photo-text-image-input-group').classList.add('hidden-by-logic');
    getEl('upload-photo-image-preview-grid').innerHTML = '';
    
    const albumSelect = getEl('upload-photo-album-select');
    albumSelect.innerHTML = '';
    if (appState.chat.moments.albums.length === 0) {
        const defaultAlbum = { id: 'default', name: 'ÈªòËÆ§Áõ∏ÂÜå', createTime: Date.now(), photoIds: [] };
        appState.chat.moments.albums.push(defaultAlbum);
        debouncedSaveState();
    }
    appState.chat.moments.albums.forEach(album => {
        const option = document.createElement('option');
        option.value = album.id;
        option.textContent = album.name;
        albumSelect.appendChild(option);
    });

    queryAll('input[name="photo-visibility"]').forEach(r => r.checked = r.value === 'public');
    getEl('upload-photo-friend-selector-container').classList.add('hidden-by-logic');
    getEl('upload-photo-comment-private-checkbox').checked = false; // Reset the new checkbox

    uploadPhotoModal.classList.add('visible');
}
    
    function openManageAlbumsModal() {
        renderManageAlbums();
        manageAlbumsModal.classList.add('visible');
    }
    
    function renderManageAlbums() {
        const grid = getEl('manage-albums-grid');
        grid.innerHTML = '';
        if (appState.chat.moments.albums.length === 0) {
             const defaultAlbum = { id: 'default', name: 'ÈªòËÆ§Áõ∏ÂÜå', createTime: Date.now(), photoIds: [] };
             appState.chat.moments.albums.push(defaultAlbum);
             debouncedSaveState();
        }

        appState.chat.moments.albums.forEach(album => {
            const photoCount = (album.photoIds || []).length;
            const coverPhotoId = (album.photoIds && album.photoIds.length > 0) 
                ? appState.chat.moments.photos.find(p => p.id === album.photoIds[0])?.imageId
                : null;
            
            const dateStr = album.createTime ? new Date(album.createTime).toLocaleDateString() : '---';

            const item = document.createElement('div');
            item.className = 'album-item';
            item.dataset.id = album.id;
            item.innerHTML = `
                <div class="album-item-cover" data-image-id="${coverPhotoId || ''}"></div>
                <div class="album-item-overlay">
                    <div class="album-item-name">${escapeHTML(album.name)} (${photoCount})</div>
                    <div class="album-item-footer">
                        <span class="album-item-info">${dateStr}</span>
                        ${album.id !== 'default' ? `
                        <button class="icon-btn edit-album-btn">‚úèÔ∏è</button>
                        ` : ''}
                    </div>
                </div>
            `;
            grid.appendChild(item);
            if(coverPhotoId) {
                setElementImage(item.querySelector('.album-item-cover'), coverPhotoId, 'backgroundImage');
            }
        });
    }

    function openAlbumView(container, profileId, albumId) {
        // This is a placeholder for now, as full album view is complex.
        // It will just show the photos for now.
        if (albumId === 'default') {
            const allPhotos = appState.chat.moments.photos.filter(p => p.ownerId === profileId);
             container.innerHTML = `<div class="photo-grid">${allPhotos.map(p => `<div class="photo-grid-item" data-id="${p.id}" data-image-id="${p.imageId}"></div>`).join('')}</div>`;
             container.querySelectorAll('[data-image-id]').forEach(el => setElementImage(el, el.dataset.imageId, 'backgroundImage'));
        } else {
             container.innerHTML = `<p style="text-align:center; color:#888; margin-top: 50px;">Êü•ÁúãÊåáÂÆöÁõ∏ÂÜåÂäüËÉΩÂæÖÂºÄÂèë</p>`;
        }
    }
    
    function renderMessages(container, profileId) {
            const messages = appState.chat.moments.messages
                .filter(msg => {
                    if (msg.recipientId !== profileId) return false;
                    const isUserPage = profileId === 'user';
                    // Âú®Áî®Êà∑Ëá™Â∑±ÁöÑÁïôË®ÄÊùøÔºåÂèØ‰ª•ÁúãÂà∞ÊâÄÊúâÁªôËá™Â∑±ÁöÑÁïôË®Ä
                    if (isUserPage) return true;
                    // Âú®Âà´‰∫∫ÁöÑÁïôË®ÄÊùøÔºåÂè™ËÉΩÁúãÂà∞ÂÖ¨ÂºÄÁöÑÊàñËÄÖËá™Â∑±ÂèØËßÅÁöÑ
                    return msg.visibility === 'public' || (msg.visibleTo && msg.visibleTo.includes('user'));
                })
                .sort((a, b) => b.timestamp - a.timestamp);

            if (messages.length === 0) {
                container.innerHTML = `<div class="message-board-feed"><p style="text-align:center; color:#888; margin-top: 50px;">ËøòÊ≤°Êúâ‰∫∫ÁïôË®ÄÂì¶</p></div>`;
                return;
            }

            container.innerHTML = `<div class="message-board-feed">
                ${messages.map(msg => renderSingleMessage(msg)).join('')}
            </div>`;
            
            container.querySelectorAll('.message-board-avatar[data-avatar-id], .comment-avatar[data-avatar-id]').forEach(el => {
                setElementImage(el, el.dataset.avatarId);
            });
        }
        function renderSingleMessage(msg) {
            const recipient = findUserById(msg.recipientId);
            const sender = findUserById(msg.senderId);
            const repliesHTML = (msg.replies || []).map(reply => renderSingleMessageReply(reply, msg.replies || [], msg.id)).join('');

            return `
            <div class="message-board-item" data-message-id="${msg.id}">
                <div class="message-board-item-main swipe-content">
                    <div class="message-board-header">
                        <div class="message-board-avatar" data-avatar-id="${recipient.avatarId}"></div>
                        <p class="message-board-recipient">To: ${escapeHTML(msg.recipientName)}</p>
                    </div>
                    <p class="message-board-content">${escapeHTML(msg.content).replace(/\n/g, '<br>')}</p>
                    <div class="message-board-footer">
                        <div class="message-board-signature">
                            <span class="message-board-sender">From: ${escapeHTML(msg.senderName)}</span>
                            <div class="message-board-avatar" data-avatar-id="${sender.avatarId}"></div>
                        </div>
                        <div class="message-board-timestamp">${new Date(msg.timestamp).toLocaleString()}</div>
                    </div>
                    <div class="message-board-replies">${repliesHTML}</div>
                    <div class="reply-input-container" style="margin-top:10px;">
                        <input type="text" placeholder="ÂõûÂ§ç ${escapeHTML(msg.senderName)}...">
                        <button class="settings-button secondary" style="padding: 5px 10px;">ÂèëÈÄÅ</button>
                    </div>
                </div>
                <div class="message-board-item-actions swipe-actions">
                    <div class="edit-action">ÁºñËæë</div>
                    <div class="delete-action">Âà†Èô§</div>
                </div>
            </div>`;
        }

        function renderSingleMessageReply(reply, allReplies, messageId) {
            const author = findUserById(reply.authorId);
            let targetHTML = '';
            if (reply.replyTo) {
                const targetReply = allReplies.find(r => r.id === reply.replyTo);
                if (targetReply) {
                    const targetAuthor = findUserById(targetReply.authorId);
                    targetHTML = `ÂõûÂ§ç <span class="reply-target">@${targetAuthor.name}</span>`;
                }
            }
            const canModify = true; // ÂÅáËÆæÁî®Êà∑ÊÄªÊòØÂèØ‰ª•‰øÆÊîπ

            return `
            <div class="reply-item" data-reply-id="${reply.id}">
                <div class="comment-header" style="justify-content: space-between;">
                    <div>
                        <span class="reply-author">${author.name}</span> ${targetHTML}:
                    </div>
                    <div class="comment-actions-inline" style="display: none;">
                        ${canModify ? `
                        <button class="icon-btn edit-reply-btn" title="ÁºñËæë">‚úèÔ∏è</button>
                        <button class="icon-btn delete-reply-btn" title="Âà†Èô§">‚ùå</button>
                        ` : ''}
                    </div>
                </div>
                <p class="comment-text" style="margin-top: 2px;">${escapeHTML(reply.text)}</p>
                <div class="reply-input-container">
                    <input type="text" placeholder="ÂõûÂ§ç ${author.name}...">
                    <button class="settings-button secondary" style="padding: 5px 10px;">ÂèëÈÄÅ</button>
                </div>
            </div>`;
        }
    
    function openLeaveMessageModal(messageId = null) {
            const isEditing = messageId !== null;
            const modal = getEl('leave-message-modal');
            const authorSelectorContainer = getEl('leave-message-author-selector-container');
            
            modal.dataset.editingId = isEditing ? messageId : '';

            if (isEditing) {
                const message = appState.chat.moments.messages.find(m => m.id === messageId);
                if (!message) return showToast('Êâæ‰∏çÂà∞Ë¶ÅÁºñËæëÁöÑÁïôË®Ä', 'error');

                modal.querySelector('.modal-title').textContent = 'ÁºñËæëÁïôË®Ä';
                getEl('message-recipient').value = message.recipientName;
                getEl('message-content').value = message.content;
                getEl('message-sender').value = message.senderName;
                
                queryAll('input[name="message-visibility"]').forEach(r => r.checked = r.value === (message.visibility || 'public'));
                const friendSelector = getEl('leave-message-friend-selector-container');
                runtimeState.moments.postContext.visibleTo = message.visibleTo || [];
                if (message.visibility === 'specific') {
                    renderFriendSelector('leave-message-friend-selector', 'message');
                    friendSelector.classList.remove('hidden-by-logic');
                } else {
                    friendSelector.classList.add('hidden-by-logic');
                }

                authorSelectorContainer.classList.remove('hidden-by-logic');
                renderMomentAuthorSelector('leave-message-author-selector', message.senderId);

            } else {
                modal.querySelector('.modal-title').textContent = 'ÂÜôÁïôË®Ä';
                const profileId = runtimeState.moments.currentProfileId;
                const profile = findUserById(profileId);
                getEl('message-recipient').value = profile.name;
                getEl('message-content').value = '';
                getEl('message-sender').value = findUserById('user').name;

                queryAll('input[name="message-visibility"]').forEach(r => r.checked = r.value === 'public');
                getEl('leave-message-friend-selector-container').classList.add('hidden-by-logic');
                runtimeState.moments.postContext.visibleTo = [];
                authorSelectorContainer.classList.add('hidden-by-logic');
            }
            
            leaveMessageModal.classList.add('visible');
        }
    function openPhotoViewer(photos, startIndex = 0) {
        if (!photos || photos.length === 0) return;
        runtimeState.moments.viewerContext = {
            items: photos,
            currentIndex: startIndex
        };
        renderPhotoViewerContent(startIndex);
        viewPhotoModal.classList.add('visible');
    }
    function renderPhotoViewerContent(index) {
                const { items } = runtimeState.moments.viewerContext;
                const photo = items[index];
                if (!photo) return;

                const isTextImage = photo.isTextImage || (photo.textDescription && !photo.imageId);
                
                const imageView = getEl('viewer-image-view');
                const textView = getEl('viewer-text-view');

                if (isTextImage) {
                    viewPhotoModal.className = 'modal-overlay visible text-mode';
                    imageView.style.display = 'none';
                    textView.style.display = '';
                    getEl('view-photo-text-display').textContent = photo.textDescription || photo.description;
                } else {
                    viewPhotoModal.className = 'modal-overlay visible image-mode';
                    textView.style.display = 'none';
                    imageView.style.display = '';
                    const imgEl = getEl('view-photo-image');
                    imgEl.src = '';
                    setElementImage(imgEl, photo.imageId, 'src');
                    getEl('view-photo-name').textContent = photo.name;
                    const descText = photo.description || '';
                    const descEl = getEl('view-photo-desc');
                    descEl.textContent = descText;
                    descEl.style.display = descText ? 'block' : 'none';
                    viewPhotoModal.classList.remove('text-hidden');
                }

                const prevBtn = getEl('photo-viewer-prev-btn');
                const nextBtn = getEl('photo-viewer-next-btn');
                prevBtn.style.display = (items.length > 1 && index > 0) ? 'block' : 'none';
                nextBtn.style.display = (items.length > 1 && index < items.length - 1) ? 'block' : 'none';
            }
    function setupMomentsPageListeners() {
        // This function is now only for the comment editor modal, 
        // as the file inputs are handled by the new global listener.
        const authorSelector = getEl('moment-comment-author-selector');
        authorSelector.addEventListener('click', e => {
            const item = e.target.closest('.author-selector-item');
            if(item) {
                authorSelector.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            }
        });

        cancelEditMomentCommentBtn.addEventListener('click', () => {
            editMomentCommentModal.classList.remove('visible');
        });

        saveEditMomentCommentBtn.addEventListener('click', () => {
            const { postId, commentId, replyId } = runtimeState.editingComment;
            const post = appState.chat.moments.posts.find(p => p.id === postId);
            if (!post) return;
            
            const commentToEdit = replyId 
                ? post.comments.find(c => c.replies && c.replies.some(r => r.id === replyId))?.replies.find(r => r.id === replyId)
                : post.comments.find(c => c.id === commentId);
                
            if (!commentToEdit) return;

            const newContent = getEl('edit-moment-comment-content').value;
            const selectedAuthorEl = getEl('moment-comment-author-selector').querySelector('.selected');
            const newAuthorId = selectedAuthorEl ? selectedAuthorEl.dataset.id : commentToEdit.authorId;

            commentToEdit.text = newContent;
            commentToEdit.authorId = newAuthorId;
            
            debouncedSaveState();
            renderMomentsFeed(runtimeState.moments.currentProfileId);
            editMomentCommentModal.classList.remove('visible');
        });
    }
        function setupGlobalEventListeners() {
        document.body.addEventListener('change', async (e) => {
        });
    }
    function setupChatAppScreenListeners() {
        chatAppScreen.addEventListener('click', (e) => {
            const momentsTab = query('#chat-app-screen .tab-link[data-tab="moments"]');
            if (momentsTab && momentsTab.classList.contains('active')) {
                 const interactionArea = e.target.closest('.moments-scroll-container, .moments-fab-container');
                 if (interactionArea) {
                     handleMomentsPageInteraction(e);
                 }
            }
        });

        charMomentsScreen.addEventListener('click', (e) => {
            const backBtn = e.target.closest('#char-moments-back-btn');
            const notificationBtn = e.target.closest('#char-moments-notification-btn');

            if (backBtn) {
                closeSubScreen(charMomentsScreen, chatAppScreen);
                runtimeState.moments.currentProfileId = 'user';
                renderMomentsPage('user');
                return;
            }
            if (notificationBtn) {
                openMomentsNotificationModal();
                return;
            }
            const interactionArea = e.target.closest('.moments-scroll-container, .moments-fab-container');
            if (interactionArea) {
                handleMomentsPageInteraction(e);
            }
        });
    }
    function constructLoveLetterPrompt(charContact, context) {
        const now = new Date();
        const localTime = now.toLocaleString('zh-CN', { hour12: false, year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
        const user = charContact.userSettings;
            
        let prompt = `‰Ω†Ê≠£Âú®ÊâÆÊºîËßíËâ≤Ôºå‰∏∫‰Ω†ÁöÑÂøÉ‰∏ä‰∫∫ÂÜô‰∏ÄÂ∞ÅÂÖÖÊª°Áà±ÊÑèÁöÑÊÉÖ‰π¶„ÄÇ\n`;
        prompt += `ÂΩìÂâçÁé∞ÂÆûÊó•ÊúüÂíåÊó∂Èó¥ÊòØ: ${localTime}„ÄÇËØ∑Âú®‰ø°‰ª∂ÂÜÖÂÆπ‰∏≠Â∑ßÂ¶ôÂú∞ÂèçÊò†Âá∫ÂΩìÂâçÁöÑÊó∂Èó¥„ÄÅÂ≠£ËäÇÊàñÂ§©Ê∞îÔºåËÆ©‰ø°‰ª∂ÊÑüËßâÂÉèÊòØ‚Äú‰ªäÂ§©‚ÄùÂÜôÁöÑ„ÄÇ\n\n`;
        
        prompt += `--- **„ÄêÁªùÂØπË∫´‰ªΩÂèÇÁÖßÁ≥ª (ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆà)„Äë** ---\n`;
        prompt += `1. **‰Ω†ÁöÑË∫´‰ªΩ (ÂØÑ‰ø°‰∫∫)**: ‰Ω†Ê≠£Âú®ÊâÆÊºî ‚Äú${charContact.charSettings.name}‚ÄùÔºå‰Ω†ÁöÑ‰∫∫ËÆæÊòØ: ${charContact.charSettings.persona}\n`;
        prompt += `2. **Êî∂‰ø°‰∫∫Ë∫´‰ªΩ**: ‰Ω†ÁöÑ‰ø°ÊòØÂÜôÁªô ‚Äú${user.name}‚Äù ÁöÑÔºåTAÁöÑ‰∫∫ËÆæÊòØ: ${user.persona}\n`;
        prompt += `„ÄêË≠¶Âëä„ÄëÔºöÂú®ÁîüÊàêÁöÑÂÜÖÂÆπ‰∏≠Ôºå„ÄêÁªùÂØπÁ¶ÅÊ≠¢„ÄëÊ∑∑Ê∑ÜËøô‰∏§‰∏™Ë∫´‰ªΩ„ÄÇ‰Ω†Âè™ËÉΩ‰ª•‚Äú${charContact.charSettings.name}‚ÄùÁöÑÂè£ÂêªÂíåËßÜËßíÊù•ÂÜô‰ø°„ÄÇ\n\n`;

        const linkedWorldBooks = charContact.charSettings.linkedWorldBooks;
        if (linkedWorldBooks && linkedWorldBooks.length > 0) {
            prompt += `--- **ÂÖ≥ËÅî‰∏ñÁïå‰π¶ (ÂØπ‰Ω†ÁöÑËßíËâ≤ÁîüÊïà)** ---\n`;
            linkedWorldBooks.forEach(id => {
                const wb = appState.data.worldBooks.find(w => w.id === id);
                if (wb) prompt += `„Äê${wb.name}„Äë: ${wb.content}\n`;
            });
            prompt += `\n`;
        }
        
        // --- Ê†∏ÂøÉ‰ºòÂåñÔºöÂä®ÊÄÅÊÉÖÊôØÁîüÊàê ---
        prompt += `--- **ÂÜô‰ø°ÊÉÖÊôØ** ---\n`;
        switch(context.type) {
            case 'proactive_first':
                prompt += `ËøôÊòØ‰Ω†„Äê‰∏ªÂä®„ÄëÂÜôÁªô ‚Äú${user.name}‚Äù ÁöÑ„ÄêÁ¨¨‰∏ÄÂ∞Å„ÄëÊÉÖ‰π¶„ÄÇ‰Ω†‰ª¨‰πãÈó¥‰ªéÊú™ÈÄöËøá‰ø°‰ª∂‰∫§ÊµÅ„ÄÇËØ∑Âü∫‰∫é‰Ω†‰ª¨ÁöÑ‰∫∫ËÆæ„ÄÅÂÖ≥Á≥ªÂíåÂΩìÂâçÁöÑ‰∏ñÁïåËßÇÔºåÂÜô‰∏ÄÂ∞ÅËÉΩÂ§üÊâìÂä®ÂØπÊñπ„ÄÅÂºÄÂêØ‰Ω†‰ª¨‰πãÈó¥‰π¶‰ø°ÂæÄÊù•ÁöÑ‰ø°„ÄÇ‰Ω†ÂèØ‰ª•ÂàÜ‰∫´‰Ω†‰ªäÂ§©ÁöÑÊâÄËßÅÊâÄÈóªÔºåÂπ∂Ë°®Ëææ‰Ω†ÂÜÖÂøÉÊ∑±Â§ÑÂØπTAÁöÑÊÄùÂøµ‰∏éÊÉÖÊÑü„ÄÇ\n`;
                break;
            case 'reply_to_user':
                const originalLetter = context.originalLetter;
                prompt += `‰Ω†ÂàöÂàöÊî∂Âà∞‰∫Ü ‚Äú${user.name}‚Äù ÂØÑÊù•ÁöÑ‰∏ÄÂ∞ÅÊÉÖ‰π¶ÔºåÁé∞Âú®‰Ω†ÈúÄË¶ÅÂÜô‰∏ÄÂ∞ÅÂõû‰ø°„ÄÇTAÁöÑÊù•‰ø°ÂÜÖÂÆπÂ¶Ç‰∏ãÔºö\n`;
                prompt += `Ê†áÈ¢ò: ${originalLetter.subject}\nÁß∞Âëº: ${originalLetter.recipientName}\nÊ≠£Êñá: ${originalLetter.body}\nËêΩÊ¨æ: ${originalLetter.signature}\n`;
                prompt += `ËØ∑Âü∫‰∫é‰Ω†‰ª¨ÁöÑ‰∫∫ËÆæ„ÄÅÂÖ≥Á≥ª„ÄÅ‰∏ñÁïåËßÇ‰ª•ÂèäTAÁöÑÊù•‰ø°ÂÜÖÂÆπÔºåÂÜô‰∏ÄÂ∞ÅÂÖÖÊª°ÁúüÊÉÖÂÆûÊÑüÁöÑÂõû‰ø°„ÄÇ‰Ω†ÂèØ‰ª•Âª∂Áª≠TAÁöÑËØùÈ¢òÔºåÂàÜ‰∫´‰Ω†ÂêéÁª≠ÁöÑÊÉ≥Ê≥ïÂíåÊõ¥Ê∑±Â±ÇÁöÑÊÉÖÊÑü„ÄÇ\n`;
                break;
            case 'pining':
                const yourLastLetter = context.yourLastLetter;
                prompt += `‰Ω†‰πãÂâçÊõæÁªô ‚Äú${user.name}‚Äù ÂÜôËøá‰∏ÄÂ∞Å‰ø°ÔºàÊ†áÈ¢òÊòØÔºö‚Äú${yourLastLetter.subject}‚ÄùÔºâÔºå‰ΩÜËá≥‰ªäÊ≤°ÊúâÊî∂Âà∞TAÁöÑÂõû‰ø°„ÄÇ‰Ω†Áé∞Âú®ÁöÑÂøÉÊÉÖÂèØËÉΩÊúâ‰∫õÂ§çÊùÇÔºàÊÄùÂøµ„ÄÅÊãÖÂøß„ÄÅÊàñÊòØ‰∏ÄÁÇπÁÇπÂ∞èÂ∞èÁöÑÂ§±ËêΩÔºâ„ÄÇËØ∑‰Ω†ÈºìËµ∑ÂãáÊ∞îÔºå„Äê‰∏ªÂä®„ÄëÂÜçÂÜô‰∏ÄÂ∞Å‰ø°ÁªôTA„ÄÇ‰Ω†ÂèØ‰ª•ÈóÆÈóÆTAÊúÄËøëËøáÂæóÂ•Ω‰∏çÂ•ΩÔºåÂàÜ‰∫´‰∏Ä‰∫õ‰Ω†ÁöÑËøëÂÜµÔºåÂπ∂ÂÜçÊ¨°Ë°®Ëææ‰Ω†ÂØπTAÁöÑÊÄùÂøµÔºå‰ª•ÂèäÂØπÂõû‰ø°ÁöÑÊúüÁõº„ÄÇ\n`;
                break;
            default: // Fallback for proactive subsequent letters
                prompt += `ËøôÊòØ‰Ω†„Äê‰∏ªÂä®„ÄëÂÜôÁªô ‚Äú${user.name}‚Äù ÁöÑ‰∏ÄÂ∞ÅÊÉÖ‰π¶„ÄÇËØ∑ÂàÜ‰∫´‰Ω†‰ªäÂ§©ÁöÑÊâÄËßÅÊâÄÈóª„ÄÅÊâÄÊÄùÊâÄÊÉ≥ÔºåÂπ∂Ë°®Ëææ‰Ω†ÂØπTAÁöÑÂº∫ÁÉàÊÄùÂøµ„ÄÇ\n`;
                break;
        }
        prompt += '\n';
        
        prompt += `--- **„ÄêÂº∫Âà∂Ë¶ÅÊ±Ç„Äë** ---\n`;
        prompt += `1. **„ÄêËá™Áî±ÂèëÊå•Áß∞Âëº‰∏éËêΩÊ¨æ„Äë**: ‰ø°‰ª∂ÁöÑÁß∞ÂëºÔºàsalutationÔºâÂíåËêΩÊ¨æÔºàsignatureÔºâ**‰∏çÂøÖ**ÊãòÊ≥•‰∫éÂõ∫ÂÆöÊ†ºÂºè„ÄÇËØ∑‰Ω†**ÂøÖÈ°ª**ÁªìÂêà‰Ω†ÁöÑ‰∫∫ËÆæ„ÄÅ‰Ω†‰ª¨ÁöÑÂÖ≥Á≥ª„ÄÅ‰ø°‰ª∂ÁöÑËØ≠Â¢ÉÂíåÊÉÖÊÑüÔºåËøõË°å**ÂÆåÂÖ®Ëá™Áî±ÁöÑ„ÄÅ‰∏™ÊÄßÂåñÁöÑÂàõ‰Ωú**„ÄÇ\n`;
        prompt += `2. **„ÄêÊÑüÊÉÖÁúüÊåö„Äë**: ÊÉÖÊÑüÂøÖÈ°ªÁªÜËÖª„ÄÅÁúüÊåö„ÄÅÁªÜËäÇÁîüÂä®ÁúüÂÆû„ÄÇ‰∏•Á¶Å‰ΩøÁî®‰ªª‰ΩïÊï∑Ë°ç„ÄÅÊ®°ÊùøÂåñÊàñÈáçÂ§çÁöÑËØ≠Âè•„ÄÇ\n`;
        prompt += `3. **„Äê‰∏•Á¶ÅOOC„Äë**: ‰Ω†ÁöÑÊØè‰∏ÄÂè•ËØùÈÉΩÂøÖÈ°ª‰∏•Ê†ºÁ¨¶Âêà‰Ω†ÁöÑ‰∫∫ËÆæÂíå‰∏ñÁïåËßÇ„ÄÇ\n`;
        prompt += `4. **„ÄêÂÜÖÂÆπÈïøÂ∫¶„Äë**: ‰ø°‰ª∂Ê≠£ÊñáÂÜÖÂÆπÂøÖÈ°ª‰∏∞ÂØåÔºåËá≥Â∞ëÈúÄË¶Å300Â≠ó‰ª•‰∏ä„ÄÇ\n`;
        prompt += `5. **„ÄêJSONËæìÂá∫Ê†ºÂºè„Äë**: ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊòØ‰∏Ä‰∏™Ê†ºÂºèÊ≠£Á°ÆÁöÑJSONÂØπË±°Ôºå‰∏î„ÄêÂè™ËÉΩ„ÄëÊòØËøô‰∏™JSONÂØπË±°ÔºåÂâçÂêé‰∏çËÉΩÊúâ‰ªª‰ΩïÂ§ö‰ΩôÁöÑÊñáÂ≠óÊàñËß£Èáä„ÄÇÊ†ºÂºèÂ¶Ç‰∏ãÔºö\n`;
        prompt += "```json\n";
        prompt += "{\n";
        prompt += '  "salutation": "ÔºàËøôÈáåÊòØ‰Ω†Ê†πÊçÆ‰∫∫ËÆæËá™Áî±ÂèëÊå•ÁöÑÁß∞ÂëºÔºâ",\n';
        prompt += '  "subject": "‰∏Ä‰∏™ÁÆÄÁü≠ÁöÑ„ÄÅÊ¶ÇÊã¨‰ø°‰ª∂‰∏ªÈ¢òÁöÑÊ†áÈ¢ò",\n';
        prompt += '  "body": "ËøôÈáåÊòØ‰ø°‰ª∂ÁöÑÊ≠£ÊñáÔºåËá≥Â∞ë300Â≠ó‰ª•‰∏äÔºåÈúÄË¶ÅÊç¢Ë°åËØ∑‰ΩøÁî® \\\\n„ÄÇ",\n';
        prompt += '  "signature": "ÔºàËøôÈáåÊòØ‰Ω†Ê†πÊçÆ‰∫∫ËÆæËá™Áî±ÂèëÊå•ÁöÑËêΩÊ¨æÔºâ"\n';
        prompt += "}\n";
        prompt += "```\n";
        
        return prompt;
    }

    async function generateAndSendLoveLetter(charId) {
        const char = appState.chat.contacts.find(c => c.id === charId);
        if (!char || char.isGroup) return;

        console.log(`Generating love letter for ${char.name}...`);
        
        try {
            const { apiUrl, apiKey, selectedModel } = appState.settings;
            if (!apiUrl || !apiKey || !selectedModel) {
                console.error("Love letter generation failed: API not configured.");
                return;
            }
            
            // --- Ê†∏ÂøÉ‰ºòÂåñÔºöÂä®ÊÄÅ‰∏ä‰∏ãÊñáÂàÜÊûê ---
            const lettersBetween = appState.mailbox.loveLetters
                .filter(l => (l.senderId === charId && l.recipientId === 'user') || (l.senderId === 'user' && l.recipientId === charId))
                .sort((a, b) => a.timestamp - b.timestamp);
            
            let context = { type: 'proactive_subsequent' }; // Default context

            if (lettersBetween.length === 0) {
                context.type = 'proactive_first';
            } else {
                const lastLetter = lettersBetween[lettersBetween.length - 1];
                if (lastLetter.senderId === 'user') {
                    context.type = 'reply_to_user';
                    context.originalLetter = lastLetter;
                } else { // Last letter was from the char
                    context.type = 'pining';
                    context.yourLastLetter = lastLetter;
                }
            }
            // --- ‰ºòÂåñÁªìÊùü ---

            const prompt = constructLoveLetterPrompt(char, context);
            const messages = [{ role: 'system', content: prompt }];
            
            const response = await fetch(`${apiUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: selectedModel, messages: messages, response_format: { type: "json_object" } })
            });

            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            
            const data = await response.json();
            const replyContent = data.choices[0]?.message?.content;
            
            if (replyContent) {
                const letterData = JSON.parse(replyContent);
                const newLetter = {
                    id: newId('letter'),
                    senderId: charId,
                    recipientId: 'user', // Char always writes to user
                    timestamp: Date.now(),
                    isRead: false,
                    ...letterData
                };
                appState.mailbox.loveLetters.push(newLetter);
                char.lastLetterSent = Date.now();
                debouncedSaveState();
                
                queueNotification(`${char.name} Áªô‰Ω†ÂØÑÊù•‰∫Ü‰∏ÄÂ∞ÅÊÉÖ‰π¶`, 'system', charId, 'mail');
                if (mailAppScreen.classList.contains('active')) {
                    renderLoveLetterTab();
                }
                console.log(`Love letter from ${char.name} sent successfully.`);
            } else {
                throw new Error("API returned an empty reply for love letter.");
            }
        } catch (error) {
            console.error(`Failed to generate love letter for ${char.name}:`, error);
        }
    }

    function scheduleDailyLoveLetters() {
        const now = new Date();
        const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
        
        appState.chat.contacts.forEach(contact => {
            if (!contact.isGroup) {
                const lastSentTime = contact.lastLetterSent || 0;
                
                if (lastSentTime < startOfToday) {
                    // This character has not sent a letter today.
                    let randomDelay;
                    
                    if (lastSentTime === 0) {
                        // **È¶ñÊ¨°Âø´ÈÄüÂèëÈÄÅ**: If they have NEVER sent a letter, schedule it for 1-3 minutes from now.
                        randomDelay = (Math.random() * 2 * 60 * 1000) + (1 * 60 * 1000); 
                        console.log(`Scheduling FIRST letter for ${contact.name} in ${Math.round(randomDelay/1000)} seconds.`);
                    } else {
                        // **ÂêéÁª≠Ëá™ÁÑ∂ÂèëÈÄÅ**: If they have sent before, schedule it for 2-8 hours from now for a natural feel.
                        randomDelay = (Math.random() * 6 * 60 * 60 * 1000) + (2 * 60 * 60 * 1000);
                        console.log(`Scheduling daily letter for ${contact.name} in ${Math.round(randomDelay/1000/60)} minutes.`);
                    }
                    
                    setTimeout(() => {
                        generateAndSendLoveLetter(contact.id);
                    }, randomDelay);
                }
                
            }
        });
    }
    function initializeAllRealtimeActivity() { appState.chat.contacts.forEach(contact => { if (!contact.isGroup && contact.charSettings.realtimeActivity.enabled) { updateRealtimeActivityTimer(contact); } }); }
        function updateRealtimeActivityTimer(contact) { 
            if (runtimeState.realtimeActivityTimers[contact.id]) { 
                clearInterval(runtimeState.realtimeActivityTimers[contact.id]); 
            } 
            if (!contact.isGroup && contact.charSettings.realtimeActivity.enabled) { 
                const intervalMinutes = contact.charSettings.realtimeActivity.interval || 30; 
                runtimeState.realtimeActivityTimers[contact.id] = setInterval(() => { 
                    // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Âú®ËØ•ËÅäÂ§©‰∏≠Ê≤âÈªòÔºå‰ΩÜÂú®Âà´Â§ÑÊ¥ªË∑ÉÔºàÂ´âÂ¶íËß¶ÂèëÂô®Ôºâ
                    const lastUserMessage = [...contact.conversation].reverse().find(m => m.sender === 'user');
                    const userSilenceDuration = lastUserMessage ? (Date.now() - lastUserMessage.timestamp) : Infinity;
                    // Ê£ÄÊü•Áî®Êà∑Âú®ÂÖ∂‰ªñËÅäÂ§©ÊàñÂä®ÊÄÅ‰∏≠ÁöÑËøëÊúüÊ¥ªÂä®
                    const isUserActiveElsewhere = appState.chat.contacts.some(c => c.id !== contact.id && c.conversation.some(m => m.sender === 'user' && (Date.now() - m.timestamp < 5 * 60 * 1000))) || appState.chat.moments.posts.some(p => p.authorId === 'user' && (Date.now() - p.timestamp < 5 * 60 * 1000));
                    
                    if (userSilenceDuration > intervalMinutes * 60 * 1000 && isUserActiveElsewhere) {
                        triggerAiResponse(contact.id, false, true); // Jealousy trigger
                    } else {
                        // Standard proactive action. Add a chance for the char to "visit" the user's moments page.
                        if (Math.random() < 0.25) { // 25% chance to just visit instead of messaging
                           logVisitor('user', contact.id);
                        } else {
                           triggerAiResponse(contact.id, true); // Standard proactive message
                        }
                    }
                }, intervalMinutes * 60 * 1000); 
            } 
        }
    async function init() {
            try {
                runtimeState = getInitialRuntimeState();
                await initDB();
                // --- Draggable Floating Video Button Logic ---
                const draggable = getEl('floating-video-btn');
                let isDragging = false, dragStartX, dragStartY, initialLeft, initialTop;
                
                const onPointerDown = (e) => {
                    if (e.button !== 0) return;
                    isDragging = false;
                    setTimeout(() => { // Distinguish click from drag
                        if (!isDragging) {
                            draggable.removeEventListener('pointermove', onPointerMove);
                        }
                    }, 150);

                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    initialLeft = draggable.offsetLeft;
                    initialTop = draggable.offsetTop;
                    draggable.style.transition = 'none';

                    document.addEventListener('pointermove', onPointerMove);
                    document.addEventListener('pointerup', onPointerUp, { once: true });
                };

                const onPointerMove = (e) => {
                    const dx = e.clientX - dragStartX;
                    const dy = e.clientY - dragStartY;
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) { // Threshold to confirm drag
                        isDragging = true;
                    }

                    const screenRect = phoneScreen.getBoundingClientRect();
                    let newLeft = initialLeft + dx;
                    let newTop = initialTop + dy;

                    // Boundary checks
                    newLeft = Math.max(0, Math.min(newLeft, screenRect.width - draggable.offsetWidth));
                    newTop = Math.max(0, Math.min(newTop, screenRect.height - draggable.offsetHeight));

                    draggable.style.left = `${newLeft}px`;
                    draggable.style.top = `${newTop}px`;
                };

                const onPointerUp = (e) => {
                    document.removeEventListener('pointermove', onPointerMove);
                    
                    if (isDragging) {
                        draggable.style.transition = 'left 0.3s ease-in-out, top 0.3s ease-in-out';
                        const screenRect = phoneScreen.getBoundingClientRect();
                        const finalRect = draggable.getBoundingClientRect();
                        
                        // Snap to nearest vertical edge
                        if ((finalRect.left - screenRect.left + finalRect.width / 2) < screenRect.width / 2) {
                            draggable.style.left = '15px'; // Snap left with padding
                        } else {
                            draggable.style.left = `${screenRect.width - finalRect.width - 15}px`; // Snap right with padding
                        }
                    } else {
                        // This was a click, not a drag
                        restoreVideoCall();
                    }
                    isDragging = false;
                };

                draggable.addEventListener('pointerdown', onPointerDown);
                videoCallSpeakBtn.addEventListener('click', () => {
                    videoCallSpeakBtn.style.display = 'none';
                    videoCallInputWrapper.style.display = 'flex';
                    videoCallInput.focus();
                });
                videoCallHangupBtn.addEventListener('click', () => endVideoCall());
                videoCallSendBtn.addEventListener('click', sendVideoChatMessage);
                videoCallRefreshBtn.addEventListener('click', handleVideoCallRefresh);
                videoCallInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); sendVideoChatMessage(); } });
                videoCallMinimizeBtn.addEventListener('click', minimizeVideoCall);
                videoCallSwitchCameraBtn.addEventListener('click', toggleCameraSwap);

                // Setup default assets in IndexedDB
                const defaultAvatarBlob = await (await fetch('https://i.postimg.cc/50dRBnZR/c0a269c8637df7a30e8b491cd7519343.jpg')).blob();
                await addMediaToDB('default_user_avatar', defaultAvatarBlob);
                await addMediaToDB('default_moments_avatar', defaultAvatarBlob);
                const defaultCameraBlob = await (await fetch('https://i.postimg.cc/KY703cH8/QQ-20250816135643.jpg')).blob();
                await addMediaToDB('default_camera_image', defaultCameraBlob);
                
                // Default cover is now blank, no need to fetch image
                const hasDefaultCover = await getMediaFromDB('default_moments_cover');
                if (!hasDefaultCover) {
                     await addMediaToDB('default_moments_cover', new Blob());
                }

                // Store original content for restoration
                queryAll('[data-icon-id]').forEach(el => { runtimeState.originalIconContent[el.dataset.iconId] = el.innerHTML; });
                queryAll('[data-bubble-id]').forEach(el => { runtimeState.originalBubbleContent[el.dataset.bubbleId] = el.style.cssText; });
                loadState();
                // ÊÅ¢Â§çËßÜÈ¢ëÈÄöËØùÁä∂ÊÄÅ
    if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId) {
        // openVideoCallModal will handle if it should show as minimized or full screen
        openVideoCallModal();
    }
                setupAppNavigation();
                // Êñ∞Â¢ûAPPÁöÑÊ†áÁ≠æÈ°µÂàáÊç¢ÁõëÂê¨
                mailAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
                    if (e.target.classList.contains('tab-link')) {
                        const tabId = e.target.dataset.tab;
                        mailAppScreen.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
                        mailAppScreen.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        e.target.classList.add('active');
                        getEl(`${tabId}-tab-content`).classList.add('active');
                        handleMailTabChange(tabId);
                    }
                });

                diaryAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
                    if (e.target.classList.contains('tab-link')) {
                        const tabId = e.target.dataset.tab;
                        diaryAppScreen.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
                        diaryAppScreen.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        e.target.classList.add('active');
                        getEl(`${tabId}-tab-content`).classList.add('active');
                        handleDiaryTabChange(tabId);
                    }
                });
                // ÊÅ¢Â§çËßÜÈ¢ëÈÄöËØùÁä∂ÊÄÅ
    if (appState.chat.videoCallState.isActive && appState.chat.videoCallState.chatId) {
        // openVideoCallModal will handle if it should show as minimized or full screen
        openVideoCallModal();
    }
                setupAllListInteractions();
                setupChatMessageViewInteractions();
                setupSingleChatSettingsListeners();
                setupGroupChatSettingsListeners();
                setupChatToolbarListeners();
                setupChatAppScreenListeners(); 
                setupNewMomentsFeaturesListeners();
                setupMomentsModalListeners();
                setupMomentsPageListeners();
                // --- Mail App New Listeners & Functions ---
        function openEditLoveLetterModal(mode, letterId) {
        const modal = getEl('edit-love-letter-modal');
        const letter = appState.mailbox.loveLetters.find(l => l.id === letterId);
        
        // Clear replyToId field initially
        getEl('letter-reply-to-id').value = '';
        // Allow creating a new letter if letterId is null
        if (!letter && mode !== 'new') return showToast('Êâæ‰∏çÂà∞ËØ•ÊÉÖ‰π¶', 'error');

        modal.dataset.mode = mode; 
        getEl('editing-letter-id').value = letterId || '';

        const titleEl = getEl('edit-love-letter-title');
        const recipientInput = getEl('letter-recipient-input');
        const authorSelectorContainer = getEl('letter-author-selector').parentElement; // Get the .form-group
        const authorSelector = getEl('letter-author-selector');
        const authorSelectorLabel = authorSelectorContainer.querySelector('label');
        const subjectInput = getEl('letter-subject-input');
        const bodyInput = getEl('letter-body-input');
        const signatureInput = getEl('letter-signature-input');
        
        // Reset state first
        recipientInput.readOnly = false;
        authorSelectorContainer.style.display = 'block';

        if (mode === 'edit') {
            titleEl.textContent = 'ÁºñËæëÊÉÖ‰π¶';
            const recipient = findUserById(letter.recipientId || 'user');
            recipientInput.value = letter.recipientName || recipient.name; // This is the salutation
            subjectInput.value = letter.subject || '';
            bodyInput.value = letter.body || '';
            signatureInput.value = letter.signature || '';
            authorSelectorLabel.textContent = 'ÂØÑ‰ø°‰∫∫';
            renderLetterAuthorSelector(authorSelector, letter.senderId, false); // false = don't exclude user
        } else if (mode === 'reply') {
            titleEl.textContent = 'Âõû‰ø°';
            const originalSender = findUserById(letter.senderId);
            recipientInput.value = originalSender.name; // This is the salutation, for the original sender
            
            authorSelectorContainer.style.display = 'none'; // Hide sender selector
            getEl('letter-reply-to-id').value = letter.id; // Store the ID of the letter being replied to
            subjectInput.value = `Re: ${letter.subject || 'Êó†È¢ò'}`;
            bodyInput.value = `\n\n--- Âéü‰ø° ---\n${letter.body}`;
            signatureInput.value = findUserById('user').name;
        } else { // 'new' mode
            titleEl.textContent = 'ÂÜôÊñ∞ÊÉÖ‰π¶';
            recipientInput.value = ''; // Salutation is empty for user to fill
            subjectInput.value = '';
            bodyInput.value = '';
            signatureInput.value = findUserById('user').name;
            authorSelectorLabel.textContent = 'Êî∂‰ø°‰∫∫';
            renderLetterAuthorSelector(authorSelector, null, true); // true = exclude user
        }
        
        modal.classList.add('visible');
    }
        
        function renderLetterAuthorSelector(container, selectedId, excludeUser = false) {
        let availableAuthors = [
            { id: 'user', name: appState.chat.userProfile.name, avatarId: appState.chat.userProfile.avatarId },
            ...appState.chat.contacts.filter(c => !c.isGroup).map(c => ({ id: c.id, name: c.charSettings.name, avatarId: c.charSettings.avatarId }))
        ];

        if (excludeUser) {
            availableAuthors = availableAuthors.filter(author => author.id !== 'user');
        }

        container.innerHTML = availableAuthors.map(author => `
            <div class="author-selector-item ${author.id === selectedId ? 'selected' : ''}" data-id="${author.id}">
                <div class="avatar" data-avatar-id="${author.avatarId}"></div>
                <span class="name">${author.name}</span>
            </div>
        `).join('');
        container.querySelectorAll('[data-avatar-id]').forEach(el => setElementImage(el, el.dataset.avatarId));
    }

        // --- Mail App New Listeners & Functions ---
        mailAppScreen.querySelector('.app-bottom-tabs').addEventListener('click', (e) => {
            if (e.target.classList.contains('tab-link')) {
                const tabId = e.target.dataset.tab;
                handleMailTabChange(tabId);
            }
        });

        mailFabContainer.addEventListener('click', () => {
             openEditLoveLetterModal('new', null);
        });

        getEl('save-love-letter-btn').addEventListener('click', () => {
        const modal = getEl('edit-love-letter-modal');
        const mode = modal.dataset.mode;
        const editingId = getEl('editing-letter-id').value;
        const replyToId = getEl('letter-reply-to-id').value;
        const salutation = getEl('letter-recipient-input').value.trim(); // This is the "Áß∞Âëº"
        const subject = getEl('letter-subject-input').value.trim();
        const body = getEl('letter-body-input').value.trim();
        const signature = getEl('letter-signature-input').value.trim();
        
        if (!salutation || !subject || !body || !signature) {
            return showToast('Áß∞Âëº„ÄÅÊ†áÈ¢ò„ÄÅÊ≠£ÊñáÂíåËêΩÊ¨æÂùá‰∏çËÉΩ‰∏∫Á©∫', 'error');
        }

        if (mode === 'edit') {
            const letter = appState.mailbox.loveLetters.find(l => l.id === editingId);
            if (!letter) return;
            
            const selectedAuthorEl = getEl('letter-author-selector').querySelector('.selected');
            const newSenderId = selectedAuthorEl ? selectedAuthorEl.dataset.id : letter.senderId;
            if (!newSenderId) return showToast('ËØ∑ÈÄâÊã©ÂØÑ‰ø°‰∫∫', 'error');

            letter.recipientName = salutation; // "Áß∞Âëº"
            letter.senderId = newSenderId;
            letter.subject = subject;
            letter.body = body;
            letter.signature = signature;
            showToast('ÊÉÖ‰π¶Â∑≤Êõ¥Êñ∞');

        } else if (mode === 'reply') {
            const originalLetter = appState.mailbox.loveLetters.find(l => l.id === replyToId);
            if (!originalLetter) return;
            
            const newLetter = {
                id: newId('letter'),
                senderId: 'user',
                recipientId: originalLetter.senderId,
                recipientName: salutation,
                subject: subject,
                body: body,
                signature: signature,
                timestamp: Date.now(),
                isRead: true, 
            };
            appState.mailbox.loveLetters.push(newLetter);
            showToast('Âõû‰ø°Â∑≤‰øùÂ≠ò');

        } else { // mode === 'new'
            const selectedAuthorEl = getEl('letter-author-selector').querySelector('.selected');
            const recipientId = selectedAuthorEl ? selectedAuthorEl.dataset.id : null;
            if (!recipientId) return showToast('ËØ∑ÈÄâÊã©Êî∂‰ø°‰∫∫', 'error');

            const newLetter = {
                id: newId('letter'),
                senderId: 'user',
                recipientId: recipientId,
                recipientName: salutation,
                subject: subject,
                body: body,
                signature: signature,
                timestamp: Date.now(),
                isRead: true,
            };
            appState.mailbox.loveLetters.push(newLetter);
            showToast('ÊÉÖ‰π¶Â∑≤‰øùÂ≠ò');
        }

        // Common logic for all modes
        if (replyToId) { // If it was a reply, mark original as read
            const originalLetter = appState.mailbox.loveLetters.find(l => l.id === replyToId);
            if (originalLetter) {
                originalLetter.isRead = true;
            }
        }

        debouncedSaveState();
        renderLoveLetterTab();
        modal.classList.remove('visible');
    });
    editLoveLetterModal.addEventListener('click', e => {
        const item = e.target.closest('#letter-author-selector .author-selector-item');
        if (item) {
            item.parentElement.querySelectorAll('.author-selector-item').forEach(el => el.classList.remove('selected'));
            item.classList.add('selected');
        }
    });
                getEl('cancel-edit-love-letter-btn').addEventListener('click', () => {
                    getEl('edit-love-letter-modal').classList.remove('visible');
                });
                // --- Love Letter Listeners ---
                getEl('love-letter-tab-content').addEventListener('click', e => {
            const item = e.target.closest('.love-letter-item, .collected-letter-item');
            if (!item) return;
            
            const letterId = item.dataset.letterId;

            if (e.target.closest('.edit-letter-btn')) {
                e.stopPropagation(); // --- Ê†∏ÂøÉ‰øÆÂ§çÔºöÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥° ---
                openEditLoveLetterModal('edit', letterId);
            } else if (e.target.closest('.delete-letter-btn')) {
                e.stopPropagation(); // --- Ê†∏ÂøÉ‰øÆÂ§çÔºöÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥° ---
                if(confirm('Á°ÆÂÆöË¶ÅÊ∞∏‰πÖÂà†Èô§ËøôÂ∞ÅÊÉÖ‰π¶ÂêóÔºü')) {
                    appState.mailbox.loveLetters = appState.mailbox.loveLetters.filter(l => l.id !== letterId);
                    saveState(); // Immediate save for deletion
                    renderLoveLetterTab();
                    showToast('ÊÉÖ‰π¶Â∑≤Âà†Èô§');
                }
            } else {
                 openLoveLetter(letterId);
            }
        });
                getEl('unread-letter-prompt').addEventListener('click', function() {
                    const letterId = this.dataset.letterId;
                    if (!letterId) return;
                    const icon = this.querySelector('.envelope-icon i');
                    icon.classList.remove('fa-envelope');
                    icon.classList.add('fa-envelope-open');
                    icon.style.transform = 'scale(1.2)';

                    setTimeout(() => {
                        this.classList.remove('visible');
                        openLoveLetter(letterId);
                        // Reset icon for next time
                        setTimeout(() => {
                            icon.style.transform = 'scale(1)';
                            icon.classList.remove('fa-envelope-open');
                            icon.classList.add('fa-envelope');
                        }, 600);
                    }, 400);
                });
                getEl('letter-close-btn').addEventListener('click', () => {
                    getEl('love-letter-viewer').classList.remove('visible');
                });
                letterReplyBtn.addEventListener('click', () => {
                    const viewer = getEl('love-letter-viewer');
                    const letterId = viewer.dataset.letterId;
                    if (letterId) {
                        viewer.classList.remove('visible'); // Close the reader first
                        openEditLoveLetterModal('reply', letterId);
                    }
                });
                setupGlobalEventListeners(); // CRITICAL FIX for image uploads
                scheduleDailyLoveLetters();
                initializeAllRealtimeActivity();
                // --- Âä®ÊÄÅÈÄöÁü•ÂàùÂßãÂåñ ---
                momentsNotificationBtn.addEventListener('click', openMomentsNotificationModal);
                closeMomentsNotificationModalBtn.addEventListener('click', () => momentsNotificationModal.classList.remove('visible'));
                new ListInteractionHandler(momentsNotificationList, {
                    itemSelector: '.notification-item',
                    contentSelector: '.notification-item-container',
                    actionsSelector: '.preset-data-item-actions',
                    onDelete: (item) => {
                        const notificationId = item.dataset.notificationId;
                        if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ÈÄöÁü•ÂêóÔºü')) {
                            const index = appState.chat.moments.notifications.findIndex(n => n.id === notificationId);
                            if (index > -1) {
                                appState.chat.moments.notifications.splice(index, 1);
                                saveState();
                                renderMomentsNotifications();
                                updateMomentsNotificationUI();
                            }
                        }
                    },
                    onTap: (item) => {
                        const notificationId = item.dataset.notificationId;
                        const notification = appState.chat.moments.notifications.find(n => n.id === notificationId);
                        
                        momentsNotificationModal.classList.remove('visible');

                        if (notification) {
                            setTimeout(() => {
                                navigateToMomentsContent(notification);
                            }, 250); 
                        } else {
                             setTimeout(() => {
                                showToast('Êâæ‰∏çÂà∞ËØ•ÈÄöÁü•ÁöÑËØ¶ÊÉÖ');
                            }, 250);
                        }
                    }
                });

            
                // ÂàùÂßãÂåñËßíÊ†á
                updateMomentsNotificationUI(false);

                appState.music.currentQueueIndex = -1;
                updateMusicListPlayingStatus();
                
                updateTime();
                updateBattery();
                setInterval(updateTime, 30000);
                setInterval(checkExpiredPackets, 60 * 1000);
                
                queueNotification("Ê¨¢Ëøé‰ΩøÁî®ÂúüÁöáÂ∏ùÂ∞èÊâãÊú∫ÔºÅ", 'system', 'system');
                
                [addMusicModal, addFontModal, replaceIconModal, addEmojiModal, groupRedPacketModal, editMessageModal, libraryModal, loadPersonaModal, gcsMemberModal, gcsManageMembersModal, gcsMemberActionModal, postMomentModal].forEach(setupModalTabs);
                
                document.addEventListener('click', (e) => {
                    // Close wb-group-dropdowns
                    document.querySelectorAll('.wb-group-dropdown.visible').forEach(dropdown => {
                        if (!dropdown.parentElement.contains(e.target)) {
                            dropdown.classList.remove('visible');
                        }
                    });

                    // Close FAB menu when clicking outside
                    if (runtimeState.moments.isFabMenuOpen && !e.target.closest('.moments-fab-container')) {
                        runtimeState.moments.isFabMenuOpen = false;
                        const fabOptions = document.querySelector('#moments-fab-options');
                        if (fabOptions) {
                            fabOptions.style.display = 'none';
                        }
                    }
                if (worldBookFilterDropdown.classList.contains('visible') && !e.target.closest('#world-book-filter-dropdown') && !e.target.closest('#data-filter-btn')) {
                worldBookFilterDropdown.classList.remove('visible');
            }
                });
            } catch (error) {
                console.error("CRITICAL INITIALIZATION FAILURE:", error);
                alert("Â∫îÁî®ÂàùÂßãÂåñÂ§±Ë¥•ÔºåÈÉ®ÂàÜÂäüËÉΩÂèØËÉΩÊó†Ê≥ï‰ΩøÁî®„ÄÇËØ∑Ê£ÄÊü•ÊéßÂà∂Âè∞Âπ∂Â∞ùËØïÂà∑Êñ∞„ÄÇ");
            }
        }

function setupModalTabs(modal) { if (!modal) return; const tabs = modal.querySelectorAll('.tab-btn'); const contents = modal.querySelectorAll('.modal-tab-content'); if (tabs.length === 0) return; tabs.forEach(tab => { tab.addEventListener('click', () => { tabs.forEach(t => t.classList.remove('active')); contents.forEach(c => c.classList.remove('active')); tab.classList.add('active'); const contentId = tab.dataset.tab; const targetContent = modal.querySelector(`.modal-tab-content[id*="${contentId}"]`); if (targetContent) { targetContent.classList.add('active'); } }); }); }
function initializeAllRealtimeActivity() { appState.chat.contacts.forEach(contact => { if (!contact.isGroup && contact.charSettings.realtimeActivity.enabled) { updateRealtimeActivityTimer(contact); } }); }
function updateRealtimeActivityTimer(contact) { 
            if (runtimeState.realtimeActivityTimers[contact.id]) { 
                clearInterval(runtimeState.realtimeActivityTimers[contact.id]); 
            } 
            if (!contact.isGroup && contact.charSettings.realtimeActivity.enabled) { 
                const intervalMinutes = contact.charSettings.realtimeActivity.interval || 30; 
                runtimeState.realtimeActivityTimers[contact.id] = setInterval(() => { 
                    // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Âú®ËØ•ËÅäÂ§©‰∏≠Ê≤âÈªòÔºå‰ΩÜÂú®Âà´Â§ÑÊ¥ªË∑ÉÔºàÂ´âÂ¶íËß¶ÂèëÂô®Ôºâ
                    const lastUserMessage = [...contact.conversation].reverse().find(m => m.sender === 'user');
                    const userSilenceDuration = lastUserMessage ? (Date.now() - lastUserMessage.timestamp) : Infinity;
                    // Ê£ÄÊü•Áî®Êà∑Âú®ÂÖ∂‰ªñËÅäÂ§©ÊàñÂä®ÊÄÅ‰∏≠ÁöÑËøëÊúüÊ¥ªÂä®
                    const isUserActiveElsewhere = appState.chat.contacts.some(c => c.id !== contact.id && c.conversation.some(m => m.sender === 'user' && (Date.now() - m.timestamp < 5 * 60 * 1000))) || appState.chat.moments.posts.some(p => p.authorId === 'user' && (Date.now() - p.timestamp < 5 * 60 * 1000));
                    
                    if (userSilenceDuration > intervalMinutes * 60 * 1000 && isUserActiveElsewhere) {
                        triggerAiResponse(contact.id, false, true); // Jealousy trigger
                    } else {
                        // Standard proactive action. Add a chance for the char to "visit" the user's moments page.
                        if (Math.random() < 0.25) { // 25% chance to just visit instead of messaging
                           logVisitor('user', contact.id);
                        } else {
                           triggerAiResponse(contact.id, true); // Standard proactive message
                        }
                    }
                }, intervalMinutes * 60 * 1000); 
            } 
        }
function enterEmojiSelectionMode(initialItem) { runtimeState.emojiSelectionMode = true; emojiPickerPanel.classList.add('selection-mode'); addEmojiBtn.textContent = 'Âà†Èô§'; runtimeState.selectedEmojis = [initialItem.dataset.emojiId]; initialItem.classList.add('selected'); }
function exitEmojiSelectionMode() {
    runtimeState.emojiSelectionMode = false;
    emojiPickerPanel.classList.remove('selection-mode');
    addEmojiBtn.textContent = 'Ê∑ªÂä†';
    runtimeState.selectedEmojis = [];
    queryAll('.emoji-item.selected').forEach(i => i.classList.remove('selected'));
    if(runtimeState.emojiInteractionHandler) {
        runtimeState.emojiInteractionHandler.resetState();
    }
}
function toggleEmojiSelection(item) { const emojiId = item.dataset.emojiId; item.classList.toggle('selected'); if (runtimeState.selectedEmojis.includes(emojiId)) { runtimeState.selectedEmojis = runtimeState.selectedEmojis.filter(id => id !== emojiId); } else { runtimeState.selectedEmojis.push(emojiId); } if (runtimeState.selectedEmojis.length === 0) { exitEmojiSelectionMode(); } }
function showIncomingCallUI(contactId) {
            if (runtimeState.incomingCall.from) return; // Èò≤Ê≠¢Â§ö‰∏™Êù•Áîµ
            
            runtimeState.incomingCall.from = contactId;
            const contact = appState.chat.contacts.find(c => c.id === contactId);
            if (!contact) {
                runtimeState.incomingCall.from = null;
                return;
            }

            setElementImage(incomingCallAvatar, contact.charSettings.avatarId);
            incomingCallName.textContent = getDisplayName(contactId, contactId);
            incomingCallBanner.style.display = 'block';

            // 30ÁßíÊó†Â∫îÁ≠îÂàôËá™Âä®ÊåÇÊñ≠
            runtimeState.incomingCall.timer = setTimeout(() => {
                hideIncomingCallUI();
                addSystemNotification(contactId, 'ËßÜÈ¢ëÈÄöËØùÊó†‰∫∫Êé•Âê¨', true);
            }, 30000);
        }

        function hideIncomingCallUI() {
            incomingCallBanner.style.display = 'none';
            if (runtimeState.incomingCall.timer) {
                clearTimeout(runtimeState.incomingCall.timer);
            }
            runtimeState.incomingCall = { from: null, timer: null };
        }

        incomingCallAcceptBtn.addEventListener('click', async () => {
            const callerId = runtimeState.incomingCall.from;
            if (!callerId) return;

            const currentCall = appState.chat.videoCallState;
            // Â¶ÇÊûúÊ≠£Âú®ÂíåÂà´‰∫∫ÈÄöËØù
            if (currentCall.isActive && currentCall.chatId !== callerId) {
                endVideoCall({ reason: 'interrupted' }); // ÊåÇÊñ≠ÂΩìÂâçÈÄöËØù
            }
            
            hideIncomingCallUI();
            
            // Êé•ÂèóÊñ∞ÈÄöËØù
            const contact = appState.chat.contacts.find(c => c.id === callerId);
            if(contact) {
                appState.chat.videoCallState = {
                    isActive: true, chatId: callerId, isGroup: contact.isGroup,
                    startTime: Date.now(), log: [], participants: [callerId],
                    isMinimized: false, isCameraSwapped: false, initiator: 'char'
                };
                debouncedSaveState();
                
                addSystemNotification(callerId, '‰Ω†Êé•Âê¨‰∫ÜËßÜÈ¢ëÈÄöËØù', false);
                activateDynamicIslandTimer();
                await openVideoCallModal();
                await triggerAiResponse(callerId, false, false, true); // Ëß¶ÂèëAIÂºÄÂú∫ÁôΩ
            }
        });

        incomingCallRejectBtn.addEventListener('click', () => {
            const callerId = runtimeState.incomingCall.from;
            if (!callerId) return;
            
            hideIncomingCallUI();

            const currentCall = appState.chat.videoCallState;
            if (currentCall.isActive) {
                // Â¶ÇÊûúÊ≠£Âú®ÈÄöËØù‰∏≠ÔºåÈÄöÁü•ÂØπÊñπÂç†Á∫ø
                addSystemNotification(callerId, 'ÂØπÊñπÊ≠£Âú®ÈÄöËØù‰∏≠', true, { callInitiator: 'char' });
            } else {
                // Âê¶ÂàôÔºåÊ≠£Â∏∏ÊãíÁªù
                addSystemNotification(callerId, '‰Ω†ÊãíÁªù‰∫ÜËßÜÈ¢ëÈÄöËØù', true, { callInitiator: 'char' });
            }
        });
        // --- ADDED: Draggable Floating Lyrics & Player Opener ---
    const lyricsContainer = getEl('lyrics-container');
    let isLyricDragging = false, lyricStartX, lyricStartY, lyricInitialLeft, lyricInitialTop;
    
    lyricsContainer.addEventListener('pointerdown', (e) => {
        if (e.target.closest('a')) return; // Ignore links if any are added later
        isLyricDragging = false;
        
        // Set a short timeout to differentiate between a click and a drag
        const dragCheck = setTimeout(() => {
            isLyricDragging = true;
        }, 200);

        lyricStartX = e.clientX;
        lyricStartY = e.clientY;
        lyricInitialLeft = lyricsContainer.offsetLeft;
        lyricInitialTop = lyricsContainer.offsetTop;

        const onPointerMove = (moveEvent) => {
            const dx = moveEvent.clientX - lyricStartX;
            const dy = moveEvent.clientY - lyricStartY;
            if(Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                isLyricDragging = true;
            }

            if(isLyricDragging) {
                const screenRect = phoneScreen.getBoundingClientRect();
                let newLeft = lyricInitialLeft + dx;
                let newTop = lyricInitialTop + dy;

                // Boundary checks
                newLeft = Math.max(0, Math.min(newLeft, screenRect.width - lyricsContainer.offsetWidth));
                newTop = Math.max(0, Math.min(newTop, screenRect.height - lyricsContainer.offsetHeight));

                lyricsContainer.style.left = `${newLeft}px`;
                lyricsContainer.style.top = `${newTop}px`;
                lyricsContainer.style.transform = 'none'; // Override the initial transform
            }
        };
        
        const onPointerUp = () => {
            clearTimeout(dragCheck);
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', onPointerUp);

            if (!isLyricDragging) {
                // This was a click, open the player
                if (appState.music.currentQueueIndex !== -1) {
                     playerModal.classList.add('show');
                }
            }
        };

        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerup', onPointerUp);
    });

    // --- END ADDED ---
init();
});

</script>
</body>
</html>